"use client";
import * as V from "./react-shim.mjs";
import $, { createContext as Hd, useReducer as ZS, useRef as Ji, useEffect as lt, useCallback as Fg, useContext as $n, useLayoutEffect as JS, useState as sn, Component as e2, createElement as Sh } from "./react-shim.mjs";
import { Vault as Bg } from "@iiif/helpers/vault";
import { jsx as xe, jsxs as t2, Fragment as n2 } from "react/jsx-runtime";
import * as Ug from "./react-dom-shim.mjs";
import Rs from "openseadragon";
import "@iiif/parser/presentation-2";
import "@iiif/helpers";
import { initReactI18next as r2, useTranslation as i2 } from "react-i18next";
import s2 from "i18next-browser-languagedetector";
import ks from "i18next";
const Cn = {
  activeLanguages: void 0,
  annotations: [],
  manifest: void 0,
  options: {
    offset: 0,
    figure: {
      display: "image-viewer",
      aspectRatio: 100 / 61.8,
      // golden ratio
      width: "38.2%"
    },
    language: {
      defaultLanguages: void 0,
      enabled: !1,
      options: []
    },
    annotations: {
      motivations: void 0
    }
  },
  searchActiveMatch: void 0,
  searchMatches: void 0,
  searchString: void 0,
  vault: new Bg()
};
function a2(t, e) {
  switch (e.type) {
    case "updateAnnotations":
      return {
        ...t,
        annotations: e.payload
      };
    case "updateActiveLanguages":
      return {
        ...t,
        activeLanguages: e.payload
      };
    case "updateSearchActiveMatch":
      return {
        ...t,
        searchActiveMatch: e.payload
      };
    case "updateSearchMatches":
      return {
        ...t,
        searchMatches: e.payload
      };
    case "updateSearchString":
      return {
        ...t,
        searchString: e.payload
      };
    default:
      return t;
  }
}
const gn = Hd({
  dispatch: () => null,
  state: Cn
}), o2 = (t) => {
  var o, u, l, c;
  const { children: e, manifest: n } = t, r = {
    ...Cn.options,
    ...t.options,
    figure: {
      ...Cn.options.figure,
      ...(o = t.options) == null ? void 0 : o.figure
    },
    language: {
      ...Cn.options.language,
      ...(u = t.options) == null ? void 0 : u.language
    },
    annotations: {
      ...Cn.options.annotations,
      ...(l = t.options) == null ? void 0 : l.annotations
    }
  }, i = ((c = r.language) == null ? void 0 : c.defaultLanguages) || [], [s, a] = ZS(a2, {
    ...Cn,
    activeLanguages: i,
    options: r
  });
  return /* @__PURE__ */ $.createElement(
    gn.Provider,
    {
      value: {
        state: { ...s, manifest: n, options: r },
        dispatch: a
      }
    },
    e
  );
}, u2 = (t, e = "none") => {
  if (!t) return null;
  if (typeof t == "string") return [t];
  if (!t[e]) {
    const n = Object.getOwnPropertyNames(t);
    if (n.length > 0) return t[n[0]];
  }
  return !t[e] || !Array.isArray(t[e]) ? null : t[e];
}, Ru = (t, e = "none", n = ", ") => {
  const r = u2(t, e);
  return Array.isArray(r) ? r.join(`${n}`) : r;
};
var be = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $g(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function l2(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var Hg = {}, js = {}, Gd = {}, Ks = {}, Vd = {};
Object.defineProperty(Vd, "__esModule", { value: !0 });
Vd.default = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map(function(t) {
    return t.charCodeAt(0);
  })
);
var zd = {};
Object.defineProperty(zd, "__esModule", { value: !0 });
zd.default = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map(function(t) {
    return t.charCodeAt(0);
  })
);
var Ec = {};
(function(t) {
  var e;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceCodePoint = t.fromCodePoint = void 0;
  var n = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  t.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(s) {
    var a = "";
    return s > 65535 && (s -= 65536, a += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), a += String.fromCharCode(s), a;
  };
  function r(s) {
    var a;
    return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (a = n.get(s)) !== null && a !== void 0 ? a : s;
  }
  t.replaceCodePoint = r;
  function i(s) {
    return (0, t.fromCodePoint)(r(s));
  }
  t.default = i;
})(Ec);
(function(t) {
  var e = be && be.__createBinding || (Object.create ? function(L, N, U, z) {
    z === void 0 && (z = U);
    var O = Object.getOwnPropertyDescriptor(N, U);
    (!O || ("get" in O ? !N.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return N[U];
    } }), Object.defineProperty(L, z, O);
  } : function(L, N, U, z) {
    z === void 0 && (z = U), L[z] = N[U];
  }), n = be && be.__setModuleDefault || (Object.create ? function(L, N) {
    Object.defineProperty(L, "default", { enumerable: !0, value: N });
  } : function(L, N) {
    L.default = N;
  }), r = be && be.__importStar || function(L) {
    if (L && L.__esModule) return L;
    var N = {};
    if (L != null) for (var U in L) U !== "default" && Object.prototype.hasOwnProperty.call(L, U) && e(N, L, U);
    return n(N, L), N;
  }, i = be && be.__importDefault || function(L) {
    return L && L.__esModule ? L : { default: L };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXML = t.decodeHTMLStrict = t.decodeHTMLAttribute = t.decodeHTML = t.determineBranch = t.EntityDecoder = t.DecodingMode = t.BinTrieFlags = t.fromCodePoint = t.replaceCodePoint = t.decodeCodePoint = t.xmlDecodeTree = t.htmlDecodeTree = void 0;
  var s = i(Vd);
  t.htmlDecodeTree = s.default;
  var a = i(zd);
  t.xmlDecodeTree = a.default;
  var o = r(Ec);
  t.decodeCodePoint = o.default;
  var u = Ec;
  Object.defineProperty(t, "replaceCodePoint", { enumerable: !0, get: function() {
    return u.replaceCodePoint;
  } }), Object.defineProperty(t, "fromCodePoint", { enumerable: !0, get: function() {
    return u.fromCodePoint;
  } });
  var l;
  (function(L) {
    L[L.NUM = 35] = "NUM", L[L.SEMI = 59] = "SEMI", L[L.EQUALS = 61] = "EQUALS", L[L.ZERO = 48] = "ZERO", L[L.NINE = 57] = "NINE", L[L.LOWER_A = 97] = "LOWER_A", L[L.LOWER_F = 102] = "LOWER_F", L[L.LOWER_X = 120] = "LOWER_X", L[L.LOWER_Z = 122] = "LOWER_Z", L[L.UPPER_A = 65] = "UPPER_A", L[L.UPPER_F = 70] = "UPPER_F", L[L.UPPER_Z = 90] = "UPPER_Z";
  })(l || (l = {}));
  var c = 32, d;
  (function(L) {
    L[L.VALUE_LENGTH = 49152] = "VALUE_LENGTH", L[L.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", L[L.JUMP_TABLE = 127] = "JUMP_TABLE";
  })(d = t.BinTrieFlags || (t.BinTrieFlags = {}));
  function f(L) {
    return L >= l.ZERO && L <= l.NINE;
  }
  function h(L) {
    return L >= l.UPPER_A && L <= l.UPPER_F || L >= l.LOWER_A && L <= l.LOWER_F;
  }
  function m(L) {
    return L >= l.UPPER_A && L <= l.UPPER_Z || L >= l.LOWER_A && L <= l.LOWER_Z || f(L);
  }
  function p(L) {
    return L === l.EQUALS || m(L);
  }
  var g;
  (function(L) {
    L[L.EntityStart = 0] = "EntityStart", L[L.NumericStart = 1] = "NumericStart", L[L.NumericDecimal = 2] = "NumericDecimal", L[L.NumericHex = 3] = "NumericHex", L[L.NamedEntity = 4] = "NamedEntity";
  })(g || (g = {}));
  var E;
  (function(L) {
    L[L.Legacy = 0] = "Legacy", L[L.Strict = 1] = "Strict", L[L.Attribute = 2] = "Attribute";
  })(E = t.DecodingMode || (t.DecodingMode = {}));
  var y = (
    /** @class */
    function() {
      function L(N, U, z) {
        this.decodeTree = N, this.emitCodePoint = U, this.errors = z, this.state = g.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = E.Strict;
      }
      return L.prototype.startEntity = function(N) {
        this.decodeMode = N, this.state = g.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }, L.prototype.write = function(N, U) {
        switch (this.state) {
          case g.EntityStart:
            return N.charCodeAt(U) === l.NUM ? (this.state = g.NumericStart, this.consumed += 1, this.stateNumericStart(N, U + 1)) : (this.state = g.NamedEntity, this.stateNamedEntity(N, U));
          case g.NumericStart:
            return this.stateNumericStart(N, U);
          case g.NumericDecimal:
            return this.stateNumericDecimal(N, U);
          case g.NumericHex:
            return this.stateNumericHex(N, U);
          case g.NamedEntity:
            return this.stateNamedEntity(N, U);
        }
      }, L.prototype.stateNumericStart = function(N, U) {
        return U >= N.length ? -1 : (N.charCodeAt(U) | c) === l.LOWER_X ? (this.state = g.NumericHex, this.consumed += 1, this.stateNumericHex(N, U + 1)) : (this.state = g.NumericDecimal, this.stateNumericDecimal(N, U));
      }, L.prototype.addToNumericResult = function(N, U, z, O) {
        if (U !== z) {
          var F = z - U;
          this.result = this.result * Math.pow(O, F) + parseInt(N.substr(U, F), O), this.consumed += F;
        }
      }, L.prototype.stateNumericHex = function(N, U) {
        for (var z = U; U < N.length; ) {
          var O = N.charCodeAt(U);
          if (f(O) || h(O))
            U += 1;
          else
            return this.addToNumericResult(N, z, U, 16), this.emitNumericEntity(O, 3);
        }
        return this.addToNumericResult(N, z, U, 16), -1;
      }, L.prototype.stateNumericDecimal = function(N, U) {
        for (var z = U; U < N.length; ) {
          var O = N.charCodeAt(U);
          if (f(O))
            U += 1;
          else
            return this.addToNumericResult(N, z, U, 10), this.emitNumericEntity(O, 2);
        }
        return this.addToNumericResult(N, z, U, 10), -1;
      }, L.prototype.emitNumericEntity = function(N, U) {
        var z;
        if (this.consumed <= U)
          return (z = this.errors) === null || z === void 0 || z.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (N === l.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === E.Strict)
          return 0;
        return this.emitCodePoint((0, o.replaceCodePoint)(this.result), this.consumed), this.errors && (N !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }, L.prototype.stateNamedEntity = function(N, U) {
        for (var z = this.decodeTree, O = z[this.treeIndex], F = (O & d.VALUE_LENGTH) >> 14; U < N.length; U++, this.excess++) {
          var B = N.charCodeAt(U);
          if (this.treeIndex = S(z, O, this.treeIndex + Math.max(1, F), B), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === E.Attribute && // We shouldn't have consumed any characters after the entity,
            (F === 0 || // And there should be no invalid characters.
            p(B)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (O = z[this.treeIndex], F = (O & d.VALUE_LENGTH) >> 14, F !== 0) {
            if (B === l.SEMI)
              return this.emitNamedEntityData(this.treeIndex, F, this.consumed + this.excess);
            this.decodeMode !== E.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }, L.prototype.emitNotTerminatedNamedEntity = function() {
        var N, U = this, z = U.result, O = U.decodeTree, F = (O[z] & d.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(z, F, this.consumed), (N = this.errors) === null || N === void 0 || N.missingSemicolonAfterCharacterReference(), this.consumed;
      }, L.prototype.emitNamedEntityData = function(N, U, z) {
        var O = this.decodeTree;
        return this.emitCodePoint(U === 1 ? O[N] & ~d.VALUE_LENGTH : O[N + 1], z), U === 3 && this.emitCodePoint(O[N + 2], z), z;
      }, L.prototype.end = function() {
        var N;
        switch (this.state) {
          case g.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== E.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          case g.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case g.NumericHex:
            return this.emitNumericEntity(0, 3);
          case g.NumericStart:
            return (N = this.errors) === null || N === void 0 || N.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case g.EntityStart:
            return 0;
        }
      }, L;
    }()
  );
  t.EntityDecoder = y;
  function T(L) {
    var N = "", U = new y(L, function(z) {
      return N += (0, o.fromCodePoint)(z);
    });
    return function(O, F) {
      for (var B = 0, H = 0; (H = O.indexOf("&", H)) >= 0; ) {
        N += O.slice(B, H), U.startEntity(F);
        var X = U.write(
          O,
          // Skip the "&"
          H + 1
        );
        if (X < 0) {
          B = H + U.end();
          break;
        }
        B = H + X, H = X === 0 ? B + 1 : B;
      }
      var w = N + O.slice(B);
      return N = "", w;
    };
  }
  function S(L, N, U, z) {
    var O = (N & d.BRANCH_LENGTH) >> 7, F = N & d.JUMP_TABLE;
    if (O === 0)
      return F !== 0 && z === F ? U : -1;
    if (F) {
      var B = z - F;
      return B < 0 || B >= O ? -1 : L[U + B] - 1;
    }
    for (var H = U, X = H + O - 1; H <= X; ) {
      var w = H + X >>> 1, Q = L[w];
      if (Q < z)
        H = w + 1;
      else if (Q > z)
        X = w - 1;
      else
        return L[w + O];
    }
    return -1;
  }
  t.determineBranch = S;
  var v = T(s.default), I = T(a.default);
  function C(L, N) {
    return N === void 0 && (N = E.Legacy), v(L, N);
  }
  t.decodeHTML = C;
  function D(L) {
    return v(L, E.Attribute);
  }
  t.decodeHTMLAttribute = D;
  function _(L) {
    return v(L, E.Strict);
  }
  t.decodeHTMLStrict = _;
  function A(L) {
    return I(L, E.Strict);
  }
  t.decodeXML = A;
})(Ks);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.QuoteType = void 0;
  var e = Ks, n;
  (function(f) {
    f[f.Tab = 9] = "Tab", f[f.NewLine = 10] = "NewLine", f[f.FormFeed = 12] = "FormFeed", f[f.CarriageReturn = 13] = "CarriageReturn", f[f.Space = 32] = "Space", f[f.ExclamationMark = 33] = "ExclamationMark", f[f.Number = 35] = "Number", f[f.Amp = 38] = "Amp", f[f.SingleQuote = 39] = "SingleQuote", f[f.DoubleQuote = 34] = "DoubleQuote", f[f.Dash = 45] = "Dash", f[f.Slash = 47] = "Slash", f[f.Zero = 48] = "Zero", f[f.Nine = 57] = "Nine", f[f.Semi = 59] = "Semi", f[f.Lt = 60] = "Lt", f[f.Eq = 61] = "Eq", f[f.Gt = 62] = "Gt", f[f.Questionmark = 63] = "Questionmark", f[f.UpperA = 65] = "UpperA", f[f.LowerA = 97] = "LowerA", f[f.UpperF = 70] = "UpperF", f[f.LowerF = 102] = "LowerF", f[f.UpperZ = 90] = "UpperZ", f[f.LowerZ = 122] = "LowerZ", f[f.LowerX = 120] = "LowerX", f[f.OpeningSquareBracket = 91] = "OpeningSquareBracket";
  })(n || (n = {}));
  var r;
  (function(f) {
    f[f.Text = 1] = "Text", f[f.BeforeTagName = 2] = "BeforeTagName", f[f.InTagName = 3] = "InTagName", f[f.InSelfClosingTag = 4] = "InSelfClosingTag", f[f.BeforeClosingTagName = 5] = "BeforeClosingTagName", f[f.InClosingTagName = 6] = "InClosingTagName", f[f.AfterClosingTagName = 7] = "AfterClosingTagName", f[f.BeforeAttributeName = 8] = "BeforeAttributeName", f[f.InAttributeName = 9] = "InAttributeName", f[f.AfterAttributeName = 10] = "AfterAttributeName", f[f.BeforeAttributeValue = 11] = "BeforeAttributeValue", f[f.InAttributeValueDq = 12] = "InAttributeValueDq", f[f.InAttributeValueSq = 13] = "InAttributeValueSq", f[f.InAttributeValueNq = 14] = "InAttributeValueNq", f[f.BeforeDeclaration = 15] = "BeforeDeclaration", f[f.InDeclaration = 16] = "InDeclaration", f[f.InProcessingInstruction = 17] = "InProcessingInstruction", f[f.BeforeComment = 18] = "BeforeComment", f[f.CDATASequence = 19] = "CDATASequence", f[f.InSpecialComment = 20] = "InSpecialComment", f[f.InCommentLike = 21] = "InCommentLike", f[f.BeforeSpecialS = 22] = "BeforeSpecialS", f[f.SpecialStartSequence = 23] = "SpecialStartSequence", f[f.InSpecialTag = 24] = "InSpecialTag", f[f.BeforeEntity = 25] = "BeforeEntity", f[f.BeforeNumericEntity = 26] = "BeforeNumericEntity", f[f.InNamedEntity = 27] = "InNamedEntity", f[f.InNumericEntity = 28] = "InNumericEntity", f[f.InHexEntity = 29] = "InHexEntity";
  })(r || (r = {}));
  function i(f) {
    return f === n.Space || f === n.NewLine || f === n.Tab || f === n.FormFeed || f === n.CarriageReturn;
  }
  function s(f) {
    return f === n.Slash || f === n.Gt || i(f);
  }
  function a(f) {
    return f >= n.Zero && f <= n.Nine;
  }
  function o(f) {
    return f >= n.LowerA && f <= n.LowerZ || f >= n.UpperA && f <= n.UpperZ;
  }
  function u(f) {
    return f >= n.UpperA && f <= n.UpperF || f >= n.LowerA && f <= n.LowerF;
  }
  var l;
  (function(f) {
    f[f.NoValue = 0] = "NoValue", f[f.Unquoted = 1] = "Unquoted", f[f.Single = 2] = "Single", f[f.Double = 3] = "Double";
  })(l = t.QuoteType || (t.QuoteType = {}));
  var c = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    // `</title`
  }, d = (
    /** @class */
    function() {
      function f(h, m) {
        var p = h.xmlMode, g = p === void 0 ? !1 : p, E = h.decodeEntities, y = E === void 0 ? !0 : E;
        this.cbs = m, this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = g, this.decodeEntities = y, this.entityTrie = g ? e.xmlDecodeTree : e.htmlDecodeTree;
      }
      return f.prototype.reset = function() {
        this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
      }, f.prototype.write = function(h) {
        this.offset += this.buffer.length, this.buffer = h, this.parse();
      }, f.prototype.end = function() {
        this.running && this.finish();
      }, f.prototype.pause = function() {
        this.running = !1;
      }, f.prototype.resume = function() {
        this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
      }, f.prototype.getIndex = function() {
        return this.index;
      }, f.prototype.getSectionStart = function() {
        return this.sectionStart;
      }, f.prototype.stateText = function(h) {
        h === n.Lt || !this.decodeEntities && this.fastForwardTo(n.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = r.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && h === n.Amp && (this.state = r.BeforeEntity);
      }, f.prototype.stateSpecialStartSequence = function(h) {
        var m = this.sequenceIndex === this.currentSequence.length, p = m ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          s(h)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (h | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!p)
          this.isSpecial = !1;
        else if (!m) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0, this.state = r.InTagName, this.stateInTagName(h);
      }, f.prototype.stateInSpecialTag = function(h) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (h === n.Gt || i(h)) {
            var m = this.index - this.currentSequence.length;
            if (this.sectionStart < m) {
              var p = this.index;
              this.index = m, this.cbs.ontext(this.sectionStart, m), this.index = p;
            }
            this.isSpecial = !1, this.sectionStart = m + 2, this.stateInClosingTagName(h);
            return;
          }
          this.sequenceIndex = 0;
        }
        (h | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === c.TitleEnd ? this.decodeEntities && h === n.Amp && (this.state = r.BeforeEntity) : this.fastForwardTo(n.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(h === n.Lt);
      }, f.prototype.stateCDATASequence = function(h) {
        h === c.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === c.Cdata.length && (this.state = r.InCommentLike, this.currentSequence = c.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = r.InDeclaration, this.stateInDeclaration(h));
      }, f.prototype.fastForwardTo = function(h) {
        for (; ++this.index < this.buffer.length + this.offset; )
          if (this.buffer.charCodeAt(this.index - this.offset) === h)
            return !0;
        return this.index = this.buffer.length + this.offset - 1, !1;
      }, f.prototype.stateInCommentLike = function(h) {
        h === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = r.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : h !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
      }, f.prototype.isTagStartChar = function(h) {
        return this.xmlMode ? !s(h) : o(h);
      }, f.prototype.startSpecial = function(h, m) {
        this.isSpecial = !0, this.currentSequence = h, this.sequenceIndex = m, this.state = r.SpecialStartSequence;
      }, f.prototype.stateBeforeTagName = function(h) {
        if (h === n.ExclamationMark)
          this.state = r.BeforeDeclaration, this.sectionStart = this.index + 1;
        else if (h === n.Questionmark)
          this.state = r.InProcessingInstruction, this.sectionStart = this.index + 1;
        else if (this.isTagStartChar(h)) {
          var m = h | 32;
          this.sectionStart = this.index, !this.xmlMode && m === c.TitleEnd[2] ? this.startSpecial(c.TitleEnd, 3) : this.state = !this.xmlMode && m === c.ScriptEnd[2] ? r.BeforeSpecialS : r.InTagName;
        } else h === n.Slash ? this.state = r.BeforeClosingTagName : (this.state = r.Text, this.stateText(h));
      }, f.prototype.stateInTagName = function(h) {
        s(h) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
      }, f.prototype.stateBeforeClosingTagName = function(h) {
        i(h) || (h === n.Gt ? this.state = r.Text : (this.state = this.isTagStartChar(h) ? r.InClosingTagName : r.InSpecialComment, this.sectionStart = this.index));
      }, f.prototype.stateInClosingTagName = function(h) {
        (h === n.Gt || i(h)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterClosingTagName, this.stateAfterClosingTagName(h));
      }, f.prototype.stateAfterClosingTagName = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeAttributeName = function(h) {
        h === n.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = r.InSpecialTag, this.sequenceIndex = 0) : this.state = r.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : h === n.Slash ? this.state = r.InSelfClosingTag : i(h) || (this.state = r.InAttributeName, this.sectionStart = this.index);
      }, f.prototype.stateInSelfClosingTag = function(h) {
        h === n.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : i(h) || (this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
      }, f.prototype.stateInAttributeName = function(h) {
        (h === n.Eq || s(h)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterAttributeName, this.stateAfterAttributeName(h));
      }, f.prototype.stateAfterAttributeName = function(h) {
        h === n.Eq ? this.state = r.BeforeAttributeValue : h === n.Slash || h === n.Gt ? (this.cbs.onattribend(l.NoValue, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : i(h) || (this.cbs.onattribend(l.NoValue, this.index), this.state = r.InAttributeName, this.sectionStart = this.index);
      }, f.prototype.stateBeforeAttributeValue = function(h) {
        h === n.DoubleQuote ? (this.state = r.InAttributeValueDq, this.sectionStart = this.index + 1) : h === n.SingleQuote ? (this.state = r.InAttributeValueSq, this.sectionStart = this.index + 1) : i(h) || (this.sectionStart = this.index, this.state = r.InAttributeValueNq, this.stateInAttributeValueNoQuotes(h));
      }, f.prototype.handleInAttributeValue = function(h, m) {
        h === m || !this.decodeEntities && this.fastForwardTo(m) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(m === n.DoubleQuote ? l.Double : l.Single, this.index), this.state = r.BeforeAttributeName) : this.decodeEntities && h === n.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
      }, f.prototype.stateInAttributeValueDoubleQuotes = function(h) {
        this.handleInAttributeValue(h, n.DoubleQuote);
      }, f.prototype.stateInAttributeValueSingleQuotes = function(h) {
        this.handleInAttributeValue(h, n.SingleQuote);
      }, f.prototype.stateInAttributeValueNoQuotes = function(h) {
        i(h) || h === n.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(l.Unquoted, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : this.decodeEntities && h === n.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
      }, f.prototype.stateBeforeDeclaration = function(h) {
        h === n.OpeningSquareBracket ? (this.state = r.CDATASequence, this.sequenceIndex = 0) : this.state = h === n.Dash ? r.BeforeComment : r.InDeclaration;
      }, f.prototype.stateInDeclaration = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateInProcessingInstruction = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeComment = function(h) {
        h === n.Dash ? (this.state = r.InCommentLike, this.currentSequence = c.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = r.InDeclaration;
      }, f.prototype.stateInSpecialComment = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeSpecialS = function(h) {
        var m = h | 32;
        m === c.ScriptEnd[3] ? this.startSpecial(c.ScriptEnd, 4) : m === c.StyleEnd[3] ? this.startSpecial(c.StyleEnd, 4) : (this.state = r.InTagName, this.stateInTagName(h));
      }, f.prototype.stateBeforeEntity = function(h) {
        this.entityExcess = 1, this.entityResult = 0, h === n.Number ? this.state = r.BeforeNumericEntity : h === n.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = r.InNamedEntity, this.stateInNamedEntity(h));
      }, f.prototype.stateInNamedEntity = function(h) {
        if (this.entityExcess += 1, this.trieIndex = (0, e.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, h), this.trieIndex < 0) {
          this.emitNamedEntity(), this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var m = this.trieCurrent & e.BinTrieFlags.VALUE_LENGTH;
        if (m) {
          var p = (m >> 14) - 1;
          if (!this.allowLegacyEntity() && h !== n.Semi)
            this.trieIndex += p;
          else {
            var g = this.index - this.entityExcess + 1;
            g > this.sectionStart && this.emitPartial(this.sectionStart, g), this.entityResult = this.trieIndex, this.trieIndex += p, this.entityExcess = 0, this.sectionStart = this.index + 1, p === 0 && this.emitNamedEntity();
          }
        }
      }, f.prototype.emitNamedEntity = function() {
        if (this.state = this.baseState, this.entityResult !== 0) {
          var h = (this.entityTrie[this.entityResult] & e.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (h) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~e.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3:
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      }, f.prototype.stateBeforeNumericEntity = function(h) {
        (h | 32) === n.LowerX ? (this.entityExcess++, this.state = r.InHexEntity) : (this.state = r.InNumericEntity, this.stateInNumericEntity(h));
      }, f.prototype.emitNumericEntity = function(h) {
        var m = this.index - this.entityExcess - 1, p = m + 2 + +(this.state === r.InHexEntity);
        p !== this.index && (m > this.sectionStart && this.emitPartial(this.sectionStart, m), this.sectionStart = this.index + Number(h), this.emitCodePoint((0, e.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
      }, f.prototype.stateInNumericEntity = function(h) {
        h === n.Semi ? this.emitNumericEntity(!0) : a(h) ? (this.entityResult = this.entityResult * 10 + (h - n.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
      }, f.prototype.stateInHexEntity = function(h) {
        h === n.Semi ? this.emitNumericEntity(!0) : a(h) ? (this.entityResult = this.entityResult * 16 + (h - n.Zero), this.entityExcess++) : u(h) ? (this.entityResult = this.entityResult * 16 + ((h | 32) - n.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
      }, f.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === r.Text || this.baseState === r.InSpecialTag);
      }, f.prototype.cleanup = function() {
        this.running && this.sectionStart !== this.index && (this.state === r.Text || this.state === r.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === r.InAttributeValueDq || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
      }, f.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      }, f.prototype.parse = function() {
        for (; this.shouldContinue(); ) {
          var h = this.buffer.charCodeAt(this.index - this.offset);
          switch (this.state) {
            case r.Text: {
              this.stateText(h);
              break;
            }
            case r.SpecialStartSequence: {
              this.stateSpecialStartSequence(h);
              break;
            }
            case r.InSpecialTag: {
              this.stateInSpecialTag(h);
              break;
            }
            case r.CDATASequence: {
              this.stateCDATASequence(h);
              break;
            }
            case r.InAttributeValueDq: {
              this.stateInAttributeValueDoubleQuotes(h);
              break;
            }
            case r.InAttributeName: {
              this.stateInAttributeName(h);
              break;
            }
            case r.InCommentLike: {
              this.stateInCommentLike(h);
              break;
            }
            case r.InSpecialComment: {
              this.stateInSpecialComment(h);
              break;
            }
            case r.BeforeAttributeName: {
              this.stateBeforeAttributeName(h);
              break;
            }
            case r.InTagName: {
              this.stateInTagName(h);
              break;
            }
            case r.InClosingTagName: {
              this.stateInClosingTagName(h);
              break;
            }
            case r.BeforeTagName: {
              this.stateBeforeTagName(h);
              break;
            }
            case r.AfterAttributeName: {
              this.stateAfterAttributeName(h);
              break;
            }
            case r.InAttributeValueSq: {
              this.stateInAttributeValueSingleQuotes(h);
              break;
            }
            case r.BeforeAttributeValue: {
              this.stateBeforeAttributeValue(h);
              break;
            }
            case r.BeforeClosingTagName: {
              this.stateBeforeClosingTagName(h);
              break;
            }
            case r.AfterClosingTagName: {
              this.stateAfterClosingTagName(h);
              break;
            }
            case r.BeforeSpecialS: {
              this.stateBeforeSpecialS(h);
              break;
            }
            case r.InAttributeValueNq: {
              this.stateInAttributeValueNoQuotes(h);
              break;
            }
            case r.InSelfClosingTag: {
              this.stateInSelfClosingTag(h);
              break;
            }
            case r.InDeclaration: {
              this.stateInDeclaration(h);
              break;
            }
            case r.BeforeDeclaration: {
              this.stateBeforeDeclaration(h);
              break;
            }
            case r.BeforeComment: {
              this.stateBeforeComment(h);
              break;
            }
            case r.InProcessingInstruction: {
              this.stateInProcessingInstruction(h);
              break;
            }
            case r.InNamedEntity: {
              this.stateInNamedEntity(h);
              break;
            }
            case r.BeforeEntity: {
              this.stateBeforeEntity(h);
              break;
            }
            case r.InHexEntity: {
              this.stateInHexEntity(h);
              break;
            }
            case r.InNumericEntity: {
              this.stateInNumericEntity(h);
              break;
            }
            default:
              this.stateBeforeNumericEntity(h);
          }
          this.index++;
        }
        this.cleanup();
      }, f.prototype.finish = function() {
        this.state === r.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
      }, f.prototype.handleTrailingData = function() {
        var h = this.buffer.length + this.offset;
        this.state === r.InCommentLike ? this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, h, 0) : this.cbs.oncomment(this.sectionStart, h, 0) : this.state === r.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InTagName || this.state === r.BeforeAttributeName || this.state === r.BeforeAttributeValue || this.state === r.AfterAttributeName || this.state === r.InAttributeName || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueDq || this.state === r.InAttributeValueNq || this.state === r.InClosingTagName || this.cbs.ontext(this.sectionStart, h);
      }, f.prototype.emitPartial = function(h, m) {
        this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribdata(h, m) : this.cbs.ontext(h, m);
      }, f.prototype.emitCodePoint = function(h) {
        this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribentity(h) : this.cbs.ontextentity(h);
      }, f;
    }()
  );
  t.default = d;
})(Gd);
var c2 = be && be.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(e, n);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[n];
  } }), Object.defineProperty(t, r, i);
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), d2 = be && be.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), f2 = be && be.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && c2(e, t, n);
  return d2(e, t), e;
};
Object.defineProperty(js, "__esModule", { value: !0 });
js.Parser = void 0;
var Ma = f2(Gd), Ah = Ks, li = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), $e = /* @__PURE__ */ new Set(["p"]), vh = /* @__PURE__ */ new Set(["thead", "tbody"]), Ih = /* @__PURE__ */ new Set(["dd", "dt"]), Ch = /* @__PURE__ */ new Set(["rt", "rp"]), h2 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", $e],
  ["h1", $e],
  ["h2", $e],
  ["h3", $e],
  ["h4", $e],
  ["h5", $e],
  ["h6", $e],
  ["select", li],
  ["input", li],
  ["output", li],
  ["button", li],
  ["datalist", li],
  ["textarea", li],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", Ih],
  ["dt", Ih],
  ["address", $e],
  ["article", $e],
  ["aside", $e],
  ["blockquote", $e],
  ["details", $e],
  ["div", $e],
  ["dl", $e],
  ["fieldset", $e],
  ["figcaption", $e],
  ["figure", $e],
  ["footer", $e],
  ["form", $e],
  ["header", $e],
  ["hr", $e],
  ["main", $e],
  ["nav", $e],
  ["ol", $e],
  ["pre", $e],
  ["section", $e],
  ["table", $e],
  ["ul", $e],
  ["rt", Ch],
  ["rp", Ch],
  ["tbody", vh],
  ["tfoot", vh]
]), m2 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), Lh = /* @__PURE__ */ new Set(["math", "svg"]), _h = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), p2 = /\s|\//, g2 = (
  /** @class */
  function() {
    function t(e, n) {
      n === void 0 && (n = {});
      var r, i, s, a, o;
      this.options = n, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = e ?? {}, this.lowerCaseTagNames = (r = n.lowerCaseTags) !== null && r !== void 0 ? r : !n.xmlMode, this.lowerCaseAttributeNames = (i = n.lowerCaseAttributeNames) !== null && i !== void 0 ? i : !n.xmlMode, this.tokenizer = new ((s = n.Tokenizer) !== null && s !== void 0 ? s : Ma.default)(this.options, this), (o = (a = this.cbs).onparserinit) === null || o === void 0 || o.call(a, this);
    }
    return t.prototype.ontext = function(e, n) {
      var r, i, s = this.getSlice(e, n);
      this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, s), this.startIndex = n;
    }, t.prototype.ontextentity = function(e) {
      var n, r, i = this.tokenizer.getSectionStart();
      this.endIndex = i - 1, (r = (n = this.cbs).ontext) === null || r === void 0 || r.call(n, (0, Ah.fromCodePoint)(e)), this.startIndex = i;
    }, t.prototype.isVoidElement = function(e) {
      return !this.options.xmlMode && m2.has(e);
    }, t.prototype.onopentagname = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
    }, t.prototype.emitOpenTag = function(e) {
      var n, r, i, s;
      this.openTagStart = this.startIndex, this.tagname = e;
      var a = !this.options.xmlMode && h2.get(e);
      if (a)
        for (; this.stack.length > 0 && a.has(this.stack[this.stack.length - 1]); ) {
          var o = this.stack.pop();
          (r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, o, !0);
        }
      this.isVoidElement(e) || (this.stack.push(e), Lh.has(e) ? this.foreignContext.push(!0) : _h.has(e) && this.foreignContext.push(!1)), (s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, e), this.cbs.onopentag && (this.attribs = {});
    }, t.prototype.endOpenTag = function(e) {
      var n, r;
      this.startIndex = this.openTagStart, this.attribs && ((r = (n = this.cbs).onopentag) === null || r === void 0 || r.call(n, this.tagname, this.attribs, e), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
    }, t.prototype.onopentagend = function(e) {
      this.endIndex = e, this.endOpenTag(!1), this.startIndex = e + 1;
    }, t.prototype.onclosetag = function(e, n) {
      var r, i, s, a, o, u;
      this.endIndex = n;
      var l = this.getSlice(e, n);
      if (this.lowerCaseTagNames && (l = l.toLowerCase()), (Lh.has(l) || _h.has(l)) && this.foreignContext.pop(), this.isVoidElement(l))
        !this.options.xmlMode && l === "br" && ((i = (r = this.cbs).onopentagname) === null || i === void 0 || i.call(r, "br"), (a = (s = this.cbs).onopentag) === null || a === void 0 || a.call(s, "br", {}, !0), (u = (o = this.cbs).onclosetag) === null || u === void 0 || u.call(o, "br", !1));
      else {
        var c = this.stack.lastIndexOf(l);
        if (c !== -1)
          if (this.cbs.onclosetag)
            for (var d = this.stack.length - c; d--; )
              this.cbs.onclosetag(this.stack.pop(), d !== 0);
          else
            this.stack.length = c;
        else !this.options.xmlMode && l === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
      }
      this.startIndex = n + 1;
    }, t.prototype.onselfclosingtag = function(e) {
      this.endIndex = e, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = e + 1) : this.onopentagend(e);
    }, t.prototype.closeCurrentTag = function(e) {
      var n, r, i = this.tagname;
      this.endOpenTag(e), this.stack[this.stack.length - 1] === i && ((r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, i, !e), this.stack.pop());
    }, t.prototype.onattribname = function(e, n) {
      this.startIndex = e;
      var r = this.getSlice(e, n);
      this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
    }, t.prototype.onattribdata = function(e, n) {
      this.attribvalue += this.getSlice(e, n);
    }, t.prototype.onattribentity = function(e) {
      this.attribvalue += (0, Ah.fromCodePoint)(e);
    }, t.prototype.onattribend = function(e, n) {
      var r, i;
      this.endIndex = n, (i = (r = this.cbs).onattribute) === null || i === void 0 || i.call(r, this.attribname, this.attribvalue, e === Ma.QuoteType.Double ? '"' : e === Ma.QuoteType.Single ? "'" : e === Ma.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
    }, t.prototype.getInstructionName = function(e) {
      var n = e.search(p2), r = n < 0 ? e : e.substr(0, n);
      return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
    }, t.prototype.ondeclaration = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      if (this.cbs.onprocessinginstruction) {
        var i = this.getInstructionName(r);
        this.cbs.onprocessinginstruction("!".concat(i), "!".concat(r));
      }
      this.startIndex = n + 1;
    }, t.prototype.onprocessinginstruction = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      if (this.cbs.onprocessinginstruction) {
        var i = this.getInstructionName(r);
        this.cbs.onprocessinginstruction("?".concat(i), "?".concat(r));
      }
      this.startIndex = n + 1;
    }, t.prototype.oncomment = function(e, n, r) {
      var i, s, a, o;
      this.endIndex = n, (s = (i = this.cbs).oncomment) === null || s === void 0 || s.call(i, this.getSlice(e, n - r)), (o = (a = this.cbs).oncommentend) === null || o === void 0 || o.call(a), this.startIndex = n + 1;
    }, t.prototype.oncdata = function(e, n, r) {
      var i, s, a, o, u, l, c, d, f, h;
      this.endIndex = n;
      var m = this.getSlice(e, n - r);
      this.options.xmlMode || this.options.recognizeCDATA ? ((s = (i = this.cbs).oncdatastart) === null || s === void 0 || s.call(i), (o = (a = this.cbs).ontext) === null || o === void 0 || o.call(a, m), (l = (u = this.cbs).oncdataend) === null || l === void 0 || l.call(u)) : ((d = (c = this.cbs).oncomment) === null || d === void 0 || d.call(c, "[CDATA[".concat(m, "]]")), (h = (f = this.cbs).oncommentend) === null || h === void 0 || h.call(f)), this.startIndex = n + 1;
    }, t.prototype.onend = function() {
      var e, n;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var r = this.stack.length; r > 0; this.cbs.onclosetag(this.stack[--r], !0))
          ;
      }
      (n = (e = this.cbs).onend) === null || n === void 0 || n.call(e);
    }, t.prototype.reset = function() {
      var e, n, r, i;
      (n = (e = this.cbs).onreset) === null || n === void 0 || n.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (i = (r = this.cbs).onparserinit) === null || i === void 0 || i.call(r, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
    }, t.prototype.parseComplete = function(e) {
      this.reset(), this.end(e);
    }, t.prototype.getSlice = function(e, n) {
      for (; e - this.bufferOffset >= this.buffers[0].length; )
        this.shiftBuffer();
      for (var r = this.buffers[0].slice(e - this.bufferOffset, n - this.bufferOffset); n - this.bufferOffset > this.buffers[0].length; )
        this.shiftBuffer(), r += this.buffers[0].slice(0, n - this.bufferOffset);
      return r;
    }, t.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
    }, t.prototype.write = function(e) {
      var n, r;
      if (this.ended) {
        (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(e), this.tokenizer.running && (this.tokenizer.write(e), this.writeIndex++);
    }, t.prototype.end = function(e) {
      var n, r;
      if (this.ended) {
        (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".end() after done!"));
        return;
      }
      e && this.write(e), this.ended = !0, this.tokenizer.end();
    }, t.prototype.pause = function() {
      this.tokenizer.pause();
    }, t.prototype.resume = function() {
      for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      this.ended && this.tokenizer.end();
    }, t.prototype.parseChunk = function(e) {
      this.write(e);
    }, t.prototype.done = function(e) {
      this.end(e);
    }, t;
  }()
);
js.Parser = g2;
var nr = {}, es = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
  var e;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(e = t.ElementType || (t.ElementType = {}));
  function n(r) {
    return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
  }
  t.isTag = n, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
})(es);
var De = {}, Rr = be && be.__extends || /* @__PURE__ */ function() {
  var t = function(e, n) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
    }, t(e, n);
  };
  return function(e, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    t(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Os = be && be.__assign || function() {
  return Os = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Os.apply(this, arguments);
};
Object.defineProperty(De, "__esModule", { value: !0 });
De.cloneNode = De.hasChildren = De.isDocument = De.isDirective = De.isComment = De.isText = De.isCDATA = De.isTag = De.Element = De.Document = De.CDATA = De.NodeWithChildren = De.ProcessingInstruction = De.Comment = De.Text = De.DataNode = De.Node = void 0;
var Nt = es, qd = (
  /** @class */
  function() {
    function t() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(e) {
        this.parent = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(e) {
        this.prev = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(e) {
        this.next = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.cloneNode = function(e) {
      return e === void 0 && (e = !1), jd(this, e);
    }, t;
  }()
);
De.Node = qd;
var ku = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(e.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(qd)
);
De.DataNode = ku;
var Gg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Nt.ElementType.Text, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ku)
);
De.Text = Gg;
var Vg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Nt.ElementType.Comment, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ku)
);
De.Comment = Vg;
var zg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e(n, r) {
      var i = t.call(this, r) || this;
      return i.name = n, i.type = Nt.ElementType.Directive, i;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ku)
);
De.ProcessingInstruction = zg;
var wu = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(e.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(qd)
);
De.NodeWithChildren = wu;
var qg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Nt.ElementType.CDATA, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(wu)
);
De.CDATA = qg;
var jg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Nt.ElementType.Root, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(wu)
);
De.Document = jg;
var Kg = (
  /** @class */
  function(t) {
    Rr(e, t);
    function e(n, r, i, s) {
      i === void 0 && (i = []), s === void 0 && (s = n === "script" ? Nt.ElementType.Script : n === "style" ? Nt.ElementType.Style : Nt.ElementType.Tag);
      var a = t.call(this, i) || this;
      return a.name = n, a.attribs = r, a.type = s, a;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var i, s;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (i = n["x-attribsNamespace"]) === null || i === void 0 ? void 0 : i[r],
            prefix: (s = n["x-attribsPrefix"]) === null || s === void 0 ? void 0 : s[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(wu)
);
De.Element = Kg;
function Wg(t) {
  return (0, Nt.isTag)(t);
}
De.isTag = Wg;
function Yg(t) {
  return t.type === Nt.ElementType.CDATA;
}
De.isCDATA = Yg;
function Xg(t) {
  return t.type === Nt.ElementType.Text;
}
De.isText = Xg;
function Qg(t) {
  return t.type === Nt.ElementType.Comment;
}
De.isComment = Qg;
function Zg(t) {
  return t.type === Nt.ElementType.Directive;
}
De.isDirective = Zg;
function Jg(t) {
  return t.type === Nt.ElementType.Root;
}
De.isDocument = Jg;
function b2(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
De.hasChildren = b2;
function jd(t, e) {
  e === void 0 && (e = !1);
  var n;
  if (Xg(t))
    n = new Gg(t.data);
  else if (Qg(t))
    n = new Vg(t.data);
  else if (Wg(t)) {
    var r = e ? ol(t.children) : [], i = new Kg(t.name, Os({}, t.attribs), r);
    r.forEach(function(u) {
      return u.parent = i;
    }), t.namespace != null && (i.namespace = t.namespace), t["x-attribsNamespace"] && (i["x-attribsNamespace"] = Os({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (i["x-attribsPrefix"] = Os({}, t["x-attribsPrefix"])), n = i;
  } else if (Yg(t)) {
    var r = e ? ol(t.children) : [], s = new qg(r);
    r.forEach(function(l) {
      return l.parent = s;
    }), n = s;
  } else if (Jg(t)) {
    var r = e ? ol(t.children) : [], a = new jg(r);
    r.forEach(function(l) {
      return l.parent = a;
    }), t["x-mode"] && (a["x-mode"] = t["x-mode"]), n = a;
  } else if (Zg(t)) {
    var o = new zg(t.name, t.data);
    t["x-name"] != null && (o["x-name"] = t["x-name"], o["x-publicId"] = t["x-publicId"], o["x-systemId"] = t["x-systemId"]), n = o;
  } else
    throw new Error("Not implemented yet: ".concat(t.type));
  return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n;
}
De.cloneNode = jd;
function ol(t) {
  for (var e = t.map(function(r) {
    return jd(r, !0);
  }), n = 1; n < e.length; n++)
    e[n].prev = e[n - 1], e[n - 1].next = e[n];
  return e;
}
(function(t) {
  var e = be && be.__createBinding || (Object.create ? function(o, u, l, c) {
    c === void 0 && (c = l);
    var d = Object.getOwnPropertyDescriptor(u, l);
    (!d || ("get" in d ? !u.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(o, c, d);
  } : function(o, u, l, c) {
    c === void 0 && (c = l), o[c] = u[l];
  }), n = be && be.__exportStar || function(o, u) {
    for (var l in o) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && e(u, o, l);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
  var r = es, i = De;
  n(De, t);
  var s = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function o(u, l, c) {
        this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = s), typeof u == "object" && (l = u, u = void 0), this.callback = u ?? null, this.options = l ?? s, this.elementCB = c ?? null;
      }
      return o.prototype.onparserinit = function(u) {
        this.parser = u;
      }, o.prototype.onreset = function() {
        this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, o.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, o.prototype.onerror = function(u) {
        this.handleCallback(u);
      }, o.prototype.onclosetag = function() {
        this.lastNode = null;
        var u = this.tagStack.pop();
        this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
      }, o.prototype.onopentag = function(u, l) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new i.Element(u, l, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, o.prototype.ontext = function(u) {
        var l = this.lastNode;
        if (l && l.type === r.ElementType.Text)
          l.data += u, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
        else {
          var c = new i.Text(u);
          this.addNode(c), this.lastNode = c;
        }
      }, o.prototype.oncomment = function(u) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += u;
          return;
        }
        var l = new i.Comment(u);
        this.addNode(l), this.lastNode = l;
      }, o.prototype.oncommentend = function() {
        this.lastNode = null;
      }, o.prototype.oncdatastart = function() {
        var u = new i.Text(""), l = new i.CDATA([u]);
        this.addNode(l), u.parent = l, this.lastNode = u;
      }, o.prototype.oncdataend = function() {
        this.lastNode = null;
      }, o.prototype.onprocessinginstruction = function(u, l) {
        var c = new i.ProcessingInstruction(u, l);
        this.addNode(c);
      }, o.prototype.handleCallback = function(u) {
        if (typeof this.callback == "function")
          this.callback(u, this.dom);
        else if (u)
          throw u;
      }, o.prototype.addNode = function(u) {
        var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
        this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), l.children.push(u), c && (u.prev = c, c.next = u), u.parent = l, this.lastNode = null;
      }, o;
    }()
  );
  t.DomHandler = a, t.default = a;
})(nr);
var Lo = {}, kr = {}, ba = {}, e1 = {}, Kr = {}, Kd = {};
Object.defineProperty(Kd, "__esModule", { value: !0 });
function Fa(t) {
  for (var e = 1; e < t.length; e++)
    t[e][0] += t[e - 1][0] + 1;
  return t;
}
Kd.default = new Map(/* @__PURE__ */ Fa([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ Fa([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ Fa([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ Fa([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var Yo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.getCodePoint = t.xmlReplacer = void 0, t.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var e = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  t.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(i, s) {
    return i.codePointAt(s);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(i, s) {
      return (i.charCodeAt(s) & 64512) === 55296 ? (i.charCodeAt(s) - 55296) * 1024 + i.charCodeAt(s + 1) - 56320 + 65536 : i.charCodeAt(s);
    }
  );
  function n(i) {
    for (var s = "", a = 0, o; (o = t.xmlReplacer.exec(i)) !== null; ) {
      var u = o.index, l = i.charCodeAt(u), c = e.get(l);
      c !== void 0 ? (s += i.substring(a, u) + c, a = u + 1) : (s += "".concat(i.substring(a, u), "&#x").concat((0, t.getCodePoint)(i, u).toString(16), ";"), a = t.xmlReplacer.lastIndex += +((l & 64512) === 55296));
    }
    return s + i.substr(a);
  }
  t.encodeXML = n, t.escape = n;
  function r(i, s) {
    return function(o) {
      for (var u, l = 0, c = ""; u = i.exec(o); )
        l !== u.index && (c += o.substring(l, u.index)), c += s.get(u[0].charCodeAt(0)), l = u.index + 1;
      return c + o.substring(l);
    };
  }
  t.escapeUTF8 = r(/[&<>'"]/g, e), t.escapeAttribute = r(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ])), t.escapeText = r(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(Yo);
var E2 = be && be.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Kr, "__esModule", { value: !0 });
Kr.encodeNonAsciiHTML = Kr.encodeHTML = void 0;
var y2 = E2(Kd), t1 = Yo, T2 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function x2(t) {
  return n1(T2, t);
}
Kr.encodeHTML = x2;
function S2(t) {
  return n1(t1.xmlReplacer, t);
}
Kr.encodeNonAsciiHTML = S2;
function n1(t, e) {
  for (var n = "", r = 0, i; (i = t.exec(e)) !== null; ) {
    var s = i.index;
    n += e.substring(r, s);
    var a = e.charCodeAt(s), o = y2.default.get(a);
    if (typeof o == "object") {
      if (s + 1 < e.length) {
        var u = e.charCodeAt(s + 1), l = typeof o.n == "number" ? o.n === u ? o.o : void 0 : o.n.get(u);
        if (l !== void 0) {
          n += l, r = t.lastIndex += 1;
          continue;
        }
      }
      o = o.v;
    }
    if (o !== void 0)
      n += o, r = s + 1;
    else {
      var c = (0, t1.getCodePoint)(e, s);
      n += "&#x".concat(c.toString(16), ";"), r = t.lastIndex += +(c !== a);
    }
  }
  return n + e.substr(r);
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXMLStrict = t.decodeHTML5Strict = t.decodeHTML4Strict = t.decodeHTML5 = t.decodeHTML4 = t.decodeHTMLAttribute = t.decodeHTMLStrict = t.decodeHTML = t.decodeXML = t.DecodingMode = t.EntityDecoder = t.encodeHTML5 = t.encodeHTML4 = t.encodeNonAsciiHTML = t.encodeHTML = t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.encode = t.decodeStrict = t.decode = t.EncodingMode = t.EntityLevel = void 0;
  var e = Ks, n = Kr, r = Yo, i;
  (function(f) {
    f[f.XML = 0] = "XML", f[f.HTML = 1] = "HTML";
  })(i = t.EntityLevel || (t.EntityLevel = {}));
  var s;
  (function(f) {
    f[f.UTF8 = 0] = "UTF8", f[f.ASCII = 1] = "ASCII", f[f.Extensive = 2] = "Extensive", f[f.Attribute = 3] = "Attribute", f[f.Text = 4] = "Text";
  })(s = t.EncodingMode || (t.EncodingMode = {}));
  function a(f, h) {
    h === void 0 && (h = i.XML);
    var m = typeof h == "number" ? h : h.level;
    if (m === i.HTML) {
      var p = typeof h == "object" ? h.mode : void 0;
      return (0, e.decodeHTML)(f, p);
    }
    return (0, e.decodeXML)(f);
  }
  t.decode = a;
  function o(f, h) {
    var m;
    h === void 0 && (h = i.XML);
    var p = typeof h == "number" ? { level: h } : h;
    return (m = p.mode) !== null && m !== void 0 || (p.mode = e.DecodingMode.Strict), a(f, p);
  }
  t.decodeStrict = o;
  function u(f, h) {
    h === void 0 && (h = i.XML);
    var m = typeof h == "number" ? { level: h } : h;
    return m.mode === s.UTF8 ? (0, r.escapeUTF8)(f) : m.mode === s.Attribute ? (0, r.escapeAttribute)(f) : m.mode === s.Text ? (0, r.escapeText)(f) : m.level === i.HTML ? m.mode === s.ASCII ? (0, n.encodeNonAsciiHTML)(f) : (0, n.encodeHTML)(f) : (0, r.encodeXML)(f);
  }
  t.encode = u;
  var l = Yo;
  Object.defineProperty(t, "encodeXML", { enumerable: !0, get: function() {
    return l.encodeXML;
  } }), Object.defineProperty(t, "escape", { enumerable: !0, get: function() {
    return l.escape;
  } }), Object.defineProperty(t, "escapeUTF8", { enumerable: !0, get: function() {
    return l.escapeUTF8;
  } }), Object.defineProperty(t, "escapeAttribute", { enumerable: !0, get: function() {
    return l.escapeAttribute;
  } }), Object.defineProperty(t, "escapeText", { enumerable: !0, get: function() {
    return l.escapeText;
  } });
  var c = Kr;
  Object.defineProperty(t, "encodeHTML", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } }), Object.defineProperty(t, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return c.encodeNonAsciiHTML;
  } }), Object.defineProperty(t, "encodeHTML4", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } }), Object.defineProperty(t, "encodeHTML5", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } });
  var d = Ks;
  Object.defineProperty(t, "EntityDecoder", { enumerable: !0, get: function() {
    return d.EntityDecoder;
  } }), Object.defineProperty(t, "DecodingMode", { enumerable: !0, get: function() {
    return d.DecodingMode;
  } }), Object.defineProperty(t, "decodeXML", { enumerable: !0, get: function() {
    return d.decodeXML;
  } }), Object.defineProperty(t, "decodeHTML", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTMLAttribute", { enumerable: !0, get: function() {
    return d.decodeHTMLAttribute;
  } }), Object.defineProperty(t, "decodeHTML4", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML5", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeXMLStrict", { enumerable: !0, get: function() {
    return d.decodeXML;
  } });
})(e1);
var Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.attributeNames = Ui.elementNames = void 0;
Ui.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(t) {
  return [t.toLowerCase(), t];
}));
Ui.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(t) {
  return [t.toLowerCase(), t];
}));
var Ai = be && be.__assign || function() {
  return Ai = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Ai.apply(this, arguments);
}, A2 = be && be.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(e, n);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[n];
  } }), Object.defineProperty(t, r, i);
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), v2 = be && be.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), I2 = be && be.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && A2(e, t, n);
  return v2(e, t), e;
};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.render = void 0;
var Yn = I2(es), Xo = e1, r1 = Ui, C2 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function L2(t) {
  return t.replace(/"/g, "&quot;");
}
function _2(t, e) {
  var n;
  if (t) {
    var r = ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) === !1 ? L2 : e.xmlMode || e.encodeEntities !== "utf8" ? Xo.encodeXML : Xo.escapeAttribute;
    return Object.keys(t).map(function(i) {
      var s, a, o = (s = t[i]) !== null && s !== void 0 ? s : "";
      return e.xmlMode === "foreign" && (i = (a = r1.attributeNames.get(i)) !== null && a !== void 0 ? a : i), !e.emptyAttrs && !e.xmlMode && o === "" ? i : "".concat(i, '="').concat(r(o), '"');
    }).join(" ");
  }
}
var Rh = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function Du(t, e) {
  e === void 0 && (e = {});
  for (var n = ("length" in t) ? t : [t], r = "", i = 0; i < n.length; i++)
    r += R2(n[i], e);
  return r;
}
ba.render = Du;
ba.default = Du;
function R2(t, e) {
  switch (t.type) {
    case Yn.Root:
      return Du(t.children, e);
    case Yn.Doctype:
    case Yn.Directive:
      return P2(t);
    case Yn.Comment:
      return M2(t);
    case Yn.CDATA:
      return N2(t);
    case Yn.Script:
    case Yn.Style:
    case Yn.Tag:
      return D2(t, e);
    case Yn.Text:
      return O2(t, e);
  }
}
var k2 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]), w2 = /* @__PURE__ */ new Set(["svg", "math"]);
function D2(t, e) {
  var n;
  e.xmlMode === "foreign" && (t.name = (n = r1.elementNames.get(t.name)) !== null && n !== void 0 ? n : t.name, t.parent && k2.has(t.parent.name) && (e = Ai(Ai({}, e), { xmlMode: !1 }))), !e.xmlMode && w2.has(t.name) && (e = Ai(Ai({}, e), { xmlMode: "foreign" }));
  var r = "<".concat(t.name), i = _2(t.attribs, e);
  return i && (r += " ".concat(i)), t.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== !1
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && Rh.has(t.name)
  )) ? (e.xmlMode || (r += " "), r += "/>") : (r += ">", t.children.length > 0 && (r += Du(t.children, e)), (e.xmlMode || !Rh.has(t.name)) && (r += "</".concat(t.name, ">"))), r;
}
function P2(t) {
  return "<".concat(t.data, ">");
}
function O2(t, e) {
  var n, r = t.data || "";
  return ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) !== !1 && !(!e.xmlMode && t.parent && C2.has(t.parent.name)) && (r = e.xmlMode || e.encodeEntities !== "utf8" ? (0, Xo.encodeXML)(r) : (0, Xo.escapeText)(r)), r;
}
function N2(t) {
  return "<![CDATA[".concat(t.children[0].data, "]]>");
}
function M2(t) {
  return "<!--".concat(t.data, "-->");
}
var F2 = be && be.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(kr, "__esModule", { value: !0 });
kr.getOuterHTML = i1;
kr.getInnerHTML = $2;
kr.getText = _o;
kr.textContent = yc;
kr.innerText = Tc;
var Dn = nr, B2 = F2(ba), U2 = es;
function i1(t, e) {
  return (0, B2.default)(t, e);
}
function $2(t, e) {
  return (0, Dn.hasChildren)(t) ? t.children.map(function(n) {
    return i1(n, e);
  }).join("") : "";
}
function _o(t) {
  return Array.isArray(t) ? t.map(_o).join("") : (0, Dn.isTag)(t) ? t.name === "br" ? `
` : _o(t.children) : (0, Dn.isCDATA)(t) ? _o(t.children) : (0, Dn.isText)(t) ? t.data : "";
}
function yc(t) {
  return Array.isArray(t) ? t.map(yc).join("") : (0, Dn.hasChildren)(t) && !(0, Dn.isComment)(t) ? yc(t.children) : (0, Dn.isText)(t) ? t.data : "";
}
function Tc(t) {
  return Array.isArray(t) ? t.map(Tc).join("") : (0, Dn.hasChildren)(t) && (t.type === U2.ElementType.Tag || (0, Dn.isCDATA)(t)) ? Tc(t.children) : (0, Dn.isText)(t) ? t.data : "";
}
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.getChildren = s1;
Hn.getParent = a1;
Hn.getSiblings = H2;
Hn.getAttributeValue = G2;
Hn.hasAttrib = V2;
Hn.getName = z2;
Hn.nextElementSibling = q2;
Hn.prevElementSibling = j2;
var Wd = nr;
function s1(t) {
  return (0, Wd.hasChildren)(t) ? t.children : [];
}
function a1(t) {
  return t.parent || null;
}
function H2(t) {
  var e, n, r = a1(t);
  if (r != null)
    return s1(r);
  for (var i = [t], s = t.prev, a = t.next; s != null; )
    i.unshift(s), e = s, s = e.prev;
  for (; a != null; )
    i.push(a), n = a, a = n.next;
  return i;
}
function G2(t, e) {
  var n;
  return (n = t.attribs) === null || n === void 0 ? void 0 : n[e];
}
function V2(t, e) {
  return t.attribs != null && Object.prototype.hasOwnProperty.call(t.attribs, e) && t.attribs[e] != null;
}
function z2(t) {
  return t.name;
}
function q2(t) {
  for (var e, n = t.next; n !== null && !(0, Wd.isTag)(n); )
    e = n, n = e.next;
  return n;
}
function j2(t) {
  for (var e, n = t.prev; n !== null && !(0, Wd.isTag)(n); )
    e = n, n = e.prev;
  return n;
}
var wr = {};
Object.defineProperty(wr, "__esModule", { value: !0 });
wr.removeElement = Ea;
wr.replaceElement = K2;
wr.appendChild = W2;
wr.append = Y2;
wr.prependChild = X2;
wr.prepend = Q2;
function Ea(t) {
  if (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.parent) {
    var e = t.parent.children, n = e.lastIndexOf(t);
    n >= 0 && e.splice(n, 1);
  }
  t.next = null, t.prev = null, t.parent = null;
}
function K2(t, e) {
  var n = e.prev = t.prev;
  n && (n.next = e);
  var r = e.next = t.next;
  r && (r.prev = e);
  var i = e.parent = t.parent;
  if (i) {
    var s = i.children;
    s[s.lastIndexOf(t)] = e, t.parent = null;
  }
}
function W2(t, e) {
  if (Ea(e), e.next = null, e.parent = t, t.children.push(e) > 1) {
    var n = t.children[t.children.length - 2];
    n.next = e, e.prev = n;
  } else
    e.prev = null;
}
function Y2(t, e) {
  Ea(e);
  var n = t.parent, r = t.next;
  if (e.next = r, e.prev = t, t.next = e, e.parent = n, r) {
    if (r.prev = e, n) {
      var i = n.children;
      i.splice(i.lastIndexOf(r), 0, e);
    }
  } else n && n.children.push(e);
}
function X2(t, e) {
  if (Ea(e), e.parent = t, e.prev = null, t.children.unshift(e) !== 1) {
    var n = t.children[1];
    n.prev = e, e.next = n;
  } else
    e.next = null;
}
function Q2(t, e) {
  Ea(e);
  var n = t.parent;
  if (n) {
    var r = n.children;
    r.splice(r.indexOf(t), 0, e);
  }
  t.prev && (t.prev.next = e), e.parent = n, e.prev = t.prev, e.next = t, t.prev = e;
}
var ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.filter = Z2;
ur.find = o1;
ur.findOneChild = J2;
ur.findOne = u1;
ur.existsOne = l1;
ur.findAll = eA;
var Wr = nr;
function Z2(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), o1(t, Array.isArray(e) ? e : [e], n, r);
}
function o1(t, e, n, r) {
  for (var i = [], s = [Array.isArray(e) ? e : [e]], a = [0]; ; ) {
    if (a[0] >= s[0].length) {
      if (a.length === 1)
        return i;
      s.shift(), a.shift();
      continue;
    }
    var o = s[0][a[0]++];
    if (t(o) && (i.push(o), --r <= 0))
      return i;
    n && (0, Wr.hasChildren)(o) && o.children.length > 0 && (a.unshift(0), s.unshift(o.children));
  }
}
function J2(t, e) {
  return e.find(t);
}
function u1(t, e, n) {
  n === void 0 && (n = !0);
  for (var r = Array.isArray(e) ? e : [e], i = 0; i < r.length; i++) {
    var s = r[i];
    if ((0, Wr.isTag)(s) && t(s))
      return s;
    if (n && (0, Wr.hasChildren)(s) && s.children.length > 0) {
      var a = u1(t, s.children, !0);
      if (a)
        return a;
    }
  }
  return null;
}
function l1(t, e) {
  return (Array.isArray(e) ? e : [e]).some(function(n) {
    return (0, Wr.isTag)(n) && t(n) || (0, Wr.hasChildren)(n) && l1(t, n.children);
  });
}
function eA(t, e) {
  for (var n = [], r = [Array.isArray(e) ? e : [e]], i = [0]; ; ) {
    if (i[0] >= r[0].length) {
      if (r.length === 1)
        return n;
      r.shift(), i.shift();
      continue;
    }
    var s = r[0][i[0]++];
    (0, Wr.isTag)(s) && t(s) && n.push(s), (0, Wr.hasChildren)(s) && s.children.length > 0 && (i.unshift(0), r.unshift(s.children));
  }
}
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.testElement = nA;
lr.getElements = rA;
lr.getElementById = iA;
lr.getElementsByTagName = sA;
lr.getElementsByClassName = aA;
lr.getElementsByTagType = oA;
var Br = nr, ya = ur, Qo = {
  tag_name: function(t) {
    return typeof t == "function" ? function(e) {
      return (0, Br.isTag)(e) && t(e.name);
    } : t === "*" ? Br.isTag : function(e) {
      return (0, Br.isTag)(e) && e.name === t;
    };
  },
  tag_type: function(t) {
    return typeof t == "function" ? function(e) {
      return t(e.type);
    } : function(e) {
      return e.type === t;
    };
  },
  tag_contains: function(t) {
    return typeof t == "function" ? function(e) {
      return (0, Br.isText)(e) && t(e.data);
    } : function(e) {
      return (0, Br.isText)(e) && e.data === t;
    };
  }
};
function Yd(t, e) {
  return typeof e == "function" ? function(n) {
    return (0, Br.isTag)(n) && e(n.attribs[t]);
  } : function(n) {
    return (0, Br.isTag)(n) && n.attribs[t] === e;
  };
}
function tA(t, e) {
  return function(n) {
    return t(n) || e(n);
  };
}
function c1(t) {
  var e = Object.keys(t).map(function(n) {
    var r = t[n];
    return Object.prototype.hasOwnProperty.call(Qo, n) ? Qo[n](r) : Yd(n, r);
  });
  return e.length === 0 ? null : e.reduce(tA);
}
function nA(t, e) {
  var n = c1(t);
  return n ? n(e) : !0;
}
function rA(t, e, n, r) {
  r === void 0 && (r = 1 / 0);
  var i = c1(t);
  return i ? (0, ya.filter)(i, e, n, r) : [];
}
function iA(t, e, n) {
  return n === void 0 && (n = !0), Array.isArray(e) || (e = [e]), (0, ya.findOne)(Yd("id", t), e, n);
}
function sA(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, ya.filter)(Qo.tag_name(t), e, n, r);
}
function aA(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, ya.filter)(Yd("class", t), e, n, r);
}
function oA(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, ya.filter)(Qo.tag_type(t), e, n, r);
}
var Zr = {};
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.DocumentPosition = void 0;
Zr.removeSubsets = uA;
Zr.compareDocumentPosition = d1;
Zr.uniqueSort = lA;
var kh = nr;
function uA(t) {
  for (var e = t.length; --e >= 0; ) {
    var n = t[e];
    if (e > 0 && t.lastIndexOf(n, e - 1) >= 0) {
      t.splice(e, 1);
      continue;
    }
    for (var r = n.parent; r; r = r.parent)
      if (t.includes(r)) {
        t.splice(e, 1);
        break;
      }
  }
  return t;
}
var fn;
(function(t) {
  t[t.DISCONNECTED = 1] = "DISCONNECTED", t[t.PRECEDING = 2] = "PRECEDING", t[t.FOLLOWING = 4] = "FOLLOWING", t[t.CONTAINS = 8] = "CONTAINS", t[t.CONTAINED_BY = 16] = "CONTAINED_BY";
})(fn || (Zr.DocumentPosition = fn = {}));
function d1(t, e) {
  var n = [], r = [];
  if (t === e)
    return 0;
  for (var i = (0, kh.hasChildren)(t) ? t : t.parent; i; )
    n.unshift(i), i = i.parent;
  for (i = (0, kh.hasChildren)(e) ? e : e.parent; i; )
    r.unshift(i), i = i.parent;
  for (var s = Math.min(n.length, r.length), a = 0; a < s && n[a] === r[a]; )
    a++;
  if (a === 0)
    return fn.DISCONNECTED;
  var o = n[a - 1], u = o.children, l = n[a], c = r[a];
  return u.indexOf(l) > u.indexOf(c) ? o === e ? fn.FOLLOWING | fn.CONTAINED_BY : fn.FOLLOWING : o === t ? fn.PRECEDING | fn.CONTAINS : fn.PRECEDING;
}
function lA(t) {
  return t = t.filter(function(e, n, r) {
    return !r.includes(e, n + 1);
  }), t.sort(function(e, n) {
    var r = d1(e, n);
    return r & fn.PRECEDING ? -1 : r & fn.FOLLOWING ? 1 : 0;
  }), t;
}
var Xd = {};
Object.defineProperty(Xd, "__esModule", { value: !0 });
Xd.getFeed = dA;
var cA = kr, Ta = lr;
function dA(t) {
  var e = Zo(gA, t);
  return e ? e.name === "feed" ? fA(e) : hA(e) : null;
}
function fA(t) {
  var e, n = t.children, r = {
    type: "atom",
    items: (0, Ta.getElementsByTagName)("entry", n).map(function(a) {
      var o, u = a.children, l = { media: f1(u) };
      Pt(l, "id", "id", u), Pt(l, "title", "title", u);
      var c = (o = Zo("link", u)) === null || o === void 0 ? void 0 : o.attribs.href;
      c && (l.link = c);
      var d = xr("summary", u) || xr("content", u);
      d && (l.description = d);
      var f = xr("updated", u);
      return f && (l.pubDate = new Date(f)), l;
    })
  };
  Pt(r, "id", "id", n), Pt(r, "title", "title", n);
  var i = (e = Zo("link", n)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (r.link = i), Pt(r, "description", "subtitle", n);
  var s = xr("updated", n);
  return s && (r.updated = new Date(s)), Pt(r, "author", "email", n, !0), r;
}
function hA(t) {
  var e, n, r = (n = (e = Zo("channel", t.children)) === null || e === void 0 ? void 0 : e.children) !== null && n !== void 0 ? n : [], i = {
    type: t.name.substr(0, 3),
    id: "",
    items: (0, Ta.getElementsByTagName)("item", t.children).map(function(a) {
      var o = a.children, u = { media: f1(o) };
      Pt(u, "id", "guid", o), Pt(u, "title", "title", o), Pt(u, "link", "link", o), Pt(u, "description", "description", o);
      var l = xr("pubDate", o) || xr("dc:date", o);
      return l && (u.pubDate = new Date(l)), u;
    })
  };
  Pt(i, "title", "title", r), Pt(i, "link", "link", r), Pt(i, "description", "description", r);
  var s = xr("lastBuildDate", r);
  return s && (i.updated = new Date(s)), Pt(i, "author", "managingEditor", r, !0), i;
}
var mA = ["url", "type", "lang"], pA = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function f1(t) {
  return (0, Ta.getElementsByTagName)("media:content", t).map(function(e) {
    for (var n = e.attribs, r = {
      medium: n.medium,
      isDefault: !!n.isDefault
    }, i = 0, s = mA; i < s.length; i++) {
      var a = s[i];
      n[a] && (r[a] = n[a]);
    }
    for (var o = 0, u = pA; o < u.length; o++) {
      var a = u[o];
      n[a] && (r[a] = parseInt(n[a], 10));
    }
    return n.expression && (r.expression = n.expression), r;
  });
}
function Zo(t, e) {
  return (0, Ta.getElementsByTagName)(t, e, !0, 1)[0];
}
function xr(t, e, n) {
  return n === void 0 && (n = !1), (0, cA.textContent)((0, Ta.getElementsByTagName)(t, e, n, 1)).trim();
}
function Pt(t, e, n, r, i) {
  i === void 0 && (i = !1);
  var s = xr(n, r, i);
  s && (t[e] = s);
}
function gA(t) {
  return t === "rss" || t === "feed" || t === "rdf:RDF";
}
(function(t) {
  var e = be && be.__createBinding || (Object.create ? function(i, s, a, o) {
    o === void 0 && (o = a);
    var u = Object.getOwnPropertyDescriptor(s, a);
    (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return s[a];
    } }), Object.defineProperty(i, o, u);
  } : function(i, s, a, o) {
    o === void 0 && (o = a), i[o] = s[a];
  }), n = be && be.__exportStar || function(i, s) {
    for (var a in i) a !== "default" && !Object.prototype.hasOwnProperty.call(s, a) && e(s, i, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.hasChildren = t.isDocument = t.isComment = t.isText = t.isCDATA = t.isTag = void 0, n(kr, t), n(Hn, t), n(wr, t), n(ur, t), n(lr, t), n(Zr, t), n(Xd, t);
  var r = nr;
  Object.defineProperty(t, "isTag", { enumerable: !0, get: function() {
    return r.isTag;
  } }), Object.defineProperty(t, "isCDATA", { enumerable: !0, get: function() {
    return r.isCDATA;
  } }), Object.defineProperty(t, "isText", { enumerable: !0, get: function() {
    return r.isText;
  } }), Object.defineProperty(t, "isComment", { enumerable: !0, get: function() {
    return r.isComment;
  } }), Object.defineProperty(t, "isDocument", { enumerable: !0, get: function() {
    return r.isDocument;
  } }), Object.defineProperty(t, "hasChildren", { enumerable: !0, get: function() {
    return r.hasChildren;
  } });
})(Lo);
(function(t) {
  var e = be && be.__createBinding || (Object.create ? function(E, y, T, S) {
    S === void 0 && (S = T);
    var v = Object.getOwnPropertyDescriptor(y, T);
    (!v || ("get" in v ? !y.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return y[T];
    } }), Object.defineProperty(E, S, v);
  } : function(E, y, T, S) {
    S === void 0 && (S = T), E[S] = y[T];
  }), n = be && be.__setModuleDefault || (Object.create ? function(E, y) {
    Object.defineProperty(E, "default", { enumerable: !0, value: y });
  } : function(E, y) {
    E.default = y;
  }), r = be && be.__importStar || function(E) {
    if (E && E.__esModule) return E;
    var y = {};
    if (E != null) for (var T in E) T !== "default" && Object.prototype.hasOwnProperty.call(E, T) && e(y, E, T);
    return n(y, E), y;
  }, i = be && be.__importDefault || function(E) {
    return E && E.__esModule ? E : { default: E };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomUtils = t.parseFeed = t.getFeed = t.ElementType = t.Tokenizer = t.createDomStream = t.parseDOM = t.parseDocument = t.DefaultHandler = t.DomHandler = t.Parser = void 0;
  var s = js, a = js;
  Object.defineProperty(t, "Parser", { enumerable: !0, get: function() {
    return a.Parser;
  } });
  var o = nr, u = nr;
  Object.defineProperty(t, "DomHandler", { enumerable: !0, get: function() {
    return u.DomHandler;
  } }), Object.defineProperty(t, "DefaultHandler", { enumerable: !0, get: function() {
    return u.DomHandler;
  } });
  function l(E, y) {
    var T = new o.DomHandler(void 0, y);
    return new s.Parser(T, y).end(E), T.root;
  }
  t.parseDocument = l;
  function c(E, y) {
    return l(E, y).children;
  }
  t.parseDOM = c;
  function d(E, y, T) {
    var S = new o.DomHandler(E, y, T);
    return new s.Parser(S, y);
  }
  t.createDomStream = d;
  var f = Gd;
  Object.defineProperty(t, "Tokenizer", { enumerable: !0, get: function() {
    return i(f).default;
  } }), t.ElementType = r(es);
  var h = Lo, m = Lo;
  Object.defineProperty(t, "getFeed", { enumerable: !0, get: function() {
    return m.getFeed;
  } });
  var p = { xmlMode: !0 };
  function g(E, y) {
    return y === void 0 && (y = p), (0, h.getFeed)(c(E, y));
  }
  t.parseFeed = g, t.DomUtils = r(Lo);
})(Hg);
var bA = (t) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, Qd = {};
Object.defineProperty(Qd, "__esModule", { value: !0 });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function wh(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function EA(t) {
  var e, n;
  return wh(t) === !1 ? !1 : (e = t.constructor, e === void 0 ? !0 : (n = e.prototype, !(wh(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
Qd.isPlainObject = EA;
var yA = function(e) {
  return TA(e) && !xA(e);
};
function TA(t) {
  return !!t && typeof t == "object";
}
function xA(t) {
  var e = Object.prototype.toString.call(t);
  return e === "[object RegExp]" || e === "[object Date]" || vA(t);
}
var SA = typeof Symbol == "function" && Symbol.for, AA = SA ? Symbol.for("react.element") : 60103;
function vA(t) {
  return t.$$typeof === AA;
}
function IA(t) {
  return Array.isArray(t) ? [] : {};
}
function Ws(t, e) {
  return e.clone !== !1 && e.isMergeableObject(t) ? $i(IA(t), t, e) : t;
}
function CA(t, e, n) {
  return t.concat(e).map(function(r) {
    return Ws(r, n);
  });
}
function LA(t, e) {
  if (!e.customMerge)
    return $i;
  var n = e.customMerge(t);
  return typeof n == "function" ? n : $i;
}
function _A(t) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter(function(e) {
    return Object.propertyIsEnumerable.call(t, e);
  }) : [];
}
function Dh(t) {
  return Object.keys(t).concat(_A(t));
}
function h1(t, e) {
  try {
    return e in t;
  } catch {
    return !1;
  }
}
function RA(t, e) {
  return h1(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e));
}
function kA(t, e, n) {
  var r = {};
  return n.isMergeableObject(t) && Dh(t).forEach(function(i) {
    r[i] = Ws(t[i], n);
  }), Dh(e).forEach(function(i) {
    RA(t, i) || (h1(t, i) && n.isMergeableObject(e[i]) ? r[i] = LA(i, n)(t[i], e[i], n) : r[i] = Ws(e[i], n));
  }), r;
}
function $i(t, e, n) {
  n = n || {}, n.arrayMerge = n.arrayMerge || CA, n.isMergeableObject = n.isMergeableObject || yA, n.cloneUnlessOtherwiseSpecified = Ws;
  var r = Array.isArray(e), i = Array.isArray(t), s = r === i;
  return s ? r ? n.arrayMerge(t, e, n) : kA(t, e, n) : Ws(e, n);
}
$i.all = function(e, n) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(r, i) {
    return $i(r, i, n);
  }, {});
};
var wA = $i, DA = wA, m1 = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.parseSrcset = n();
  })(be, function() {
    return function(e) {
      function n(S) {
        return S === " " || // space
        S === "	" || // horizontal tab
        S === `
` || // new line
        S === "\f" || // form feed
        S === "\r";
      }
      function r(S) {
        var v, I = S.exec(e.substring(g));
        if (I)
          return v = I[0], g += v.length, v;
      }
      for (var i = e.length, s = /^[ \t\n\r\u000c]+/, a = /^[, \t\n\r\u000c]+/, o = /^[^ \t\n\r\u000c]+/, u = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, d, f, h, m, p, g = 0, E = []; ; ) {
        if (r(a), g >= i)
          return E;
        d = r(o), f = [], d.slice(-1) === "," ? (d = d.replace(u, ""), T()) : y();
      }
      function y() {
        for (r(s), h = "", m = "in descriptor"; ; ) {
          if (p = e.charAt(g), m === "in descriptor")
            if (n(p))
              h && (f.push(h), h = "", m = "after descriptor");
            else if (p === ",") {
              g += 1, h && f.push(h), T();
              return;
            } else if (p === "(")
              h = h + p, m = "in parens";
            else if (p === "") {
              h && f.push(h), T();
              return;
            } else
              h = h + p;
          else if (m === "in parens")
            if (p === ")")
              h = h + p, m = "in descriptor";
            else if (p === "") {
              f.push(h), T();
              return;
            } else
              h = h + p;
          else if (m === "after descriptor" && !n(p))
            if (p === "") {
              T();
              return;
            } else
              m = "in descriptor", g -= 1;
          g += 1;
        }
      }
      function T() {
        var S = !1, v, I, C, D, _ = {}, A, L, N, U, z;
        for (D = 0; D < f.length; D++)
          A = f[D], L = A[A.length - 1], N = A.substring(0, A.length - 1), U = parseInt(N, 10), z = parseFloat(N), l.test(N) && L === "w" ? ((v || I) && (S = !0), U === 0 ? S = !0 : v = U) : c.test(N) && L === "x" ? ((v || I || C) && (S = !0), z < 0 ? S = !0 : I = z) : l.test(N) && L === "h" ? ((C || I) && (S = !0), U === 0 ? S = !0 : C = U) : S = !0;
        S ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + A + "'.") : (_.url = d, v && (_.w = v), I && (_.d = I), C && (_.h = C), E.push(_));
      }
    };
  });
})(m1);
var PA = m1.exports, Zd = { exports: {} }, Se = String, p1 = function() {
  return { isColorSupported: !1, reset: Se, bold: Se, dim: Se, italic: Se, underline: Se, inverse: Se, hidden: Se, strikethrough: Se, black: Se, red: Se, green: Se, yellow: Se, blue: Se, magenta: Se, cyan: Se, white: Se, gray: Se, bgBlack: Se, bgRed: Se, bgGreen: Se, bgYellow: Se, bgBlue: Se, bgMagenta: Se, bgCyan: Se, bgWhite: Se, blackBright: Se, redBright: Se, greenBright: Se, yellowBright: Se, blueBright: Se, magentaBright: Se, cyanBright: Se, whiteBright: Se, bgBlackBright: Se, bgRedBright: Se, bgGreenBright: Se, bgYellowBright: Se, bgBlueBright: Se, bgMagentaBright: Se, bgCyanBright: Se, bgWhiteBright: Se };
};
Zd.exports = p1();
Zd.exports.createColors = p1;
var OA = Zd.exports;
const NA = {}, MA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NA
}, Symbol.toStringTag, { value: "Module" })), bn = /* @__PURE__ */ l2(MA);
let Ph = OA, Oh = bn, xc = class g1 extends Error {
  constructor(e, n, r, i, s, a) {
    super(e), this.name = "CssSyntaxError", this.reason = e, s && (this.file = s), i && (this.source = i), a && (this.plugin = a), typeof n < "u" && typeof r < "u" && (typeof n == "number" ? (this.line = n, this.column = r) : (this.line = n.line, this.column = n.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, g1);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let n = this.source;
    e == null && (e = Ph.isColorSupported), Oh && e && (n = Oh(n));
    let r = n.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, r.length), a = String(s).length, o, u;
    if (e) {
      let { bold: l, gray: c, red: d } = Ph.createColors(!0);
      o = (f) => l(d(f)), u = (f) => c(f);
    } else
      o = u = (l) => l;
    return r.slice(i, s).map((l, c) => {
      let d = i + 1 + c, f = " " + (" " + d).slice(-a) + " | ";
      if (d === this.line) {
        let h = u(f.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return o(">") + u(f) + l + `
 ` + h + o("^");
      }
      return " " + u(f) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Jd = xc;
xc.default = xc;
var xa = {};
xa.isClean = Symbol("isClean");
xa.my = Symbol("my");
const Nh = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function FA(t) {
  return t[0].toUpperCase() + t.slice(1);
}
let Sc = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, n) {
    let r = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : i && (r += " "), e.nodes)
      this.block(e, r + i);
    else {
      let s = (e.raws.between || "") + (n ? ";" : "");
      this.builder(r + i + s, e);
    }
  }
  beforeAfter(e, n) {
    let r;
    e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : n === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
    let i = e.parent, s = 0;
    for (; i && i.type !== "root"; )
      s += 1, i = i.parent;
    if (r.includes(`
`)) {
      let a = this.raw(e, null, "indent");
      if (a.length)
        for (let o = 0; o < s; o++) r += a;
    }
    return r;
  }
  block(e, n) {
    let r = this.raw(e, "between", "beforeOpen");
    this.builder(n + r + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  body(e) {
    let n = e.nodes.length - 1;
    for (; n > 0 && e.nodes[n].type === "comment"; )
      n -= 1;
    let r = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let s = e.nodes[i], a = this.raw(s, "before");
      a && this.builder(a), this.stringify(s, n !== i || r);
    }
  }
  comment(e) {
    let n = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
    this.builder("/*" + n + e.text + r + "*/", e);
  }
  decl(e, n) {
    let r = this.raw(e, "between", "colon"), i = e.prop + r + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), n && (i += ";"), this.builder(i, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, n, r) {
    let i;
    if (r || (r = n), n && (i = e.raws[n], typeof i < "u"))
      return i;
    let s = e.parent;
    if (r === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
      return "";
    if (!s) return Nh[r];
    let a = e.root();
    if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[r] < "u")
      return a.rawCache[r];
    if (r === "before" || r === "after")
      return this.beforeAfter(e, r);
    {
      let o = "raw" + FA(r);
      this[o] ? i = this[o](a, e) : a.walk((u) => {
        if (i = u.raws[n], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = Nh[r]), a.rawCache[r] = i, i;
  }
  rawBeforeClose(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u")
        return n = r.raws.after, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeComment(e, n) {
    let r;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return r = i.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(n, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeDecl(e, n) {
    let r;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return r = i.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(n, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeOpen(e) {
    let n;
    return e.walk((r) => {
      if (r.type !== "decl" && (n = r.raws.between, typeof n < "u"))
        return !1;
    }), n;
  }
  rawBeforeRule(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u")
        return n = r.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawColon(e) {
    let n;
    return e.walkDecls((r) => {
      if (typeof r.raws.between < "u")
        return n = r.raws.between.replace(/[^\s:]/g, ""), !1;
    }), n;
  }
  rawEmptyBody(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length === 0 && (n = r.raws.after, typeof n < "u"))
        return !1;
    }), n;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let n;
    return e.walk((r) => {
      let i = r.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof r.raws.before < "u") {
        let s = r.raws.before.split(`
`);
        return n = s[s.length - 1], n = n.replace(/\S/g, ""), !1;
      }
    }), n;
  }
  rawSemicolon(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length && r.last.type === "decl" && (n = r.raws.semicolon, typeof n < "u"))
        return !1;
    }), n;
  }
  rawValue(e, n) {
    let r = e[n], i = e.raws[n];
    return i && i.value === r ? i.raw : r;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, n) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, n);
  }
};
var b1 = Sc;
Sc.default = Sc;
let BA = b1;
function Ac(t, e) {
  new BA(e).stringify(t);
}
var Pu = Ac;
Ac.default = Ac;
let { isClean: Ba, my: UA } = xa, $A = Jd, HA = b1, GA = Pu;
function vc(t, e) {
  let n = new t.constructor();
  for (let r in t) {
    if (!Object.prototype.hasOwnProperty.call(t, r) || r === "proxyCache") continue;
    let i = t[r], s = typeof i;
    r === "parent" && s === "object" ? e && (n[r] = e) : r === "source" ? n[r] = i : Array.isArray(i) ? n[r] = i.map((a) => vc(a, n)) : (s === "object" && i !== null && (i = vc(i)), n[r] = i);
  }
  return n;
}
let Ic = class {
  constructor(e = {}) {
    this.raws = {}, this[Ba] = !1, this[UA] = !0;
    for (let n in e)
      if (n === "nodes") {
        this.nodes = [];
        for (let r of e[n])
          typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
      } else
        this[n] = e[n];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let n = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${n.input.from}:${n.start.line}:${n.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let n in e)
      this[n] = e[n];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let n = vc(this);
    for (let r in e)
      n[r] = e[r];
    return n;
  }
  cloneAfter(e = {}) {
    let n = this.clone(e);
    return this.parent.insertAfter(this, n), n;
  }
  cloneBefore(e = {}) {
    let n = this.clone(e);
    return this.parent.insertBefore(this, n), n;
  }
  error(e, n = {}) {
    if (this.source) {
      let { end: r, start: i } = this.rangeBy(n);
      return this.source.input.error(
        e,
        { column: i.column, line: i.line },
        { column: r.column, line: r.line },
        n
      );
    }
    return new $A(e);
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : n === "root" ? () => e.root().toProxy() : e[n];
      },
      set(e, n, r) {
        return e[n] === r || (e[n] = r, (n === "prop" || n === "value" || n === "name" || n === "params" || n === "important" || /* c8 ignore next */
        n === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[Ba]) {
      this[Ba] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Ba] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, n) {
    let r = this.source.start;
    if (e.index)
      r = this.positionInside(e.index, n);
    else if (e.word) {
      n = this.toString();
      let i = n.indexOf(e.word);
      i !== -1 && (r = this.positionInside(i, n));
    }
    return r;
  }
  positionInside(e, n) {
    let r = n || this.toString(), i = this.source.start.column, s = this.source.start.line;
    for (let a = 0; a < e; a++)
      r[a] === `
` ? (i = 1, s += 1) : i += 1;
    return { column: i, line: s };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let n = {
      column: this.source.start.column,
      line: this.source.start.line
    }, r = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: n.column + 1,
      line: n.line
    };
    if (e.word) {
      let i = this.toString(), s = i.indexOf(e.word);
      s !== -1 && (n = this.positionInside(s, i), r = this.positionInside(s + e.word.length, i));
    } else
      e.start ? n = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (n = this.positionInside(e.index)), e.end ? r = {
        column: e.end.column,
        line: e.end.line
      } : e.endIndex ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
    return (r.line < n.line || r.line === n.line && r.column <= n.column) && (r = { column: n.column + 1, line: n.line }), { end: r, start: n };
  }
  raw(e, n) {
    return new HA().raw(this, e, n);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let n = this, r = !1;
      for (let i of e)
        i === this ? r = !0 : r ? (this.parent.insertAfter(n, i), n = i) : this.parent.insertBefore(n, i);
      r || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, n) {
    let r = {}, i = n == null;
    n = n || /* @__PURE__ */ new Map();
    let s = 0;
    for (let a in this) {
      if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue;
      let o = this[a];
      if (Array.isArray(o))
        r[a] = o.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, n) : u);
      else if (typeof o == "object" && o.toJSON)
        r[a] = o.toJSON(null, n);
      else if (a === "source") {
        let u = n.get(o.input);
        u == null && (u = s, n.set(o.input, s), s++), r[a] = {
          end: o.end,
          inputId: u,
          start: o.start
        };
      } else
        r[a] = o;
    }
    return i && (r.inputs = [...n.keys()].map((a) => a.toJSON())), r;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = GA) {
    e.stringify && (e = e.stringify);
    let n = "";
    return e(this, (r) => {
      n += r;
    }), n;
  }
  warn(e, n, r) {
    let i = { node: this };
    for (let s in r) i[s] = r[s];
    return e.warn(n, i);
  }
  get proxyOf() {
    return this;
  }
};
var Ou = Ic;
Ic.default = Ic;
let VA = Ou, Cc = class extends VA {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var Nu = Cc;
Cc.default = Cc;
let zA = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", qA = (t = 21) => {
  let e = "", n = t | 0;
  for (; n--; )
    e += zA[Math.random() * 64 | 0];
  return e;
};
var jA = { nanoid: qA };
let { SourceMapConsumer: Mh, SourceMapGenerator: Fh } = bn, { existsSync: KA, readFileSync: WA } = bn, { dirname: ul, join: YA } = bn;
function XA(t) {
  return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
}
let Lc = class {
  constructor(e, n) {
    if (n.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let r = n.map ? n.map.prev : void 0, i = this.loadMap(n.from, r);
    !this.mapFile && n.from && (this.mapFile = n.from), this.mapFile && (this.root = ul(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Mh(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let n = /^data:application\/json;charset=utf-?8;base64,/, r = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/;
    if (i.test(e) || s.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (n.test(e) || r.test(e))
      return XA(e.substr(RegExp.lastMatch.length));
    let a = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + a);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let n = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!n) return;
    let r = e.lastIndexOf(n.pop()), i = e.indexOf("*/", r);
    r > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(r, i)));
  }
  loadFile(e) {
    if (this.root = ul(e), KA(e))
      return this.mapFile = e, WA(e, "utf-8").toString().trim();
  }
  loadMap(e, n) {
    if (n === !1) return !1;
    if (n) {
      if (typeof n == "string")
        return n;
      if (typeof n == "function") {
        let r = n(e);
        if (r) {
          let i = this.loadFile(r);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + r.toString()
            );
          return i;
        }
      } else {
        if (n instanceof Mh)
          return Fh.fromSourceMap(n).toString();
        if (n instanceof Fh)
          return n.toString();
        if (this.isMap(n))
          return JSON.stringify(n);
        throw new Error(
          "Unsupported previous source map format: " + n.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let r = this.annotation;
        return e && (r = YA(ul(e), r)), this.loadFile(r);
      }
    }
  }
  startWith(e, n) {
    return e ? e.substr(0, n.length) === n : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var E1 = Lc;
Lc.default = Lc;
let { SourceMapConsumer: QA, SourceMapGenerator: ZA } = bn, { fileURLToPath: Bh, pathToFileURL: Ua } = bn, { isAbsolute: _c, resolve: Rc } = bn, { nanoid: JA } = jA, ll = bn, Uh = Jd, ev = E1, cl = Symbol("fromOffsetCache"), tv = !!(QA && ZA), $h = !!(Rc && _c), Jo = class {
  constructor(e, n = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, n.from && (!$h || /^\w+:\/\//.test(n.from) || _c(n.from) ? this.file = n.from : this.file = Rc(n.from)), $h && tv) {
      let r = new ev(this.css, n);
      if (r.text) {
        this.map = r;
        let i = r.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + JA(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, n, r, i = {}) {
    let s, a, o;
    if (n && typeof n == "object") {
      let l = n, c = r;
      if (typeof l.offset == "number") {
        let d = this.fromOffset(l.offset);
        n = d.line, r = d.col;
      } else
        n = l.line, r = l.column;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        a = d.line, o = d.col;
      } else
        a = c.line, o = c.column;
    } else if (!r) {
      let l = this.fromOffset(n);
      n = l.line, r = l.col;
    }
    let u = this.origin(n, r, a, o);
    return u ? s = new Uh(
      e,
      u.endLine === void 0 ? u.line : { column: u.column, line: u.line },
      u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine },
      u.source,
      u.file,
      i.plugin
    ) : s = new Uh(
      e,
      a === void 0 ? n : { column: r, line: n },
      a === void 0 ? r : { column: o, line: a },
      this.css,
      this.file,
      i.plugin
    ), s.input = { column: r, endColumn: o, endLine: a, line: n, source: this.css }, this.file && (Ua && (s.input.url = Ua(this.file).toString()), s.input.file = this.file), s;
  }
  fromOffset(e) {
    let n, r;
    if (this[cl])
      r = this[cl];
    else {
      let s = this.css.split(`
`);
      r = new Array(s.length);
      let a = 0;
      for (let o = 0, u = s.length; o < u; o++)
        r[o] = a, a += s[o].length + 1;
      this[cl] = r;
    }
    n = r[r.length - 1];
    let i = 0;
    if (e >= n)
      i = r.length - 1;
    else {
      let s = r.length - 2, a;
      for (; i < s; )
        if (a = i + (s - i >> 1), e < r[a])
          s = a - 1;
        else if (e >= r[a + 1])
          i = a + 1;
        else {
          i = a;
          break;
        }
    }
    return {
      col: e - r[i] + 1,
      line: i + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Rc(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, n, r, i) {
    if (!this.map) return !1;
    let s = this.map.consumer(), a = s.originalPositionFor({ column: n, line: e });
    if (!a.source) return !1;
    let o;
    typeof r == "number" && (o = s.originalPositionFor({ column: i, line: r }));
    let u;
    _c(a.source) ? u = Ua(a.source) : u = new URL(
      a.source,
      this.map.consumer().sourceRoot || Ua(this.map.mapFile)
    );
    let l = {
      column: a.column,
      endColumn: o && o.column,
      endLine: o && o.line,
      line: a.line,
      url: u.toString()
    };
    if (u.protocol === "file:")
      if (Bh)
        l.file = Bh(u);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = s.sourceContentFor(a.source);
    return c && (l.source = c), l;
  }
  toJSON() {
    let e = {};
    for (let n of ["hasBOM", "css", "file", "id"])
      this[n] != null && (e[n] = this[n]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var Mu = Jo;
Jo.default = Jo;
ll && ll.registerInput && ll.registerInput(Jo);
let { SourceMapConsumer: y1, SourceMapGenerator: Ro } = bn, { dirname: ko, relative: T1, resolve: x1, sep: S1 } = bn, { pathToFileURL: Hh } = bn, nv = Mu, rv = !!(y1 && Ro), iv = !!(ko && x1 && T1 && S1), sv = class {
  constructor(e, n, r, i) {
    this.stringify = e, this.mapOpts = r.map || {}, this.root = n, this.opts = r, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let n = `
`;
    this.css.includes(`\r
`) && (n = `\r
`), this.css += n + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let n = this.toUrl(this.path(e.file)), r = e.root || ko(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new y1(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, n, this.toUrl(this.path(r)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let n = this.root.nodes.length - 1; n >= 0; n--)
          e = this.root.nodes[n], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(n);
      } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), iv && rv && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (n) => {
        e += n;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Ro.fromSourceMap(e);
    } else
      this.map = new Ro({ file: this.outputFile() }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Ro({ file: this.outputFile() });
    let e = 1, n = 1, r = "<no source>", i = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, s, a;
    this.stringify(this.root, (o, u, l) => {
      if (this.css += o, u && l !== "end" && (i.generated.line = e, i.generated.column = n - 1, u.source && u.source.start ? (i.source = this.sourcePath(u), i.original.line = u.source.start.line, i.original.column = u.source.start.column - 1, this.map.addMapping(i)) : (i.source = r, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), s = o.match(/\n/g), s ? (e += s.length, a = o.lastIndexOf(`
`), n = o.length - a) : n += o.length, u && l !== "start") {
        let c = u.parent || { raws: {} };
        (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== c.last || c.raws.semicolon) && (u.source && u.source.end ? (i.source = this.sourcePath(u), i.original.line = u.source.end.line, i.original.column = u.source.end.column - 1, i.generated.line = e, i.generated.column = n - 2, this.map.addMapping(i)) : (i.source = r, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = n - 1, this.map.addMapping(i)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((n) => n.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let n = this.memoizedPaths.get(e);
    if (n) return n;
    let r = this.opts.to ? ko(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (r = ko(x1(r, this.mapOpts.annotation)));
    let i = T1(r, e);
    return this.memoizedPaths.set(e, i), i;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let n = e.source.input.map;
            this.previousMaps.includes(n) || this.previousMaps.push(n);
          }
        });
      else {
        let e = new nv(this.css, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((n) => {
        if (n.source) {
          let r = n.source.input.from;
          if (r && !e[r]) {
            e[r] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(r) : this.toUrl(this.path(r));
            this.map.setSourceContent(i, n.source.input.css);
          }
        }
      });
    else if (this.css) {
      let n = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(n, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let n = this.memoizedFileURLs.get(e);
    if (n) return n;
    if (Hh) {
      let r = Hh(e).toString();
      return this.memoizedFileURLs.set(e, r), r;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let n = this.memoizedURLs.get(e);
    if (n) return n;
    S1 === "\\" && (e = e.replace(/\\/g, "/"));
    let r = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, r), r;
  }
};
var A1 = sv;
let av = Ou, kc = class extends av {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var Fu = kc;
kc.default = kc;
let { isClean: v1, my: I1 } = xa, C1 = Nu, L1 = Fu, ov = Ou, _1, ef, tf, R1;
function k1(t) {
  return t.map((e) => (e.nodes && (e.nodes = k1(e.nodes)), delete e.source, e));
}
function w1(t) {
  if (t[v1] = !1, t.proxyOf.nodes)
    for (let e of t.proxyOf.nodes)
      w1(e);
}
let rr = class D1 extends ov {
  append(...e) {
    for (let n of e) {
      let r = this.normalize(n, this.last);
      for (let i of r) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let n of this.nodes) n.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let n = this.getIterator(), r, i;
    for (; this.indexes[n] < this.proxyOf.nodes.length && (r = this.indexes[n], i = e(this.proxyOf.nodes[r], r), i !== !1); )
      this.indexes[n] += 1;
    return delete this.indexes[n], i;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : e[n] ? n === "each" || typeof n == "string" && n.startsWith("walk") ? (...r) => e[n](
          ...r.map((i) => typeof i == "function" ? (s, a) => i(s.toProxy(), a) : i)
        ) : n === "every" || n === "some" ? (r) => e[n](
          (i, ...s) => r(i.toProxy(), ...s)
        ) : n === "root" ? () => e.root().toProxy() : n === "nodes" ? e.nodes.map((r) => r.toProxy()) : n === "first" || n === "last" ? e[n].toProxy() : e[n] : e[n];
      },
      set(e, n, r) {
        return e[n] === r || (e[n] = r, (n === "name" || n === "params" || n === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, n) {
    let r = this.index(e), i = this.normalize(n, this.proxyOf.nodes[r]).reverse();
    r = this.index(e);
    for (let a of i) this.proxyOf.nodes.splice(r + 1, 0, a);
    let s;
    for (let a in this.indexes)
      s = this.indexes[a], r < s && (this.indexes[a] = s + i.length);
    return this.markDirty(), this;
  }
  insertBefore(e, n) {
    let r = this.index(e), i = r === 0 ? "prepend" : !1, s = this.normalize(n, this.proxyOf.nodes[r], i).reverse();
    r = this.index(e);
    for (let o of s) this.proxyOf.nodes.splice(r, 0, o);
    let a;
    for (let o in this.indexes)
      a = this.indexes[o], r <= a && (this.indexes[o] = a + s.length);
    return this.markDirty(), this;
  }
  normalize(e, n) {
    if (typeof e == "string")
      e = k1(_1(e).nodes);
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new C1(e)];
    } else if (e.selector)
      e = [new ef(e)];
    else if (e.name)
      e = [new tf(e)];
    else if (e.text)
      e = [new L1(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[I1] || D1.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[v1] && w1(i), typeof i.raws.before > "u" && n && typeof n.raws.before < "u" && (i.raws.before = n.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  prepend(...e) {
    e = e.reverse();
    for (let n of e) {
      let r = this.normalize(n, this.first, "prepend").reverse();
      for (let i of r) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + r.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let n;
    for (let r in this.indexes)
      n = this.indexes[r], n >= e && (this.indexes[r] = n - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, n, r) {
    return r || (r = n, n = {}), this.walkDecls((i) => {
      n.props && !n.props.includes(i.prop) || n.fast && !i.value.includes(n.fast) || (i.value = i.value.replace(e, r));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((n, r) => {
      let i;
      try {
        i = e(n, r);
      } catch (s) {
        throw n.addToError(s);
      }
      return i !== !1 && n.walk && (i = n.walk(e)), i;
    });
  }
  walkAtRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "atrule" && e.test(r.name))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "atrule" && r.name === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "atrule")
        return n(r, i);
    }));
  }
  walkComments(e) {
    return this.walk((n, r) => {
      if (n.type === "comment")
        return e(n, r);
    });
  }
  walkDecls(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "decl" && e.test(r.prop))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "decl" && r.prop === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "decl")
        return n(r, i);
    }));
  }
  walkRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "rule" && e.test(r.selector))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "rule" && r.selector === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "rule")
        return n(r, i);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
rr.registerParse = (t) => {
  _1 = t;
};
rr.registerRule = (t) => {
  ef = t;
};
rr.registerAtRule = (t) => {
  tf = t;
};
rr.registerRoot = (t) => {
  R1 = t;
};
var Jr = rr;
rr.default = rr;
rr.rebuild = (t) => {
  t.type === "atrule" ? Object.setPrototypeOf(t, tf.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, ef.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, C1.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, L1.prototype) : t.type === "root" && Object.setPrototypeOf(t, R1.prototype), t[I1] = !0, t.nodes && t.nodes.forEach((e) => {
    rr.rebuild(e);
  });
};
let uv = Jr, P1, O1, Ys = class extends uv {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new P1(new O1(), this, e).stringify();
  }
};
Ys.registerLazyResult = (t) => {
  P1 = t;
};
Ys.registerProcessor = (t) => {
  O1 = t;
};
var nf = Ys;
Ys.default = Ys;
let wc = class {
  constructor(e, n = {}) {
    if (this.type = "warning", this.text = e, n.node && n.node.source) {
      let r = n.node.rangeBy(n);
      this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
    }
    for (let r in n) this[r] = n[r];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var N1 = wc;
wc.default = wc;
let lv = N1, Dc = class {
  constructor(e, n, r) {
    this.processor = e, this.messages = [], this.root = n, this.opts = r, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, n = {}) {
    n.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (n.plugin = this.lastPlugin.postcssPlugin);
    let r = new lv(e, n);
    return this.messages.push(r), r;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var rf = Dc;
Dc.default = Dc;
const dl = 39, Gh = 34, $a = 92, Vh = 47, Ha = 10, gs = 32, Ga = 12, Va = 9, za = 13, cv = 91, dv = 93, fv = 40, hv = 41, mv = 123, pv = 125, gv = 59, bv = 42, Ev = 58, yv = 64, qa = /[\t\n\f\r "#'()/;[\\\]{}]/g, ja = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Tv = /.[\r\n"'(/\\]/, zh = /[\da-f]/i;
var xv = function(e, n = {}) {
  let r = e.css.valueOf(), i = n.ignoreErrors, s, a, o, u, l, c, d, f, h, m, p = r.length, g = 0, E = [], y = [];
  function T() {
    return g;
  }
  function S(D) {
    throw e.error("Unclosed " + D, g);
  }
  function v() {
    return y.length === 0 && g >= p;
  }
  function I(D) {
    if (y.length) return y.pop();
    if (g >= p) return;
    let _ = D ? D.ignoreUnclosed : !1;
    switch (s = r.charCodeAt(g), s) {
      case Ha:
      case gs:
      case Va:
      case za:
      case Ga: {
        a = g;
        do
          a += 1, s = r.charCodeAt(a);
        while (s === gs || s === Ha || s === Va || s === za || s === Ga);
        m = ["space", r.slice(g, a)], g = a - 1;
        break;
      }
      case cv:
      case dv:
      case mv:
      case pv:
      case Ev:
      case gv:
      case hv: {
        let A = String.fromCharCode(s);
        m = [A, A, g];
        break;
      }
      case fv: {
        if (f = E.length ? E.pop()[1] : "", h = r.charCodeAt(g + 1), f === "url" && h !== dl && h !== Gh && h !== gs && h !== Ha && h !== Va && h !== Ga && h !== za) {
          a = g;
          do {
            if (c = !1, a = r.indexOf(")", a + 1), a === -1)
              if (i || _) {
                a = g;
                break;
              } else
                S("bracket");
            for (d = a; r.charCodeAt(d - 1) === $a; )
              d -= 1, c = !c;
          } while (c);
          m = ["brackets", r.slice(g, a + 1), g, a], g = a;
        } else
          a = r.indexOf(")", g + 1), u = r.slice(g, a + 1), a === -1 || Tv.test(u) ? m = ["(", "(", g] : (m = ["brackets", u, g, a], g = a);
        break;
      }
      case dl:
      case Gh: {
        o = s === dl ? "'" : '"', a = g;
        do {
          if (c = !1, a = r.indexOf(o, a + 1), a === -1)
            if (i || _) {
              a = g + 1;
              break;
            } else
              S("string");
          for (d = a; r.charCodeAt(d - 1) === $a; )
            d -= 1, c = !c;
        } while (c);
        m = ["string", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      case yv: {
        qa.lastIndex = g + 1, qa.test(r), qa.lastIndex === 0 ? a = r.length - 1 : a = qa.lastIndex - 2, m = ["at-word", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      case $a: {
        for (a = g, l = !0; r.charCodeAt(a + 1) === $a; )
          a += 1, l = !l;
        if (s = r.charCodeAt(a + 1), l && s !== Vh && s !== gs && s !== Ha && s !== Va && s !== za && s !== Ga && (a += 1, zh.test(r.charAt(a)))) {
          for (; zh.test(r.charAt(a + 1)); )
            a += 1;
          r.charCodeAt(a + 1) === gs && (a += 1);
        }
        m = ["word", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      default: {
        s === Vh && r.charCodeAt(g + 1) === bv ? (a = r.indexOf("*/", g + 2) + 1, a === 0 && (i || _ ? a = r.length : S("comment")), m = ["comment", r.slice(g, a + 1), g, a], g = a) : (ja.lastIndex = g + 1, ja.test(r), ja.lastIndex === 0 ? a = r.length - 1 : a = ja.lastIndex - 2, m = ["word", r.slice(g, a + 1), g, a], E.push(m), g = a);
        break;
      }
    }
    return g++, m;
  }
  function C(D) {
    y.push(D);
  }
  return {
    back: C,
    endOfFile: v,
    nextToken: I,
    position: T
  };
};
let M1 = Jr, eu = class extends M1 {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var sf = eu;
eu.default = eu;
M1.registerAtRule(eu);
let F1 = Jr, B1, U1, Hi = class extends F1 {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, n, r) {
    let i = super.normalize(e);
    if (n) {
      if (r === "prepend")
        this.nodes.length > 1 ? n.raws.before = this.nodes[1].raws.before : delete n.raws.before;
      else if (this.first !== n)
        for (let s of i)
          s.raws.before = n.raws.before;
    }
    return i;
  }
  removeChild(e, n) {
    let r = this.index(e);
    return !n && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new B1(new U1(), this, e).stringify();
  }
};
Hi.registerLazyResult = (t) => {
  B1 = t;
};
Hi.registerProcessor = (t) => {
  U1 = t;
};
var Sa = Hi;
Hi.default = Hi;
F1.registerRoot(Hi);
let Xs = {
  comma(t) {
    return Xs.split(t, [","], !0);
  },
  space(t) {
    let e = [" ", `
`, "	"];
    return Xs.split(t, e);
  },
  split(t, e, n) {
    let r = [], i = "", s = !1, a = 0, o = !1, u = "", l = !1;
    for (let c of t)
      l ? l = !1 : c === "\\" ? l = !0 : o ? c === u && (o = !1) : c === '"' || c === "'" ? (o = !0, u = c) : c === "(" ? a += 1 : c === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(c) && (s = !0), s ? (i !== "" && r.push(i.trim()), i = "", s = !1) : i += c;
    return (n || i !== "") && r.push(i.trim()), r;
  }
};
var $1 = Xs;
Xs.default = Xs;
let H1 = Jr, Sv = $1, tu = class extends H1 {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return Sv.comma(this.selector);
  }
  set selectors(e) {
    let n = this.selector ? this.selector.match(/,\s*/) : null, r = n ? n[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(r);
  }
};
var af = tu;
tu.default = tu;
H1.registerRule(tu);
let Av = Nu, vv = xv, Iv = Fu, Cv = sf, Lv = Sa, qh = af;
const jh = {
  empty: !0,
  space: !0
};
function _v(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let n = t[e], r = n[3] || n[2];
    if (r) return r;
  }
}
let Rv = class {
  constructor(e) {
    this.input = e, this.root = new Lv(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let n = new Cv();
    n.name = e[1].slice(1), n.name === "" && this.unnamedAtrule(n, e), this.init(n, e[2]);
    let r, i, s, a = !1, o = !1, u = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? l.push(r === "(" ? ")" : "]") : r === "{" && l.length > 0 ? l.push("}") : r === l[l.length - 1] && l.pop(), l.length === 0)
        if (r === ";") {
          n.source.end = this.getPosition(e[2]), n.source.end.offset++, this.semicolon = !0;
          break;
        } else if (r === "{") {
          o = !0;
          break;
        } else if (r === "}") {
          if (u.length > 0) {
            for (s = u.length - 1, i = u[s]; i && i[0] === "space"; )
              i = u[--s];
            i && (n.source.end = this.getPosition(i[3] || i[2]), n.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          u.push(e);
      else
        u.push(e);
      if (this.tokenizer.endOfFile()) {
        a = !0;
        break;
      }
    }
    n.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (n.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(n, "params", u), a && (e = u[u.length - 1], n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++, this.spaces = n.raws.between, n.raws.between = "")) : (n.raws.afterName = "", n.params = ""), o && (n.nodes = [], this.current = n);
  }
  checkMissedSemicolon(e) {
    let n = this.colon(e);
    if (n === !1) return;
    let r = 0, i;
    for (let s = n - 1; s >= 0 && (i = e[s], !(i[0] !== "space" && (r += 1, r === 2))); s--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
  colon(e) {
    let n = 0, r, i, s;
    for (let [a, o] of e.entries()) {
      if (r = o, i = r[0], i === "(" && (n += 1), i === ")" && (n -= 1), n === 0 && i === ":")
        if (!s)
          this.doubleColon(r);
        else {
          if (s[0] === "word" && s[1] === "progid")
            continue;
          return a;
        }
      s = r;
    }
    return !1;
  }
  comment(e) {
    let n = new Iv();
    this.init(n, e[2]), n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++;
    let r = e[1].slice(2, -2);
    if (/^\s*$/.test(r))
      n.text = "", n.raws.left = r, n.raws.right = "";
    else {
      let i = r.match(/^(\s*)([^]*\S)(\s*)$/);
      n.text = i[2], n.raws.left = i[1], n.raws.right = i[3];
    }
  }
  createTokenizer() {
    this.tokenizer = vv(this.input);
  }
  decl(e, n) {
    let r = new Av();
    this.init(r, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), r.source.end = this.getPosition(
      i[3] || i[2] || _v(e)
    ), r.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
    for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      r.prop += e.shift()[1];
    }
    r.raws.between = "";
    let s;
    for (; e.length; )
      if (s = e.shift(), s[0] === ":") {
        r.raws.between += s[1];
        break;
      } else
        s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), r.raws.between += s[1];
    (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
    let a = [], o;
    for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
      a.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (s = e[l], s[1].toLowerCase() === "!important") {
        r.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (r.raws.important = c);
        break;
      } else if (s[1].toLowerCase() === "important") {
        let c = e.slice(0), d = "";
        for (let f = l; f > 0; f--) {
          let h = c[f][0];
          if (d.trim().indexOf("!") === 0 && h !== "space")
            break;
          d = c.pop()[1] + d;
        }
        d.trim().indexOf("!") === 0 && (r.important = !0, r.raws.important = d, e = c);
      }
      if (s[0] !== "space" && s[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (r.raws.between += a.map((l) => l[1]).join(""), a = []), this.raw(r, "value", a.concat(e), n), r.value.includes(":") && !n && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let n = new qh();
    this.init(n, e[2]), n.selector = "", n.raws.between = "", this.current = n;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let n = this.current.nodes[this.current.nodes.length - 1];
      n && n.type === "rule" && !n.raws.ownSemicolon && (n.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let n = this.input.fromOffset(e);
    return {
      column: n.col,
      line: n.line,
      offset: e
    };
  }
  init(e, n) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(n)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let n = !1, r = null, i = !1, s = null, a = [], o = e[1].startsWith("--"), u = [], l = e;
    for (; l; ) {
      if (r = l[0], u.push(l), r === "(" || r === "[")
        s || (s = l), a.push(r === "(" ? ")" : "]");
      else if (o && i && r === "{")
        s || (s = l), a.push("}");
      else if (a.length === 0)
        if (r === ";")
          if (i) {
            this.decl(u, o);
            return;
          } else
            break;
        else if (r === "{") {
          this.rule(u);
          return;
        } else if (r === "}") {
          this.tokenizer.back(u.pop()), n = !0;
          break;
        } else r === ":" && (i = !0);
      else r === a[a.length - 1] && (a.pop(), a.length === 0 && (s = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (n = !0), a.length > 0 && this.unclosedBracket(s), n && i) {
      if (!o)
        for (; u.length && (l = u[u.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(u.pop());
      this.decl(u, o);
    } else
      this.unknownWord(u);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, n, r, i) {
    let s, a, o = r.length, u = "", l = !0, c, d;
    for (let f = 0; f < o; f += 1)
      s = r[f], a = s[0], a === "space" && f === o - 1 && !i ? l = !1 : a === "comment" ? (d = r[f - 1] ? r[f - 1][0] : "empty", c = r[f + 1] ? r[f + 1][0] : "empty", !jh[d] && !jh[c] ? u.slice(-1) === "," ? l = !1 : u += s[1] : l = !1) : u += s[1];
    if (!l) {
      let f = r.reduce((h, m) => h + m[1], "");
      e.raws[n] = { raw: f, value: u };
    }
    e[n] = u;
  }
  rule(e) {
    e.pop();
    let n = new qh();
    this.init(n, e[0][2]), n.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(n, "selector", e), this.current = n;
  }
  spacesAndCommentsFromEnd(e) {
    let n, r = "";
    for (; e.length && (n = e[e.length - 1][0], !(n !== "space" && n !== "comment")); )
      r = e.pop()[1] + r;
    return r;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let n, r = "";
    for (; e.length && (n = e[0][0], !(n !== "space" && n !== "comment")); )
      r += e.shift()[1];
    return r;
  }
  spacesFromEnd(e) {
    let n, r = "";
    for (; e.length && (n = e[e.length - 1][0], n === "space"); )
      r = e.pop()[1] + r;
    return r;
  }
  stringFrom(e, n) {
    let r = "";
    for (let i = n; i < e.length; i++)
      r += e[i][1];
    return e.splice(n, e.length - n), r;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, n) {
    throw this.input.error(
      "At-rule without name",
      { offset: n[2] },
      { offset: n[2] + n[1].length }
    );
  }
};
var kv = Rv;
let wv = Jr, Dv = kv, Pv = Mu;
function nu(t, e) {
  let n = new Pv(t, e), r = new Dv(n);
  try {
    r.parse();
  } catch (i) {
    throw i;
  }
  return r.root;
}
var of = nu;
nu.default = nu;
wv.registerParse(nu);
let { isClean: xn, my: Ov } = xa, Nv = A1, Mv = Pu, Fv = Jr, Bv = nf, Kh = rf, Uv = of, $v = Sa;
const Hv = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, Gv = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, Vv = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, Gi = 0;
function bs(t) {
  return typeof t == "object" && typeof t.then == "function";
}
function G1(t) {
  let e = !1, n = Hv[t.type];
  return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
    n,
    n + "-" + e,
    Gi,
    n + "Exit",
    n + "Exit-" + e
  ] : e ? [n, n + "-" + e, n + "Exit", n + "Exit-" + e] : t.append ? [n, Gi, n + "Exit"] : [n, n + "Exit"];
}
function Wh(t) {
  let e;
  return t.type === "document" ? e = ["Document", Gi, "DocumentExit"] : t.type === "root" ? e = ["Root", Gi, "RootExit"] : e = G1(t), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: t,
    visitorIndex: 0,
    visitors: []
  };
}
function Pc(t) {
  return t[xn] = !1, t.nodes && t.nodes.forEach((e) => Pc(e)), t;
}
let Oc = {}, Vi = class V1 {
  constructor(e, n, r) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof n == "object" && n !== null && (n.type === "root" || n.type === "document"))
      i = Pc(n);
    else if (n instanceof V1 || n instanceof Kh)
      i = Pc(n.root), n.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = !1), r.map.prev = n.map);
    else {
      let s = Uv;
      r.syntax && (s = r.syntax.parse), r.parser && (s = r.parser), s.parse && (s = s.parse);
      try {
        i = s(n, r);
      } catch (a) {
        this.processed = !0, this.error = a;
      }
      i && !i[Ov] && Fv.rebuild(i);
    }
    this.result = new Kh(e, i, r), this.helpers = { ...Oc, postcss: Oc, result: this.result }, this.plugins = this.processor.plugins.map((s) => typeof s == "object" && s.prepare ? { ...s, ...s.prepare(this.result) } : s);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, n) {
    let r = this.result.lastPlugin;
    try {
      n && n.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (n, r, i) => {
      this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([n, i]);
    };
    for (let n of this.plugins)
      if (typeof n == "object")
        for (let r in n) {
          if (!Gv[r] && /^[A-Z]/.test(r))
            throw new Error(
              `Unknown event ${r} in ${n.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!Vv[r])
            if (typeof n[r] == "object")
              for (let i in n[r])
                i === "*" ? e(n, r, n[r][i]) : e(
                  n,
                  r + "-" + i.toLowerCase(),
                  n[r][i]
                );
            else typeof n[r] == "function" && e(n, r, n[r]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let n = this.plugins[e], r = this.runOnRoot(n);
      if (bs(r))
        try {
          await r;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[xn]; ) {
        e[xn] = !0;
        let n = [Wh(e)];
        for (; n.length > 0; ) {
          let r = this.visitTick(n);
          if (bs(r))
            try {
              await r;
            } catch (i) {
              let s = n[n.length - 1].node;
              throw this.handleError(i, s);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [n, r] of this.listeners.OnceExit) {
          this.result.lastPlugin = n;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (s) => r(s, this.helpers)
              );
              await Promise.all(i);
            } else
              await r(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let n = this.result.root.nodes.map(
            (r) => e.Once(r, this.helpers)
          );
          return bs(n[0]) ? Promise.all(n) : n;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (n) {
      throw this.handleError(n);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, n = Mv;
    e.syntax && (n = e.syntax.stringify), e.stringifier && (n = e.stringifier), n.stringify && (n = n.stringify);
    let i = new Nv(n, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let n = this.runOnRoot(e);
      if (bs(n))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[xn]; )
        e[xn] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let n of e.nodes)
            this.visitSync(this.listeners.OnceExit, n);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, n) {
    return this.async().then(e, n);
  }
  toString() {
    return this.css;
  }
  visitSync(e, n) {
    for (let [r, i] of e) {
      this.result.lastPlugin = r;
      let s;
      try {
        s = i(n, this.helpers);
      } catch (a) {
        throw this.handleError(a, n.proxyOf);
      }
      if (n.type !== "root" && n.type !== "document" && !n.parent)
        return !0;
      if (bs(s))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let n = e[e.length - 1], { node: r, visitors: i } = n;
    if (r.type !== "root" && r.type !== "document" && !r.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && n.visitorIndex < i.length) {
      let [a, o] = i[n.visitorIndex];
      n.visitorIndex += 1, n.visitorIndex === i.length && (n.visitors = [], n.visitorIndex = 0), this.result.lastPlugin = a;
      try {
        return o(r.toProxy(), this.helpers);
      } catch (u) {
        throw this.handleError(u, r);
      }
    }
    if (n.iterator !== 0) {
      let a = n.iterator, o;
      for (; o = r.nodes[r.indexes[a]]; )
        if (r.indexes[a] += 1, !o[xn]) {
          o[xn] = !0, e.push(Wh(o));
          return;
        }
      n.iterator = 0, delete r.indexes[a];
    }
    let s = n.events;
    for (; n.eventIndex < s.length; ) {
      let a = s[n.eventIndex];
      if (n.eventIndex += 1, a === Gi) {
        r.nodes && r.nodes.length && (r[xn] = !0, n.iterator = r.getIterator());
        return;
      } else if (this.listeners[a]) {
        n.visitors = this.listeners[a];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[xn] = !0;
    let n = G1(e);
    for (let r of n)
      if (r === Gi)
        e.nodes && e.each((i) => {
          i[xn] || this.walkSync(i);
        });
      else {
        let i = this.listeners[r];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
Vi.registerPostcss = (t) => {
  Oc = t;
};
var z1 = Vi;
Vi.default = Vi;
$v.registerLazyResult(Vi);
Bv.registerLazyResult(Vi);
let zv = A1, qv = Pu, jv = of;
const Kv = rf;
let Nc = class {
  constructor(e, n, r) {
    n = n.toString(), this.stringified = !1, this._processor = e, this._css = n, this._opts = r, this._map = void 0;
    let i, s = qv;
    this.result = new Kv(this._processor, i, this._opts), this.result.css = n;
    let a = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return a.root;
      }
    });
    let o = new zv(s, i, this._opts, n);
    if (o.isMap()) {
      let [u, l] = o.generate();
      u && (this.result.css = u), l && (this.result.map = l);
    }
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, n) {
    return this.async().then(e, n);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, n = jv;
    try {
      e = n(this._css, this._opts);
    } catch (r) {
      this.error = r;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var Wv = Nc;
Nc.default = Nc;
let Yv = Wv, Xv = z1, Qv = nf, Zv = Sa, Qs = class {
  constructor(e = []) {
    this.version = "8.4.31", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let n = [];
    for (let r of e)
      if (r.postcss === !0 ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins))
        n = n.concat(r.plugins);
      else if (typeof r == "object" && r.postcssPlugin)
        n.push(r);
      else if (typeof r == "function")
        n.push(r);
      else if (!(typeof r == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
    return n;
  }
  process(e, n = {}) {
    return this.plugins.length === 0 && typeof n.parser > "u" && typeof n.stringifier > "u" && typeof n.syntax > "u" ? new Yv(this, e, n) : new Xv(this, e, n);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var Jv = Qs;
Qs.default = Qs;
Zv.registerProcessor(Qs);
Qv.registerProcessor(Qs);
let eI = Nu, tI = E1, nI = Fu, rI = sf, iI = Mu, sI = Sa, aI = af;
function Zs(t, e) {
  if (Array.isArray(t)) return t.map((i) => Zs(i));
  let { inputs: n, ...r } = t;
  if (n) {
    e = [];
    for (let i of n) {
      let s = { ...i, __proto__: iI.prototype };
      s.map && (s.map = {
        ...s.map,
        __proto__: tI.prototype
      }), e.push(s);
    }
  }
  if (r.nodes && (r.nodes = t.nodes.map((i) => Zs(i, e))), r.source) {
    let { inputId: i, ...s } = r.source;
    r.source = s, i != null && (r.source.input = e[i]);
  }
  if (r.type === "root")
    return new sI(r);
  if (r.type === "decl")
    return new eI(r);
  if (r.type === "rule")
    return new aI(r);
  if (r.type === "comment")
    return new nI(r);
  if (r.type === "atrule")
    return new rI(r);
  throw new Error("Unknown node type: " + t.type);
}
var oI = Zs;
Zs.default = Zs;
let uI = Jd, q1 = Nu, lI = z1, cI = Jr, uf = Jv, dI = Pu, fI = oI, j1 = nf, hI = N1, K1 = Fu, W1 = sf, mI = rf, pI = Mu, gI = of, bI = $1, Y1 = af, X1 = Sa, EI = Ou;
function Ue(...t) {
  return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new uf(t);
}
Ue.plugin = function(e, n) {
  let r = !1;
  function i(...a) {
    console && console.warn && !r && (r = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:
https://www.w3ctech.com/topic/2226`
    ));
    let o = n(...a);
    return o.postcssPlugin = e, o.postcssVersion = new uf().version, o;
  }
  let s;
  return Object.defineProperty(i, "postcss", {
    get() {
      return s || (s = i()), s;
    }
  }), i.process = function(a, o, u) {
    return Ue([i(u)]).process(a, o);
  }, i;
};
Ue.stringify = dI;
Ue.parse = gI;
Ue.fromJSON = fI;
Ue.list = bI;
Ue.comment = (t) => new K1(t);
Ue.atRule = (t) => new W1(t);
Ue.decl = (t) => new q1(t);
Ue.rule = (t) => new Y1(t);
Ue.root = (t) => new X1(t);
Ue.document = (t) => new j1(t);
Ue.CssSyntaxError = uI;
Ue.Declaration = q1;
Ue.Container = cI;
Ue.Processor = uf;
Ue.Document = j1;
Ue.Comment = K1;
Ue.Warning = hI;
Ue.AtRule = W1;
Ue.Result = mI;
Ue.Input = pI;
Ue.Rule = Y1;
Ue.Root = X1;
Ue.Node = EI;
lI.registerPostcss(Ue);
var yI = Ue;
Ue.default = Ue;
const TI = Hg, Yh = bA, { isPlainObject: xI } = Qd, Xh = DA, SI = PA, { parse: AI } = yI, vI = [
  "img",
  "audio",
  "video",
  "picture",
  "svg",
  "object",
  "map",
  "iframe",
  "embed"
], II = ["script", "style"];
function Ti(t, e) {
  t && Object.keys(t).forEach(function(n) {
    e(t[n], n);
  });
}
function Zn(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function Qh(t, e) {
  const n = [];
  return Ti(t, function(r) {
    e(r) && n.push(r);
  }), n;
}
function CI(t) {
  for (const e in t)
    if (Zn(t, e))
      return !1;
  return !0;
}
function LI(t) {
  return t.map(function(e) {
    if (!e.url)
      throw new Error("URL missing");
    return e.url + (e.w ? ` ${e.w}w` : "") + (e.h ? ` ${e.h}h` : "") + (e.d ? ` ${e.d}x` : "");
  }).join(", ");
}
var _I = Js;
const RI = /^[^\0\t\n\f\r /<=>]+$/;
function Js(t, e, n) {
  if (t == null)
    return "";
  typeof t == "number" && (t = t.toString());
  let r = "", i = "";
  function s(O, F) {
    const B = this;
    this.tag = O, this.attribs = F || {}, this.tagPosition = r.length, this.text = "", this.openingTagLength = 0, this.mediaChildren = [], this.updateParentNodeText = function() {
      if (g.length) {
        const H = g[g.length - 1];
        H.text += B.text;
      }
    }, this.updateParentNodeMediaChildren = function() {
      g.length && vI.includes(this.tag) && g[g.length - 1].mediaChildren.push(this.tag);
    };
  }
  e = Object.assign({}, Js.defaults, e), e.parser = Object.assign({}, kI, e.parser);
  const a = function(O) {
    return e.allowedTags === !1 || (e.allowedTags || []).indexOf(O) > -1;
  };
  II.forEach(function(O) {
    a(O) && !e.allowVulnerableTags && console.warn(`

âš ï¸ Your \`allowedTags\` option includes, \`${O}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
  });
  const o = e.nonTextTags || [
    "script",
    "style",
    "textarea",
    "option"
  ];
  let u, l;
  e.allowedAttributes && (u = {}, l = {}, Ti(e.allowedAttributes, function(O, F) {
    u[F] = [];
    const B = [];
    O.forEach(function(H) {
      typeof H == "string" && H.indexOf("*") >= 0 ? B.push(Yh(H).replace(/\\\*/g, ".*")) : u[F].push(H);
    }), B.length && (l[F] = new RegExp("^(" + B.join("|") + ")$"));
  }));
  const c = {}, d = {}, f = {};
  Ti(e.allowedClasses, function(O, F) {
    if (u && (Zn(u, F) || (u[F] = []), u[F].push("class")), c[F] = O, Array.isArray(O)) {
      const B = [];
      c[F] = [], f[F] = [], O.forEach(function(H) {
        typeof H == "string" && H.indexOf("*") >= 0 ? B.push(Yh(H).replace(/\\\*/g, ".*")) : H instanceof RegExp ? f[F].push(H) : c[F].push(H);
      }), B.length && (d[F] = new RegExp("^(" + B.join("|") + ")$"));
    }
  });
  const h = {};
  let m;
  Ti(e.transformTags, function(O, F) {
    let B;
    typeof O == "function" ? B = O : typeof O == "string" && (B = Js.simpleTransform(O)), F === "*" ? m = B : h[F] = B;
  });
  let p, g, E, y, T, S, v = !1;
  C();
  const I = new TI.Parser({
    onopentag: function(O, F) {
      if (e.onOpenTag && e.onOpenTag(O, F), e.enforceHtmlBoundary && O === "html" && C(), T) {
        S++;
        return;
      }
      const B = new s(O, F);
      g.push(B);
      let H = !1;
      const X = !!B.text;
      let w;
      if (Zn(h, O) && (w = h[O](O, F), B.attribs = F = w.attribs, w.text !== void 0 && (B.innerText = w.text), O !== w.tagName && (B.name = O = w.tagName, y[p] = w.tagName)), m && (w = m(O, F), B.attribs = F = w.attribs, O !== w.tagName && (B.name = O = w.tagName, y[p] = w.tagName)), (!a(O) || e.disallowedTagsMode === "recursiveEscape" && !CI(E) || e.nestingLimit != null && p >= e.nestingLimit) && (H = !0, E[p] = !0, (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && o.indexOf(O) !== -1 && (T = !0, S = 1)), p++, H) {
        if (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") {
          if (B.innerText && !X) {
            const R = D(B.innerText);
            e.textFilter ? r += e.textFilter(R, O) : r += R, v = !0;
          }
          return;
        }
        i = r, r = "";
      }
      r += "<" + O, O === "script" && (e.allowedScriptHostnames || e.allowedScriptDomains) && (B.innerText = ""), H && (e.disallowedTagsMode === "escape" || e.disallowedTagsMode === "recursiveEscape") && e.preserveEscapedAttributes ? Ti(F, function(R, te) {
        r += " " + te + '="' + D(R || "", !0) + '"';
      }) : (!u || Zn(u, O) || u["*"]) && Ti(F, function(R, te) {
        if (!RI.test(te)) {
          delete B.attribs[te];
          return;
        }
        if (R === "" && !e.allowedEmptyAttributes.includes(te) && (e.nonBooleanAttributes.includes(te) || e.nonBooleanAttributes.includes("*"))) {
          delete B.attribs[te];
          return;
        }
        let he = !1;
        if (!u || Zn(u, O) && u[O].indexOf(te) !== -1 || u["*"] && u["*"].indexOf(te) !== -1 || Zn(l, O) && l[O].test(te) || l["*"] && l["*"].test(te))
          he = !0;
        else if (u && u[O]) {
          for (const ae of u[O])
            if (xI(ae) && ae.name && ae.name === te) {
              he = !0;
              let me = "";
              if (ae.multiple === !0) {
                const ke = R.split(" ");
                for (const Pe of ke)
                  ae.values.indexOf(Pe) !== -1 && (me === "" ? me = Pe : me += " " + Pe);
              } else ae.values.indexOf(R) >= 0 && (me = R);
              R = me;
            }
        }
        if (he) {
          if (e.allowedSchemesAppliedToAttributes.indexOf(te) !== -1 && _(O, R)) {
            delete B.attribs[te];
            return;
          }
          if (O === "script" && te === "src") {
            let ae = !0;
            try {
              const me = A(R);
              if (e.allowedScriptHostnames || e.allowedScriptDomains) {
                const ke = (e.allowedScriptHostnames || []).find(function(Oe) {
                  return Oe === me.url.hostname;
                }), Pe = (e.allowedScriptDomains || []).find(function(Oe) {
                  return me.url.hostname === Oe || me.url.hostname.endsWith(`.${Oe}`);
                });
                ae = ke || Pe;
              }
            } catch {
              ae = !1;
            }
            if (!ae) {
              delete B.attribs[te];
              return;
            }
          }
          if (O === "iframe" && te === "src") {
            let ae = !0;
            try {
              const me = A(R);
              if (me.isRelativeUrl)
                ae = Zn(e, "allowIframeRelativeUrls") ? e.allowIframeRelativeUrls : !e.allowedIframeHostnames && !e.allowedIframeDomains;
              else if (e.allowedIframeHostnames || e.allowedIframeDomains) {
                const ke = (e.allowedIframeHostnames || []).find(function(Oe) {
                  return Oe === me.url.hostname;
                }), Pe = (e.allowedIframeDomains || []).find(function(Oe) {
                  return me.url.hostname === Oe || me.url.hostname.endsWith(`.${Oe}`);
                });
                ae = ke || Pe;
              }
            } catch {
              ae = !1;
            }
            if (!ae) {
              delete B.attribs[te];
              return;
            }
          }
          if (te === "srcset")
            try {
              let ae = SI(R);
              if (ae.forEach(function(me) {
                _("srcset", me.url) && (me.evil = !0);
              }), ae = Qh(ae, function(me) {
                return !me.evil;
              }), ae.length)
                R = LI(Qh(ae, function(me) {
                  return !me.evil;
                })), B.attribs[te] = R;
              else {
                delete B.attribs[te];
                return;
              }
            } catch {
              delete B.attribs[te];
              return;
            }
          if (te === "class") {
            const ae = c[O], me = c["*"], ke = d[O], Pe = f[O], Oe = f["*"], bt = d["*"], qn = [
              ke,
              bt
            ].concat(Pe, Oe).filter(function(Ht) {
              return Ht;
            });
            if (ae && me ? R = z(R, Xh(ae, me), qn) : R = z(R, ae || me, qn), !R.length) {
              delete B.attribs[te];
              return;
            }
          }
          if (te === "style") {
            if (e.parseStyleAttributes)
              try {
                const ae = AI(O + " {" + R + "}", { map: !1 }), me = L(ae, e.allowedStyles);
                if (R = N(me), R.length === 0) {
                  delete B.attribs[te];
                  return;
                }
              } catch {
                typeof window < "u" && console.warn('Failed to parse "' + O + " {" + R + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete B.attribs[te];
                return;
              }
            else if (e.allowedStyles)
              throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
          }
          r += " " + te, R && R.length ? r += '="' + D(R, !0) + '"' : e.allowedEmptyAttributes.includes(te) && (r += '=""');
        } else
          delete B.attribs[te];
      }), e.selfClosing.indexOf(O) !== -1 ? r += " />" : (r += ">", B.innerText && !X && !e.textFilter && (r += D(B.innerText), v = !0)), H && (r = i + D(r), i = ""), B.openingTagLength = r.length - B.tagPosition;
    },
    ontext: function(O) {
      if (T)
        return;
      const F = g[g.length - 1];
      let B;
      if (F && (B = F.tag, O = F.innerText !== void 0 ? F.innerText : O), e.disallowedTagsMode === "completelyDiscard" && !a(B))
        O = "";
      else if ((e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && (B === "script" || B === "style"))
        r += O;
      else if (!v) {
        const H = D(O, !1);
        e.textFilter ? r += e.textFilter(H, B) : r += H;
      }
      if (g.length) {
        const H = g[g.length - 1];
        H.text += O;
      }
    },
    onclosetag: function(O, F) {
      if (e.onCloseTag && e.onCloseTag(O, F), T)
        if (S--, !S)
          T = !1;
        else
          return;
      const B = g.pop();
      if (!B)
        return;
      if (B.tag !== O) {
        g.push(B);
        return;
      }
      T = e.enforceHtmlBoundary ? O === "html" : !1, p--;
      const H = E[p];
      if (H) {
        if (delete E[p], e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") {
          B.updateParentNodeText();
          return;
        }
        i = r, r = "";
      }
      if (y[p] && (O = y[p], delete y[p]), e.exclusiveFilter) {
        const X = e.exclusiveFilter(B);
        if (X === "excludeTag") {
          H && (r = i, i = ""), r = r.substring(0, B.tagPosition) + r.substring(B.tagPosition + B.openingTagLength);
          return;
        } else if (X) {
          r = r.substring(0, B.tagPosition);
          return;
        }
      }
      if (B.updateParentNodeMediaChildren(), B.updateParentNodeText(), // Already output />
      e.selfClosing.indexOf(O) !== -1 || // Escaped tag, closing tag is implied
      F && !a(O) && ["escape", "recursiveEscape"].indexOf(e.disallowedTagsMode) >= 0) {
        H && (r = i, i = "");
        return;
      }
      r += "</" + O + ">", H && (r = i + D(r), i = ""), v = !1;
    }
  }, e.parser);
  return I.write(t), I.end(), r;
  function C() {
    r = "", p = 0, g = [], E = {}, y = {}, T = !1, S = 0;
  }
  function D(O, F) {
    return typeof O != "string" && (O = O + ""), e.parser.decodeEntities && (O = O.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), F && (O = O.replace(/"/g, "&quot;"))), O = O.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), F && (O = O.replace(/"/g, "&quot;")), O;
  }
  function _(O, F) {
    for (F = F.replace(/[\x00-\x20]+/g, ""); ; ) {
      const X = F.indexOf("<!--");
      if (X === -1)
        break;
      const w = F.indexOf("-->", X + 4);
      if (w === -1)
        break;
      F = F.substring(0, X) + F.substring(w + 3);
    }
    const B = F.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!B)
      return F.match(/^[/\\]{2}/) ? !e.allowProtocolRelative : !1;
    const H = B[1].toLowerCase();
    return Zn(e.allowedSchemesByTag, O) ? e.allowedSchemesByTag[O].indexOf(H) === -1 : !e.allowedSchemes || e.allowedSchemes.indexOf(H) === -1;
  }
  function A(O) {
    if (O = O.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), O.startsWith("relative:"))
      throw new Error("relative: exploit attempt");
    let F = "relative://relative-site";
    for (let X = 0; X < 100; X++)
      F += `/${X}`;
    const B = new URL(O, F);
    return {
      isRelativeUrl: B && B.hostname === "relative-site" && B.protocol === "relative:",
      url: B
    };
  }
  function L(O, F) {
    if (!F)
      return O;
    const B = O.nodes[0];
    let H;
    return F[B.selector] && F["*"] ? H = Xh(
      F[B.selector],
      F["*"]
    ) : H = F[B.selector] || F["*"], H && (O.nodes[0].nodes = B.nodes.reduce(U(H), [])), O;
  }
  function N(O) {
    return O.nodes[0].nodes.reduce(function(F, B) {
      return F.push(
        `${B.prop}:${B.value}${B.important ? " !important" : ""}`
      ), F;
    }, []).join(";");
  }
  function U(O) {
    return function(F, B) {
      return Zn(O, B.prop) && O[B.prop].some(function(X) {
        return X.test(B.value);
      }) && F.push(B), F;
    };
  }
  function z(O, F, B) {
    return F ? (O = O.split(/\s+/), O.filter(function(H) {
      return F.indexOf(H) !== -1 || B.some(function(X) {
        return X.test(H);
      });
    }).join(" ")) : O;
  }
}
const kI = {
  decodeEntities: !0
};
Js.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    "address",
    "article",
    "aside",
    "footer",
    "header",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hgroup",
    "main",
    "nav",
    "section",
    // Text content
    "blockquote",
    "dd",
    "div",
    "dl",
    "dt",
    "figcaption",
    "figure",
    "hr",
    "li",
    "menu",
    "ol",
    "p",
    "pre",
    "ul",
    // Inline text semantics
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "cite",
    "code",
    "data",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "time",
    "u",
    "var",
    "wbr",
    // Table content
    "caption",
    "col",
    "colgroup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    "abbr",
    "accept",
    "accept-charset",
    "accesskey",
    "action",
    "allow",
    "alt",
    "as",
    "autocapitalize",
    "autocomplete",
    "blocking",
    "charset",
    "cite",
    "class",
    "color",
    "cols",
    "colspan",
    "content",
    "contenteditable",
    "coords",
    "crossorigin",
    "data",
    "datetime",
    "decoding",
    "dir",
    "dirname",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "fetchpriority",
    "for",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formtarget",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "http-equiv",
    "id",
    "imagesizes",
    "imagesrcset",
    "inputmode",
    "integrity",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemtype",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "name",
    "nonce",
    "optimum",
    "pattern",
    "ping",
    "placeholder",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "referrerpolicy",
    "rel",
    "rows",
    "rowspan",
    "sandbox",
    "scope",
    "shape",
    "size",
    "sizes",
    "slot",
    "span",
    "spellcheck",
    "src",
    "srcdoc",
    "srclang",
    "srcset",
    "start",
    "step",
    "style",
    "tabindex",
    "target",
    "title",
    "translate",
    "type",
    "usemap",
    "value",
    "width",
    "wrap",
    // Event handlers
    "onauxclick",
    "onafterprint",
    "onbeforematch",
    "onbeforeprint",
    "onbeforeunload",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onpagehide",
    "onpageshow",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onrejectionhandled",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwheel"
  ],
  disallowedTagsMode: "discard",
  allowedAttributes: {
    a: ["href", "name", "target"],
    // We don't currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
  },
  allowedEmptyAttributes: [
    "alt"
  ],
  // Lots of these won't come up by default because we don't allow them
  selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
  // URL schemes we permit
  allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
  allowProtocolRelative: !0,
  enforceHtmlBoundary: !1,
  parseStyleAttributes: !0,
  preserveEscapedAttributes: !1
};
Js.simpleTransform = function(t, e, n) {
  return n = n === void 0 ? !0 : n, e = e || {}, function(r, i) {
    let s;
    if (n)
      for (s in e)
        i[s] = e[s];
    else
      i = e;
    return {
      tagName: t,
      attribs: i
    };
  };
};
const wI = /* @__PURE__ */ $g(_I);
function DI(t) {
  return { __html: PI(t) };
}
function Aa(t, e) {
  const n = Object.keys(t).filter(
    (i) => e.includes(i) ? null : i
  ), r = new Object();
  return n.forEach((i) => {
    r[i] = t[i];
  }), r;
}
function PI(t) {
  return wI(t, {
    allowedAttributes: {
      a: ["href"],
      img: ["alt", "src", "height", "width"]
    },
    allowedSchemes: ["http", "https", "mailto"],
    allowedTags: [
      "a",
      "b",
      "br",
      "i",
      "img",
      "p",
      "small",
      "span",
      "sub",
      "sup"
    ]
  });
}
var He = "colors", Ct = "sizes", ce = "space", OI = { gap: ce, gridGap: ce, columnGap: ce, gridColumnGap: ce, rowGap: ce, gridRowGap: ce, inset: ce, insetBlock: ce, insetBlockEnd: ce, insetBlockStart: ce, insetInline: ce, insetInlineEnd: ce, insetInlineStart: ce, margin: ce, marginTop: ce, marginRight: ce, marginBottom: ce, marginLeft: ce, marginBlock: ce, marginBlockEnd: ce, marginBlockStart: ce, marginInline: ce, marginInlineEnd: ce, marginInlineStart: ce, padding: ce, paddingTop: ce, paddingRight: ce, paddingBottom: ce, paddingLeft: ce, paddingBlock: ce, paddingBlockEnd: ce, paddingBlockStart: ce, paddingInline: ce, paddingInlineEnd: ce, paddingInlineStart: ce, top: ce, right: ce, bottom: ce, left: ce, scrollMargin: ce, scrollMarginTop: ce, scrollMarginRight: ce, scrollMarginBottom: ce, scrollMarginLeft: ce, scrollMarginX: ce, scrollMarginY: ce, scrollMarginBlock: ce, scrollMarginBlockEnd: ce, scrollMarginBlockStart: ce, scrollMarginInline: ce, scrollMarginInlineEnd: ce, scrollMarginInlineStart: ce, scrollPadding: ce, scrollPaddingTop: ce, scrollPaddingRight: ce, scrollPaddingBottom: ce, scrollPaddingLeft: ce, scrollPaddingX: ce, scrollPaddingY: ce, scrollPaddingBlock: ce, scrollPaddingBlockEnd: ce, scrollPaddingBlockStart: ce, scrollPaddingInline: ce, scrollPaddingInlineEnd: ce, scrollPaddingInlineStart: ce, fontSize: "fontSizes", background: He, backgroundColor: He, backgroundImage: He, borderImage: He, border: He, borderBlock: He, borderBlockEnd: He, borderBlockStart: He, borderBottom: He, borderBottomColor: He, borderColor: He, borderInline: He, borderInlineEnd: He, borderInlineStart: He, borderLeft: He, borderLeftColor: He, borderRight: He, borderRightColor: He, borderTop: He, borderTopColor: He, caretColor: He, color: He, columnRuleColor: He, fill: He, outline: He, outlineColor: He, stroke: He, textDecorationColor: He, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: Ct, minBlockSize: Ct, maxBlockSize: Ct, inlineSize: Ct, minInlineSize: Ct, maxInlineSize: Ct, width: Ct, minWidth: Ct, maxWidth: Ct, height: Ct, minHeight: Ct, maxHeight: Ct, flexBasis: Ct, gridTemplateColumns: Ct, gridTemplateRows: Ct, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, NI = (t, e) => typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e, ts = () => {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n, ...r) => {
    const i = ((s) => JSON.stringify(s, NI))(e);
    return i in t ? t[i] : t[i] = n(e, ...r);
  };
}, Hr = Symbol.for("sxs.internal"), lf = (t, e) => Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)), Zh = (t) => {
  for (const e in t) return !0;
  return !1;
}, { hasOwnProperty: MI } = Object.prototype, Mc = (t) => t.includes("-") ? t : t.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase()), FI = /\s+(?![^()]*\))/, ci = (t) => (e) => t(...typeof e == "string" ? String(e).split(FI) : [e]), Jh = { appearance: (t) => ({ WebkitAppearance: t, appearance: t }), backfaceVisibility: (t) => ({ WebkitBackfaceVisibility: t, backfaceVisibility: t }), backdropFilter: (t) => ({ WebkitBackdropFilter: t, backdropFilter: t }), backgroundClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }), boxDecorationBreak: (t) => ({ WebkitBoxDecorationBreak: t, boxDecorationBreak: t }), clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }), content: (t) => ({ content: t.includes('"') || t.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(t) ? t : `"${t}"` }), hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }), maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }), maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }), tabSize: (t) => ({ MozTabSize: t, tabSize: t }), textSizeAdjust: (t) => ({ WebkitTextSizeAdjust: t, textSizeAdjust: t }), userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }), marginBlock: ci((t, e) => ({ marginBlockStart: t, marginBlockEnd: e || t })), marginInline: ci((t, e) => ({ marginInlineStart: t, marginInlineEnd: e || t })), maxSize: ci((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })), minSize: ci((t, e) => ({ minBlockSize: t, minInlineSize: e || t })), paddingBlock: ci((t, e) => ({ paddingBlockStart: t, paddingBlockEnd: e || t })), paddingInline: ci((t, e) => ({ paddingInlineStart: t, paddingInlineEnd: e || t })) }, fl = /([\d.]+)([^]*)/, BI = (t, e) => t.length ? t.reduce((n, r) => (n.push(...e.map((i) => i.includes("&") ? i.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(i) ? `:is(${r})` : r) : r + " " + i)), n), []) : e, UI = (t, e) => t in $I && typeof e == "string" ? e.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (n, r, i, s) => r + (i === "stretch" ? `-moz-available${s};${Mc(t)}:${r}-webkit-fill-available` : `-moz-fit-content${s};${Mc(t)}:${r}fit-content`) + s) : String(e), $I = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, ir = (t) => t ? t + "-" : "", Q1 = (t, e, n) => t.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, i, s, a, o) => a == "$" == !!s ? r : (i || a == "--" ? "calc(" : "") + "var(--" + (a === "$" ? ir(e) + (o.includes("$") ? "" : ir(n)) + o.replace(/\$/g, "-") : o) + ")" + (i || a == "--" ? "*" + (i || "") + (s || "1") + ")" : "")), HI = /\s*,\s*(?![^()]*\))/, GI = Object.prototype.toString, vi = (t, e, n, r, i) => {
  let s, a, o;
  const u = (l, c, d) => {
    let f, h;
    const m = (p) => {
      for (f in p) {
        const y = f.charCodeAt(0) === 64, T = y && Array.isArray(p[f]) ? p[f] : [p[f]];
        for (h of T) {
          const S = /[A-Z]/.test(E = f) ? E : E.replace(/-[^]/g, (I) => I[1].toUpperCase()), v = typeof h == "object" && h && h.toString === GI && (!r.utils[S] || !c.length);
          if (S in r.utils && !v) {
            const I = r.utils[S];
            if (I !== a) {
              a = I, m(I(h)), a = null;
              continue;
            }
          } else if (S in Jh) {
            const I = Jh[S];
            if (I !== o) {
              o = I, m(I(h)), o = null;
              continue;
            }
          }
          if (y && (g = f.slice(1) in r.media ? "@media " + r.media[f.slice(1)] : f, f = g.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (I, C, D, _, A, L) => {
            const N = fl.test(C), U = 0.0625 * (N ? -1 : 1), [z, O] = N ? [_, C] : [C, _];
            return "(" + (D[0] === "=" ? "" : D[0] === ">" === N ? "max-" : "min-") + z + ":" + (D[0] !== "=" && D.length === 1 ? O.replace(fl, (F, B, H) => Number(B) + U * (D === ">" ? 1 : -1) + H) : O) + (A ? ") and (" + (A[0] === ">" ? "min-" : "max-") + z + ":" + (A.length === 1 ? L.replace(fl, (F, B, H) => Number(B) + U * (A === ">" ? -1 : 1) + H) : L) : "") + ")";
          })), v) {
            const I = y ? d.concat(f) : [...d], C = y ? [...c] : BI(c, f.split(HI));
            s !== void 0 && i(e0(...s)), s = void 0, u(h, C, I);
          } else s === void 0 && (s = [[], c, d]), f = y || f.charCodeAt(0) !== 36 ? f : `--${ir(r.prefix)}${f.slice(1).replace(/\$/g, "-")}`, h = v ? h : typeof h == "number" ? h && S in VI ? String(h) + "px" : String(h) : Q1(UI(S, h ?? ""), r.prefix, r.themeMap[S]), s[0].push(`${y ? `${f} ` : `${Mc(f)}:`}${h}`);
        }
      }
      var g, E;
    };
    m(l), s !== void 0 && i(e0(...s)), s = void 0;
  };
  u(t, e, n);
}, e0 = (t, e, n) => `${n.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${t.join(";")}${e.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, VI = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, t0 = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)), Gr = (t) => ((e) => {
  let n, r = "";
  for (n = Math.abs(e); n > 52; n = n / 52 | 0) r = t0(n % 52) + r;
  return t0(n % 52) + r;
})(((e, n) => {
  let r = n.length;
  for (; r; ) e = 33 * e ^ n.charCodeAt(--r);
  return e;
})(5381, JSON.stringify(t)) >>> 0), ws = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], zI = (t) => {
  if (t.href && !t.href.startsWith(location.origin)) return !1;
  try {
    return !!t.cssRules;
  } catch {
    return !1;
  }
}, qI = (t) => {
  let e;
  const n = () => {
    const { cssRules: i } = e.sheet;
    return [].map.call(i, (s, a) => {
      const { cssText: o } = s;
      let u = "";
      if (o.startsWith("--sxs")) return "";
      if (i[a - 1] && (u = i[a - 1].cssText).startsWith("--sxs")) {
        if (!s.cssRules.length) return "";
        for (const l in e.rules) if (e.rules[l].group === s) return `--sxs{--sxs:${[...e.rules[l].cache].join(" ")}}${o}`;
        return s.cssRules.length ? `${u}${o}` : "";
      }
      return o;
    }).join("");
  }, r = () => {
    if (e) {
      const { rules: o, sheet: u } = e;
      if (!u.deleteRule) {
        for (; Object(Object(u.cssRules)[0]).type === 3; ) u.cssRules.splice(0, 1);
        u.cssRules = [];
      }
      for (const l in o) delete o[l];
    }
    const i = Object(t).styleSheets || [];
    for (const o of i) if (zI(o)) {
      for (let u = 0, l = o.cssRules; l[u]; ++u) {
        const c = Object(l[u]);
        if (c.type !== 1) continue;
        const d = Object(l[u + 1]);
        if (d.type !== 4) continue;
        ++u;
        const { cssText: f } = c;
        if (!f.startsWith("--sxs")) continue;
        const h = f.slice(14, -3).trim().split(/\s+/), m = ws[h[0]];
        m && (e || (e = { sheet: o, reset: r, rules: {}, toString: n }), e.rules[m] = { group: d, index: u, cache: new Set(h) });
      }
      if (e) break;
    }
    if (!e) {
      const o = (u, l) => ({ type: l, cssRules: [], insertRule(c, d) {
        this.cssRules.splice(d, 0, o(c, { import: 3, undefined: 1 }[(c.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return u === "@media{}" ? `@media{${[].map.call(this.cssRules, (c) => c.cssText).join("")}}` : u;
      } });
      e = { sheet: t ? (t.head || t).appendChild(document.createElement("style")).sheet : o("", "text/css"), rules: {}, reset: r, toString: n };
    }
    const { sheet: s, rules: a } = e;
    for (let o = ws.length - 1; o >= 0; --o) {
      const u = ws[o];
      if (!a[u]) {
        const l = ws[o + 1], c = a[l] ? a[l].index : s.cssRules.length;
        s.insertRule("@media{}", c), s.insertRule(`--sxs{--sxs:${o}}`, c), a[u] = { group: s.cssRules[c + 1], index: c, cache: /* @__PURE__ */ new Set([o]) };
      }
      jI(a[u]);
    }
  };
  return r(), e;
}, jI = (t) => {
  const e = t.group;
  let n = e.cssRules.length;
  t.apply = (r) => {
    try {
      e.insertRule(r, n), ++n;
    } catch {
    }
  };
}, Es = Symbol(), KI = ts(), n0 = (t, e) => KI(t, () => (...n) => {
  let r = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const i of n) if (i != null) if (i[Hr]) {
    r.type == null && (r.type = i[Hr].type);
    for (const s of i[Hr].composers) r.composers.add(s);
  } else i.constructor !== Object || i.$$typeof ? r.type == null && (r.type = i) : r.composers.add(WI(i, t));
  return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), YI(t, r, e);
}), WI = ({ variants: t, compoundVariants: e, defaultVariants: n, ...r }, i) => {
  const s = `${ir(i.prefix)}c-${Gr(r)}`, a = [], o = [], u = /* @__PURE__ */ Object.create(null), l = [];
  for (const f in n) u[f] = String(n[f]);
  if (typeof t == "object" && t) for (const f in t) {
    c = u, d = f, MI.call(c, d) || (u[f] = "undefined");
    const h = t[f];
    for (const m in h) {
      const p = { [f]: String(m) };
      String(m) === "undefined" && l.push(f);
      const g = h[m], E = [p, g, !Zh(g)];
      a.push(E);
    }
  }
  var c, d;
  if (typeof e == "object" && e) for (const f of e) {
    let { css: h, ...m } = f;
    h = typeof h == "object" && h || {};
    for (const g in m) m[g] = String(m[g]);
    const p = [m, h, !Zh(h)];
    o.push(p);
  }
  return [s, r, a, o, u, l];
}, YI = (t, e, n) => {
  const [r, i, s, a] = XI(e.composers), o = typeof e.type == "function" || e.type.$$typeof ? ((d) => {
    function f() {
      for (let h = 0; h < f[Es].length; h++) {
        const [m, p] = f[Es][h];
        d.rules[m].apply(p);
      }
      return f[Es] = [], null;
    }
    return f[Es] = [], f.rules = {}, ws.forEach((h) => f.rules[h] = { apply: (m) => f[Es].push([h, m]) }), f;
  })(n) : null, u = (o || n).rules, l = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, c = (d) => {
    d = typeof d == "object" && d || QI;
    const { css: f, ...h } = d, m = {};
    for (const E in s) if (delete h[E], E in d) {
      let y = d[E];
      typeof y == "object" && y ? m[E] = { "@initial": s[E], ...y } : (y = String(y), m[E] = y !== "undefined" || a.has(E) ? y : s[E]);
    } else m[E] = s[E];
    const p = /* @__PURE__ */ new Set([...i]);
    for (const [E, y, T, S] of e.composers) {
      n.rules.styled.cache.has(E) || (n.rules.styled.cache.add(E), vi(y, [`.${E}`], [], t, (C) => {
        u.styled.apply(C);
      }));
      const v = r0(T, m, t.media), I = r0(S, m, t.media, !0);
      for (const C of v) if (C !== void 0) for (const [D, _, A] of C) {
        const L = `${E}-${Gr(_)}-${D}`;
        p.add(L);
        const N = (A ? n.rules.resonevar : n.rules.onevar).cache, U = A ? u.resonevar : u.onevar;
        N.has(L) || (N.add(L), vi(_, [`.${L}`], [], t, (z) => {
          U.apply(z);
        }));
      }
      for (const C of I) if (C !== void 0) for (const [D, _] of C) {
        const A = `${E}-${Gr(_)}-${D}`;
        p.add(A), n.rules.allvar.cache.has(A) || (n.rules.allvar.cache.add(A), vi(_, [`.${A}`], [], t, (L) => {
          u.allvar.apply(L);
        }));
      }
    }
    if (typeof f == "object" && f) {
      const E = `${r}-i${Gr(f)}-css`;
      p.add(E), n.rules.inline.cache.has(E) || (n.rules.inline.cache.add(E), vi(f, [`.${E}`], [], t, (y) => {
        u.inline.apply(y);
      }));
    }
    for (const E of String(d.className || "").trim().split(/\s+/)) E && p.add(E);
    const g = h.className = [...p].join(" ");
    return { type: e.type, className: g, selector: l, props: h, toString: () => g, deferredInjector: o };
  };
  return lf(c, { className: r, selector: l, [Hr]: e, toString: () => (n.rules.styled.cache.has(r) || c(), r) });
}, XI = (t) => {
  let e = "";
  const n = [], r = {}, i = [];
  for (const [s, , , , a, o] of t) {
    e === "" && (e = s), n.push(s), i.push(...o);
    for (const u in a) {
      const l = a[u];
      (r[u] === void 0 || l !== "undefined" || o.includes(l)) && (r[u] = l);
    }
  }
  return [e, n, r, new Set(i)];
}, r0 = (t, e, n, r) => {
  const i = [];
  e: for (let [s, a, o] of t) {
    if (o) continue;
    let u, l = 0, c = !1;
    for (u in s) {
      const d = s[u];
      let f = e[u];
      if (f !== d) {
        if (typeof f != "object" || !f) continue e;
        {
          let h, m, p = 0;
          for (const g in f) {
            if (d === String(f[g])) {
              if (g !== "@initial") {
                const E = g.slice(1);
                (m = m || []).push(E in n ? n[E] : g.replace(/^@media ?/, "")), c = !0;
              }
              l += p, h = !0;
            }
            ++p;
          }
          if (m && m.length && (a = { ["@media " + m.join(", ")]: a }), !h) continue e;
        }
      }
    }
    (i[l] = i[l] || []).push([r ? "cv" : `${u}-${s[u]}`, a, c]);
  }
  return i;
}, QI = {}, ZI = ts(), JI = (t, e) => ZI(t, () => (...n) => {
  const r = () => {
    for (let i of n) {
      i = typeof i == "object" && i || {};
      let s = Gr(i);
      if (!e.rules.global.cache.has(s)) {
        if (e.rules.global.cache.add(s), "@import" in i) {
          let a = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
          for (let o of [].concat(i["@import"])) o = o.includes('"') || o.includes("'") ? o : `"${o}"`, e.sheet.insertRule(`@import ${o};`, a++);
          delete i["@import"];
        }
        vi(i, [], [], t, (a) => {
          e.rules.global.apply(a);
        });
      }
    }
    return "";
  };
  return lf(r, { toString: r });
}), eC = ts(), tC = (t, e) => eC(t, () => (n) => {
  const r = `${ir(t.prefix)}k-${Gr(n)}`, i = () => {
    if (!e.rules.global.cache.has(r)) {
      e.rules.global.cache.add(r);
      const s = [];
      vi(n, [], [], t, (o) => s.push(o));
      const a = `@keyframes ${r}{${s.join("")}}`;
      e.rules.global.apply(a);
    }
    return r;
  };
  return lf(i, { get name() {
    return i();
  }, toString: i });
}), nC = class {
  constructor(e, n, r, i) {
    this.token = e == null ? "" : String(e), this.value = n == null ? "" : String(n), this.scale = r == null ? "" : String(r), this.prefix = i == null ? "" : String(i);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + ir(this.prefix) + ir(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, rC = ts(), iC = (t, e) => rC(t, () => (n, r) => {
  r = typeof n == "object" && n || Object(r);
  const i = `.${n = (n = typeof n == "string" ? n : "") || `${ir(t.prefix)}t-${Gr(r)}`}`, s = {}, a = [];
  for (const u in r) {
    s[u] = {};
    for (const l in r[u]) {
      const c = `--${ir(t.prefix)}${u}-${l}`, d = Q1(String(r[u][l]), t.prefix, u);
      s[u][l] = new nC(l, d, u, t.prefix), a.push(`${c}:${d}`);
    }
  }
  const o = () => {
    if (a.length && !e.rules.themed.cache.has(n)) {
      e.rules.themed.cache.add(n);
      const u = `${r === t.theme ? ":root," : ""}.${n}{${a.join(";")}}`;
      e.rules.themed.apply(u);
    }
    return n;
  };
  return { ...s, get className() {
    return o();
  }, selector: i, toString: o };
}), sC = ts(), aC = ts(), oC = (t) => {
  const e = ((n) => {
    let r = !1;
    const i = sC(n, (s) => {
      r = !0;
      const a = "prefix" in (s = typeof s == "object" && s || {}) ? String(s.prefix) : "", o = typeof s.media == "object" && s.media || {}, u = typeof s.root == "object" ? s.root || null : globalThis.document || null, l = typeof s.theme == "object" && s.theme || {}, c = { prefix: a, media: o, theme: l, themeMap: typeof s.themeMap == "object" && s.themeMap || { ...OI }, utils: typeof s.utils == "object" && s.utils || {} }, d = qI(u), f = { css: n0(c, d), globalCss: JI(c, d), keyframes: tC(c, d), createTheme: iC(c, d), reset() {
        d.reset(), f.theme.toString();
      }, theme: {}, sheet: d, config: c, prefix: a, getCssText: d.toString, toString: d.toString };
      return String(f.theme = f.createTheme(l)), f;
    });
    return r || i.reset(), i;
  })(t);
  return e.styled = (({ config: n, sheet: r }) => aC(n, () => {
    const i = n0(n, r);
    return (...s) => {
      const a = i(...s), o = a[Hr].type, u = $.forwardRef((l, c) => {
        const d = l && l.as || o, { props: f, deferredInjector: h } = a(l);
        return delete f.as, f.ref = c, h ? $.createElement($.Fragment, null, $.createElement(d, f), $.createElement(h, null)) : $.createElement(d, f);
      });
      return u.className = a.className, u.displayName = `Styled.${o.displayName || o.name || o}`, u.selector = a.selector, u.toString = () => a.selector, u[Hr] = a[Hr], u;
    };
  }))(e), e;
};
const hl = 209, uC = {
  colors: {
    /*
     * Black and dark grays in a light theme.
     * Must contrast to 4.5 or greater with `secondary`.
     */
    primary: "#1a1d1e",
    primaryMuted: "#26292b",
    primaryAlt: "#151718",
    /*
     * Key brand color(s).
     * Must contrast to 4.5 or greater with `secondary`.
     */
    accent: `hsl(${hl} 100% 38.2%)`,
    accentMuted: `hsl(${hl} 80% 61.8%)`,
    accentAlt: `hsl(${hl} 80% 30%)`,
    /*
     * White and light grays in a light theme.
     * Must contrast to 4.5 or greater with `primary` and  `accent`.
     */
    secondary: "#FFFFFF",
    secondaryMuted: "#e6e8eb",
    secondaryAlt: "#c1c8cd"
  },
  fontSizes: {
    1: "12px",
    2: "13px",
    3: "15px",
    4: "17px",
    5: "19px",
    6: "21px",
    7: "27px",
    8: "35px",
    9: "59px"
  },
  lineHeights: {
    1: "12px",
    2: "13px",
    3: "15px",
    4: "17px",
    5: "19px",
    6: "21px",
    7: "27px",
    8: "35px",
    9: "59px"
  },
  sizes: {
    1: "5px",
    2: "10px",
    3: "15px",
    4: "20px",
    5: "25px",
    6: "35px",
    7: "45px",
    8: "65px",
    9: "80px"
  },
  space: {
    1: "5px",
    2: "10px",
    3: "15px",
    4: "20px",
    5: "25px",
    6: "35px",
    7: "45px",
    8: "65px",
    9: "80px"
  },
  radii: {
    1: "4px",
    2: "6px",
    3: "8px",
    4: "12px",
    round: "50%",
    pill: "9999px"
  },
  transitions: {
    all: "all 200ms cubic-bezier(0.16, 1, 0.3, 1)"
  },
  zIndices: {
    1: "100",
    2: "200",
    3: "300",
    4: "400",
    max: "999"
  }
}, lC = {
  xxs: "(max-width: 349px)",
  xs: "(max-width: 575px)",
  sm: "(max-width: 767px)",
  md: "(max-width: 991px)",
  lg: "(max-width: 90rem)",
  xl: "(min-width: calc(90rem + 1px))"
}, { styled: fe, css: bq, keyframes: Z1, createTheme: Eq } = oC({
  theme: uC,
  media: lC
}), cC = fe("span", {}), J1 = (t) => {
  const { as: e, label: n } = t, i = Aa(t, ["as", "label"]);
  return /* @__PURE__ */ $.createElement(cC, { as: e, ...i }, Ru(n, i.lang));
}, ue = Number.isFinite || function(t) {
  return typeof t == "number" && isFinite(t);
}, dC = Number.isSafeInteger || function(t) {
  return typeof t == "number" && Math.abs(t) <= fC;
}, fC = Number.MAX_SAFE_INTEGER || 9007199254740991;
let de = /* @__PURE__ */ function(t) {
  return t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError", t;
}({}), q = /* @__PURE__ */ function(t) {
  return t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", t.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", t.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_PARSING_ERROR = "levelParsingError", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.FRAG_GAP = "fragGap", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.ASSET_LIST_LOAD_ERROR = "assetListLoadError", t.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", t.ASSET_LIST_PARSING_ERROR = "assetListParsingError", t.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.ATTACH_MEDIA_ERROR = "attachMediaError", t.UNKNOWN = "unknown", t;
}({}), x = /* @__PURE__ */ function(t) {
  return t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.MEDIA_ENDED = "hlsMediaEnded", t.STALL_RESOLVED = "hlsStallResolved", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFERED_TO_END = "hlsBufferedToEnd", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached", t.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", t.ASSET_LIST_LOADING = "hlsAssetListLoading", t.ASSET_LIST_LOADED = "hlsAssetListLoaded", t.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", t.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", t.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", t.INTERSTITIAL_STARTED = "hlsInterstitialStarted", t.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", t.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", t.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", t.INTERSTITIAL_ENDED = "hlsInterstitialEnded", t.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", t.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", t.EVENT_CUE_ENTER = "hlsEventCueEnter", t;
}({});
var _e = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
}, le = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
class di {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(e, n = 0, r = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = n, this.totalWeight_ = r;
  }
  sample(e, n) {
    const r = Math.pow(this.alpha_, e);
    this.estimate_ = n * (1 - r) + r * this.estimate_, this.totalWeight_ += e;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class hC {
  constructor(e, n, r, i = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new di(e), this.fast_ = new di(n), this.defaultTTFB_ = i, this.ttfb_ = new di(e);
  }
  update(e, n) {
    const {
      slow_: r,
      fast_: i,
      ttfb_: s
    } = this;
    r.halfLife !== e && (this.slow_ = new di(e, r.getEstimate(), r.getTotalWeight())), i.halfLife !== n && (this.fast_ = new di(n, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new di(e, s.getEstimate(), s.getTotalWeight()));
  }
  sample(e, n) {
    e = Math.max(e, this.minDelayMs_);
    const r = 8 * n, i = e / 1e3, s = r / i;
    this.fast_.sample(i, s), this.slow_.sample(i, s);
  }
  sampleTTFB(e) {
    const n = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(n, 2) / 2);
    this.ttfb_.sample(r, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
  }
  get defaultEstimate() {
    return this.defaultEstimate_;
  }
  destroy() {
  }
}
function mC(t, e, n) {
  return (e = gC(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Ge() {
  return Ge = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Ge.apply(null, arguments);
}
function i0(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fe(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? i0(Object(n), !0).forEach(function(r) {
      mC(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i0(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function pC(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function gC(t) {
  var e = pC(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
class on {
  constructor(e, n) {
    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
    const r = `[${e}]:`;
    this.trace = yr, this.debug = n.debug.bind(null, r), this.log = n.log.bind(null, r), this.warn = n.warn.bind(null, r), this.info = n.info.bind(null, r), this.error = n.error.bind(null, r);
  }
}
const yr = function() {
}, bC = {
  trace: yr,
  debug: yr,
  log: yr,
  warn: yr,
  info: yr,
  error: yr
};
function Fc() {
  return Ge({}, bC);
}
function EC(t, e) {
  const n = self.console[t];
  return n ? n.bind(self.console, `${e ? "[" + e + "] " : ""}[${t}] >`) : yr;
}
function s0(t, e, n) {
  return e[t] ? e[t].bind(e) : EC(t, n);
}
const Bc = Fc();
function yC(t, e, n) {
  const r = Fc();
  if (typeof console == "object" && t === !0 || typeof t == "object") {
    const i = [
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    ];
    i.forEach((s) => {
      r[s] = s0(s, t, n);
    });
    try {
      r.log(`Debug logs enabled for "${e}" in hls.js version 1.6.13`);
    } catch {
      return Fc();
    }
    i.forEach((s) => {
      Bc[s] = s0(s, t);
    });
  } else
    Ge(Bc, r);
  return r;
}
const Be = Bc;
function vr(t = !0) {
  return typeof self > "u" ? void 0 : (t || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;
}
function TC(t) {
  return typeof self < "u" && t === self.ManagedMediaSource;
}
function eb(t, e) {
  const n = Object.keys(t), r = Object.keys(e), i = n.length, s = r.length;
  return !i || !s || i === s && !n.some((a) => r.indexOf(a) === -1);
}
function Zt(t, e = !1) {
  if (typeof TextDecoder < "u") {
    const l = new TextDecoder("utf-8").decode(t);
    if (e) {
      const c = l.indexOf("\0");
      return c !== -1 ? l.substring(0, c) : l;
    }
    return l.replace(/\0/g, "");
  }
  const n = t.length;
  let r, i, s, a = "", o = 0;
  for (; o < n; ) {
    if (r = t[o++], r === 0 && e)
      return a;
    if (r === 0 || r === 3)
      continue;
    switch (r >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(r);
        break;
      case 12:
      case 13:
        i = t[o++], a += String.fromCharCode((r & 31) << 6 | i & 63);
        break;
      case 14:
        i = t[o++], s = t[o++], a += String.fromCharCode((r & 15) << 12 | (i & 63) << 6 | (s & 63) << 0);
        break;
    }
  }
  return a;
}
function Lt(t) {
  let e = "";
  for (let n = 0; n < t.length; n++) {
    let r = t[n].toString(16);
    r.length < 2 && (r = "0" + r), e += r;
  }
  return e;
}
function tb(t) {
  return Uint8Array.from(t.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
function xC(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ml = { exports: {} }, a0;
function SC() {
  return a0 || (a0 = 1, function(t, e) {
    (function(n) {
      var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(u, l, c) {
          if (c = c || {}, u = u.trim(), l = l.trim(), !l) {
            if (!c.alwaysNormalize)
              return u;
            var d = o.parseURL(u);
            if (!d)
              throw new Error("Error trying to parse base URL.");
            return d.path = o.normalizePath(
              d.path
            ), o.buildURLFromParts(d);
          }
          var f = o.parseURL(l);
          if (!f)
            throw new Error("Error trying to parse relative URL.");
          if (f.scheme)
            return c.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : l;
          var h = o.parseURL(u);
          if (!h)
            throw new Error("Error trying to parse base URL.");
          if (!h.netLoc && h.path && h.path[0] !== "/") {
            var m = i.exec(h.path);
            h.netLoc = m[1], h.path = m[2];
          }
          h.netLoc && !h.path && (h.path = "/");
          var p = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: h.scheme,
            netLoc: f.netLoc,
            path: null,
            params: f.params,
            query: f.query,
            fragment: f.fragment
          };
          if (!f.netLoc && (p.netLoc = h.netLoc, f.path[0] !== "/"))
            if (!f.path)
              p.path = h.path, f.params || (p.params = h.params, f.query || (p.query = h.query));
            else {
              var g = h.path, E = g.substring(0, g.lastIndexOf("/") + 1) + f.path;
              p.path = o.normalizePath(E);
            }
          return p.path === null && (p.path = c.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(p);
        },
        parseURL: function(u) {
          var l = r.exec(u);
          return l ? {
            scheme: l[1] || "",
            netLoc: l[2] || "",
            path: l[3] || "",
            params: l[4] || "",
            query: l[5] || "",
            fragment: l[6] || ""
          } : null;
        },
        normalizePath: function(u) {
          for (u = u.split("").reverse().join("").replace(s, ""); u.length !== (u = u.replace(a, "")).length; )
            ;
          return u.split("").reverse().join("");
        },
        buildURLFromParts: function(u) {
          return u.scheme + u.netLoc + u.path + u.params + u.query + u.fragment;
        }
      };
      t.exports = o;
    })();
  }(ml)), ml.exports;
}
var cf = SC();
class df {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var Ve = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class nb {
  constructor(e) {
    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = {
      url: e
    }), this.base = e, vC(this, "stats");
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(e, n) {
    const r = e.split("@", 2);
    let i;
    r.length === 1 ? i = (n == null ? void 0 : n.byteRangeEndOffset) || 0 : i = parseInt(r[1]), this._byteRange = [i, parseInt(r[0]) + i];
  }
  get baseurl() {
    return this.base.url;
  }
  get byteRange() {
    return this._byteRange === null ? [] : this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get elementaryStreams() {
    return this._streams === null && (this._streams = {
      [Ve.AUDIO]: null,
      [Ve.VIDEO]: null,
      [Ve.AUDIOVIDEO]: null
    }), this._streams;
  }
  set elementaryStreams(e) {
    this._streams = e;
  }
  get hasStats() {
    return this._stats !== null;
  }
  get hasStreams() {
    return this._streams !== null;
  }
  get stats() {
    return this._stats === null && (this._stats = new df()), this._stats;
  }
  set stats(e) {
    this._stats = e;
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = cf.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || "";
  }
  set url(e) {
    this._url = e;
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[Ve.AUDIO] = null, e[Ve.VIDEO] = null, e[Ve.AUDIOVIDEO] = null;
  }
}
function ct(t) {
  return t.sn !== "initSegment";
}
class pl extends nb {
  constructor(e, n) {
    super(n), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;
  }
  get byteLength() {
    if (this.hasStats) {
      const e = this.stats.total;
      if (e)
        return e;
    }
    if (this.byteRange.length) {
      const e = this.byteRange[0], n = this.byteRange[1];
      if (ue(e) && ue(n))
        return n - e;
    }
    return null;
  }
  get bitrate() {
    return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;
  }
  set bitrate(e) {
    this._bitrate = e;
  }
  get decryptdata() {
    var e;
    const {
      levelkeys: n
    } = this;
    if (!n || n.NONE)
      return null;
    if (n.identity)
      this._decryptdata || (this._decryptdata = n.identity.getDecryptData(this.sn));
    else if (!((e = this._decryptdata) != null && e.keyId)) {
      const r = Object.keys(n);
      if (r.length === 1) {
        const i = this._decryptdata = n[r[0]] || null;
        i && (this._decryptdata = i.getDecryptData(this.sn, n));
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null)
      return null;
    const e = ue(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted)
      return !0;
    if (this.levelkeys) {
      var n;
      const r = Object.keys(this.levelkeys), i = r.length;
      if (i > 1 || i === 1 && (n = this.levelkeys[r[0]]) != null && n.encrypted)
        return !0;
    }
    return !1;
  }
  get programDateTime() {
    return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;
  }
  set programDateTime(e) {
    if (!ue(e)) {
      this._programDateTime = this.rawProgramDateTime = null;
      return;
    }
    this._programDateTime = e;
  }
  get ref() {
    return ct(this) ? (this._ref || (this._ref = {
      base: this.base,
      start: this.start,
      duration: this.duration,
      sn: this.sn,
      programDateTime: this.programDateTime
    }), this._ref) : null;
  }
  addStart(e) {
    this.setStart(this.start + e);
  }
  setStart(e) {
    this.start = e, this._ref && (this._ref.start = e);
  }
  setDuration(e) {
    this.duration = e, this._ref && (this._ref.duration = e);
  }
  setKeyFormat(e) {
    const n = this.levelkeys;
    if (n) {
      var r;
      const i = n[e];
      i && !((r = this._decryptdata) != null && r.keyId) && (this._decryptdata = i.getDecryptData(this.sn, n));
    }
  }
  abortRequests() {
    var e, n;
    (e = this.loader) == null || e.abort(), (n = this.keyLoader) == null || n.abort();
  }
  setElementaryStreamInfo(e, n, r, i, s, a = !1) {
    const {
      elementaryStreams: o
    } = this, u = o[e];
    if (!u) {
      o[e] = {
        startPTS: n,
        endPTS: r,
        startDTS: i,
        endDTS: s,
        partial: a
      };
      return;
    }
    u.startPTS = Math.min(u.startPTS, n), u.endPTS = Math.max(u.endPTS, r), u.startDTS = Math.min(u.startDTS, i), u.endDTS = Math.max(u.endDTS, s);
  }
}
class AC extends nb {
  constructor(e, n, r, i, s) {
    super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = n, this.index = i;
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, s), s && (this.fragOffset = s.fragOffset + s.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
function rb(t, e) {
  const n = Object.getPrototypeOf(t);
  if (n) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    return r || rb(n, e);
  }
}
function vC(t, e) {
  const n = rb(t, e);
  n && (n.enumerable = !0, Object.defineProperty(t, e, n));
}
const o0 = Math.pow(2, 32) - 1, IC = [].push, ib = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function dt(t) {
  return String.fromCharCode.apply(null, t);
}
function sb(t, e) {
  const n = t[e] << 8 | t[e + 1];
  return n < 0 ? 65536 + n : n;
}
function pe(t, e) {
  const n = ab(t, e);
  return n < 0 ? 4294967296 + n : n;
}
function u0(t, e) {
  let n = pe(t, e);
  return n *= Math.pow(2, 32), n += pe(t, e + 4), n;
}
function ab(t, e) {
  return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
function CC(t) {
  const e = t.byteLength;
  for (let n = 0; n < e; ) {
    const r = pe(t, n);
    if (r > 8 && t[n + 4] === 109 && t[n + 5] === 111 && t[n + 6] === 111 && t[n + 7] === 102)
      return !0;
    n = r > 1 ? n + r : e;
  }
  return !1;
}
function Ce(t, e) {
  const n = [];
  if (!e.length)
    return n;
  const r = t.byteLength;
  for (let i = 0; i < r; ) {
    const s = pe(t, i), a = dt(t.subarray(i + 4, i + 8)), o = s > 1 ? i + s : r;
    if (a === e[0])
      if (e.length === 1)
        n.push(t.subarray(i + 8, o));
      else {
        const u = Ce(t.subarray(i + 8, o), e.slice(1));
        u.length && IC.apply(n, u);
      }
    i = o;
  }
  return n;
}
function LC(t) {
  const e = [], n = t[0];
  let r = 8;
  const i = pe(t, r);
  r += 4;
  let s = 0, a = 0;
  n === 0 ? (s = pe(t, r), a = pe(t, r + 4), r += 8) : (s = u0(t, r), a = u0(t, r + 8), r += 16), r += 2;
  let o = t.length + a;
  const u = sb(t, r);
  r += 2;
  for (let l = 0; l < u; l++) {
    let c = r;
    const d = pe(t, c);
    c += 4;
    const f = d & 2147483647;
    if ((d & 2147483648) >>> 31 === 1)
      return Be.warn("SIDX has hierarchical references (not supported)"), null;
    const m = pe(t, c);
    c += 4, e.push({
      referenceSize: f,
      subsegmentDuration: m,
      // unscaled
      info: {
        duration: m / i,
        start: o,
        end: o + f - 1
      }
    }), o += f, c += 4, r = c;
  }
  return {
    earliestPresentationTime: s,
    timescale: i,
    version: n,
    referencesCount: u,
    references: e
  };
}
function ob(t) {
  const e = [], n = Ce(t, ["moov", "trak"]);
  for (let i = 0; i < n.length; i++) {
    const s = n[i], a = Ce(s, ["tkhd"])[0];
    if (a) {
      let o = a[0];
      const u = pe(a, o === 0 ? 12 : 20), l = Ce(s, ["mdia", "mdhd"])[0];
      if (l) {
        o = l[0];
        const c = pe(l, o === 0 ? 12 : 20), d = Ce(s, ["mdia", "hdlr"])[0];
        if (d) {
          const f = dt(d.subarray(8, 12)), h = {
            soun: Ve.AUDIO,
            vide: Ve.VIDEO
          }[f], m = Ce(s, ["mdia", "minf", "stbl", "stsd"])[0], p = _C(m);
          h ? (e[u] = {
            timescale: c,
            type: h,
            stsd: p
          }, e[h] = Fe({
            timescale: c,
            id: u
          }, p)) : e[u] = {
            timescale: c,
            type: f,
            stsd: p
          };
        }
      }
    }
  }
  return Ce(t, ["moov", "mvex", "trex"]).forEach((i) => {
    const s = pe(i, 4), a = e[s];
    a && (a.default = {
      duration: pe(i, 12),
      flags: pe(i, 20)
    });
  }), e;
}
function _C(t) {
  const e = t.subarray(8), n = e.subarray(86), r = dt(e.subarray(4, 8));
  let i = r, s;
  const a = r === "enca" || r === "encv";
  if (a) {
    const l = Ce(e, [r])[0].subarray(r === "enca" ? 28 : 78);
    Ce(l, ["sinf"]).forEach((d) => {
      const f = Ce(d, ["schm"])[0];
      if (f) {
        const h = dt(f.subarray(4, 8));
        if (h === "cbcs" || h === "cenc") {
          const m = Ce(d, ["frma"])[0];
          m && (i = dt(m));
        }
      }
    });
  }
  const o = i;
  switch (i) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const u = Ce(n, ["avcC"])[0];
      u && u.length > 3 && (i += "." + Wa(u[1]) + Wa(u[2]) + Wa(u[3]), s = Ka(o === "avc1" ? "dva1" : "dvav", n));
      break;
    }
    case "mp4a": {
      const u = Ce(e, [r])[0], l = Ce(u.subarray(28), ["esds"])[0];
      if (l && l.length > 7) {
        let c = 4;
        if (l[c++] !== 3)
          break;
        c = gl(l, c), c += 2;
        const d = l[c++];
        if (d & 128 && (c += 2), d & 64 && (c += l[c++]), l[c++] !== 4)
          break;
        c = gl(l, c);
        const f = l[c++];
        if (f === 64)
          i += "." + Wa(f);
        else
          break;
        if (c += 12, l[c++] !== 5)
          break;
        c = gl(l, c);
        const h = l[c++];
        let m = (h & 248) >> 3;
        m === 31 && (m += 1 + ((h & 7) << 3) + ((l[c] & 224) >> 5)), i += "." + m;
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const u = Ce(n, ["hvcC"])[0];
      if (u && u.length > 12) {
        const l = u[1], c = ["", "A", "B", "C"][l >> 6], d = l & 31, f = pe(u, 2), h = (l & 32) >> 5 ? "H" : "L", m = u[12], p = u.subarray(6, 12);
        i += "." + c + d, i += "." + RC(f).toString(16).toUpperCase(), i += "." + h + m;
        let g = "";
        for (let E = p.length; E--; ) {
          const y = p[E];
          (y || g) && (g = "." + y.toString(16).toUpperCase() + g);
        }
        i += g;
      }
      s = Ka(o == "hev1" ? "dvhe" : "dvh1", n);
      break;
    }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1": {
      i = Ka(i, n) || i;
      break;
    }
    case "vp09": {
      const u = Ce(n, ["vpcC"])[0];
      if (u && u.length > 6) {
        const l = u[4], c = u[5], d = u[6] >> 4 & 15;
        i += "." + Sn(l) + "." + Sn(c) + "." + Sn(d);
      }
      break;
    }
    case "av01": {
      const u = Ce(n, ["av1C"])[0];
      if (u && u.length > 2) {
        const l = u[1] >>> 5, c = u[1] & 31, d = u[2] >>> 7 ? "H" : "M", f = (u[2] & 64) >> 6, h = (u[2] & 32) >> 5, m = l === 2 && f ? h ? 12 : 10 : f ? 10 : 8, p = (u[2] & 16) >> 4, g = (u[2] & 8) >> 3, E = (u[2] & 4) >> 2, y = u[2] & 3;
        i += "." + l + "." + Sn(c) + d + "." + Sn(m) + "." + p + "." + g + E + y + "." + Sn(1) + "." + Sn(1) + "." + Sn(1) + "." + 0, s = Ka("dav1", n);
      }
      break;
    }
  }
  return {
    codec: i,
    encrypted: a,
    supplemental: s
  };
}
function Ka(t, e) {
  const n = Ce(e, ["dvvC"]), r = n.length ? n[0] : Ce(e, ["dvcC"])[0];
  if (r) {
    const i = r[2] >> 1 & 127, s = r[2] << 5 & 32 | r[3] >> 3 & 31;
    return t + "." + Sn(i) + "." + Sn(s);
  }
}
function RC(t) {
  let e = 0;
  for (let n = 0; n < 32; n++)
    e |= (t >> n & 1) << 31 - n;
  return e >>> 0;
}
function gl(t, e) {
  const n = e + 5;
  for (; t[e++] & 128 && e < n; )
    ;
  return e;
}
function Wa(t) {
  return ("0" + t.toString(16).toUpperCase()).slice(-2);
}
function Sn(t) {
  return (t < 10 ? "0" : "") + t;
}
function kC(t, e) {
  if (!t || !e)
    return;
  const n = e.keyId;
  n && e.isCommonEncryption && ub(t, (r, i) => {
    const s = r.subarray(8, 24);
    s.some((a) => a !== 0) || (Be.log(`[eme] Patching keyId in 'enc${i ? "a" : "v"}>sinf>>tenc' box: ${Lt(s)} -> ${Lt(n)}`), r.set(n, 8));
  });
}
function wC(t) {
  const e = [];
  return ub(t, (n) => e.push(n.subarray(8, 24))), e;
}
function ub(t, e) {
  Ce(t, ["moov", "trak"]).forEach((r) => {
    const i = Ce(r, ["mdia", "minf", "stbl", "stsd"])[0];
    if (!i) return;
    const s = i.subarray(8);
    let a = Ce(s, ["enca"]);
    const o = a.length > 0;
    o || (a = Ce(s, ["encv"])), a.forEach((u) => {
      const l = o ? u.subarray(28) : u.subarray(78);
      Ce(l, ["sinf"]).forEach((d) => {
        const f = lb(d);
        f && e(f, o);
      });
    });
  });
}
function lb(t) {
  const e = Ce(t, ["schm"])[0];
  if (e) {
    const n = dt(e.subarray(4, 8));
    if (n === "cbcs" || n === "cenc") {
      const r = Ce(t, ["schi", "tenc"])[0];
      if (r)
        return r;
    }
  }
}
function DC(t, e, n) {
  const r = {}, i = Ce(t, ["moof", "traf"]);
  for (let s = 0; s < i.length; s++) {
    const a = i[s], o = Ce(a, ["tfhd"])[0], u = pe(o, 4), l = e[u];
    if (!l)
      continue;
    r[u] || (r[u] = {
      start: NaN,
      duration: 0,
      sampleCount: 0,
      timescale: l.timescale,
      type: l.type
    });
    const c = r[u], d = Ce(a, ["tfdt"])[0];
    if (d) {
      const T = d[0];
      let S = pe(d, 4);
      T === 1 && (S === o0 ? n.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (S *= o0 + 1, S += pe(d, 8))), ue(S) && (!ue(c.start) || S < c.start) && (c.start = S);
    }
    const f = l.default, h = pe(o, 0) | (f == null ? void 0 : f.flags);
    let m = (f == null ? void 0 : f.duration) || 0;
    h & 8 && (h & 2 ? m = pe(o, 12) : m = pe(o, 8));
    const p = Ce(a, ["trun"]);
    let g = c.start || 0, E = 0, y = m;
    for (let T = 0; T < p.length; T++) {
      const S = p[T], v = pe(S, 4), I = c.sampleCount;
      c.sampleCount += v;
      const C = S[3] & 1, D = S[3] & 4, _ = S[2] & 1, A = S[2] & 2, L = S[2] & 4, N = S[2] & 8;
      let U = 8, z = v;
      for (C && (U += 4), D && v && (!(S[U + 1] & 1) && c.keyFrameIndex === void 0 && (c.keyFrameIndex = I), U += 4, _ ? (y = pe(S, U), U += 4) : y = m, A && (U += 4), N && (U += 4), g += y, E += y, z--); z--; )
        _ ? (y = pe(S, U), U += 4) : y = m, A && (U += 4), L && (S[U + 1] & 1 || c.keyFrameIndex === void 0 && (c.keyFrameIndex = c.sampleCount - (z + 1), c.keyFrameStart = g), U += 4), N && (U += 4), g += y, E += y;
      !E && m && (E += m * v);
    }
    c.duration += E;
  }
  if (!Object.keys(r).some((s) => r[s].duration)) {
    let s = 1 / 0, a = 0;
    const o = Ce(t, ["sidx"]);
    for (let u = 0; u < o.length; u++) {
      const l = LC(o[u]);
      if (l != null && l.references) {
        s = Math.min(s, l.earliestPresentationTime / l.timescale);
        const c = l.references.reduce((d, f) => d + f.info.duration || 0, 0);
        a = Math.max(a, c + l.earliestPresentationTime / l.timescale);
      }
    }
    a && ue(a) && Object.keys(r).forEach((u) => {
      r[u].duration || (r[u].duration = a * r[u].timescale - r[u].start);
    });
  }
  return r;
}
function PC(t) {
  const e = {
    valid: null,
    remainder: null
  }, n = Ce(t, ["moof"]);
  if (n.length < 2)
    return e.remainder = t, e;
  const r = n[n.length - 1];
  return e.valid = t.slice(0, r.byteOffset - 8), e.remainder = t.slice(r.byteOffset - 8), e;
}
function an(t, e) {
  const n = new Uint8Array(t.length + e.length);
  return n.set(t), n.set(e, t.length), n;
}
function l0(t, e) {
  const n = [], r = e.samples, i = e.timescale, s = e.id;
  let a = !1;
  return Ce(r, ["moof"]).map((u) => {
    const l = u.byteOffset - 8;
    Ce(u, ["traf"]).map((d) => {
      const f = Ce(d, ["tfdt"]).map((h) => {
        const m = h[0];
        let p = pe(h, 4);
        return m === 1 && (p *= Math.pow(2, 32), p += pe(h, 8)), p / i;
      })[0];
      return f !== void 0 && (t = f), Ce(d, ["tfhd"]).map((h) => {
        const m = pe(h, 4), p = pe(h, 0) & 16777215, g = (p & 1) !== 0, E = (p & 2) !== 0, y = (p & 8) !== 0;
        let T = 0;
        const S = (p & 16) !== 0;
        let v = 0;
        const I = (p & 32) !== 0;
        let C = 8;
        m === s && (g && (C += 8), E && (C += 4), y && (T = pe(h, C), C += 4), S && (v = pe(h, C), C += 4), I && (C += 4), e.type === "video" && (a = Bu(e.codec)), Ce(d, ["trun"]).map((D) => {
          const _ = D[0], A = pe(D, 0) & 16777215, L = (A & 1) !== 0;
          let N = 0;
          const U = (A & 4) !== 0, z = (A & 256) !== 0;
          let O = 0;
          const F = (A & 512) !== 0;
          let B = 0;
          const H = (A & 1024) !== 0, X = (A & 2048) !== 0;
          let w = 0;
          const Q = pe(D, 4);
          let J = 8;
          L && (N = pe(D, J), J += 4), U && (J += 4);
          let R = N + l;
          for (let te = 0; te < Q; te++) {
            if (z ? (O = pe(D, J), J += 4) : O = T, F ? (B = pe(D, J), J += 4) : B = v, H && (J += 4), X && (_ === 0 ? w = pe(D, J) : w = ab(D, J), J += 4), e.type === Ve.VIDEO) {
              let he = 0;
              for (; he < B; ) {
                const ae = pe(r, R);
                if (R += 4, OC(a, r[R])) {
                  const me = r.subarray(R, R + ae);
                  ff(me, a ? 2 : 1, t + w / i, n);
                }
                R += ae, he += ae + 4;
              }
            }
            t += O / i;
          }
        }));
      });
    });
  }), n;
}
function Bu(t) {
  if (!t)
    return !1;
  const e = t.substring(0, 4);
  return e === "hvc1" || e === "hev1" || // Dolby Vision
  e === "dvh1" || e === "dvhe";
}
function OC(t, e) {
  if (t) {
    const n = e >> 1 & 63;
    return n === 39 || n === 40;
  } else
    return (e & 31) === 6;
}
function ff(t, e, n, r) {
  const i = cb(t);
  let s = 0;
  s += e;
  let a = 0, o = 0, u = 0;
  for (; s < i.length; ) {
    a = 0;
    do {
      if (s >= i.length)
        break;
      u = i[s++], a += u;
    } while (u === 255);
    o = 0;
    do {
      if (s >= i.length)
        break;
      u = i[s++], o += u;
    } while (u === 255);
    const l = i.length - s;
    let c = s;
    if (o < l)
      s += o;
    else if (o > l) {
      Be.error(`Malformed SEI payload. ${o} is too small, only ${l} bytes left to parse.`);
      break;
    }
    if (a === 4) {
      if (i[c++] === 181) {
        const f = sb(i, c);
        if (c += 2, f === 49) {
          const h = pe(i, c);
          if (c += 4, h === 1195456820) {
            const m = i[c++];
            if (m === 3) {
              const p = i[c++], g = 31 & p, E = 64 & p, y = E ? 2 + g * 3 : 0, T = new Uint8Array(y);
              if (E) {
                T[0] = p;
                for (let S = 1; S < y; S++)
                  T[S] = i[c++];
              }
              r.push({
                type: m,
                payloadType: a,
                pts: n,
                bytes: T
              });
            }
          }
        }
      }
    } else if (a === 5 && o > 16) {
      const d = [];
      for (let m = 0; m < 16; m++) {
        const p = i[c++].toString(16);
        d.push(p.length == 1 ? "0" + p : p), (m === 3 || m === 5 || m === 7 || m === 9) && d.push("-");
      }
      const f = o - 16, h = new Uint8Array(f);
      for (let m = 0; m < f; m++)
        h[m] = i[c++];
      r.push({
        payloadType: a,
        pts: n,
        uuid: d.join(""),
        userData: Zt(h),
        userDataBytes: h
      });
    }
  }
}
function cb(t) {
  const e = t.byteLength, n = [];
  let r = 1;
  for (; r < e - 2; )
    t[r] === 0 && t[r + 1] === 0 && t[r + 2] === 3 ? (n.push(r + 2), r += 2) : r++;
  if (n.length === 0)
    return t;
  const i = e - n.length, s = new Uint8Array(i);
  let a = 0;
  for (r = 0; r < i; a++, r++)
    a === n[0] && (a++, n.shift()), s[r] = t[a];
  return s;
}
function NC(t) {
  const e = t[0];
  let n = "", r = "", i = 0, s = 0, a = 0, o = 0, u = 0, l = 0;
  if (e === 0) {
    for (; dt(t.subarray(l, l + 1)) !== "\0"; )
      n += dt(t.subarray(l, l + 1)), l += 1;
    for (n += dt(t.subarray(l, l + 1)), l += 1; dt(t.subarray(l, l + 1)) !== "\0"; )
      r += dt(t.subarray(l, l + 1)), l += 1;
    r += dt(t.subarray(l, l + 1)), l += 1, i = pe(t, 12), s = pe(t, 16), o = pe(t, 20), u = pe(t, 24), l = 28;
  } else if (e === 1) {
    l += 4, i = pe(t, l), l += 4;
    const d = pe(t, l);
    l += 4;
    const f = pe(t, l);
    for (l += 4, a = 2 ** 32 * d + f, dC(a) || (a = Number.MAX_SAFE_INTEGER, Be.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = pe(t, l), l += 4, u = pe(t, l), l += 4; dt(t.subarray(l, l + 1)) !== "\0"; )
      n += dt(t.subarray(l, l + 1)), l += 1;
    for (n += dt(t.subarray(l, l + 1)), l += 1; dt(t.subarray(l, l + 1)) !== "\0"; )
      r += dt(t.subarray(l, l + 1)), l += 1;
    r += dt(t.subarray(l, l + 1)), l += 1;
  }
  const c = t.subarray(l, t.byteLength);
  return {
    schemeIdUri: n,
    value: r,
    timeScale: i,
    presentationTime: a,
    presentationTimeDelta: s,
    eventDuration: o,
    id: u,
    payload: c
  };
}
function MC(t, ...e) {
  const n = e.length;
  let r = 8, i = n;
  for (; i--; )
    r += e[i].byteLength;
  const s = new Uint8Array(r);
  for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = r & 255, s.set(t, 4), i = 0, r = 8; i < n; i++)
    s.set(e[i], r), r += e[i].byteLength;
  return s;
}
function FC(t, e, n) {
  if (t.byteLength !== 16)
    throw new RangeError("Invalid system id");
  let r, i;
  r = 0, i = new Uint8Array();
  let s;
  r > 0 ? (s = new Uint8Array(4), e.length > 0 && new DataView(s.buffer).setUint32(0, e.length, !1)) : s = new Uint8Array();
  const a = new Uint8Array(4);
  return n.byteLength > 0 && new DataView(a.buffer).setUint32(0, n.byteLength, !1), MC(
    [112, 115, 115, 104],
    new Uint8Array([
      r,
      0,
      0,
      0
      // Flags
    ]),
    t,
    // 16 bytes
    s,
    i,
    a,
    n
  );
}
function BC(t) {
  const e = [];
  if (t instanceof ArrayBuffer) {
    const n = t.byteLength;
    let r = 0;
    for (; r + 32 < n; ) {
      const i = new DataView(t, r), s = UC(i);
      e.push(s), r += s.size;
    }
  }
  return e;
}
function UC(t) {
  const e = t.getUint32(0), n = t.byteOffset, r = t.byteLength;
  if (r < e)
    return {
      offset: n,
      size: r
    };
  if (t.getUint32(4) !== 1886614376)
    return {
      offset: n,
      size: e
    };
  const s = t.getUint32(8) >>> 24;
  if (s !== 0 && s !== 1)
    return {
      offset: n,
      size: e
    };
  const a = t.buffer, o = Lt(new Uint8Array(a, n + 12, 16));
  let u = null, l = null, c = 0;
  if (s === 0)
    c = 28;
  else {
    const f = t.getUint32(28);
    if (!f || r < 32 + f * 16)
      return {
        offset: n,
        size: e
      };
    u = [];
    for (let h = 0; h < f; h++)
      u.push(new Uint8Array(a, n + 32 + h * 16, 16));
    c = 32 + f * 16;
  }
  if (!c)
    return {
      offset: n,
      size: e
    };
  const d = t.getUint32(c);
  return e - 32 < d ? {
    offset: n,
    size: e
  } : (l = new Uint8Array(a, n + c + 4, d), {
    version: s,
    systemId: o,
    kids: u,
    data: l,
    offset: n,
    size: e
  });
}
const db = () => /\(Windows.+Firefox\//i.test(navigator.userAgent), zi = {
  audio: {
    a3ds: 1,
    "ac-3": 0.95,
    "ac-4": 1,
    alac: 0.9,
    alaw: 1,
    dra1: 1,
    "dts+": 1,
    "dts-": 1,
    dtsc: 1,
    dtse: 1,
    dtsh: 1,
    "ec-3": 0.9,
    enca: 1,
    fLaC: 0.9,
    // MP4-RA listed codec entry for FLAC
    flac: 0.9,
    // legacy browser codec name for FLAC
    FLAC: 0.9,
    // some manifests may list "FLAC" with Apple's tools
    g719: 1,
    g726: 1,
    m4ae: 1,
    mha1: 1,
    mha2: 1,
    mhm1: 1,
    mhm2: 1,
    mlpa: 1,
    mp4a: 1,
    "raw ": 1,
    Opus: 1,
    opus: 1,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: 1,
    sawb: 1,
    sawp: 1,
    sevc: 1,
    sqcp: 1,
    ssmv: 1,
    twos: 1,
    ulaw: 1
  },
  video: {
    avc1: 1,
    avc2: 1,
    avc3: 1,
    avc4: 1,
    avcp: 1,
    av01: 0.8,
    dav1: 0.8,
    drac: 1,
    dva1: 1,
    dvav: 1,
    dvh1: 0.7,
    dvhe: 0.7,
    encv: 1,
    hev1: 0.75,
    hvc1: 0.75,
    mjp2: 1,
    mp4v: 1,
    mvc1: 1,
    mvc2: 1,
    mvc3: 1,
    mvc4: 1,
    resv: 1,
    rv60: 1,
    s263: 1,
    svc1: 1,
    svc2: 1,
    "vc-1": 1,
    vp08: 1,
    vp09: 0.9
  },
  text: {
    stpp: 1,
    wvtt: 1
  }
};
function hf(t, e) {
  const n = zi[e];
  return !!n && !!n[t.slice(0, 4)];
}
function ea(t, e, n = !0) {
  return !t.split(",").some((r) => !mf(r, e, n));
}
function mf(t, e, n = !0) {
  var r;
  const i = vr(n);
  return (r = i == null ? void 0 : i.isTypeSupported(ta(t, e))) != null ? r : !1;
}
function ta(t, e) {
  return `${e}/mp4;codecs=${t}`;
}
function c0(t) {
  if (t) {
    const e = t.substring(0, 4);
    return zi.video[e];
  }
  return 2;
}
function ru(t) {
  const e = db();
  return t.split(",").reduce((n, r) => {
    const s = e && Bu(r) ? 9 : zi.video[r];
    return s ? (s * 2 + n) / (n ? 3 : 2) : (zi.audio[r] + n) / (n ? 2 : 1);
  }, 0);
}
const bl = {};
function $C(t, e = !0) {
  if (bl[t])
    return bl[t];
  const n = {
    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"],
    // Replace audio codec info if browser does not support mp4a.40.34,
    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
    "mp4a.40.34": ["mp3"]
  }[t];
  for (let i = 0; i < n.length; i++) {
    var r;
    if (mf(n[i], "audio", e))
      return bl[t] = n[i], n[i];
    if (n[i] === "mp3" && (r = vr(e)) != null && r.isTypeSupported("audio/mpeg"))
      return "";
  }
  return t;
}
const HC = /flac|opus|mp4a\.40\.34/i;
function iu(t, e = !0) {
  return t.replace(HC, (n) => $C(n.toLowerCase(), e));
}
function GC(t, e) {
  const n = [];
  if (t) {
    const r = t.split(",");
    for (let i = 0; i < r.length; i++)
      hf(r[i], "video") || n.push(r[i]);
  }
  return e && n.push(e), n.join(",");
}
function wo(t, e) {
  if (t && (t.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(t) !== -1) && (d0(t, "audio") || d0(t, "video")))
    return t;
  if (e) {
    const n = e.split(",");
    if (n.length > 1) {
      if (t) {
        for (let r = n.length; r--; )
          if (n[r].substring(0, 4) === t.substring(0, 4))
            return n[r];
      }
      return n[0];
    }
  }
  return e || t;
}
function d0(t, e) {
  return hf(t, e) && mf(t, e);
}
function VC(t) {
  const e = t.split(",");
  for (let n = 0; n < e.length; n++) {
    const r = e[n].split(".");
    r.length > 2 && r[0] === "avc1" && (e[n] = `avc1.${parseInt(r[1]).toString(16)}${("000" + parseInt(r[2]).toString(16)).slice(-4)}`);
  }
  return e.join(",");
}
function zC(t) {
  if (t.startsWith("av01.")) {
    const e = t.split("."), n = ["0", "111", "01", "01", "01", "0"];
    for (let r = e.length; r > 4 && r < 10; r++)
      e[r] = n[r - 4];
    return e.join(".");
  }
  return t;
}
function f0(t) {
  const e = vr(t) || {
    isTypeSupported: () => !1
  };
  return {
    mpeg: e.isTypeSupported("audio/mpeg"),
    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
  };
}
function Uc(t) {
  return t.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const qC = {
  supported: !0,
  powerEfficient: !0,
  smooth: !0
  // keySystemAccess: null,
}, jC = {
  supported: !1,
  smooth: !1,
  powerEfficient: !1
  // keySystemAccess: null,
}, fb = {
  supported: !0,
  configurations: [],
  decodingInfoResults: [qC]
};
function hb(t, e) {
  return {
    supported: !1,
    configurations: e,
    decodingInfoResults: [jC],
    error: t
  };
}
function KC(t, e, n, r, i, s) {
  const a = t.videoCodec, o = t.audioCodec ? t.audioGroups : null, u = s == null ? void 0 : s.audioCodec, l = s == null ? void 0 : s.channels, c = l ? parseInt(l) : u ? 1 / 0 : 2;
  let d = null;
  if (o != null && o.length)
    try {
      o.length === 1 && o[0] ? d = e.groups[o[0]].channels : d = o.reduce((f, h) => {
        if (h) {
          const m = e.groups[h];
          if (!m)
            throw new Error(`Audio track group ${h} not found`);
          Object.keys(m.channels).forEach((p) => {
            f[p] = (f[p] || 0) + m.channels[p];
          });
        }
        return f;
      }, {
        2: 0
      });
    } catch {
      return !0;
    }
  return a !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
  (a.split(",").some((f) => Bu(f)) || t.width > 1920 && t.height > 1088 || t.height > 1920 && t.width > 1088 || t.frameRate > Math.max(r, 30) || t.videoRange !== "SDR" && t.videoRange !== n || t.bitrate > Math.max(i, 8e6)) || !!d && ue(c) && Object.keys(d).some((f) => parseInt(f) > c);
}
function mb(t, e, n, r = {}) {
  const i = t.videoCodec;
  if (!i && !t.audioCodec || !n)
    return Promise.resolve(fb);
  const s = [], a = WC(t), o = a.length, u = YC(t, e, o > 0), l = u.length;
  for (let c = o || 1 * l || 1; c--; ) {
    const d = {
      type: "media-source"
    };
    if (o && (d.video = a[c % o]), l) {
      d.audio = u[c % l];
      const f = d.audio.bitrate;
      d.video && f && (d.video.bitrate -= f);
    }
    s.push(d);
  }
  if (i) {
    const c = navigator.userAgent;
    if (i.split(",").some((d) => Bu(d)) && db())
      return Promise.resolve(hb(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${c})`), s));
  }
  return Promise.all(s.map((c) => {
    const d = QC(c);
    return r[d] || (r[d] = n.decodingInfo(c));
  })).then((c) => ({
    supported: !c.some((d) => !d.supported),
    configurations: s,
    decodingInfoResults: c
  })).catch((c) => ({
    supported: !1,
    configurations: s,
    decodingInfoResults: [],
    error: c
  }));
}
function WC(t) {
  var e;
  const n = (e = t.videoCodec) == null ? void 0 : e.split(","), r = pb(t), i = t.width || 640, s = t.height || 480, a = t.frameRate || 30, o = t.videoRange.toLowerCase();
  return n ? n.map((u) => {
    const l = {
      contentType: ta(zC(u), "video"),
      width: i,
      height: s,
      bitrate: r,
      framerate: a
    };
    return o !== "sdr" && (l.transferFunction = o), l;
  }) : [];
}
function YC(t, e, n) {
  var r;
  const i = (r = t.audioCodec) == null ? void 0 : r.split(","), s = pb(t);
  return i && t.audioGroups ? t.audioGroups.reduce((a, o) => {
    var u;
    const l = o ? (u = e.groups[o]) == null ? void 0 : u.tracks : null;
    return l ? l.reduce((c, d) => {
      if (d.groupId === o) {
        const f = parseFloat(d.channels || "");
        i.forEach((h) => {
          const m = {
            contentType: ta(h, "audio"),
            bitrate: n ? XC(h, s) : s
          };
          f && (m.channels = "" + f), c.push(m);
        });
      }
      return c;
    }, a) : a;
  }, []) : [];
}
function XC(t, e) {
  if (e <= 1)
    return 1;
  let n = 128e3;
  return t === "ec-3" ? n = 768e3 : t === "ac-3" && (n = 64e4), Math.min(e / 2, n);
}
function pb(t) {
  return Math.ceil(Math.max(t.bitrate * 0.9, t.averageBitrate) / 1e3) * 1e3 || 1;
}
function QC(t) {
  let e = "";
  const {
    audio: n,
    video: r
  } = t;
  if (r) {
    const i = Uc(r.contentType);
    e += `${i}_r${r.height}x${r.width}f${Math.ceil(r.framerate)}${r.transferFunction || "sd"}_${Math.ceil(r.bitrate / 1e5)}`;
  }
  if (n) {
    const i = Uc(n.contentType);
    e += `${r ? "_" : ""}${i}_c${n.channels}`;
  }
  return e;
}
const $c = ["NONE", "TYPE-0", "TYPE-1", null];
function ZC(t) {
  return $c.indexOf(t) > -1;
}
const su = ["SDR", "PQ", "HLG"];
function JC(t) {
  return !!t && su.indexOf(t) > -1;
}
var Do = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function h0(t) {
  const {
    canSkipUntil: e,
    canSkipDateRanges: n,
    age: r
  } = t, i = r < e / 2;
  return e && i ? n ? Do.v2 : Do.Yes : Do.No;
}
class m0 {
  constructor(e, n, r) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = n, this.skip = r;
  }
  addDirectives(e) {
    const n = new self.URL(e);
    return this.msn !== void 0 && n.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && n.searchParams.set("_HLS_part", this.part.toString()), this.skip && n.searchParams.set("_HLS_skip", this.skip), n.href;
  }
}
class na {
  constructor(e) {
    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((r) => !!r).map((r) => r.substring(0, 4)).join(","), "supplemental" in e) {
      var n;
      this.supplemental = e.supplemental;
      const r = (n = e.supplemental) == null ? void 0 : n.videoCodec;
      r && r !== e.videoCodec && (this.codecSet += `,${r.substring(0, 4)}`);
    }
    this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(e) {
    return p0(this._audioGroups, e);
  }
  hasSubtitleGroup(e) {
    return p0(this._subtitleGroups, e);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(e, n) {
    if (n) {
      if (e === "audio") {
        let r = this._audioGroups;
        r || (r = this._audioGroups = []), r.indexOf(n) === -1 && r.push(n);
      } else if (e === "text") {
        let r = this._subtitleGroups;
        r || (r = this._subtitleGroups = []), r.indexOf(n) === -1 && r.push(n);
      }
    }
  }
  // Deprecated methods (retained for backwards compatibility)
  get urlId() {
    return 0;
  }
  set urlId(e) {
  }
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : void 0;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : void 0;
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroups) == null ? void 0 : e[0];
  }
  get textGroupId() {
    var e;
    return (e = this.subtitleGroups) == null ? void 0 : e[0];
  }
  addFallback() {
  }
}
function p0(t, e) {
  return !e || !t ? !1 : t.indexOf(e) !== -1;
}
function eL() {
  if (typeof matchMedia == "function") {
    const t = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query");
    if (t.media !== e.media)
      return t.matches === !0;
  }
  return !1;
}
function tL(t, e) {
  let n = !1, r = [];
  if (t && (n = t !== "SDR", r = [t]), e) {
    r = e.allowedVideoRanges || su.slice(0);
    const i = r.join("") !== "SDR" && !e.videoCodec;
    n = e.preferHDR !== void 0 ? e.preferHDR : i && eL(), n || (r = ["SDR"]);
  }
  return {
    preferHDR: n,
    allowedVideoRanges: r
  };
}
const nL = (t) => {
  const e = /* @__PURE__ */ new WeakSet();
  return (n, r) => {
    if (t && (r = t(n, r)), typeof r == "object" && r !== null) {
      if (e.has(r))
        return;
      e.add(r);
    }
    return r;
  };
}, ze = (t, e) => JSON.stringify(t, nL(e));
function rL(t, e, n, r, i) {
  const s = Object.keys(t), a = r == null ? void 0 : r.channels, o = r == null ? void 0 : r.audioCodec, u = i == null ? void 0 : i.videoCodec, l = a && parseInt(a) === 2;
  let c = !1, d = !1, f = 1 / 0, h = 1 / 0, m = 1 / 0, p = 1 / 0, g = 0, E = [];
  const {
    preferHDR: y,
    allowedVideoRanges: T
  } = tL(e, i);
  for (let D = s.length; D--; ) {
    const _ = t[s[D]];
    c || (c = _.channels[2] > 0), f = Math.min(f, _.minHeight), h = Math.min(h, _.minFramerate), m = Math.min(m, _.minBitrate), T.filter((L) => _.videoRanges[L] > 0).length > 0 && (d = !0);
  }
  f = ue(f) ? f : 0, h = ue(h) ? h : 0;
  const S = Math.max(1080, f), v = Math.max(30, h);
  m = ue(m) ? m : n, n = Math.max(m, n), d || (e = void 0);
  const I = s.length > 1;
  return {
    codecSet: s.reduce((D, _) => {
      const A = t[_];
      if (_ === D)
        return D;
      if (E = d ? T.filter((L) => A.videoRanges[L] > 0) : [], I) {
        if (A.minBitrate > n)
          return yn(_, `min bitrate of ${A.minBitrate} > current estimate of ${n}`), D;
        if (!A.hasDefaultAudio)
          return yn(_, "no renditions with default or auto-select sound found"), D;
        if (o && _.indexOf(o.substring(0, 4)) % 5 !== 0)
          return yn(_, `audio codec preference "${o}" not found`), D;
        if (a && !l) {
          if (!A.channels[a])
            return yn(_, `no renditions with ${a} channel sound found (channels options: ${Object.keys(A.channels)})`), D;
        } else if ((!o || l) && c && A.channels[2] === 0)
          return yn(_, "no renditions with stereo sound found"), D;
        if (A.minHeight > S)
          return yn(_, `min resolution of ${A.minHeight} > maximum of ${S}`), D;
        if (A.minFramerate > v)
          return yn(_, `min framerate of ${A.minFramerate} > maximum of ${v}`), D;
        if (!E.some((L) => A.videoRanges[L] > 0))
          return yn(_, `no variants with VIDEO-RANGE of ${ze(E)} found`), D;
        if (u && _.indexOf(u.substring(0, 4)) % 5 !== 0)
          return yn(_, `video codec preference "${u}" not found`), D;
        if (A.maxScore < g)
          return yn(_, `max score of ${A.maxScore} < selected max of ${g}`), D;
      }
      return D && (ru(_) >= ru(D) || A.fragmentError > t[D].fragmentError) ? D : (p = A.minIndex, g = A.maxScore, _);
    }, void 0),
    videoRanges: E,
    preferHDR: y,
    minFramerate: h,
    minBitrate: m,
    minIndex: p
  };
}
function yn(t, e) {
  Be.log(`[abr] start candidates with "${t}" ignored because ${e}`);
}
function gb(t) {
  return t.reduce((e, n) => {
    let r = e.groups[n.groupId];
    r || (r = e.groups[n.groupId] = {
      tracks: [],
      channels: {
        2: 0
      },
      hasDefault: !1,
      hasAutoSelect: !1
    }), r.tracks.push(n);
    const i = n.channels || "2";
    return r.channels[i] = (r.channels[i] || 0) + 1, r.hasDefault = r.hasDefault || n.default, r.hasAutoSelect = r.hasAutoSelect || n.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;
  }, {
    hasDefaultAudio: !1,
    hasAutoSelectAudio: !1,
    groups: {}
  });
}
function iL(t, e, n, r) {
  return t.slice(n, r + 1).reduce((i, s, a) => {
    if (!s.codecSet)
      return i;
    const o = s.audioGroups;
    let u = i[s.codecSet];
    u || (i[s.codecSet] = u = {
      minBitrate: 1 / 0,
      minHeight: 1 / 0,
      minFramerate: 1 / 0,
      minIndex: a,
      maxScore: 0,
      videoRanges: {
        SDR: 0
      },
      channels: {
        2: 0
      },
      hasDefaultAudio: !o,
      fragmentError: 0
    }), u.minBitrate = Math.min(u.minBitrate, s.bitrate);
    const l = Math.min(s.height, s.width);
    return u.minHeight = Math.min(u.minHeight, l), u.minFramerate = Math.min(u.minFramerate, s.frameRate), u.minIndex = Math.min(u.minIndex, a), u.maxScore = Math.max(u.maxScore, s.score), u.fragmentError += s.fragmentError, u.videoRanges[s.videoRange] = (u.videoRanges[s.videoRange] || 0) + 1, o && o.forEach((c) => {
      if (!c)
        return;
      const d = e.groups[c];
      d && (u.hasDefaultAudio = u.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(d.channels).forEach((f) => {
        u.channels[f] = (u.channels[f] || 0) + d.channels[f];
      }));
    }), i;
  }, {});
}
function g0(t) {
  if (!t)
    return t;
  const {
    lang: e,
    assocLang: n,
    characteristics: r,
    channels: i,
    audioCodec: s
  } = t;
  return {
    lang: e,
    assocLang: n,
    characteristics: r,
    channels: i,
    audioCodec: s
  };
}
function Rn(t, e, n) {
  if ("attrs" in t) {
    const r = e.indexOf(t);
    if (r !== -1)
      return r;
  }
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (Vr(t, i, n))
      return r;
  }
  return -1;
}
function Vr(t, e, n) {
  const {
    groupId: r,
    name: i,
    lang: s,
    assocLang: a,
    default: o
  } = t, u = t.forced;
  return (r === void 0 || e.groupId === r) && (i === void 0 || e.name === i) && (s === void 0 || sL(s, e.lang)) && (s === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (u === void 0 || e.forced === u) && (!("characteristics" in t) || aL(t.characteristics || "", e.characteristics)) && (n === void 0 || n(t, e));
}
function sL(t, e = "--") {
  return t.length === e.length ? t === e : t.startsWith(e) || e.startsWith(t);
}
function aL(t, e = "") {
  const n = t.split(","), r = e.split(",");
  return n.length === r.length && !n.some((i) => r.indexOf(i) === -1);
}
function Fr(t, e) {
  const {
    audioCodec: n,
    channels: r
  } = t;
  return (n === void 0 || (e.audioCodec || "").substring(0, 4) === n.substring(0, 4)) && (r === void 0 || r === (e.channels || "2"));
}
function oL(t, e, n, r, i) {
  const s = e[r], o = e.reduce((f, h, m) => {
    const p = h.uri;
    return (f[p] || (f[p] = [])).push(m), f;
  }, {})[s.uri];
  o.length > 1 && (r = Math.max.apply(Math, o));
  const u = s.videoRange, l = s.frameRate, c = s.codecSet.substring(0, 4), d = b0(e, r, (f) => {
    if (f.videoRange !== u || f.frameRate !== l || f.codecSet.substring(0, 4) !== c)
      return !1;
    const h = f.audioGroups, m = n.filter((p) => !h || h.indexOf(p.groupId) !== -1);
    return Rn(t, m, i) > -1;
  });
  return d > -1 ? d : b0(e, r, (f) => {
    const h = f.audioGroups, m = n.filter((p) => !h || h.indexOf(p.groupId) !== -1);
    return Rn(t, m, i) > -1;
  });
}
function b0(t, e, n) {
  for (let r = e; r > -1; r--)
    if (n(t[r]))
      return r;
  for (let r = e + 1; r < t.length; r++)
    if (n(t[r]))
      return r;
  return -1;
}
function au(t, e) {
  var n;
  return !!t && t !== ((n = e.loadLevelObj) == null ? void 0 : n.uri);
}
class uL extends on {
  constructor(e) {
    super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (n) => {
      var r;
      const {
        fragCurrent: i,
        partCurrent: s,
        hls: a
      } = this, {
        autoLevelEnabled: o,
        media: u
      } = a;
      if (!i || !u)
        return;
      const l = performance.now(), c = s ? s.stats : i.stats, d = s ? s.duration : i.duration, f = l - c.loading.start, h = a.minAutoLevel, m = i.level, p = this._nextAutoLevel;
      if (c.aborted || c.loaded && c.loaded === c.total || m <= h) {
        this.clearTimer(), this._nextAutoLevel = -1;
        return;
      }
      if (!o)
        return;
      const g = p > -1 && p !== m, E = !!n || g;
      if (!E && (u.paused || !u.playbackRate || !u.readyState))
        return;
      const y = a.mainForwardBufferInfo;
      if (!E && y === null)
        return;
      const T = this.bwEstimator.getEstimateTTFB(), S = Math.abs(u.playbackRate);
      if (f <= Math.max(T, 1e3 * (d / (S * 2))))
        return;
      const v = y ? y.len / S : 0, I = c.loading.first ? c.loading.first - c.loading.start : -1, C = c.loaded && I > -1, D = this.getBwEstimate(), _ = a.levels, A = _[m], L = Math.max(c.loaded, Math.round(d * (i.bitrate || A.averageBitrate) / 8));
      let N = C ? f - I : f;
      N < 1 && C && (N = Math.min(f, c.loaded * 8 / D));
      const U = C ? c.loaded * 1e3 / N : 0, z = T / 1e3, O = U ? (L - c.loaded) / U : L * 8 / D + z;
      if (O <= v)
        return;
      const F = U ? U * 8 : D, B = ((r = (n == null ? void 0 : n.details) || this.hls.latestLevelDetails) == null ? void 0 : r.live) === !0, H = this.hls.config.abrBandWidthUpFactor;
      let X = Number.POSITIVE_INFINITY, w;
      for (w = m - 1; w > h; w--) {
        const te = _[w].maxBitrate, he = !_[w].details || B;
        if (X = this.getTimeToLoadFrag(z, F, d * te, he), X < Math.min(v, d + z))
          break;
      }
      if (X >= O || X > d * 10)
        return;
      C ? this.bwEstimator.sample(f - Math.min(T, I), c.loaded) : this.bwEstimator.sampleTTFB(f);
      const Q = _[w].maxBitrate;
      this.getBwEstimate() * H > Q && this.resetEstimator(Q);
      const J = this.findBestLevel(Q, h, w, 0, v, 1, 1);
      J > -1 && (w = J), this.warn(`Fragment ${i.sn}${s ? " part " + s.index : ""} of level ${m} is loading too slowly;
      Fragment duration: ${i.duration.toFixed(3)}
      Time to underbuffer: ${v.toFixed(3)} s
      Estimated load time for current fragment: ${O.toFixed(3)} s
      Estimated load time for down switch fragment: ${X.toFixed(3)} s
      TTFB estimate: ${I | 0} ms
      Current BW estimate: ${ue(D) ? D | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${w} @ ${Q | 0} bps`), a.nextLoadLevel = a.nextAutoLevel = w, this.clearTimer();
      const R = () => {
        if (this.clearTimer(), this.fragCurrent === i && this.hls.loadLevel === w && w > 0) {
          const te = this.getStarvationDelay();
          if (this.warn(`Aborting inflight request ${w > 0 ? "and switching down" : ""}
      Fragment duration: ${i.duration.toFixed(3)} s
      Time to underbuffer: ${te.toFixed(3)} s`), i.abortRequests(), this.fragCurrent = this.partCurrent = null, w > h) {
            let he = this.findBestLevel(this.hls.levels[h].bitrate, h, w, 0, te, 1, 1);
            he === -1 && (he = h), this.hls.nextLoadLevel = this.hls.nextAutoLevel = he, this.resetEstimator(this.hls.levels[he].bitrate);
          }
        }
      };
      g || O > X * 2 ? R() : this.timer = self.setInterval(R, X * 1e3), a.trigger(x.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag: i,
        part: s,
        stats: c
      });
    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();
  }
  resetEstimator(e) {
    e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();
  }
  initEstimator() {
    const e = this.hls.config;
    return new hC(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;
  }
  onManifestLoading(e, n) {
    this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();
  }
  onLevelsUpdated() {
    this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;
  }
  onMaxAutoLevelUpdated() {
    this.firstSelection = -1, this.nextAutoLevelKey = "";
  }
  onFragLoading(e, n) {
    const r = n.frag;
    if (!this.ignoreFragment(r)) {
      if (!r.bitrateTest) {
        var i;
        this.fragCurrent = r, this.partCurrent = (i = n.part) != null ? i : null;
      }
      this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
  }
  onLevelSwitching(e, n) {
    this.clearTimer();
  }
  onError(e, n) {
    if (!n.fatal)
      switch (n.details) {
        case q.BUFFER_ADD_CODEC_ERROR:
        case q.BUFFER_APPEND_ERROR:
          this.lastLoadedFragLevel = -1, this.firstSelection = -1;
          break;
        case q.FRAG_LOAD_TIMEOUT: {
          const r = n.frag, {
            fragCurrent: i,
            partCurrent: s
          } = this;
          if (r && i && r.sn === i.sn && r.level === i.level) {
            const a = performance.now(), o = s ? s.stats : r.stats, u = a - o.loading.start, l = o.loading.first ? o.loading.first - o.loading.start : -1;
            if (o.loaded && l > -1) {
              const d = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(u - Math.min(d, l), o.loaded);
            } else
              this.bwEstimator.sampleTTFB(u);
          }
          break;
        }
      }
  }
  getTimeToLoadFrag(e, n, r, i) {
    const s = e + r / n, a = i ? e + this.lastLevelLoadSec : 0;
    return s + a;
  }
  onLevelLoaded(e, n) {
    const r = this.hls.config, {
      loading: i
    } = n.stats, s = i.end - i.first;
    ue(s) && (this.lastLevelLoadSec = s / 1e3), n.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(n.levelInfo);
  }
  onFragLoaded(e, {
    frag: n,
    part: r
  }) {
    const i = r ? r.stats : n.stats;
    if (n.type === le.MAIN && this.bwEstimator.sampleTTFB(i.loading.first - i.loading.start), !this.ignoreFragment(n)) {
      if (this.clearTimer(), n.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
        const s = r ? r.duration : n.duration, a = this.hls.levels[n.level], o = (a.loaded ? a.loaded.bytes : 0) + i.loaded, u = (a.loaded ? a.loaded.duration : 0) + s;
        a.loaded = {
          bytes: o,
          duration: u
        }, a.realBitrate = Math.round(8 * o / u);
      }
      if (n.bitrateTest) {
        const s = {
          stats: i,
          frag: n,
          part: r,
          id: n.type
        };
        this.onFragBuffered(x.FRAG_BUFFERED, s), n.bitrateTest = !1;
      } else
        this.lastLoadedFragLevel = n.level;
    }
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = i != null && i.stats.loaded ? i.stats : r.stats;
    if (s.aborted || this.ignoreFragment(r))
      return;
    const a = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(a, s.loaded), s.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0;
  }
  ignoreFragment(e) {
    return e.type !== le.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);
  }
  get firstAutoLevel() {
    const {
      maxAutoLevel: e,
      minAutoLevel: n
    } = this.hls, r = this.getBwEstimate(), i = this.hls.config.maxStarvationDelay, s = this.findBestLevel(r, n, e, 0, i, 1, 1);
    if (s > -1)
      return s;
    const a = this.hls.firstLevel, o = Math.min(Math.max(a, n), e);
    return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`), o;
  }
  get forcedAutoLevel() {
    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
  }
  // return next auto level
  get nextAutoLevel() {
    const e = this.forcedAutoLevel, r = this.bwEstimator.canEstimate(), i = this.lastLoadedFragLevel > -1;
    if (e !== -1 && (!r || !i || this.nextAutoLevelKey === this.getAutoLevelKey()))
      return e;
    const s = r && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (e !== -1) {
      const a = this.hls.levels;
      if (a.length > Math.max(e, s) && a[e].loadError <= a[s].loadError)
        return e;
    }
    return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s;
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: n,
      hls: r
    } = this;
    if (r.levels.length <= 1)
      return r.loadLevel;
    const {
      maxAutoLevel: i,
      config: s,
      minAutoLevel: a
    } = r, o = n ? n.duration : e ? e.duration : 0, u = this.getBwEstimate(), l = this.getStarvationDelay();
    let c = s.abrBandWidthFactor, d = s.abrBandWidthUpFactor;
    if (l) {
      const g = this.findBestLevel(u, a, i, l, 0, c, d);
      if (g >= 0)
        return this.rebufferNotice = -1, g;
    }
    let f = o ? Math.min(o, s.maxStarvationDelay) : s.maxStarvationDelay;
    if (!l) {
      const g = this.bitrateTestDelay;
      g && (f = (o ? Math.min(o, s.maxLoadingDelay) : s.maxLoadingDelay) - g, this.info(`bitrate test took ${Math.round(1e3 * g)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), c = d = 1);
    }
    const h = this.findBestLevel(u, a, i, l, f, c, d);
    if (this.rebufferNotice !== h && (this.rebufferNotice = h, this.info(`${l ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${h}`)), h > -1)
      return h;
    const m = r.levels[a], p = r.loadLevelObj;
    return p && (m == null ? void 0 : m.bitrate) < p.bitrate ? a : r.loadLevel;
  }
  getStarvationDelay() {
    const e = this.hls, n = e.media;
    if (!n)
      return 1 / 0;
    const r = n && n.playbackRate !== 0 ? Math.abs(n.playbackRate) : 1, i = e.mainForwardBufferInfo;
    return (i ? i.len : 0) / r;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(e, n, r, i, s, a, o) {
    var u;
    const l = i + s, c = this.lastLoadedFragLevel, d = c === -1 ? this.hls.firstLevel : c, {
      fragCurrent: f,
      partCurrent: h
    } = this, {
      levels: m,
      allAudioTracks: p,
      loadLevel: g,
      config: E
    } = this.hls;
    if (m.length === 1)
      return 0;
    const y = m[d], T = !!((u = this.hls.latestLevelDetails) != null && u.live), S = g === -1 || c === -1;
    let v, I = "SDR", C = (y == null ? void 0 : y.frameRate) || 0;
    const {
      audioPreference: D,
      videoPreference: _
    } = E, A = this.audioTracksByGroup || (this.audioTracksByGroup = gb(p));
    let L = -1;
    if (S) {
      if (this.firstSelection !== -1)
        return this.firstSelection;
      const F = this.codecTiers || (this.codecTiers = iL(m, A, n, r)), B = rL(F, I, e, D, _), {
        codecSet: H,
        videoRanges: X,
        minFramerate: w,
        minBitrate: Q,
        minIndex: J,
        preferHDR: R
      } = B;
      L = J, v = H, I = R ? X[X.length - 1] : X[0], C = w, e = Math.max(e, Q), this.log(`picked start tier ${ze(B)}`);
    } else
      v = y == null ? void 0 : y.codecSet, I = y == null ? void 0 : y.videoRange;
    const N = h ? h.duration : f ? f.duration : 0, U = this.bwEstimator.getEstimateTTFB() / 1e3, z = [];
    for (let F = r; F >= n; F--) {
      var O;
      const B = m[F], H = F > d;
      if (!B)
        continue;
      if (E.useMediaCapabilities && !B.supportedResult && !B.supportedPromise) {
        const he = navigator.mediaCapabilities;
        typeof (he == null ? void 0 : he.decodingInfo) == "function" && KC(B, A, I, C, e, D) ? (B.supportedPromise = mb(B, A, he, this.supportedCache), B.supportedPromise.then((ae) => {
          if (!this.hls)
            return;
          B.supportedResult = ae;
          const me = this.hls.levels, ke = me.indexOf(B);
          ae.error ? this.warn(`MediaCapabilities decodingInfo error: "${ae.error}" for level ${ke} ${ze(ae)}`) : ae.supported ? ae.decodingInfoResults.some((Pe) => Pe.smooth === !1 || Pe.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${ke} not smooth or powerEfficient: ${ze(ae)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${ke} ${ze(ae)}`), ke > -1 && me.length > 1 && (this.log(`Removing unsupported level ${ke}`), this.hls.removeLevel(ke), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
        }).catch((ae) => {
          this.warn(`Error handling MediaCapabilities decodingInfo: ${ae}`);
        })) : B.supportedResult = fb;
      }
      if ((v && B.codecSet !== v || I && B.videoRange !== I || H && C > B.frameRate || !H && C > 0 && C < B.frameRate || (O = B.supportedResult) != null && (O = O.decodingInfoResults) != null && O.some((he) => he.smooth === !1)) && (!S || F !== L)) {
        z.push(F);
        continue;
      }
      const X = B.details, w = (h ? X == null ? void 0 : X.partTarget : X == null ? void 0 : X.averagetargetduration) || N;
      let Q;
      H ? Q = o * e : Q = a * e;
      const J = N && i >= N * 2 && s === 0 ? B.averageBitrate : B.maxBitrate, R = this.getTimeToLoadFrag(U, Q, J * w, X === void 0);
      if (
        // if adjusted bw is greater than level bitrate AND
        Q >= J && // no level change, or new level has no error history
        (F === c || B.loadError === 0 && B.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
        (R <= U || !ue(R) || T && !this.bitrateTestDelay || R < l)
      ) {
        const he = this.forcedAutoLevel;
        return F !== g && (he === -1 || he !== g) && (z.length && this.trace(`Skipped level(s) ${z.join(",")} of ${r} max with CODECS and VIDEO-RANGE:"${m[z[0]].codecs}" ${m[z[0]].videoRange}; not compatible with "${v}" ${I}`), this.info(`switch candidate:${d}->${F} adjustedbw(${Math.round(Q)})-bitrate=${Math.round(Q - J)} ttfb:${U.toFixed(1)} avgDuration:${w.toFixed(1)} maxFetchDuration:${l.toFixed(1)} fetchDuration:${R.toFixed(1)} firstSelection:${S} codecSet:${B.codecSet} videoRange:${B.videoRange} hls.loadLevel:${g}`)), S && (this.firstSelection = F), F;
      }
    }
    return -1;
  }
  set nextAutoLevel(e) {
    const n = this.deriveNextAutoLevel(e);
    this._nextAutoLevel !== n && (this.nextAutoLevelKey = "", this._nextAutoLevel = n);
  }
  deriveNextAutoLevel(e) {
    const {
      maxAutoLevel: n,
      minAutoLevel: r
    } = this.hls;
    return Math.min(Math.max(e, r), n);
  }
}
const bb = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(t, e) {
    let n = 0, r = t.length - 1, i = null, s = null;
    for (; n <= r; ) {
      i = (n + r) / 2 | 0, s = t[i];
      const a = e(s);
      if (a > 0)
        n = i + 1;
      else if (a < 0)
        r = i - 1;
      else
        return s;
    }
    return null;
  }
};
function lL(t, e, n) {
  if (e === null || !Array.isArray(t) || !t.length || !ue(e))
    return null;
  const r = t[0].programDateTime;
  if (e < (r || 0))
    return null;
  const i = t[t.length - 1].endProgramDateTime;
  if (e >= (i || 0))
    return null;
  for (let s = 0; s < t.length; ++s) {
    const a = t[s];
    if (dL(e, n, a))
      return a;
  }
  return null;
}
function Yr(t, e, n = 0, r = 0, i = 5e-3) {
  let s = null;
  if (t) {
    s = e[1 + t.sn - e[0].sn] || null;
    const o = t.endDTS - n;
    o > 0 && o < 15e-7 && (n += 15e-7), s && t.level !== s.level && s.end <= t.end && (s = e[2 + t.sn - e[0].sn] || null);
  } else n === 0 && e[0].start === 0 && (s = e[0]);
  if (s && ((!t || t.level === s.level) && E0(n, r, s) === 0 || cL(s, t, Math.min(i, r))))
    return s;
  const a = bb.search(e, E0.bind(null, n, r));
  return a && (a !== t || !s) ? a : s;
}
function cL(t, e, n) {
  if (e && e.start === 0 && e.level < t.level && (e.endPTS || 0) > 0) {
    const r = e.tagList.reduce((i, s) => (s[0] === "INF" && (i += parseFloat(s[1])), i), n);
    return t.start <= r;
  }
  return !1;
}
function E0(t = 0, e = 0, n) {
  if (n.start <= t && n.start + n.duration > t)
    return 0;
  const r = Math.min(e, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
  return n.start + n.duration - r <= t ? 1 : n.start - r > t && n.start ? -1 : 0;
}
function dL(t, e, n) {
  const r = Math.min(e, n.duration + (n.deltaPTS ? n.deltaPTS : 0)) * 1e3;
  return (n.endProgramDateTime || 0) - r > t;
}
function Eb(t, e, n) {
  if (t && t.startCC <= e && t.endCC >= e) {
    let r = t.fragments;
    const {
      fragmentHint: i
    } = t;
    i && (r = r.concat(i));
    let s;
    return bb.search(r, (a) => a.cc < e ? 1 : a.cc > e ? -1 : (s = a, a.end <= n ? 1 : a.start > n ? -1 : 0)), s || null;
  }
  return null;
}
function ou(t) {
  switch (t.details) {
    case q.FRAG_LOAD_TIMEOUT:
    case q.KEY_LOAD_TIMEOUT:
    case q.LEVEL_LOAD_TIMEOUT:
    case q.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function yb(t) {
  return t.details.startsWith("key");
}
function Tb(t) {
  return yb(t) && !!t.frag && !t.frag.decryptdata;
}
function y0(t, e) {
  const n = ou(e);
  return t.default[`${n ? "timeout" : "error"}Retry`];
}
function pf(t, e) {
  const n = t.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(n * t.retryDelayMs, t.maxRetryDelayMs);
}
function T0(t) {
  return Fe(Fe({}, t), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function uu(t, e, n, r) {
  if (!t)
    return !1;
  const i = r == null ? void 0 : r.code, s = e < t.maxNumRetry && (fL(i) || !!n);
  return t.shouldRetry ? t.shouldRetry(t, e, n, r, s) : s;
}
function fL(t) {
  return Hc(t) || !!t && (t < 400 || t > 499);
}
function Hc(t) {
  return t === 0 && navigator.onLine === !1;
}
var Tt = {
  DoNothing: 0,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  RetryRequest: 5
}, Wt = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  MoveAllAlternatesMatchingKey: 4
};
class hL extends on {
  constructor(e) {
    super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.ERROR, this.onError, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.ERROR, this.onError, this), e.off(x.ERROR, this.onErrorOut, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this));
  }
  destroy() {
    this.unregisterListeners(), this.hls = null;
  }
  startLoad(e) {
  }
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === le.MAIN ? e.level : this.getVariantIndex();
  }
  getVariantIndex() {
    var e;
    const n = this.hls, r = n.currentLevel;
    return (e = n.loadLevelObj) != null && e.details || r === -1 ? n.loadLevel : r;
  }
  variantHasKey(e, n) {
    if (e) {
      var r;
      if ((r = e.details) != null && r.hasKey(n))
        return !0;
      const i = e.audioGroups;
      if (i)
        return this.hls.allAudioTracks.filter((a) => i.indexOf(a.groupId) >= 0).some((a) => {
          var o;
          return (o = a.details) == null ? void 0 : o.hasKey(n);
        });
    }
    return !1;
  }
  onManifestLoading() {
    this.playlistError = 0;
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(e, n) {
    var r;
    if (n.fatal)
      return;
    const i = this.hls, s = n.context;
    switch (n.details) {
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        n.errorAction = this.getFragRetryOrSwitchAction(n);
        return;
      case q.FRAG_PARSING_ERROR:
        if ((r = n.frag) != null && r.gap) {
          n.errorAction = Li();
          return;
        }
      case q.FRAG_GAP:
      case q.FRAG_DECRYPT_ERROR: {
        n.errorAction = this.getFragRetryOrSwitchAction(n), n.errorAction.action = Tt.SendAlternateToPenaltyBox;
        return;
      }
      case q.LEVEL_EMPTY_ERROR:
      case q.LEVEL_PARSING_ERROR:
        {
          var a;
          const u = n.parent === le.MAIN ? n.level : i.loadLevel;
          n.details === q.LEVEL_EMPTY_ERROR && ((a = n.context) != null && (a = a.levelDetails) != null && a.live) ? n.errorAction = this.getPlaylistRetryOrSwitchAction(n, u) : (n.levelRetry = !1, n.errorAction = this.getLevelSwitchAction(n, u));
        }
        return;
      case q.LEVEL_LOAD_ERROR:
      case q.LEVEL_LOAD_TIMEOUT:
        typeof (s == null ? void 0 : s.level) == "number" && (n.errorAction = this.getPlaylistRetryOrSwitchAction(n, s.level));
        return;
      case q.AUDIO_TRACK_LOAD_ERROR:
      case q.AUDIO_TRACK_LOAD_TIMEOUT:
      case q.SUBTITLE_LOAD_ERROR:
      case q.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (s) {
          const u = i.loadLevelObj;
          if (u && (s.type === _e.AUDIO_TRACK && u.hasAudioGroup(s.groupId) || s.type === _e.SUBTITLE_TRACK && u.hasSubtitleGroup(s.groupId))) {
            n.errorAction = this.getPlaylistRetryOrSwitchAction(n, i.loadLevel), n.errorAction.action = Tt.SendAlternateToPenaltyBox, n.errorAction.flags = Wt.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        n.errorAction = {
          action: Tt.SendAlternateToPenaltyBox,
          flags: Wt.MoveAllAlternatesMatchingHDCP
        };
        return;
      case q.KEY_SYSTEM_SESSION_UPDATE_FAILED:
      case q.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
      case q.KEY_SYSTEM_NO_SESSION:
        n.errorAction = {
          action: Tt.SendAlternateToPenaltyBox,
          flags: Wt.MoveAllAlternatesMatchingKey
        };
        return;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.REMUX_ALLOC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (!n.errorAction) {
          var o;
          n.errorAction = this.getLevelSwitchAction(n, (o = n.level) != null ? o : i.loadLevel);
        }
        return;
      case q.INTERNAL_EXCEPTION:
      case q.BUFFER_APPENDING_ERROR:
      case q.BUFFER_FULL_ERROR:
      case q.LEVEL_SWITCH_ERROR:
      case q.BUFFER_STALLED_ERROR:
      case q.BUFFER_SEEK_OVER_HOLE:
      case q.BUFFER_NUDGE_ON_STALL:
        n.errorAction = Li();
        return;
    }
    n.type === de.KEY_SYSTEM_ERROR && (n.levelRetry = !1, n.errorAction = Li());
  }
  getPlaylistRetryOrSwitchAction(e, n) {
    const r = this.hls, i = y0(r.config.playlistLoadPolicy, e), s = this.playlistError++;
    if (uu(i, s, ou(e), e.response))
      return {
        action: Tt.RetryRequest,
        flags: Wt.None,
        retryConfig: i,
        retryCount: s
      };
    const o = this.getLevelSwitchAction(e, n);
    return i && (o.retryConfig = i, o.retryCount = s), o;
  }
  getFragRetryOrSwitchAction(e) {
    const n = this.hls, r = this.getVariantLevelIndex(e.frag), i = n.levels[r], {
      fragLoadPolicy: s,
      keyLoadPolicy: a
    } = n.config, o = y0(yb(e) ? a : s, e), u = n.levels.reduce((c, d) => c + d.fragmentError, 0);
    if (i && (e.details !== q.FRAG_GAP && i.fragmentError++, !Tb(e) && uu(o, u, ou(e), e.response)))
      return {
        action: Tt.RetryRequest,
        flags: Wt.None,
        retryConfig: o,
        retryCount: u
      };
    const l = this.getLevelSwitchAction(e, r);
    return o && (l.retryConfig = o, l.retryCount = u), l;
  }
  getLevelSwitchAction(e, n) {
    const r = this.hls;
    n == null && (n = r.loadLevel);
    const i = this.hls.levels[n];
    if (i) {
      var s, a;
      const l = e.details;
      i.loadError++, l === q.BUFFER_APPEND_ERROR && i.fragmentError++;
      let c = -1;
      const {
        levels: d,
        loadLevel: f,
        minAutoLevel: h,
        maxAutoLevel: m
      } = r;
      !r.autoLevelEnabled && !r.config.preserveManualLevelOnError && (r.loadLevel = -1);
      const p = (s = e.frag) == null ? void 0 : s.type, E = (p === le.AUDIO && l === q.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (l === q.BUFFER_ADD_CODEC_ERROR || l === q.BUFFER_APPEND_ERROR)) && d.some(({
        audioCodec: I
      }) => i.audioCodec !== I), T = e.sourceBufferName === "video" && (l === q.BUFFER_ADD_CODEC_ERROR || l === q.BUFFER_APPEND_ERROR) && d.some(({
        codecSet: I,
        audioCodec: C
      }) => i.codecSet !== I && i.audioCodec === C), {
        type: S,
        groupId: v
      } = (a = e.context) != null ? a : {};
      for (let I = d.length; I--; ) {
        const C = (I + f) % d.length;
        if (C !== f && C >= h && C <= m && d[C].loadError === 0) {
          var o, u;
          const D = d[C];
          if (l === q.FRAG_GAP && p === le.MAIN && e.frag) {
            const _ = d[C].details;
            if (_) {
              const A = Yr(e.frag, _.fragments, e.frag.start);
              if (A != null && A.gap)
                continue;
            }
          } else {
            if (S === _e.AUDIO_TRACK && D.hasAudioGroup(v) || S === _e.SUBTITLE_TRACK && D.hasSubtitleGroup(v))
              continue;
            if (p === le.AUDIO && (o = i.audioGroups) != null && o.some((_) => D.hasAudioGroup(_)) || p === le.SUBTITLE && (u = i.subtitleGroups) != null && u.some((_) => D.hasSubtitleGroup(_)) || E && i.audioCodec === D.audioCodec || T && i.codecSet === D.codecSet || !E && i.codecSet !== D.codecSet)
              continue;
          }
          c = C;
          break;
        }
      }
      if (c > -1 && r.loadLevel !== c)
        return e.levelRetry = !0, this.playlistError = 0, {
          action: Tt.SendAlternateToPenaltyBox,
          flags: Wt.None,
          nextAutoLevel: c
        };
    }
    return {
      action: Tt.SendAlternateToPenaltyBox,
      flags: Wt.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(e, n) {
    var r;
    switch ((r = n.errorAction) == null ? void 0 : r.action) {
      case Tt.DoNothing:
        break;
      case Tt.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(n), !n.errorAction.resolved && n.details !== q.FRAG_GAP ? n.fatal = !0 : /MediaSource readyState: ended/.test(n.error.message) && (this.warn(`MediaSource ended after "${n.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());
        break;
    }
    if (n.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const n = this.hls, r = e.errorAction;
    if (!r)
      return;
    const {
      flags: i
    } = r, s = r.nextAutoLevel;
    switch (i) {
      case Wt.None:
        this.switchLevel(e, s);
        break;
      case Wt.MoveAllAlternatesMatchingHDCP: {
        const u = this.getVariantLevelIndex(e.frag), l = n.levels[u], c = l == null ? void 0 : l.attrs["HDCP-LEVEL"];
        if (r.hdcpLevel = c, c === "NONE")
          this.warn("HDCP policy resticted output with HDCP-LEVEL=NONE");
        else if (c) {
          n.maxHdcpLevel = $c[$c.indexOf(c) - 1], r.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of "${n.maxHdcpLevel}" or lower`);
          break;
        }
      }
      case Wt.MoveAllAlternatesMatchingKey: {
        const u = e.decryptdata;
        if (u) {
          const l = this.hls.levels, c = l.length;
          for (let f = c; f--; )
            if (this.variantHasKey(l[f], u)) {
              var a, o;
              this.log(`Banned key found in level ${f} (${l[f].bitrate}bps) or audio group "${(a = l[f].audioGroups) == null ? void 0 : a.join(",")}" (${(o = e.frag) == null ? void 0 : o.type} fragment) ${Lt(u.keyId || [])}`), l[f].fragmentError++, l[f].loadError++, this.log(`Removing level ${f} with key error (${e.error})`), this.hls.removeLevel(f);
            }
          const d = e.frag;
          if (this.hls.levels.length < c)
            r.resolved = !0;
          else if (d && d.type !== le.MAIN) {
            const f = d.decryptdata;
            f && !u.matches(f) && (r.resolved = !0);
          }
        }
        break;
      }
    }
    r.resolved || this.switchLevel(e, s);
  }
  switchLevel(e, n) {
    if (n !== void 0 && e.errorAction && (this.warn(`switching to level ${n} after ${e.details}`), this.hls.nextAutoLevel = n, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === q.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
      const r = Uc(e.mimeType), i = this.hls.levels;
      for (let s = i.length; s--; )
        i[s][`${e.sourceBufferName}Codec`] === r && (this.log(`Removing level ${s} for ${e.details} ("${r}" not supported)`), this.hls.removeLevel(s));
    }
  }
}
function Li(t) {
  const e = {
    action: Tt.DoNothing,
    flags: Wt.None
  };
  return t && (e.resolved = !0), e;
}
var ft = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class mL {
  constructor(e) {
    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  destroy() {
    this._unregisterListeners(), this.hls = // @ts-ignore
    this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(e, n) {
    const r = this.activePartLists[n];
    if (r)
      for (let i = r.length; i--; ) {
        const s = r[i];
        if (!s)
          break;
        if (s.start <= e && e <= s.end && s.loaded)
          return s;
      }
    return this.getBufferedFrag(e, n);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(e, n) {
    return this.getFragAtPos(e, n, !0);
  }
  getFragAtPos(e, n, r) {
    const {
      fragments: i
    } = this, s = Object.keys(i);
    for (let a = s.length; a--; ) {
      const o = i[s[a]];
      if ((o == null ? void 0 : o.body.type) === n && (!r || o.buffered)) {
        const u = o.body;
        if (u.start <= e && e <= u.end)
          return u;
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(e, n, r, i, s) {
    this.timeRanges && (this.timeRanges[e] = n);
    const a = (i == null ? void 0 : i.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((o) => {
      const u = this.fragments[o];
      if (!u || a >= u.body.sn)
        return;
      if (!u.buffered && (!u.loaded || s)) {
        u.body.type === r && this.removeFragment(u.body);
        return;
      }
      const l = u.range[e];
      if (l) {
        if (l.time.length === 0) {
          this.removeFragment(u.body);
          return;
        }
        l.time.some((c) => {
          const d = !this.isTimeBuffered(c.startPTS, c.endPTS, n);
          return d && this.removeFragment(u.body), d;
        });
      }
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(e) {
    const n = this.timeRanges;
    if (!n || e.frag.sn === "initSegment")
      return;
    const r = e.frag, i = fi(r), s = this.fragments[i];
    if (!s || s.buffered && r.gap)
      return;
    const a = !r.relurl;
    Object.keys(n).forEach((o) => {
      const u = r.elementaryStreams[o];
      if (!u)
        return;
      const l = n[o], c = a || u.partial === !0;
      s.range[o] = this.getBufferedTimes(r, e.part, c, l);
    }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, (s.body.endList = r.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), Ya(s) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(s.body);
  }
  removeParts(e, n) {
    const r = this.activePartLists[n];
    r && (this.activePartLists[n] = x0(r, (i) => i.fragment.sn >= e));
  }
  fragBuffered(e, n) {
    const r = fi(e);
    let i = this.fragments[r];
    !i && n && (i = this.fragments[r] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0);
  }
  getBufferedTimes(e, n, r, i) {
    const s = {
      time: [],
      partial: r
    }, a = e.start, o = e.end, u = e.minEndPTS || o, l = e.maxStartPTS || a;
    for (let c = 0; c < i.length; c++) {
      const d = i.start(c) - this.bufferPadding, f = i.end(c) + this.bufferPadding;
      if (l >= d && u <= f) {
        s.time.push({
          startPTS: Math.max(a, i.start(c)),
          endPTS: Math.min(o, i.end(c))
        });
        break;
      } else if (a < f && o > d) {
        const h = Math.max(a, i.start(c)), m = Math.min(o, i.end(c));
        m > h && (s.partial = !0, s.time.push({
          startPTS: h,
          endPTS: m
        }));
      } else if (o <= d)
        break;
    }
    return s;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(e) {
    let n = null, r, i, s, a = 0;
    const {
      bufferPadding: o,
      fragments: u
    } = this;
    return Object.keys(u).forEach((l) => {
      const c = u[l];
      c && Ya(c) && (i = c.body.start - o, s = c.body.end + o, e >= i && e <= s && (r = Math.min(e - i, s - e), a <= r && (n = c.body, a = r)));
    }), n;
  }
  isEndListAppended(e) {
    const n = this.endListFragments[e];
    return n !== void 0 && (n.buffered || Ya(n));
  }
  getState(e) {
    const n = fi(e), r = this.fragments[n];
    return r ? r.buffered ? Ya(r) ? ft.PARTIAL : ft.OK : ft.APPENDING : ft.NOT_LOADED;
  }
  isTimeBuffered(e, n, r) {
    let i, s;
    for (let a = 0; a < r.length; a++) {
      if (i = r.start(a) - this.bufferPadding, s = r.end(a) + this.bufferPadding, e >= i && n <= s)
        return !0;
      if (n <= i)
        return !1;
    }
    return !1;
  }
  onManifestLoading() {
    this.removeAllFragments();
  }
  onFragLoaded(e, n) {
    if (n.frag.sn === "initSegment" || n.frag.bitrateTest)
      return;
    const r = n.frag, i = n.part ? null : n, s = fi(r);
    this.fragments[s] = {
      body: r,
      appendedPTS: null,
      loaded: i,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(e, n) {
    const {
      frag: r,
      part: i,
      timeRanges: s,
      type: a
    } = n;
    if (r.sn === "initSegment")
      return;
    const o = r.type;
    if (i) {
      let l = this.activePartLists[o];
      l || (this.activePartLists[o] = l = []), l.push(i);
    }
    this.timeRanges = s;
    const u = s[a];
    this.detectEvictedFragments(a, u, o, i);
  }
  onFragBuffered(e, n) {
    this.detectPartialFragments(n);
  }
  hasFragment(e) {
    const n = fi(e);
    return !!this.fragments[n];
  }
  hasFragments(e) {
    const {
      fragments: n
    } = this, r = Object.keys(n);
    if (!e)
      return r.length > 0;
    for (let i = r.length; i--; ) {
      const s = n[r[i]];
      if ((s == null ? void 0 : s.body.type) === e)
        return !0;
    }
    return !1;
  }
  hasParts(e) {
    var n;
    return !!((n = this.activePartLists[e]) != null && n.length);
  }
  removeFragmentsInRange(e, n, r, i, s) {
    i && !this.hasGaps || Object.keys(this.fragments).forEach((a) => {
      const o = this.fragments[a];
      if (!o)
        return;
      const u = o.body;
      u.type !== r || i && !u.gap || u.start < n && u.end > e && (o.buffered || s) && this.removeFragment(u);
    });
  }
  removeFragment(e) {
    const n = fi(e);
    e.clearElementaryStreamInfo();
    const r = this.activePartLists[e.type];
    if (r) {
      const i = e.sn;
      this.activePartLists[e.type] = x0(r, (s) => s.fragment.sn !== i);
    }
    delete this.fragments[n], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    var e;
    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
    const n = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;
    n && n.forEach((r) => r.clearElementaryStreamInfo());
  }
}
function Ya(t) {
  var e, n, r;
  return t.buffered && !!(t.body.gap || (e = t.range.video) != null && e.partial || (n = t.range.audio) != null && n.partial || (r = t.range.audiovideo) != null && r.partial);
}
function fi(t) {
  return `${t.type}_${t.level}_${t.sn}`;
}
function x0(t, e) {
  return t.filter((n) => {
    const r = e(n);
    return r || n.clearElementaryStreamInfo(), r;
  });
}
var Ir = {
  cbc: 0,
  ctr: 1
};
class pL {
  constructor(e, n, r) {
    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = n, this.aesMode = r;
  }
  decrypt(e, n) {
    switch (this.aesMode) {
      case Ir.cbc:
        return this.subtle.decrypt({
          name: "AES-CBC",
          iv: this.aesIV
        }, n, e);
      case Ir.ctr:
        return this.subtle.decrypt(
          {
            name: "AES-CTR",
            counter: this.aesIV,
            length: 64
          },
          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
          n,
          e
        );
      default:
        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
    }
  }
}
function gL(t) {
  const e = t.byteLength, n = e && new DataView(t.buffer).getUint8(e - 1);
  return n ? t.slice(0, e - n) : t;
}
class bL {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(e) {
    const n = new DataView(e), r = new Uint32Array(4);
    for (let i = 0; i < 4; i++)
      r[i] = n.getUint32(i * 4);
    return r;
  }
  initTable() {
    const e = this.sBox, n = this.invSBox, r = this.subMix, i = r[0], s = r[1], a = r[2], o = r[3], u = this.invSubMix, l = u[0], c = u[1], d = u[2], f = u[3], h = new Uint32Array(256);
    let m = 0, p = 0, g = 0;
    for (g = 0; g < 256; g++)
      g < 128 ? h[g] = g << 1 : h[g] = g << 1 ^ 283;
    for (g = 0; g < 256; g++) {
      let E = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
      E = E >>> 8 ^ E & 255 ^ 99, e[m] = E, n[E] = m;
      const y = h[m], T = h[y], S = h[T];
      let v = h[E] * 257 ^ E * 16843008;
      i[m] = v << 24 | v >>> 8, s[m] = v << 16 | v >>> 16, a[m] = v << 8 | v >>> 24, o[m] = v, v = S * 16843009 ^ T * 65537 ^ y * 257 ^ m * 16843008, l[E] = v << 24 | v >>> 8, c[E] = v << 16 | v >>> 16, d[E] = v << 8 | v >>> 24, f[E] = v, m ? (m = y ^ h[h[h[S ^ y]]], p ^= h[h[p]]) : m = p = 1;
    }
  }
  expandKey(e) {
    const n = this.uint8ArrayToUint32Array_(e);
    let r = !0, i = 0;
    for (; i < n.length && r; )
      r = n[i] === this.key[i], i++;
    if (r)
      return;
    this.key = n;
    const s = this.keySize = n.length;
    if (s !== 4 && s !== 6 && s !== 8)
      throw new Error("Invalid aes key size=" + s);
    const a = this.ksRows = (s + 6 + 1) * 4;
    let o, u;
    const l = this.keySchedule = new Uint32Array(a), c = this.invKeySchedule = new Uint32Array(a), d = this.sBox, f = this.rcon, h = this.invSubMix, m = h[0], p = h[1], g = h[2], E = h[3];
    let y, T;
    for (o = 0; o < a; o++) {
      if (o < s) {
        y = l[o] = n[o];
        continue;
      }
      T = y, o % s === 0 ? (T = T << 8 | T >>> 24, T = d[T >>> 24] << 24 | d[T >>> 16 & 255] << 16 | d[T >>> 8 & 255] << 8 | d[T & 255], T ^= f[o / s | 0] << 24) : s > 6 && o % s === 4 && (T = d[T >>> 24] << 24 | d[T >>> 16 & 255] << 16 | d[T >>> 8 & 255] << 8 | d[T & 255]), l[o] = y = (l[o - s] ^ T) >>> 0;
    }
    for (u = 0; u < a; u++)
      o = a - u, u & 3 ? T = l[o] : T = l[o - 4], u < 4 || o <= 4 ? c[u] = T : c[u] = m[d[T >>> 24]] ^ p[d[T >>> 16 & 255]] ^ g[d[T >>> 8 & 255]] ^ E[d[T & 255]], c[u] = c[u] >>> 0;
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
  }
  decrypt(e, n, r) {
    const i = this.keySize + 6, s = this.invKeySchedule, a = this.invSBox, o = this.invSubMix, u = o[0], l = o[1], c = o[2], d = o[3], f = this.uint8ArrayToUint32Array_(r);
    let h = f[0], m = f[1], p = f[2], g = f[3];
    const E = new Int32Array(e), y = new Int32Array(E.length);
    let T, S, v, I, C, D, _, A, L, N, U, z, O, F;
    const B = this.networkToHostOrderSwap;
    for (; n < E.length; ) {
      for (L = B(E[n]), N = B(E[n + 1]), U = B(E[n + 2]), z = B(E[n + 3]), C = L ^ s[0], D = z ^ s[1], _ = U ^ s[2], A = N ^ s[3], O = 4, F = 1; F < i; F++)
        T = u[C >>> 24] ^ l[D >> 16 & 255] ^ c[_ >> 8 & 255] ^ d[A & 255] ^ s[O], S = u[D >>> 24] ^ l[_ >> 16 & 255] ^ c[A >> 8 & 255] ^ d[C & 255] ^ s[O + 1], v = u[_ >>> 24] ^ l[A >> 16 & 255] ^ c[C >> 8 & 255] ^ d[D & 255] ^ s[O + 2], I = u[A >>> 24] ^ l[C >> 16 & 255] ^ c[D >> 8 & 255] ^ d[_ & 255] ^ s[O + 3], C = T, D = S, _ = v, A = I, O = O + 4;
      T = a[C >>> 24] << 24 ^ a[D >> 16 & 255] << 16 ^ a[_ >> 8 & 255] << 8 ^ a[A & 255] ^ s[O], S = a[D >>> 24] << 24 ^ a[_ >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[C & 255] ^ s[O + 1], v = a[_ >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[C >> 8 & 255] << 8 ^ a[D & 255] ^ s[O + 2], I = a[A >>> 24] << 24 ^ a[C >> 16 & 255] << 16 ^ a[D >> 8 & 255] << 8 ^ a[_ & 255] ^ s[O + 3], y[n] = B(T ^ h), y[n + 1] = B(I ^ m), y[n + 2] = B(v ^ p), y[n + 3] = B(S ^ g), h = L, m = N, p = U, g = z, n = n + 4;
    }
    return y.buffer;
  }
}
class EL {
  constructor(e, n, r) {
    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = n, this.aesMode = r;
  }
  expandKey() {
    const e = yL(this.aesMode);
    return this.subtle.importKey("raw", this.key, {
      name: e
    }, !1, ["encrypt", "decrypt"]);
  }
}
function yL(t) {
  switch (t) {
    case Ir.cbc:
      return "AES-CBC";
    case Ir.ctr:
      return "AES-CTR";
    default:
      throw new Error(`[FastAESKey] invalid aes mode ${t}`);
  }
}
const TL = 16;
class gf {
  constructor(e, {
    removePKCS7Padding: n = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = n, n)
      try {
        const r = self.crypto;
        r && (this.subtle = r.subtle || r.webkitSubtle);
      } catch {
      }
    this.useSoftware = !this.subtle;
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult: e,
      remainderData: n
    } = this;
    if (!e || n)
      return this.reset(), null;
    const r = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? gL(r) : r;
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, n, r, i) {
    return this.useSoftware ? new Promise((s, a) => {
      const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
      this.softwareDecrypt(o, n, r, i);
      const u = this.flush();
      u ? s(u.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"));
    }) : this.webCryptoDecrypt(new Uint8Array(e), n, r, i);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(e, n, r, i) {
    const {
      currentIV: s,
      currentResult: a,
      remainderData: o
    } = this;
    if (i !== Ir.cbc || n.byteLength !== 16)
      return Be.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
    this.logOnce("JS AES decrypt"), o && (e = an(o, e), this.remainderData = null);
    const u = this.getValidChunk(e);
    if (!u.length)
      return null;
    s && (r = s);
    let l = this.softwareDecrypter;
    l || (l = this.softwareDecrypter = new bL()), l.expandKey(n);
    const c = a;
    return this.currentResult = l.decrypt(u.buffer, 0, r), this.currentIV = u.slice(-16).buffer, c || null;
  }
  webCryptoDecrypt(e, n, r, i) {
    if (this.key !== n || !this.fastAesKey) {
      if (!this.subtle)
        return Promise.resolve(this.onWebCryptoError(e, n, r, i));
      this.key = n, this.fastAesKey = new EL(this.subtle, n, i);
    }
    return this.fastAesKey.expandKey().then((s) => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new pL(this.subtle, new Uint8Array(r), i).decrypt(e.buffer, s)) : Promise.reject(new Error("web crypto not initialized"))).catch((s) => (Be.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`), this.onWebCryptoError(e, n, r, i)));
  }
  onWebCryptoError(e, n, r, i) {
    const s = this.enableSoftwareAES;
    if (s) {
      this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, n, r, i);
      const a = this.flush();
      if (a)
        return a.buffer;
    }
    throw new Error("WebCrypto" + (s ? " and softwareDecrypt" : "") + ": failed to decrypt data");
  }
  getValidChunk(e) {
    let n = e;
    const r = e.length - e.length % TL;
    return r !== e.length && (n = e.slice(0, r), this.remainderData = e.slice(r)), n;
  }
  logOnce(e) {
    this.logEnabled && (Be.log(`[decrypter]: ${e}`), this.logEnabled = !1);
  }
}
const S0 = Math.pow(2, 17);
class xL {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, n) {
    const r = e.url;
    if (!r)
      return Promise.reject(new Jn({
        type: de.NETWORK_ERROR,
        details: q.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error(`Fragment does not have a ${r ? "part list" : "url"}`),
        networkDetails: null
      }));
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, u) => {
      if (this.loader && this.loader.destroy(), e.gap)
        if (e.tagList.some((m) => m[0] === "GAP")) {
          u(v0(e));
          return;
        } else
          e.gap = !1;
      const l = this.loader = s ? new s(i) : new a(i), c = A0(e);
      e.loader = l;
      const d = T0(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: e.sn === "initSegment" ? 1 / 0 : S0
      };
      e.stats = l.stats;
      const h = {
        onSuccess: (m, p, g, E) => {
          this.resetLoader(e, l);
          let y = m.data;
          g.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(y.slice(0, 16)), y = y.slice(16)), o({
            frag: e,
            part: null,
            payload: y,
            networkDetails: E
          });
        },
        onError: (m, p, g, E) => {
          this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: Fe({
              url: r,
              data: void 0
            }, m),
            error: new Error(`HTTP Error ${m.code} ${m.text}`),
            networkDetails: g,
            stats: E
          }));
        },
        onAbort: (m, p, g) => {
          this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: g,
            stats: m
          }));
        },
        onTimeout: (m, p, g) => {
          this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: g,
            stats: m
          }));
        }
      };
      n && (h.onProgress = (m, p, g, E) => n({
        frag: e,
        part: null,
        payload: g,
        networkDetails: E
      })), l.load(c, f, h);
    });
  }
  loadPart(e, n, r) {
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, u) => {
      if (this.loader && this.loader.destroy(), e.gap || n.gap) {
        u(v0(e, n));
        return;
      }
      const l = this.loader = s ? new s(i) : new a(i), c = A0(e, n);
      e.loader = l;
      const d = T0(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: S0
      };
      n.stats = l.stats, l.load(c, f, {
        onSuccess: (h, m, p, g) => {
          this.resetLoader(e, l), this.updateStatsFromPart(e, n);
          const E = {
            frag: e,
            part: n,
            payload: h.data,
            networkDetails: g
          };
          r(E), o(E);
        },
        onError: (h, m, p, g) => {
          this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: n,
            response: Fe({
              url: c.url,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: p,
            stats: g
          }));
        },
        onAbort: (h, m, p) => {
          e.stats.aborted = n.stats.aborted, this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: n,
            error: new Error("Aborted"),
            networkDetails: p,
            stats: h
          }));
        },
        onTimeout: (h, m, p) => {
          this.resetLoader(e, l), u(new Jn({
            type: de.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: n,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: p,
            stats: h
          }));
        }
      });
    });
  }
  updateStatsFromPart(e, n) {
    const r = e.stats, i = n.stats, s = i.total;
    if (r.loaded += i.loaded, s) {
      const u = Math.round(e.duration / n.duration), l = Math.min(Math.round(r.loaded / s), u), d = (u - l) * Math.round(r.loaded / l);
      r.total = r.loaded + d;
    } else
      r.total = Math.max(r.loaded, r.total);
    const a = r.loading, o = i.loading;
    a.start ? a.first += o.first - o.start : (a.start = o.start, a.first = o.first), a.end = o.end;
  }
  resetLoader(e, n) {
    e.loader = null, this.loader === n && (self.clearTimeout(this.partLoadTimeout), this.loader = null), n.destroy();
  }
}
function A0(t, e = null) {
  const n = e || t, r = {
    frag: t,
    part: e,
    responseType: "arraybuffer",
    url: n.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }, i = n.byteRangeStartOffset, s = n.byteRangeEndOffset;
  if (ue(i) && ue(s)) {
    var a;
    let o = i, u = s;
    if (t.sn === "initSegment" && SL((a = t.decryptdata) == null ? void 0 : a.method)) {
      const l = s - i;
      l % 16 && (u = s + (16 - l % 16)), i !== 0 && (r.resetIV = !0, o = i - 16);
    }
    r.rangeStart = o, r.rangeEnd = u;
  }
  return r;
}
function v0(t, e) {
  const n = new Error(`GAP ${t.gap ? "tag" : "attribute"} found`), r = {
    type: de.MEDIA_ERROR,
    details: q.FRAG_GAP,
    fatal: !1,
    frag: t,
    error: n,
    networkDetails: null
  };
  return e && (r.part = e), (e || t).stats.aborted = !0, new Jn(r);
}
function SL(t) {
  return t === "AES-128" || t === "AES-256";
}
class Jn extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e;
  }
}
class xb extends on {
  constructor(e, n) {
    super(e, n), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
}
class bf {
  constructor(e, n, r, i = 0, s = -1, a = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = Xa(), this.buffering = {
      audio: Xa(),
      video: Xa(),
      audiovideo: Xa()
    }, this.level = e, this.sn = n, this.id = r, this.size = i, this.part = s, this.partial = a;
  }
}
function Xa() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
const I0 = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class ye {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(e, n) {
    if (e) {
      const r = ye.getBuffered(e);
      for (let i = r.length; i--; )
        if (n >= r.start(i) && n <= r.end(i))
          return !0;
    }
    return !1;
  }
  static bufferedRanges(e) {
    if (e) {
      const n = ye.getBuffered(e);
      return ye.timeRangesToArray(n);
    }
    return [];
  }
  static timeRangesToArray(e) {
    const n = [];
    for (let r = 0; r < e.length; r++)
      n.push({
        start: e.start(r),
        end: e.end(r)
      });
    return n;
  }
  static bufferInfo(e, n, r) {
    if (e) {
      const i = ye.bufferedRanges(e);
      if (i.length)
        return ye.bufferedInfo(i, n, r);
    }
    return {
      len: 0,
      start: n,
      end: n,
      bufferedIndex: -1
    };
  }
  static bufferedInfo(e, n, r) {
    n = Math.max(0, n), e.length > 1 && e.sort((c, d) => c.start - d.start || d.end - c.end);
    let i = -1, s = [];
    if (r)
      for (let c = 0; c < e.length; c++) {
        n >= e[c].start && n <= e[c].end && (i = c);
        const d = s.length;
        if (d) {
          const f = s[d - 1].end;
          e[c].start - f < r ? e[c].end > f && (s[d - 1].end = e[c].end) : s.push(e[c]);
        } else
          s.push(e[c]);
      }
    else
      s = e;
    let a = 0, o, u = n, l = n;
    for (let c = 0; c < s.length; c++) {
      const d = s[c].start, f = s[c].end;
      if (i === -1 && n >= d && n <= f && (i = c), n + r >= d && n < f)
        u = d, l = f, a = l - n;
      else if (n + r < d) {
        o = d;
        break;
      }
    }
    return {
      len: a,
      start: u || 0,
      end: l || 0,
      nextStart: o,
      buffered: e,
      bufferedIndex: i
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(e) {
    try {
      return e.buffered || I0;
    } catch (n) {
      return Be.log("failed to get media.buffered", n), I0;
    }
  }
}
const Sb = /\{\$([a-zA-Z0-9-_]+)\}/g;
function C0(t) {
  return Sb.test(t);
}
function Gc(t, e) {
  if (t.variableList !== null || t.hasVariableRefs) {
    const n = t.variableList;
    return e.replace(Sb, (r) => {
      const i = r.substring(2, r.length - 1), s = n == null ? void 0 : n[i];
      return s === void 0 ? (t.playlistParsingError || (t.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${i}"`)), r) : s;
    });
  }
  return e;
}
function L0(t, e, n) {
  let r = t.variableList;
  r || (t.variableList = r = {});
  let i, s;
  if ("QUERYPARAM" in e) {
    i = e.QUERYPARAM;
    try {
      const a = new self.URL(n).searchParams;
      if (a.has(i))
        s = a.get(i);
      else
        throw new Error(`"${i}" does not match any query parameter in URI: "${n}"`);
    } catch (a) {
      t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`));
    }
  } else
    i = e.NAME, s = e.VALUE;
  i in r ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${i}"`)) : r[i] = s || "";
}
function AL(t, e, n) {
  const r = e.IMPORT;
  if (n && r in n) {
    let i = t.variableList;
    i || (t.variableList = i = {}), i[r] = n[r];
  } else
    t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`));
}
const vL = /^(\d+)x(\d+)$/, _0 = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class Ze {
  constructor(e, n) {
    typeof e == "string" && (e = Ze.parseAttrList(e, n)), Ge(this, e);
  }
  get clientAttrs() {
    return Object.keys(this).filter((e) => e.substring(0, 2) === "X-");
  }
  decimalInteger(e) {
    const n = parseInt(this[e], 10);
    return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let n = (this[e] || "0x").slice(2);
      n = (n.length & 1 ? "0" : "") + n;
      const r = new Uint8Array(n.length / 2);
      for (let i = 0; i < n.length / 2; i++)
        r[i] = parseInt(n.slice(i * 2, i * 2 + 2), 16);
      return r;
    }
    return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const n = parseInt(this[e], 16);
    return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, n) {
    const r = this[e];
    return r ? parseFloat(r) : n;
  }
  enumeratedString(e) {
    return this[e];
  }
  enumeratedStringList(e, n) {
    const r = this[e];
    return (r ? r.split(/[ ,]+/) : []).reduce((i, s) => (i[s.toLowerCase()] = !0, i), n);
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const n = vL.exec(this[e]);
    if (n !== null)
      return {
        width: parseInt(n[1], 10),
        height: parseInt(n[2], 10)
      };
  }
  static parseAttrList(e, n) {
    let r;
    const i = {}, s = '"';
    for (_0.lastIndex = 0; (r = _0.exec(e)) !== null; ) {
      const a = r[1].trim();
      let o = r[2];
      const u = o.indexOf(s) === 0 && o.lastIndexOf(s) === o.length - 1;
      let l = !1;
      if (u)
        o = o.slice(1, -1);
      else
        switch (a) {
          case "IV":
          case "SCTE35-CMD":
          case "SCTE35-IN":
          case "SCTE35-OUT":
            l = !0;
        }
      if (n && (u || l))
        o = Gc(n, o);
      else if (!l && !u)
        switch (a) {
          case "CLOSED-CAPTIONS":
            if (o === "NONE")
              break;
          case "ALLOWED-CPC":
          case "CLASS":
          case "ASSOC-LANGUAGE":
          case "AUDIO":
          case "BYTERANGE":
          case "CHANNELS":
          case "CHARACTERISTICS":
          case "CODECS":
          case "DATA-ID":
          case "END-DATE":
          case "GROUP-ID":
          case "ID":
          case "IMPORT":
          case "INSTREAM-ID":
          case "KEYFORMAT":
          case "KEYFORMATVERSIONS":
          case "LANGUAGE":
          case "NAME":
          case "PATHWAY-ID":
          case "QUERYPARAM":
          case "RECENTLY-REMOVED-DATERANGES":
          case "SERVER-URI":
          case "STABLE-RENDITION-ID":
          case "STABLE-VARIANT-ID":
          case "START-DATE":
          case "SUBTITLES":
          case "SUPPLEMENTAL-CODECS":
          case "URI":
          case "VALUE":
          case "VIDEO":
          case "X-ASSET-LIST":
          case "X-ASSET-URI":
            Be.warn(`${e}: attribute ${a} is missing quotes`);
        }
      i[a] = o;
    }
    return i;
  }
}
const IL = "com.apple.hls.interstitial";
function CL(t) {
  return t !== "ID" && t !== "CLASS" && t !== "CUE" && t !== "START-DATE" && t !== "DURATION" && t !== "END-DATE" && t !== "END-ON-NEXT";
}
function LL(t) {
  return t === "SCTE35-OUT" || t === "SCTE35-IN" || t === "SCTE35-CMD";
}
class Ab {
  constructor(e, n, r = 0) {
    var i;
    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (n == null ? void 0 : n.tagAnchor) || null, this.tagOrder = (i = n == null ? void 0 : n.tagOrder) != null ? i : r, n) {
      const s = n.attr;
      for (const a in s)
        if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== s[a]) {
          Be.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = a;
          break;
        }
      e = Ge(new Ze({}), s, e);
    }
    if (this.attr = e, n ? (this._startDate = n._startDate, this._cue = n._cue, this._endDate = n._endDate, this._dateAtEnd = n._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const s = (n == null ? void 0 : n.endDate) || new Date(this.attr["END-DATE"]);
      ue(s.getTime()) && (this._endDate = s);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get cue() {
    const e = this._cue;
    return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
      pre: !1,
      post: !1,
      once: !1
    }) : e;
  }
  get startTime() {
    const {
      tagAnchor: e
    } = this;
    return e === null || e.programDateTime === null ? (Be.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    const e = this._endDate || this._dateAtEnd;
    if (e)
      return e;
    const n = this.duration;
    return n !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + n * 1e3) : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (ue(e))
        return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isInterstitial() {
    return this.class === IL;
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && ue(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
  }
}
const _L = 10;
class RL {
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return;
    }
    const n = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!r || !!n || !this.live, this.advanced = this.endSN > e.endSN || n > 0 || n === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;
  }
  hasKey(e) {
    return this.encryptedFragments.some((n) => {
      let r = n.decryptdata;
      return r || (n.setKeyFormat(e.keyFormat), r = n.decryptdata), !!r && e.matches(r);
    });
  }
  get hasProgramDateTime() {
    return this.fragments.length ? ue(this.fragments[this.fragments.length - 1].programDateTime) : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || _L;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
  }
  get fragmentEnd() {
    return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0;
  }
  get fragmentStart() {
    return this.fragments.length ? this.fragments[0].start : 0;
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
  }
  get maxPartIndex() {
    const e = this.partList;
    if (e) {
      const n = this.lastPartIndex;
      if (n !== -1) {
        for (let r = e.length; r--; )
          if (e[r].index > n)
            return e[r].index;
        return n;
      }
    }
    return 0;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
  }
  get expired() {
    if (this.live && this.age && this.misses < 3) {
      const e = this.partEnd - this.fragmentStart;
      return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration;
    }
    return !1;
  }
}
function lu(t, e) {
  return t.length === e.length ? !t.some((n, r) => n !== e[r]) : !1;
}
function R0(t, e) {
  return !t && !e ? !0 : !t || !e ? !1 : lu(t, e);
}
function _i(t) {
  return t === "AES-128" || t === "AES-256" || t === "AES-256-CTR";
}
function Ef(t) {
  switch (t) {
    case "AES-128":
    case "AES-256":
      return Ir.cbc;
    case "AES-256-CTR":
      return Ir.ctr;
    default:
      throw new Error(`invalid full segment method ${t}`);
  }
}
function yf(t) {
  return Uint8Array.from(atob(t), (e) => e.charCodeAt(0));
}
function Vc(t) {
  return Uint8Array.from(unescape(encodeURIComponent(t)), (e) => e.charCodeAt(0));
}
function kL(t) {
  const e = Vc(t).subarray(0, 16), n = new Uint8Array(16);
  return n.set(e, 16 - e.length), n;
}
function vb(t) {
  const e = function(r, i, s) {
    const a = r[i];
    r[i] = r[s], r[s] = a;
  };
  e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7);
}
function Ib(t) {
  const e = t.split(":");
  let n = null;
  if (e[0] === "data" && e.length === 2) {
    const r = e[1].split(";"), i = r[r.length - 1].split(",");
    if (i.length === 2) {
      const s = i[0] === "base64", a = i[1];
      s ? (r.splice(-1, 1), n = yf(a)) : n = kL(a);
    }
  }
  return n;
}
const cu = typeof self < "u" ? self : void 0;
var Je = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}, xt = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function Po(t) {
  switch (t) {
    case xt.FAIRPLAY:
      return Je.FAIRPLAY;
    case xt.PLAYREADY:
      return Je.PLAYREADY;
    case xt.WIDEVINE:
      return Je.WIDEVINE;
    case xt.CLEARKEY:
      return Je.CLEARKEY;
  }
}
function El(t) {
  switch (t) {
    case Je.FAIRPLAY:
      return xt.FAIRPLAY;
    case Je.PLAYREADY:
      return xt.PLAYREADY;
    case Je.WIDEVINE:
      return xt.WIDEVINE;
    case Je.CLEARKEY:
      return xt.CLEARKEY;
  }
}
function Ds(t) {
  const {
    drmSystems: e,
    widevineLicenseUrl: n
  } = t, r = e ? [Je.FAIRPLAY, Je.WIDEVINE, Je.PLAYREADY, Je.CLEARKEY].filter((i) => !!e[i]) : [];
  return !r[Je.WIDEVINE] && n && r.push(Je.WIDEVINE), r;
}
const Cb = function(t) {
  return cu != null && (t = cu.navigator) != null && t.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
}();
function wL(t, e, n, r) {
  let i;
  switch (t) {
    case Je.FAIRPLAY:
      i = ["cenc", "sinf"];
      break;
    case Je.WIDEVINE:
    case Je.PLAYREADY:
      i = ["cenc"];
      break;
    case Je.CLEARKEY:
      i = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${t}`);
  }
  return DL(i, e, n, r);
}
function DL(t, e, n, r) {
  return [{
    initDataTypes: t,
    persistentState: r.persistentState || "optional",
    distinctiveIdentifier: r.distinctiveIdentifier || "optional",
    sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
    audioCapabilities: e.map((s) => ({
      contentType: `audio/mp4; codecs=${s}`,
      robustness: r.audioRobustness || "",
      encryptionScheme: r.audioEncryptionScheme || null
    })),
    videoCapabilities: n.map((s) => ({
      contentType: `video/mp4; codecs=${s}`,
      robustness: r.videoRobustness || "",
      encryptionScheme: r.videoEncryptionScheme || null
    }))
  }];
}
function PL(t) {
  var e;
  return !!t && (t.sessionType === "persistent-license" || !!((e = t.sessionTypes) != null && e.some((n) => n === "persistent-license")));
}
function Lb(t) {
  const e = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2), n = String.fromCharCode.apply(null, Array.from(e)), r = n.substring(n.indexOf("<"), n.length), a = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("KID")[0];
  if (a) {
    const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
    if (o) {
      const u = yf(o).subarray(0, 16);
      return vb(u), u;
    }
  }
  return null;
}
let Qa = {};
class zr {
  static clearKeyUriToKeyIdMap() {
    Qa = {};
  }
  static setKeyIdForUri(e, n) {
    Qa[e] = n;
  }
  constructor(e, n, r, i = [1], s = null, a) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = n, this.keyFormat = r, this.keyFormatVersions = i, this.iv = s, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !_i(e), a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(tb(a)));
  }
  matches(e) {
    return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && lu(e.keyFormatVersions, this.keyFormatVersions) && R0(e.iv, this.iv) && R0(e.keyId, this.keyId);
  }
  isSupported() {
    if (this.method) {
      if (_i(this.method) || this.method === "NONE")
        return !0;
      if (this.keyFormat === "identity")
        return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case xt.FAIRPLAY:
        case xt.WIDEVINE:
        case xt.PLAYREADY:
        case xt.CLEARKEY:
          return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
      }
    }
    return !1;
  }
  getDecryptData(e, n) {
    if (!this.encrypted || !this.uri)
      return null;
    if (_i(this.method)) {
      let s = this.iv;
      return s || (typeof e != "number" && (Be.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0), s = NL(e)), new zr(this.method, this.uri, "identity", this.keyFormatVersions, s);
    }
    if (this.keyId) {
      const s = Qa[this.uri];
      if (s && !lu(this.keyId, s) && zr.setKeyIdForUri(this.uri, this.keyId), this.pssh)
        return this;
    }
    const r = Ib(this.uri);
    if (r)
      switch (this.keyFormat) {
        case xt.WIDEVINE:
          if (this.pssh = r, !this.keyId) {
            const s = BC(r.buffer);
            if (s.length) {
              var i;
              const a = s[0];
              this.keyId = (i = a.kids) != null && i.length ? a.kids[0] : null;
            }
          }
          this.keyId || (this.keyId = k0(n));
          break;
        case xt.PLAYREADY: {
          const s = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = FC(s, null, r), this.keyId = Lb(r);
          break;
        }
        default: {
          let s = r.subarray(0, 16);
          if (s.length !== 16) {
            const a = new Uint8Array(16);
            a.set(s, 16 - s.length), s = a;
          }
          this.keyId = s;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let s;
      s = OL(n), s || (s = k0(n), s || (s = Qa[this.uri])), s && (this.keyId = s, zr.setKeyIdForUri(this.uri, s));
    }
    return this;
  }
}
function OL(t) {
  const e = t == null ? void 0 : t[xt.WIDEVINE];
  return e ? e.keyId : null;
}
function k0(t) {
  const e = t == null ? void 0 : t[xt.PLAYREADY];
  if (e) {
    const n = Ib(e.uri);
    if (n)
      return Lb(n);
  }
  return null;
}
function NL(t) {
  const e = new Uint8Array(16);
  for (let n = 12; n < 16; n++)
    e[n] = t >> 8 * (15 - n) & 255;
  return e;
}
const w0 = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, D0 = /#EXT-X-MEDIA:(.*)/g, ML = /^#EXT(?:INF|-X-TARGETDURATION):/m, yl = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g"), FL = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class kn {
  static findGroup(e, n) {
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if (i.id === n)
        return i;
    }
  }
  static resolve(e, n) {
    return cf.buildAbsoluteURL(n, e, {
      alwaysNormalize: !0
    });
  }
  static isMediaPlaylist(e) {
    return ML.test(e);
  }
  static parseMasterPlaylist(e, n) {
    const r = C0(e), i = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: r
    }, s = [];
    if (w0.lastIndex = 0, !e.startsWith("#EXTM3U"))
      return i.playlistParsingError = new Error("no EXTM3U delimiter"), i;
    let a;
    for (; (a = w0.exec(e)) != null; )
      if (a[1]) {
        var o;
        const l = new Ze(a[1], i), c = Gc(i, a[2]), d = {
          attrs: l,
          bitrate: l.decimalInteger("BANDWIDTH") || l.decimalInteger("AVERAGE-BANDWIDTH"),
          name: l.NAME,
          url: kn.resolve(c, n)
        }, f = l.decimalResolution("RESOLUTION");
        f && (d.width = f.width, d.height = f.height), N0(l.CODECS, d);
        const h = l["SUPPLEMENTAL-CODECS"];
        h && (d.supplemental = {}, N0(h, d.supplemental)), (o = d.unknownCodecs) != null && o.length || s.push(d), i.levels.push(d);
      } else if (a[3]) {
        const l = a[3], c = a[4];
        switch (l) {
          case "SESSION-DATA": {
            const d = new Ze(c, i), f = d["DATA-ID"];
            f && (i.sessionData === null && (i.sessionData = {}), i.sessionData[f] = d);
            break;
          }
          case "SESSION-KEY": {
            const d = P0(c, n, i);
            d.encrypted && d.isSupported() ? (i.sessionKeys === null && (i.sessionKeys = []), i.sessionKeys.push(d)) : Be.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${c}"`);
            break;
          }
          case "DEFINE": {
            {
              const d = new Ze(c, i);
              L0(i, d, n);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const d = new Ze(c, i);
            i.contentSteering = {
              uri: kn.resolve(d["SERVER-URI"], n),
              pathwayId: d["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            i.startTimeOffset = O0(c);
            break;
          }
        }
      }
    const u = s.length > 0 && s.length < i.levels.length;
    return i.levels = u ? s : i.levels, i.levels.length === 0 && (i.playlistParsingError = new Error("no levels found in manifest")), i;
  }
  static parseMasterPlaylistMedia(e, n, r) {
    let i;
    const s = {}, a = r.levels, o = {
      AUDIO: a.map((l) => ({
        id: l.attrs.AUDIO,
        audioCodec: l.audioCodec
      })),
      SUBTITLES: a.map((l) => ({
        id: l.attrs.SUBTITLES,
        textCodec: l.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let u = 0;
    for (D0.lastIndex = 0; (i = D0.exec(e)) !== null; ) {
      const l = new Ze(i[1], r), c = l.TYPE;
      if (c) {
        const d = o[c], f = s[c] || [];
        s[c] = f;
        const h = l.LANGUAGE, m = l["ASSOC-LANGUAGE"], p = l.CHANNELS, g = l.CHARACTERISTICS, E = l["INSTREAM-ID"], y = {
          attrs: l,
          bitrate: 0,
          id: u++,
          groupId: l["GROUP-ID"] || "",
          name: l.NAME || h || "",
          type: c,
          default: l.bool("DEFAULT"),
          autoselect: l.bool("AUTOSELECT"),
          forced: l.bool("FORCED"),
          lang: h,
          url: l.URI ? kn.resolve(l.URI, n) : ""
        };
        if (m && (y.assocLang = m), p && (y.channels = p), g && (y.characteristics = g), E && (y.instreamId = E), d != null && d.length) {
          const T = kn.findGroup(d, y.groupId) || d[0];
          M0(y, T, "audioCodec"), M0(y, T, "textCodec");
        }
        f.push(y);
      }
    }
    return s;
  }
  static parseLevelPlaylist(e, n, r, i, s, a) {
    var o;
    const u = {
      url: n
    }, l = new RL(n), c = l.fragments, d = [];
    let f = null, h = 0, m = 0, p = 0, g = 0, E = 0, y = null, T = new pl(i, u), S, v, I, C = -1, D = !1, _ = null, A;
    if (yl.lastIndex = 0, l.m3u8 = e, l.hasVariableRefs = C0(e), ((o = yl.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
      return l.playlistParsingError = new Error("Missing format identifier #EXTM3U"), l;
    for (; (S = yl.exec(e)) !== null; ) {
      D && (D = !1, T = new pl(i, u), T.playlistOffset = p, T.setStart(p), T.sn = h, T.cc = g, E && (T.bitrate = E), T.level = r, f && (T.initSegment = f, f.rawProgramDateTime && (T.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null), _ && (T.setByteRange(_), _ = null)));
      const z = S[1];
      if (z) {
        T.duration = parseFloat(z);
        const O = (" " + S[2]).slice(1);
        T.title = O || null, T.tagList.push(O ? ["INF", z, O] : ["INF", z]);
      } else if (S[3]) {
        if (ue(T.duration)) {
          T.playlistOffset = p, T.setStart(p), I && B0(T, I, l), T.sn = h, T.level = r, T.cc = g, c.push(T);
          const O = (" " + S[3]).slice(1);
          T.relurl = Gc(l, O), zc(T, y, d), y = T, p += T.duration, h++, m = 0, D = !0;
        }
      } else {
        if (S = S[0].match(FL), !S) {
          Be.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (v = 1; v < S.length && S[v] === void 0; v++)
          ;
        const O = (" " + S[v]).slice(1), F = (" " + S[v + 1]).slice(1), B = S[v + 2] ? (" " + S[v + 2]).slice(1) : null;
        switch (O) {
          case "BYTERANGE":
            y ? T.setByteRange(F, y) : T.setByteRange(F);
            break;
          case "PROGRAM-DATE-TIME":
            T.rawProgramDateTime = F, T.tagList.push(["PROGRAM-DATE-TIME", F]), C === -1 && (C = c.length);
            break;
          case "PLAYLIST-TYPE":
            l.type && Xn(l, O, S), l.type = F.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            l.startSN !== 0 ? Xn(l, O, S) : c.length > 0 && U0(l, O, S), h = l.startSN = parseInt(F);
            break;
          case "SKIP": {
            l.skippedSegments && Xn(l, O, S);
            const H = new Ze(F, l), X = H.decimalInteger("SKIPPED-SEGMENTS");
            if (ue(X)) {
              l.skippedSegments += X;
              for (let Q = X; Q--; )
                c.push(null);
              h += X;
            }
            const w = H.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            w && (l.recentlyRemovedDateranges = (l.recentlyRemovedDateranges || []).concat(w.split("	")));
            break;
          }
          case "TARGETDURATION":
            l.targetduration !== 0 && Xn(l, O, S), l.targetduration = Math.max(parseInt(F), 1);
            break;
          case "VERSION":
            l.version !== null && Xn(l, O, S), l.version = parseInt(F);
            break;
          case "INDEPENDENT-SEGMENTS":
            break;
          case "ENDLIST":
            l.live || Xn(l, O, S), l.live = !1;
            break;
          case "#":
            (F || B) && T.tagList.push(B ? [F, B] : [F]);
            break;
          case "DISCONTINUITY":
            g++, T.tagList.push(["DIS"]);
            break;
          case "GAP":
            T.gap = !0, T.tagList.push([O]);
            break;
          case "BITRATE":
            T.tagList.push([O, F]), E = parseInt(F) * 1e3, ue(E) ? T.bitrate = E : E = 0;
            break;
          case "DATERANGE": {
            const H = new Ze(F, l), X = new Ab(H, l.dateRanges[H.ID], l.dateRangeTagCount);
            l.dateRangeTagCount++, X.isValid || l.skippedSegments ? l.dateRanges[X.id] = X : Be.warn(`Ignoring invalid DATERANGE tag: "${F}"`), T.tagList.push(["EXT-X-DATERANGE", F]);
            break;
          }
          case "DEFINE": {
            {
              const H = new Ze(F, l);
              "IMPORT" in H ? AL(l, H, a) : L0(l, H, n);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            l.startCC !== 0 ? Xn(l, O, S) : c.length > 0 && U0(l, O, S), l.startCC = g = parseInt(F);
            break;
          case "KEY": {
            const H = P0(F, n, l);
            if (H.isSupported()) {
              if (H.method === "NONE") {
                I = void 0;
                break;
              }
              I || (I = {});
              const X = I[H.keyFormat];
              X != null && X.matches(H) || (X && (I = Ge({}, I)), I[H.keyFormat] = H);
            } else
              Be.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${F}"`);
            break;
          }
          case "START":
            l.startTimeOffset = O0(F);
            break;
          case "MAP": {
            const H = new Ze(F, l);
            if (T.duration) {
              const X = new pl(i, u);
              F0(X, H, r, I), f = X, T.initSegment = f, f.rawProgramDateTime && !T.rawProgramDateTime && (T.rawProgramDateTime = f.rawProgramDateTime);
            } else {
              const X = T.byteRangeEndOffset;
              if (X) {
                const w = T.byteRangeStartOffset;
                _ = `${X - w}@${w}`;
              } else
                _ = null;
              F0(T, H, r, I), f = T, D = !0;
            }
            f.cc = g;
            break;
          }
          case "SERVER-CONTROL": {
            A && Xn(l, O, S), A = new Ze(F), l.canBlockReload = A.bool("CAN-BLOCK-RELOAD"), l.canSkipUntil = A.optionalFloat("CAN-SKIP-UNTIL", 0), l.canSkipDateRanges = l.canSkipUntil > 0 && A.bool("CAN-SKIP-DATERANGES"), l.partHoldBack = A.optionalFloat("PART-HOLD-BACK", 0), l.holdBack = A.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            l.partTarget && Xn(l, O, S);
            const H = new Ze(F);
            l.partTarget = H.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let H = l.partList;
            H || (H = l.partList = []);
            const X = m > 0 ? H[H.length - 1] : void 0, w = m++, Q = new Ze(F, l), J = new AC(Q, T, u, w, X);
            H.push(J), T.duration += J.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const H = new Ze(F, l);
            l.preloadHint = H;
            break;
          }
          case "RENDITION-REPORT": {
            const H = new Ze(F, l);
            l.renditionReports = l.renditionReports || [], l.renditionReports.push(H);
            break;
          }
          default:
            Be.warn(`line parsed but not handled: ${S}`);
            break;
        }
      }
    }
    y && !y.relurl ? (c.pop(), p -= y.duration, l.partList && (l.fragmentHint = y)) : l.partList && (zc(T, y, d), T.cc = g, l.fragmentHint = T, I && B0(T, I, l)), l.targetduration || (l.playlistParsingError = new Error("Missing Target Duration"));
    const L = c.length, N = c[0], U = c[L - 1];
    if (p += l.skippedSegments * l.targetduration, p > 0 && L && U) {
      l.averagetargetduration = p / L;
      const z = U.sn;
      l.endSN = z !== "initSegment" ? z : 0, l.live || (U.endList = !0), C > 0 && (UL(c, C), N && d.unshift(N));
    }
    return l.fragmentHint && (p += l.fragmentHint.duration), l.totalduration = p, d.length && l.dateRangeTagCount && N && _b(d, l), l.endCC = g, l;
  }
}
function _b(t, e) {
  let n = t.length;
  if (!n)
    if (e.hasProgramDateTime) {
      const o = e.fragments[e.fragments.length - 1];
      t.push(o), n++;
    } else
      return;
  const r = t[n - 1], i = e.live ? 1 / 0 : e.totalduration, s = Object.keys(e.dateRanges);
  for (let o = s.length; o--; ) {
    const u = e.dateRanges[s[o]], l = u.startDate.getTime();
    u.tagAnchor = r.ref;
    for (let c = n; c--; ) {
      var a;
      if (((a = t[c]) == null ? void 0 : a.sn) < e.startSN)
        break;
      const d = BL(e, l, t, c, i);
      if (d !== -1) {
        u.tagAnchor = e.fragments[d].ref;
        break;
      }
    }
  }
}
function BL(t, e, n, r, i) {
  const s = n[r];
  if (s) {
    const o = s.programDateTime;
    if (e >= o || r === 0) {
      var a;
      const u = (((a = n[r + 1]) == null ? void 0 : a.start) || i) - s.start;
      if (e <= o + u * 1e3) {
        const l = n[r].sn - t.startSN;
        if (l < 0)
          return -1;
        const c = t.fragments;
        if (c.length > n.length) {
          const f = (n[r + 1] || c[c.length - 1]).sn - t.startSN;
          for (let h = f; h > l; h--) {
            const m = c[h].programDateTime;
            if (e >= m && e < m + c[h].duration * 1e3)
              return h;
          }
        }
        return l;
      }
    }
  }
  return -1;
}
function P0(t, e, n) {
  var r, i;
  const s = new Ze(t, n), a = (r = s.METHOD) != null ? r : "", o = s.URI, u = s.hexadecimalInteger("IV"), l = s.KEYFORMATVERSIONS, c = (i = s.KEYFORMAT) != null ? i : "identity";
  o && s.IV && !u && Be.error(`Invalid IV: ${s.IV}`);
  const d = o ? kn.resolve(o, e) : "", f = (l || "1").split("/").map(Number).filter(Number.isFinite);
  return new zr(a, d, c, f, u, s.KEYID);
}
function O0(t) {
  const n = new Ze(t).decimalFloatingPoint("TIME-OFFSET");
  return ue(n) ? n : null;
}
function N0(t, e) {
  let n = (t || "").split(/[ ,]+/).filter((r) => r);
  ["video", "audio", "text"].forEach((r) => {
    const i = n.filter((s) => hf(s, r));
    i.length && (e[`${r}Codec`] = i.map((s) => s.split("/")[0]).join(","), n = n.filter((s) => i.indexOf(s) === -1));
  }), e.unknownCodecs = n;
}
function M0(t, e, n) {
  const r = e[n];
  r && (t[n] = r);
}
function UL(t, e) {
  let n = t[e];
  for (let r = e; r--; ) {
    const i = t[r];
    if (!i)
      return;
    i.programDateTime = n.programDateTime - i.duration * 1e3, n = i;
  }
}
function zc(t, e, n) {
  t.rawProgramDateTime ? n.push(t) : e != null && e.programDateTime && (t.programDateTime = e.endProgramDateTime);
}
function F0(t, e, n, r) {
  t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = n, t.sn = "initSegment", r && (t.levelkeys = r), t.initSegment = null;
}
function B0(t, e, n) {
  t.levelkeys = e;
  const {
    encryptedFragments: r
  } = n;
  (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some((i) => e[i].isCommonEncryption) && r.push(t);
}
function Xn(t, e, n) {
  t.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${n[0]})`);
}
function U0(t, e, n) {
  t.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${n[0]})`);
}
function Tl(t, e) {
  const n = e.startPTS;
  if (ue(n)) {
    let r = 0, i;
    e.sn > t.sn ? (r = n - t.start, i = t) : (r = t.start - n, i = e), i.duration !== r && i.setDuration(r);
  } else e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.setStart(t.start + (t.minEndPTS - t.start)) : e.setStart(t.start + t.duration) : e.setStart(Math.max(t.start - e.duration, 0));
}
function Rb(t, e, n, r, i, s, a) {
  r - n <= 0 && (a.warn("Fragment should have a positive duration", e), r = n + e.duration, s = i + e.duration);
  let u = n, l = r;
  const c = e.startPTS, d = e.endPTS;
  if (ue(c)) {
    const E = Math.abs(c - n);
    t && E > t.totalduration ? a.warn(`media timestamps and playlist times differ by ${E}s for level ${e.level} ${t.url}`) : ue(e.deltaPTS) ? e.deltaPTS = Math.max(E, e.deltaPTS) : e.deltaPTS = E, u = Math.max(n, c), n = Math.min(n, c), i = e.startDTS !== void 0 ? Math.min(i, e.startDTS) : i, l = Math.min(r, d), r = Math.max(r, d), s = e.endDTS !== void 0 ? Math.max(s, e.endDTS) : s;
  }
  const f = n - e.start;
  e.start !== 0 && e.setStart(n), e.setDuration(r - e.start), e.startPTS = n, e.maxStartPTS = u, e.startDTS = i, e.endPTS = r, e.minEndPTS = l, e.endDTS = s;
  const h = e.sn;
  if (!t || h < t.startSN || h > t.endSN)
    return 0;
  let m;
  const p = h - t.startSN, g = t.fragments;
  for (g[p] = e, m = p; m > 0; m--)
    Tl(g[m], g[m - 1]);
  for (m = p; m < g.length - 1; m++)
    Tl(g[m], g[m + 1]);
  return t.fragmentHint && Tl(g[g.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, f;
}
function $L(t, e, n) {
  if (t === e)
    return;
  let r = null;
  const i = t.fragments;
  for (let c = i.length - 1; c >= 0; c--) {
    const d = i[c].initSegment;
    if (d) {
      r = d;
      break;
    }
  }
  t.fragmentHint && delete t.fragmentHint.endPTS;
  let s;
  VL(t, e, (c, d, f, h) => {
    if ((!e.startCC || e.skippedSegments) && d.cc !== c.cc) {
      const m = c.cc - d.cc;
      for (let p = f; p < h.length; p++)
        h[p].cc += m;
      e.endCC = h[h.length - 1].cc;
    }
    ue(c.startPTS) && ue(c.endPTS) && (d.setStart(d.startPTS = c.startPTS), d.startDTS = c.startDTS, d.maxStartPTS = c.maxStartPTS, d.endPTS = c.endPTS, d.endDTS = c.endDTS, d.minEndPTS = c.minEndPTS, d.setDuration(c.endPTS - c.startPTS), d.duration && (s = d), e.PTSKnown = e.alignedSliding = !0), c.hasStreams && (d.elementaryStreams = c.elementaryStreams), d.loader = c.loader, c.hasStats && (d.stats = c.stats), c.initSegment && (d.initSegment = c.initSegment, r = c.initSegment);
  });
  const a = e.fragments, o = e.fragmentHint ? a.concat(e.fragmentHint) : a;
  if (r && o.forEach((c) => {
    var d;
    c && (!c.initSegment || c.initSegment.relurl === ((d = r) == null ? void 0 : d.relurl)) && (c.initSegment = r);
  }), e.skippedSegments) {
    if (e.deltaUpdateFailed = a.some((c) => !c), e.deltaUpdateFailed) {
      n.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let c = e.skippedSegments; c--; )
        a.shift();
      e.startSN = a[0].sn;
    } else {
      e.canSkipDateRanges && (e.dateRanges = HL(t.dateRanges, e, n));
      const c = t.fragments.filter((d) => d.rawProgramDateTime);
      if (t.hasProgramDateTime && !e.hasProgramDateTime)
        for (let d = 1; d < o.length; d++)
          o[d].programDateTime === null && zc(o[d], o[d - 1], c);
      _b(c, e);
    }
    e.endCC = a[a.length - 1].cc;
  }
  if (!e.startCC) {
    var u;
    const c = Db(t, e.startSN - 1);
    e.startCC = (u = c == null ? void 0 : c.cc) != null ? u : a[0].cc;
  }
  GL(t.partList, e.partList, (c, d) => {
    d.elementaryStreams = c.elementaryStreams, d.stats = c.stats;
  }), s ? Rb(e, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS, n) : kb(t, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
  const l = e.advancedDateTime;
  if (e.advanced && l) {
    const c = e.edge;
    e.driftStart || (e.driftStartTime = l, e.driftStart = c), e.driftEndTime = l, e.driftEnd = c;
  } else
    e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime;
  e.requestScheduled === -1 && (e.requestScheduled = t.requestScheduled);
}
function HL(t, e, n) {
  const {
    dateRanges: r,
    recentlyRemovedDateranges: i
  } = e, s = Ge({}, t);
  i && i.forEach((u) => {
    delete s[u];
  });
  const o = Object.keys(s).length;
  return o ? (Object.keys(r).forEach((u) => {
    const l = s[u], c = new Ab(r[u].attr, l);
    c.isValid ? (s[u] = c, l || (c.tagOrder += o)) : n.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${ze(r[u].attr)}"`);
  }), s) : r;
}
function GL(t, e, n) {
  if (t && e) {
    let r = 0;
    for (let i = 0, s = t.length; i <= s; i++) {
      const a = t[i], o = e[i + r];
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? n(a, o) : r--;
    }
  }
}
function VL(t, e, n) {
  const r = e.skippedSegments, i = Math.max(t.startSN, e.startSN) - e.startSN, s = (t.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, a = e.startSN - t.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, u = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments;
  for (let l = i; l <= s; l++) {
    const c = u[a + l];
    let d = o[l];
    if (r && !d && c && (d = e.fragments[l] = c), c && d) {
      n(c, d, l, o);
      const f = c.relurl, h = d.relurl;
      if (f && zL(f, h)) {
        e.playlistParsingError = $0(`media sequence mismatch ${d.sn}:`, t, e, c, d);
        return;
      } else if (c.cc !== d.cc) {
        e.playlistParsingError = $0(`discontinuity sequence mismatch (${c.cc}!=${d.cc})`, t, e, c, d);
        return;
      }
    }
  }
}
function $0(t, e, n, r, i) {
  return new Error(`${t} ${i.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${n.startSN}
${n.m3u8}`);
}
function kb(t, e, n = !0) {
  const r = e.startSN + e.skippedSegments - t.startSN, i = t.fragments, s = r >= 0;
  let a = 0;
  if (s && r < i.length)
    a = i[r].start;
  else if (s && e.startSN === t.endSN + 1)
    a = t.fragmentEnd;
  else if (s && n)
    a = t.fragmentStart + r * e.levelTargetDuration;
  else if (!e.skippedSegments && e.fragmentStart === 0)
    a = t.fragmentStart;
  else
    return;
  qc(e, a);
}
function qc(t, e) {
  if (e) {
    const n = t.fragments;
    for (let r = t.skippedSegments; r < n.length; r++)
      n[r].addStart(e);
    t.fragmentHint && t.fragmentHint.addStart(e);
  }
}
function wb(t, e = 1 / 0) {
  let n = 1e3 * t.targetduration;
  if (t.updated) {
    const r = t.fragments;
    if (r.length && n * 4 > e) {
      const s = r[r.length - 1].duration * 1e3;
      s < n && (n = s);
    }
  } else
    n /= 2;
  return Math.round(n);
}
function Db(t, e, n) {
  if (!t)
    return null;
  let r = t.fragments[e - t.startSN];
  return r || (r = t.fragmentHint, r && r.sn === e) ? r : e < t.startSN && n && n.sn === e ? n : null;
}
function H0(t, e, n) {
  return t ? Pb(t.partList, e, n) : null;
}
function Pb(t, e, n) {
  if (t)
    for (let r = t.length; r--; ) {
      const i = t[r];
      if (i.index === n && i.fragment.sn === e)
        return i;
    }
  return null;
}
function Ob(t) {
  t.forEach((e, n) => {
    var r;
    (r = e.details) == null || r.fragments.forEach((i) => {
      i.level = n, i.initSegment && (i.initSegment.level = n);
    });
  });
}
function zL(t, e) {
  return t !== e && e ? G0(t) !== G0(e) : !1;
}
function G0(t) {
  return t.replace(/\?[^?]*$/, "");
}
function Ns(t, e) {
  for (let r = 0, i = t.length; r < i; r++) {
    var n;
    if (((n = t[r]) == null ? void 0 : n.cc) === e)
      return t[r];
  }
  return null;
}
function qL(t, e) {
  return !!(t && e.startCC < t.endCC && e.endCC > t.startCC);
}
function V0(t, e) {
  const n = t.start + e;
  t.startPTS = n, t.setStart(n), t.endPTS = n + t.duration;
}
function Nb(t, e) {
  const n = e.fragments;
  for (let r = 0, i = n.length; r < i; r++)
    V0(n[r], t);
  e.fragmentHint && V0(e.fragmentHint, t), e.alignedSliding = !0;
}
function jL(t, e) {
  t && (Mb(e, t), e.alignedSliding || du(e, t), !e.alignedSliding && !e.skippedSegments && kb(t, e, !1));
}
function Mb(t, e) {
  if (!qL(e, t))
    return;
  const n = Math.min(e.endCC, t.endCC), r = Ns(e.fragments, n), i = Ns(t.fragments, n);
  if (!r || !i)
    return;
  Be.log(`Aligning playlist at start of dicontinuity sequence ${n}`);
  const s = r.start - i.start;
  Nb(s, t);
}
function du(t, e) {
  if (!t.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const n = t.fragments, r = e.fragments;
  if (!n.length || !r.length)
    return;
  let i, s;
  const a = Math.min(e.endCC, t.endCC);
  e.startCC < a && t.startCC < a && (i = Ns(r, a), s = Ns(n, a)), (!i || !s) && (i = r[Math.floor(r.length / 2)], s = Ns(n, i.cc) || n[Math.floor(n.length / 2)]);
  const o = i.programDateTime, u = s.programDateTime;
  if (!o || !u)
    return;
  const l = (u - o) / 1e3 - (s.start - i.start);
  Nb(l, t);
}
function _t(t, e, n) {
  Ot(t, e, n), t.addEventListener(e, n);
}
function Ot(t, e, n) {
  t.removeEventListener(e, n);
}
const KL = {
  toString: function(t) {
    let e = "";
    const n = t.length;
    for (let r = 0; r < n; r++)
      e += `[${t.start(r).toFixed(3)}-${t.end(r).toFixed(3)}]`;
    return e;
  }
}, Y = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
class Tf extends xb {
  constructor(e, n, r, i, s) {
    super(i, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = Y.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => {
      const {
        config: a,
        fragCurrent: o,
        media: u,
        mediaBuffer: l,
        state: c
      } = this, d = u ? u.currentTime : 0, f = ye.bufferInfo(l || u, d, a.maxBufferHole), h = !f.len;
      if (this.log(`Media seeking to ${ue(d) ? d.toFixed(3) : d}, state: ${c}, ${h ? "out of" : "in"} buffer`), this.state === Y.ENDED)
        this.resetLoadingState();
      else if (o) {
        const m = a.maxFragLookUpTolerance, p = o.start - m, g = o.start + o.duration + m;
        if (h || g < f.start || p > f.end) {
          const E = d > g;
          (d < p || E) && (E && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`), o.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
        }
      }
      if (u) {
        this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);
        const m = this.lastCurrentTime;
        if (d > m && (this.lastCurrentTime = d), !this.loadingParts) {
          const p = Math.max(f.end, d), g = this.shouldLoadParts(this.getLevelDetails(), p);
          g && (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${p.toFixed(2)}`), this.loadingParts = g);
        }
      }
      this.hls.hasEnoughToStart || (this.log(`Setting ${h ? "startPosition" : "nextLoadPosition"} to ${d} for seek without enough to start`), this.nextLoadPosition = d, h && (this.startPosition = d)), h && this.state === Y.IDLE && this.tickImmediate();
    }, this.onMediaEnded = () => {
      this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0;
    }, this.playlistType = s, this.hls = e, this.fragmentLoader = new xL(e.config), this.keyLoader = r, this.fragmentTracker = n, this.config = e.config, this.decrypter = new gf(e.config);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  startLoad(e) {
  }
  stopLoad() {
    if (this.state === Y.STOPPED)
      return;
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Y.STOPPED;
  }
  get startPositionValue() {
    const {
      nextLoadPosition: e,
      startPosition: n
    } = this;
    return n === -1 && e ? e : n;
  }
  get bufferingEnabled() {
    return this.buffering;
  }
  pauseBuffering() {
    this.buffering = !1;
  }
  resumeBuffering() {
    this.buffering = !0;
  }
  get inFlightFrag() {
    return {
      frag: this.fragCurrent,
      state: this.state
    };
  }
  _streamEnded(e, n) {
    if (n.live || !this.media)
      return !1;
    const r = e.end || 0, i = this.config.timelineOffset || 0;
    if (r <= i)
      return !1;
    const s = e.buffered;
    this.config.maxBufferHole && s && s.length > 1 && (e = ye.bufferedInfo(s, e.start, 0));
    const a = e.nextStart;
    if (a && a > i && a < n.edge || this.media.currentTime < e.start)
      return !1;
    const u = n.partList;
    if (u != null && u.length) {
      const c = u[u.length - 1];
      return ye.isBuffered(this.media, c.start + c.duration / 2);
    }
    const l = n.fragments[n.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(l);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null)
      return this.levelLastLoaded.details;
  }
  get timelineOffset() {
    const e = this.config.timelineOffset;
    if (e) {
      var n;
      return ((n = this.getLevelDetails()) == null ? void 0 : n.appliedTimelineOffset) || e;
    }
    return 0;
  }
  onMediaAttached(e, n) {
    const r = this.media = this.mediaBuffer = n.media;
    _t(r, "seeking", this.onMediaSeeking), _t(r, "ended", this.onMediaEnded);
    const i = this.config;
    this.levels && i.autoStartLoad && this.state === Y.STOPPED && this.startLoad(i.startPosition);
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia, i = this.media;
    if (i !== null) {
      if (i.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), Ot(i, "seeking", this.onMediaSeeking), Ot(i, "ended", this.onMediaEnded), this.keyLoader && !r && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, r) {
        this.resetLoadingState(), this.resetTransmuxer();
        return;
      }
      this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
    }
  }
  onManifestLoading() {
    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;
  }
  onError(e, n) {
  }
  onManifestLoaded(e, n) {
    this.startTimeOffset = n.startTimeOffset;
  }
  onHandlerDestroying() {
    this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;
  }
  onHandlerDestroyed() {
    this.state = Y.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
  }
  loadFragment(e, n, r) {
    this.startFragRequested = !0, this._loadFragForPlayback(e, n, r);
  }
  _loadFragForPlayback(e, n, r) {
    const i = (s) => {
      const a = s.frag;
      if (this.fragContextChanged(a)) {
        this.warn(`${a.type} sn: ${a.sn}${s.part ? " part: " + s.part.index : ""} of ${this.fragInfo(a, !1, s.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(a);
        return;
      }
      a.stats.chunkCount++, this._handleFragmentLoadProgress(s);
    };
    this._doFragLoad(e, n, r, i).then((s) => {
      if (!s)
        return;
      const a = this.state, o = s.frag;
      if (this.fragContextChanged(o)) {
        (a === Y.FRAG_LOADING || !this.fragCurrent && a === Y.PARSING) && (this.fragmentTracker.removeFragment(o), this.state = Y.IDLE);
        return;
      }
      "payload" in s && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`), this.hls.trigger(x.FRAG_LOADED, s)), this._handleFragmentLoadComplete(s);
    }).catch((s) => {
      this.state === Y.STOPPED || this.state === Y.ERROR || (this.warn(`Frag error: ${(s == null ? void 0 : s.message) || s}`), this.resetFragmentLoading(e));
    });
  }
  clearTrackerIfNeeded(e) {
    var n;
    const {
      fragmentTracker: r
    } = this;
    if (r.getState(e) === ft.APPENDING) {
      const s = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, s), o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength), u = this.backtrackFragment;
      ((u ? e.sn - u.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && r.removeFragment(e);
    } else ((n = this.mediaBuffer) == null ? void 0 : n.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({
      frag: e,
      part: null,
      stats: e.stats,
      id: e.type
    }), r.getState(e) === ft.PARTIAL && r.removeFragment(e));
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const n = e.fragments[e.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: n,
        part: null,
        stats: n.stats,
        id: n.type
      });
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0);
  }
  waitForLive(e) {
    const n = e.details;
    return (n == null ? void 0 : n.live) && n.type !== "EVENT" && (this.levelLastLoaded !== e || n.expired);
  }
  flushMainBuffer(e, n, r = null) {
    if (!(e - n))
      return;
    const i = {
      startOffset: e,
      endOffset: n,
      type: r
    };
    this.hls.trigger(x.BUFFER_FLUSHING, i);
  }
  _loadInitSegment(e, n) {
    this._doFragLoad(e, n).then((r) => {
      const i = r == null ? void 0 : r.frag;
      if (!i || this.fragContextChanged(i) || !this.levels)
        throw new Error("init load aborted");
      return r;
    }).then((r) => {
      const {
        hls: i
      } = this, {
        frag: s,
        payload: a
      } = r, o = s.decryptdata;
      if (a && a.byteLength > 0 && o != null && o.key && o.iv && _i(o.method)) {
        const u = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, Ef(o.method)).catch((l) => {
          throw i.trigger(x.ERROR, {
            type: de.MEDIA_ERROR,
            details: q.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: l,
            reason: l.message,
            frag: s
          }), l;
        }).then((l) => {
          const c = self.performance.now();
          return i.trigger(x.FRAG_DECRYPTED, {
            frag: s,
            payload: l,
            stats: {
              tstart: u,
              tdecrypt: c
            }
          }), r.payload = l, this.completeInitSegmentLoad(r);
        });
      }
      return this.completeInitSegmentLoad(r);
    }).catch((r) => {
      this.state === Y.STOPPED || this.state === Y.ERROR || (this.warn(r), this.resetFragmentLoading(e));
    });
  }
  completeInitSegmentLoad(e) {
    const {
      levels: n
    } = this;
    if (!n)
      throw new Error("init load aborted, missing levels");
    const r = e.frag.stats;
    this.state !== Y.STOPPED && (this.state = Y.IDLE), e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick();
  }
  unhandledEncryptionError(e, n) {
    var r, i;
    const s = e.tracks;
    if (s && !n.encrypted && ((r = s.audio) != null && r.encrypted || (i = s.video) != null && i.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
      const a = this.media, o = new Error(`Encrypted track with no key in ${this.fragInfo(n)} (media ${a ? "attached mediaKeys: " + a.mediaKeys : "detached"})`);
      return this.warn(o.message), !a || a.mediaKeys ? !1 : (this.hls.trigger(x.ERROR, {
        type: de.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_KEYS,
        fatal: !1,
        error: o,
        frag: n
      }), this.resetTransmuxer(), !0);
    }
    return !1;
  }
  fragContextChanged(e) {
    const {
      fragCurrent: n
    } = this;
    return !e || !n || e.sn !== n.sn || e.level !== n.level;
  }
  fragBufferedComplete(e, n) {
    const r = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.log(`Buffered ${e.type} sn: ${e.sn}${n ? " part: " + n.index : ""} of ${this.fragInfo(e, !1, n)} > buffer:${r ? KL.toString(ye.getBuffered(r)) : "(detached)"})`), ct(e)) {
      var i;
      if (e.type !== le.SUBTITLE) {
        const a = e.elementaryStreams;
        if (!Object.keys(a).some((o) => !!a[o])) {
          this.state = Y.IDLE;
          return;
        }
      }
      const s = (i = this.levels) == null ? void 0 : i[e.level];
      s != null && s.fragmentError && (this.log(`Resetting level fragment error count of ${s.fragmentError} on frag buffered`), s.fragmentError = 0);
    }
    this.state = Y.IDLE;
  }
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: n
    } = this;
    if (!n)
      return;
    const {
      frag: r,
      part: i,
      partsLoaded: s
    } = e, a = !s || s.length === 0 || s.some((u) => !u), o = new bf(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !a);
    n.flush(o);
  }
  _handleFragmentLoadProgress(e) {
  }
  _doFragLoad(e, n, r = null, i) {
    var s;
    this.fragCurrent = e;
    const a = n.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let o = null;
    if (e.encrypted && !((s = e.decryptdata) != null && s.key)) {
      if (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = Y.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then((f) => {
        if (!this.fragContextChanged(f.frag))
          return this.hls.trigger(x.KEY_LOADED, f), this.state === Y.KEY_LOADING && (this.state = Y.IDLE), f;
      }), this.hls.trigger(x.KEY_LOADING, {
        frag: e
      }), this.fragCurrent === null)
        return this.log("context changed in KEY_LOADING"), Promise.resolve(null);
    } else e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested), o && this.log("[eme] blocking frag load until media-keys acquired"));
    const u = this.fragPrevious;
    if (ct(e) && (!u || e.sn !== u.sn)) {
      const f = this.shouldLoadParts(n.details, e.end);
      f !== this.loadingParts && (this.log(`LL-Part loading ${f ? "ON" : "OFF"} loading sn ${u == null ? void 0 : u.sn}->${e.sn}`), this.loadingParts = f);
    }
    if (r = Math.max(e.start, r || 0), this.loadingParts && ct(e)) {
      const f = a.partList;
      if (f && i) {
        r > a.fragmentEnd && a.fragmentHint && (e = a.fragmentHint);
        const h = this.getNextPart(f, e, r);
        if (h > -1) {
          const m = f[h];
          e = this.fragCurrent = m.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${m.index} (${h}/${f.length - 1}) of ${this.fragInfo(e, !1, m)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = m.start + m.duration, this.state = Y.FRAG_LOADING;
          let p;
          return o ? p = o.then((g) => !g || this.fragContextChanged(g.frag) ? null : this.doFragPartsLoad(e, m, n, i)).catch((g) => this.handleFragLoadError(g)) : p = this.doFragPartsLoad(e, m, n, i).catch((g) => this.handleFragLoadError(g)), this.hls.trigger(x.FRAG_LOADING, {
            frag: e,
            part: m,
            targetBufferTime: r
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : p;
        } else if (!e.url || this.loadedEndOfParts(f, r))
          return Promise.resolve(null);
      }
    }
    if (ct(e) && this.loadingParts) {
      var l;
      this.log(`LL-Part loading OFF after next part miss @${r.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(l = a.partList) == null ? void 0 : l.filter((f) => f.loaded).map((f) => `[${f.start}-${f.end}]`)}`), this.loadingParts = !1;
    } else if (!e.url)
      return Promise.resolve(null);
    this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + a.startSN + "-" + a.endSN + "]"}, target: ${parseFloat(r.toFixed(3))}`), ue(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = Y.FRAG_LOADING;
    const c = this.config.progressive;
    let d;
    return c && o ? d = o.then((f) => !f || this.fragContextChanged(f.frag) ? null : this.fragmentLoader.load(e, i)).catch((f) => this.handleFragLoadError(f)) : d = Promise.all([this.fragmentLoader.load(e, c ? i : void 0), o]).then(([f]) => (!c && i && i(f), f)).catch((f) => this.handleFragLoadError(f)), this.hls.trigger(x.FRAG_LOADING, {
      frag: e,
      targetBufferTime: r
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d;
  }
  doFragPartsLoad(e, n, r, i) {
    return new Promise((s, a) => {
      var o;
      const u = [], l = (o = r.details) == null ? void 0 : o.partList, c = (d) => {
        this.fragmentLoader.loadPart(e, d, i).then((f) => {
          u[d.index] = f;
          const h = f.part;
          this.hls.trigger(x.FRAG_LOADED, f);
          const m = H0(r.details, e.sn, d.index + 1) || Pb(l, e.sn, d.index + 1);
          if (m)
            c(m);
          else
            return s({
              frag: e,
              part: h,
              partsLoaded: u
            });
        }).catch(a);
      };
      c(n);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const n = e.data;
      n.frag && n.details === q.INTERNAL_ABORTED ? this.handleFragLoadAborted(n.frag, n.part) : n.frag && n.type === de.KEY_SYSTEM_ERROR ? (n.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(n.frag)) : this.hls.trigger(x.ERROR, n);
    } else
      this.hls.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const n = this.getCurrentContext(e);
    if (!n || this.state !== Y.PARSING) {
      !this.fragCurrent && this.state !== Y.STOPPED && this.state !== Y.ERROR && (this.state = Y.IDLE);
      return;
    }
    const {
      frag: r,
      part: i,
      level: s
    } = n, a = self.performance.now();
    r.stats.parsing.end = a, i && (i.stats.parsing.end = a);
    const o = this.getLevelDetails(), l = o && r.sn > o.endSN || this.shouldLoadParts(o, r.end);
    l !== this.loadingParts && (this.log(`LL-Part loading ${l ? "ON" : "OFF"} after parsing segment ending @${r.end.toFixed(2)}`), this.loadingParts = l), this.updateLevelTiming(r, i, s, e.partial);
  }
  shouldLoadParts(e, n) {
    if (this.config.lowLatencyMode) {
      if (!e)
        return this.loadingParts;
      if (e.partList) {
        var r;
        const s = e.partList[0];
        if (s.fragment.type === le.SUBTITLE)
          return !1;
        const a = s.end + (((r = e.fragmentHint) == null ? void 0 : r.duration) || 0);
        if (n >= a) {
          var i;
          if ((this.hls.hasEnoughToStart ? ((i = this.media) == null ? void 0 : i.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > s.start - s.fragment.duration)
            return !0;
        }
      }
    }
    return !1;
  }
  getCurrentContext(e) {
    const {
      levels: n,
      fragCurrent: r
    } = this, {
      level: i,
      sn: s,
      part: a
    } = e;
    if (!(n != null && n[i]))
      return this.warn(`Levels object was unset while buffering fragment ${s} of ${this.playlistLabel()} ${i}. The current chunk will not be buffered.`), null;
    const o = n[i], u = o.details, l = a > -1 ? H0(u, s, a) : null, c = l ? l.fragment : Db(u, s, r);
    return c ? (r && r !== c && (c.stats = r.stats), {
      frag: c,
      part: l,
      level: o
    }) : null;
  }
  bufferFragmentData(e, n, r, i, s) {
    if (this.state !== Y.PARSING)
      return;
    const {
      data1: a,
      data2: o
    } = e;
    let u = a;
    if (o && (u = an(a, o)), !u.length)
      return;
    const l = this.initPTS[n.cc], c = l ? -l.baseTime / l.timescale : void 0, d = {
      type: e.type,
      frag: n,
      part: r,
      chunkMeta: i,
      offset: c,
      parent: n.type,
      data: u
    };
    if (this.hls.trigger(x.BUFFER_APPENDING, d), e.dropped && e.independent && !r) {
      if (s)
        return;
      this.flushBufferGap(n);
    }
  }
  flushBufferGap(e) {
    const n = this.media;
    if (!n)
      return;
    if (!ye.isBuffered(n, n.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const r = n.currentTime, i = ye.bufferInfo(n, r, 0), s = e.duration, a = Math.min(this.config.maxFragLookUpTolerance * 2, s * 0.25), o = Math.max(Math.min(e.start - a, i.end - a), r + a);
    e.start - o > a && this.flushMainBuffer(o, e.start);
  }
  getFwdBufferInfo(e, n) {
    var r;
    const i = this.getLoadPosition();
    if (!ue(i))
      return null;
    const a = this.lastCurrentTime > i || (r = this.media) != null && r.paused ? 0 : this.config.maxBufferHole;
    return this.getFwdBufferInfoAtPos(e, i, n, a);
  }
  getFwdBufferInfoAtPos(e, n, r, i) {
    const s = ye.bufferInfo(e, n, i);
    if (s.len === 0 && s.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(n, r);
      if (a && (s.nextStart <= a.end || a.gap)) {
        const o = Math.max(Math.min(s.nextStart, a.end) - n, i);
        return ye.bufferInfo(e, n, o);
      }
    }
    return s;
  }
  getMaxBufferLength(e) {
    const {
      config: n
    } = this;
    let r;
    return e ? r = Math.max(8 * n.maxBufferSize / e, n.maxBufferLength) : r = n.maxBufferLength, Math.min(r, n.maxMaxBufferLength);
  }
  reduceMaxBufferLength(e, n) {
    const r = this.config, i = Math.max(Math.min(e - n, r.maxBufferLength), n), s = Math.max(e - n * 3, r.maxMaxBufferLength / 2, i);
    return s >= i ? (r.maxMaxBufferLength = s, this.warn(`Reduce max buffer length to ${s}s`), !0) : !1;
  }
  getAppendedFrag(e, n = le.MAIN) {
    const r = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, n) : null;
    return r && "fragment" in r ? r.fragment : r;
  }
  getNextFragment(e, n) {
    const r = n.fragments, i = r.length;
    if (!i)
      return null;
    const {
      config: s
    } = this, a = r[0].start, o = s.lowLatencyMode && !!n.partList;
    let u = null;
    if (n.live) {
      const d = s.initialLiveManifestSize;
      if (i < d)
        return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${d})`), null;
      if (!n.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) {
        var l;
        o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), u = this.getInitialLiveFragment(n);
        const f = this.hls.startPosition, h = this.hls.liveSyncPosition, m = u ? (f !== -1 && f >= a ? f : h) || u.start : e;
        this.log(`Setting startPosition to ${m} to match start frag at live edge. mainStart: ${f} liveSyncPosition: ${h} frag.start: ${(l = u) == null ? void 0 : l.start}`), this.startPosition = this.nextLoadPosition = m;
      }
    } else e <= a && (u = r[0]);
    if (!u) {
      const d = this.loadingParts ? n.partEnd : n.fragmentEnd;
      u = this.getFragmentAtPosition(e, d, n);
    }
    let c = this.filterReplacedPrimary(u, n);
    if (!c && u) {
      const d = u.sn - n.startSN;
      c = this.filterReplacedPrimary(r[d + 1] || null, n);
    }
    return this.mapToInitFragWhenRequired(c);
  }
  isLoopLoading(e, n) {
    const r = this.fragmentTracker.getState(e);
    return (r === ft.OK || r === ft.PARTIAL && !!e.gap) && this.nextLoadPosition > n;
  }
  getNextFragmentLoopLoading(e, n, r, i, s) {
    let a = null;
    if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, n), a && !a.gap && r.nextStart)) {
      const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, i, 0);
      if (o !== null && r.len + o.len >= s) {
        const u = a.sn;
        return this.loopSn !== u && (this.log(`buffer full after gaps in "${i}" playlist starting at sn: ${u}`), this.loopSn = u), null;
      }
    }
    return this.loopSn = void 0, a;
  }
  get primaryPrefetch() {
    if (z0(this.config)) {
      var e;
      if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event)
        return !0;
    }
    return !1;
  }
  filterReplacedPrimary(e, n) {
    if (!e)
      return e;
    if (z0(this.config) && e.type !== le.SUBTITLE) {
      const r = this.hls.interstitialsManager, i = r == null ? void 0 : r.bufferingItem;
      if (i) {
        const a = i.event;
        if (a) {
          if (a.appendInPlace || Math.abs(e.start - i.start) > 1 || i.start === 0)
            return null;
        } else if (e.end <= i.start && (n == null ? void 0 : n.live) === !1 || e.start > i.end && i.nextEvent && (i.nextEvent.appendInPlace || e.start - i.end > 1))
          return null;
      }
      const s = r == null ? void 0 : r.playerQueue;
      if (s)
        for (let a = s.length; a--; ) {
          const o = s[a].interstitial;
          if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime)
            return null;
        }
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e;
  }
  getNextPart(e, n, r) {
    let i = -1, s = !1, a = !0;
    for (let o = 0, u = e.length; o < u; o++) {
      const l = e[o];
      if (a = a && !l.independent, i > -1 && r < l.start)
        break;
      const c = l.loaded;
      c ? i = -1 : (s || (l.independent || a) && l.fragment === n) && (l.fragment !== n && this.warn(`Need buffer at ${r} but next unloaded part starts at ${l.start}`), i = o), s = c;
    }
    return i;
  }
  loadedEndOfParts(e, n) {
    let r;
    for (let i = e.length; i--; ) {
      if (r = e[i], !r.loaded)
        return !1;
      if (n > r.start)
        return !0;
    }
    return !1;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(e) {
    const n = e.fragments, r = this.fragPrevious;
    let i = null;
    if (r) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), i = lL(n, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {
        const s = r.sn + 1;
        if (s >= e.startSN && s <= e.endSN) {
          const a = n[s - e.startSN];
          r.cc === a.cc && (i = a, this.log(`Live playlist, switching playlist, load frag with next SN: ${i.sn}`));
        }
        i || (i = Eb(e, r.cc, r.end), i && this.log(`Live playlist, switching playlist, load frag with same CC: ${i.sn}`));
      }
    } else {
      const s = this.hls.liveSyncPosition;
      s !== null && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e));
    }
    return i;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(e, n, r) {
    const {
      config: i
    } = this;
    let {
      fragPrevious: s
    } = this, {
      fragments: a,
      endSN: o
    } = r;
    const {
      fragmentHint: u
    } = r, {
      maxFragLookUpTolerance: l
    } = i, c = r.partList, d = !!(this.loadingParts && c != null && c.length && u);
    d && !this.bitrateTest && c[c.length - 1].fragment.sn === u.sn && (a = a.concat(u), o = u.sn);
    let f;
    if (e < n) {
      var h;
      const p = e < this.lastCurrentTime || e > n - l || (h = this.media) != null && h.paused || !this.startFragRequested ? 0 : l;
      f = Yr(s, a, e, p);
    } else
      f = a[a.length - 1];
    if (f) {
      const m = f.sn - r.startSN, p = this.fragmentTracker.getState(f);
      if ((p === ft.OK || p === ft.PARTIAL && f.gap) && (s = f), s && f.sn === s.sn && (!d || c[0].fragment.sn > f.sn || !r.live) && f.level === s.level) {
        const E = a[m + 1];
        f.sn < o && this.fragmentTracker.getState(E) !== ft.OK ? f = E : f = null;
      }
    }
    return f;
  }
  alignPlaylists(e, n, r) {
    const i = e.fragments.length;
    if (!i)
      return this.warn("No fragments in live playlist"), 0;
    const s = e.fragmentStart, a = !n, o = e.alignedSliding && ue(s);
    if (a || !o && !s) {
      jL(r, e);
      const u = e.fragmentStart;
      return this.log(`Live playlist sliding: ${u.toFixed(2)} start-sn: ${n ? n.startSN : "na"}->${e.startSN} fragments: ${i}`), u;
    }
    return s;
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
  }
  setStartPosition(e, n) {
    let r = this.startPosition;
    r < n && (r = -1);
    const i = this.timelineOffset;
    if (r === -1) {
      const s = this.startTimeOffset !== null, a = s ? this.startTimeOffset : e.startTimeOffset;
      a !== null && ue(a) ? (r = n + a, a < 0 && (r += e.edge), r = Math.min(Math.max(n, r), n + e.totalduration), this.log(`Setting startPosition to ${r} for start time offset ${a} found in ${s ? "multivariant" : "media"} playlist`), this.startPosition = r) : e.live ? (r = this.hls.liveSyncPosition || n, this.log(`Setting startPosition to -1 to start at live edge ${r}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = r = 0), this.lastCurrentTime = r + i;
    }
    this.nextLoadPosition = r + i;
  }
  getLoadPosition() {
    var e;
    const {
      media: n
    } = this;
    let r = 0;
    return (e = this.hls) != null && e.hasEnoughToStart && n ? r = n.currentTime : this.nextLoadPosition >= 0 && (r = this.nextLoadPosition), r;
  }
  handleFragLoadAborted(e, n) {
    this.transmuxer && e.type === this.playlistType && ct(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${n ? " part " + n.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== Y.FRAG_LOADING_WAITING_RETRY) && (this.state = Y.IDLE);
  }
  onFragmentOrKeyLoadError(e, n) {
    var r;
    if (n.chunkMeta && !n.frag) {
      const E = this.getCurrentContext(n.chunkMeta);
      E && (n.frag = E.frag);
    }
    const i = n.frag;
    if (!i || i.type !== e || !this.levels)
      return;
    if (this.fragContextChanged(i)) {
      var s;
      this.warn(`Frag load error must match current frag to retry ${i.url} > ${(s = this.fragCurrent) == null ? void 0 : s.url}`);
      return;
    }
    const a = n.details === q.FRAG_GAP;
    a && this.fragmentTracker.fragBuffered(i, !0);
    const o = n.errorAction;
    if (!o) {
      this.state = Y.ERROR;
      return;
    }
    const {
      action: u,
      flags: l,
      retryCount: c = 0,
      retryConfig: d
    } = o, f = !!d, h = f && u === Tt.RetryRequest, m = f && !o.resolved && l === Wt.MoveAllAlternatesMatchingHost, p = (r = this.hls.latestLevelDetails) == null ? void 0 : r.live;
    if (!h && m && ct(i) && !i.endList && p && !Tb(n))
      this.resetFragmentErrors(e), this.treatAsGap(i), o.resolved = !0;
    else if ((h || m) && c < d.maxNumRetry) {
      var g;
      const E = Hc((g = n.response) == null ? void 0 : g.code), y = pf(d, c);
      if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + y, this.state = Y.FRAG_LOADING_WAITING_RETRY, o.resolved = !0, E) {
        this.log("Waiting for connection (offline)"), this.retryDate = 1 / 0, n.reason = "offline";
        return;
      }
      this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${n.details}, retrying loading ${c + 1}/${d.maxNumRetry} in ${y}ms`);
    } else if (d)
      if (this.resetFragmentErrors(e), c < d.maxNumRetry)
        !a && u !== Tt.RemoveAlternatePermanently && (o.resolved = !0);
      else {
        this.warn(`${n.details} reached or exceeded max retry (${c})`);
        return;
      }
    else u === Tt.SendAlternateToPenaltyBox ? this.state = Y.WAITING_LEVEL : this.state = Y.ERROR;
    this.tickImmediate();
  }
  checkRetryDate() {
    const e = self.performance.now(), n = this.retryDate, r = n === 1 / 0;
    (!n || e >= n || r && !Hc(0)) && (r && this.log("Connection restored (online)"), this.resetStartWhenNotLoaded(), this.state = Y.IDLE);
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === Y.PARSING || this.state === Y.PARSED) {
      const n = e.frag, r = e.parent, i = this.getFwdBufferInfo(this.mediaBuffer, r), s = i && i.len > 0.5;
      s && this.reduceMaxBufferLength(i.len, (n == null ? void 0 : n.duration) || 10);
      const a = !s;
      return a && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${r} buffer`), n && (this.fragmentTracker.removeFragment(n), this.nextLoadPosition = n.start), this.resetLoadingState(), a;
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === le.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== Y.STOPPED && (this.state = Y.IDLE);
  }
  afterBufferFlushed(e, n, r) {
    if (!e)
      return;
    const i = ye.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(n, i, r), this.state === Y.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== Y.STOPPED && (this.state = Y.IDLE);
  }
  resetStartWhenNotLoaded() {
    if (!this.hls.hasEnoughToStart) {
      this.startFragRequested = !1;
      const e = this.levelLastLoaded, n = e ? e.details : null;
      n != null && n.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(n, n.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
    }
  }
  resetWhenMissingContext(e) {
    this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
  }
  updateLevelTiming(e, n, r, i) {
    const s = r.details;
    if (!s) {
      this.warn("level.details undefined");
      return;
    }
    if (!Object.keys(e.elementaryStreams).reduce((u, l) => {
      const c = e.elementaryStreams[l];
      if (c) {
        const d = c.endPTS - c.startPTS;
        if (d <= 0)
          return this.warn(`Could not parse fragment ${e.sn} ${l} duration reliably (${d})`), u || !1;
        const f = i ? 0 : Rb(s, e, c.startPTS, c.endPTS, c.startDTS, c.endDTS, this);
        return this.hls.trigger(x.LEVEL_PTS_UPDATED, {
          details: s,
          level: r,
          drift: f,
          type: l,
          frag: e,
          start: c.startPTS,
          end: c.endPTS
        }), !0;
      }
      return u;
    }, !1)) {
      var o;
      if (r.fragmentError === 0 && this.treatAsGap(e, r), ((o = this.transmuxer) == null ? void 0 : o.error) === null) {
        const u = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
        if (this.warn(u.message), this.hls.trigger(x.ERROR, {
          type: de.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          error: u,
          frag: e,
          reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${r.url}"`
        }), !this.hls)
          return;
        this.resetTransmuxer();
      }
    }
    this.state = Y.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${n ? " part: " + n.index : ""} of ${this.fragInfo(e, !1, n)})`), this.hls.trigger(x.FRAG_PARSED, {
      frag: e,
      part: n
    });
  }
  playlistLabel() {
    return this.playlistType === le.MAIN ? "level" : "track";
  }
  fragInfo(e, n = !0, r) {
    var i, s;
    return `${this.playlistLabel()} ${e.level} (${r ? "part" : "frag"}:[${((i = n && !r ? e.startPTS : (r || e).start) != null ? i : NaN).toFixed(3)}-${((s = n && !r ? e.endPTS : (r || e).end) != null ? s : NaN).toFixed(3)}]${r && e.type === "main" ? "INDEPENDENT=" + (r.independent ? "YES" : "NO") : ""}`;
  }
  treatAsGap(e, n) {
    n && n.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);
  }
  resetTransmuxer() {
    var e;
    (e = this.transmuxer) == null || e.reset();
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState());
  }
  set state(e) {
    const n = this._state;
    n !== e && (this._state = e, this.log(`${n}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function z0(t) {
  return !!t.interstitialsController && t.enableInterstitialPlayback !== !1;
}
class Fb {
  constructor() {
    this.chunks = [], this.dataLength = 0;
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length;
  }
  flush() {
    const {
      chunks: e,
      dataLength: n
    } = this;
    let r;
    if (e.length)
      e.length === 1 ? r = e[0] : r = WL(e, n);
    else return new Uint8Array(0);
    return this.reset(), r;
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0;
  }
}
function WL(t, e) {
  const n = new Uint8Array(e);
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    n.set(s, r), r += s.length;
  }
  return n;
}
var xl = { exports: {} }, q0;
function YL() {
  return q0 || (q0 = 1, function(t) {
    var e = Object.prototype.hasOwnProperty, n = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
    function i(u, l, c) {
      this.fn = u, this.context = l, this.once = c || !1;
    }
    function s(u, l, c, d, f) {
      if (typeof c != "function")
        throw new TypeError("The listener must be a function");
      var h = new i(c, d || u, f), m = n ? n + l : l;
      return u._events[m] ? u._events[m].fn ? u._events[m] = [u._events[m], h] : u._events[m].push(h) : (u._events[m] = h, u._eventsCount++), u;
    }
    function a(u, l) {
      --u._eventsCount === 0 ? u._events = new r() : delete u._events[l];
    }
    function o() {
      this._events = new r(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var l = [], c, d;
      if (this._eventsCount === 0) return l;
      for (d in c = this._events)
        e.call(c, d) && l.push(n ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l;
    }, o.prototype.listeners = function(l) {
      var c = n ? n + l : l, d = this._events[c];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, m = new Array(h); f < h; f++)
        m[f] = d[f].fn;
      return m;
    }, o.prototype.listenerCount = function(l) {
      var c = n ? n + l : l, d = this._events[c];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(l, c, d, f, h, m) {
      var p = n ? n + l : l;
      if (!this._events[p]) return !1;
      var g = this._events[p], E = arguments.length, y, T;
      if (g.fn) {
        switch (g.once && this.removeListener(l, g.fn, void 0, !0), E) {
          case 1:
            return g.fn.call(g.context), !0;
          case 2:
            return g.fn.call(g.context, c), !0;
          case 3:
            return g.fn.call(g.context, c, d), !0;
          case 4:
            return g.fn.call(g.context, c, d, f), !0;
          case 5:
            return g.fn.call(g.context, c, d, f, h), !0;
          case 6:
            return g.fn.call(g.context, c, d, f, h, m), !0;
        }
        for (T = 1, y = new Array(E - 1); T < E; T++)
          y[T - 1] = arguments[T];
        g.fn.apply(g.context, y);
      } else {
        var S = g.length, v;
        for (T = 0; T < S; T++)
          switch (g[T].once && this.removeListener(l, g[T].fn, void 0, !0), E) {
            case 1:
              g[T].fn.call(g[T].context);
              break;
            case 2:
              g[T].fn.call(g[T].context, c);
              break;
            case 3:
              g[T].fn.call(g[T].context, c, d);
              break;
            case 4:
              g[T].fn.call(g[T].context, c, d, f);
              break;
            default:
              if (!y) for (v = 1, y = new Array(E - 1); v < E; v++)
                y[v - 1] = arguments[v];
              g[T].fn.apply(g[T].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(l, c, d) {
      return s(this, l, c, d, !1);
    }, o.prototype.once = function(l, c, d) {
      return s(this, l, c, d, !0);
    }, o.prototype.removeListener = function(l, c, d, f) {
      var h = n ? n + l : l;
      if (!this._events[h]) return this;
      if (!c)
        return a(this, h), this;
      var m = this._events[h];
      if (m.fn)
        m.fn === c && (!f || m.once) && (!d || m.context === d) && a(this, h);
      else {
        for (var p = 0, g = [], E = m.length; p < E; p++)
          (m[p].fn !== c || f && !m[p].once || d && m[p].context !== d) && g.push(m[p]);
        g.length ? this._events[h] = g.length === 1 ? g[0] : g : a(this, h);
      }
      return this;
    }, o.prototype.removeAllListeners = function(l) {
      var c;
      return l ? (c = n ? n + l : l, this._events[c] && a(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, t.exports = o;
  }(xl)), xl.exports;
}
var XL = YL(), xf = /* @__PURE__ */ xC(XL);
const ra = "1.6.13", qi = {};
function QL() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function ZL() {
  const t = qi[ra];
  if (t)
    return t.clientCount++, t;
  const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  }), n = self.URL.createObjectURL(e), i = {
    worker: new self.Worker(n),
    objectURL: n,
    clientCount: 1
  };
  return qi[ra] = i, i;
}
function JL(t) {
  const e = qi[t];
  if (e)
    return e.clientCount++, e;
  const n = new self.URL(t, self.location.href).href, i = {
    worker: new self.Worker(n),
    scriptURL: n,
    clientCount: 1
  };
  return qi[t] = i, i;
}
function e_(t) {
  const e = qi[t || ra];
  if (e && e.clientCount-- === 1) {
    const {
      worker: r,
      objectURL: i
    } = e;
    delete qi[t || ra], i && self.URL.revokeObjectURL(i), r.terminate();
  }
}
function Bb(t, e) {
  return e + 10 <= t.length && t[e] === 51 && t[e + 1] === 68 && t[e + 2] === 73 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;
}
function Sf(t, e) {
  return e + 10 <= t.length && t[e] === 73 && t[e + 1] === 68 && t[e + 2] === 51 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;
}
function Uu(t, e) {
  let n = 0;
  return n = (t[e] & 127) << 21, n |= (t[e + 1] & 127) << 14, n |= (t[e + 2] & 127) << 7, n |= t[e + 3] & 127, n;
}
function ia(t, e) {
  const n = e;
  let r = 0;
  for (; Sf(t, e); ) {
    r += 10;
    const i = Uu(t, e + 6);
    r += i, Bb(t, e + 10) && (r += 10), e += r;
  }
  if (r > 0)
    return t.subarray(n, n + r);
}
function t_(t, e, n, r) {
  const i = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], s = e[n + 2], a = s >> 2 & 15;
  if (a > 12) {
    const h = new Error(`invalid ADTS sampling index:${a}`);
    t.emit(x.ERROR, x.ERROR, {
      type: de.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      fatal: !0,
      error: h,
      reason: h.message
    });
    return;
  }
  const o = (s >> 6 & 3) + 1, u = e[n + 3] >> 6 & 3 | (s & 1) << 2, l = "mp4a.40." + o, c = i[a];
  let d = a;
  (o === 5 || o === 29) && (d -= 3);
  const f = [o << 3 | (d & 14) >> 1, (d & 1) << 7 | u << 3];
  return Be.log(`manifest codec:${r}, parsed codec:${l}, channels:${u}, rate:${c} (ADTS object type:${o} sampling index:${a})`), {
    config: f,
    samplerate: c,
    channelCount: u,
    codec: l,
    parsedCodec: l,
    manifestCodec: r
  };
}
function Ub(t, e) {
  return t[e] === 255 && (t[e + 1] & 246) === 240;
}
function $b(t, e) {
  return t[e + 1] & 1 ? 7 : 9;
}
function Af(t, e) {
  return (t[e + 3] & 3) << 11 | t[e + 4] << 3 | (t[e + 5] & 224) >>> 5;
}
function n_(t, e) {
  return e + 5 < t.length;
}
function fu(t, e) {
  return e + 1 < t.length && Ub(t, e);
}
function r_(t, e) {
  return n_(t, e) && Ub(t, e) && Af(t, e) <= t.length - e;
}
function i_(t, e) {
  if (fu(t, e)) {
    const n = $b(t, e);
    if (e + n >= t.length)
      return !1;
    const r = Af(t, e);
    if (r <= n)
      return !1;
    const i = e + r;
    return i === t.length || fu(t, i);
  }
  return !1;
}
function Hb(t, e, n, r, i) {
  if (!t.samplerate) {
    const s = t_(e, n, r, i);
    if (!s)
      return;
    Ge(t, s);
  }
}
function Gb(t) {
  return 1024 * 9e4 / t;
}
function s_(t, e) {
  const n = $b(t, e);
  if (e + n <= t.length) {
    const r = Af(t, e) - n;
    if (r > 0)
      return {
        headerLength: n,
        frameLength: r
      };
  }
}
function Vb(t, e, n, r, i) {
  const s = Gb(t.samplerate), a = r + i * s, o = s_(e, n);
  let u;
  if (o) {
    const {
      frameLength: d,
      headerLength: f
    } = o, h = f + d, m = Math.max(0, n + h - e.length);
    m ? (u = new Uint8Array(h - f), u.set(e.subarray(n + f, e.length), 0)) : u = e.subarray(n + f, n + h);
    const p = {
      unit: u,
      pts: a
    };
    return m || t.samples.push(p), {
      sample: p,
      length: h,
      missing: m
    };
  }
  const l = e.length - n;
  return u = new Uint8Array(l), u.set(e.subarray(n, e.length), 0), {
    sample: {
      unit: u,
      pts: a
    },
    length: l,
    missing: -1
  };
}
function a_(t, e) {
  return Sf(t, e) && Uu(t, e + 6) + 10 <= t.length - e;
}
function o_(t) {
  return t instanceof ArrayBuffer ? t : t.byteOffset == 0 && t.byteLength == t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
}
function Sl(t, e = 0, n = 1 / 0) {
  return u_(t, e, n, Uint8Array);
}
function u_(t, e, n, r) {
  const i = l_(t);
  let s = 1;
  "BYTES_PER_ELEMENT" in r && (s = r.BYTES_PER_ELEMENT);
  const a = c_(t) ? t.byteOffset : 0, o = (a + t.byteLength) / s, u = (a + e) / s, l = Math.floor(Math.max(0, Math.min(u, o))), c = Math.floor(Math.min(l + Math.max(n, 0), o));
  return new r(i, l, c - l);
}
function l_(t) {
  return t instanceof ArrayBuffer ? t : t.buffer;
}
function c_(t) {
  return t && t.buffer instanceof ArrayBuffer && t.byteLength !== void 0 && t.byteOffset !== void 0;
}
function d_(t) {
  const e = {
    key: t.type,
    description: "",
    data: "",
    mimeType: null,
    pictureType: null
  }, n = 3;
  if (t.size < 2)
    return;
  if (t.data[0] !== n) {
    console.log("Ignore frame with unrecognized character encoding");
    return;
  }
  const r = t.data.subarray(1).indexOf(0);
  if (r === -1)
    return;
  const i = Zt(Sl(t.data, 1, r)), s = t.data[2 + r], a = t.data.subarray(3 + r).indexOf(0);
  if (a === -1)
    return;
  const o = Zt(Sl(t.data, 3 + r, a));
  let u;
  return i === "-->" ? u = Zt(Sl(t.data, 4 + r + a)) : u = o_(t.data.subarray(4 + r + a)), e.mimeType = i, e.pictureType = s, e.description = o, e.data = u, e;
}
function f_(t) {
  if (t.size < 2)
    return;
  const e = Zt(t.data, !0), n = new Uint8Array(t.data.subarray(e.length + 1));
  return {
    key: t.type,
    info: e,
    data: n.buffer
  };
}
function h_(t) {
  if (t.size < 2)
    return;
  if (t.type === "TXXX") {
    let n = 1;
    const r = Zt(t.data.subarray(n), !0);
    n += r.length + 1;
    const i = Zt(t.data.subarray(n));
    return {
      key: t.type,
      info: r,
      data: i
    };
  }
  const e = Zt(t.data.subarray(1));
  return {
    key: t.type,
    info: "",
    data: e
  };
}
function m_(t) {
  if (t.type === "WXXX") {
    if (t.size < 2)
      return;
    let n = 1;
    const r = Zt(t.data.subarray(n), !0);
    n += r.length + 1;
    const i = Zt(t.data.subarray(n));
    return {
      key: t.type,
      info: r,
      data: i
    };
  }
  const e = Zt(t.data);
  return {
    key: t.type,
    info: "",
    data: e
  };
}
function p_(t) {
  return t.type === "PRIV" ? f_(t) : t.type[0] === "W" ? m_(t) : t.type === "APIC" ? d_(t) : h_(t);
}
function g_(t) {
  const e = String.fromCharCode(t[0], t[1], t[2], t[3]), n = Uu(t, 4), r = 10;
  return {
    type: e,
    size: n,
    data: t.subarray(r, r + n)
  };
}
const Za = 10, b_ = 10;
function zb(t) {
  let e = 0;
  const n = [];
  for (; Sf(t, e); ) {
    const r = Uu(t, e + 6);
    t[e + 5] >> 6 & 1 && (e += Za), e += Za;
    const i = e + r;
    for (; e + b_ < i; ) {
      const s = g_(t.subarray(e)), a = p_(s);
      a && n.push(a), e += s.size + Za;
    }
    Bb(t, e) && (e += Za);
  }
  return n;
}
function qb(t) {
  return t && t.key === "PRIV" && t.info === "com.apple.streaming.transportStreamTimestamp";
}
function E_(t) {
  if (t.data.byteLength === 8) {
    const e = new Uint8Array(t.data), n = e[3] & 1;
    let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return r /= 45, n && (r += 4772185884e-2), Math.round(r);
  }
}
function vf(t) {
  const e = zb(t);
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (qb(r))
      return E_(r);
  }
}
let Xt = /* @__PURE__ */ function(t) {
  return t.audioId3 = "org.id3", t.dateRange = "com.apple.quicktime.HLS", t.emsg = "https://aomedia.org/emsg/ID3", t.misbklv = "urn:misb:KLV:bin:1910.1", t;
}({});
function vn(t = "", e = 9e4) {
  return {
    type: t,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
class If {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
  }
  resetInitSegment(e, n, r, i) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
  }
  canParse(e, n) {
    return !1;
  }
  appendFrame(e, n, r) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(e, n) {
    this.cachedData && (e = an(this.cachedData, e), this.cachedData = null);
    let r = ia(e, 0), i = r ? r.length : 0, s;
    const a = this._audioTrack, o = this._id3Track, u = r ? vf(r) : void 0, l = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && ue(u)) && (this.basePTS = y_(u, n, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && o.samples.push({
      pts: this.lastPTS,
      dts: this.lastPTS,
      data: r,
      type: Xt.audioId3,
      duration: Number.POSITIVE_INFINITY
    }); i < l; ) {
      if (this.canParse(e, i)) {
        const c = this.appendFrame(a, e, i);
        c ? (this.frameIndex++, this.lastPTS = c.sample.pts, i += c.length, s = i) : i = l;
      } else a_(e, i) ? (r = ia(e, i), o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: r,
        type: Xt.audioId3,
        duration: Number.POSITIVE_INFINITY
      }), i += r.length, s = i) : i++;
      if (i === l && s !== l) {
        const c = e.slice(s);
        this.cachedData ? this.cachedData = an(this.cachedData, c) : this.cachedData = c;
      }
    }
    return {
      audioTrack: a,
      videoTrack: vn(),
      id3Track: o,
      textTrack: vn()
    };
  }
  demuxSampleAes(e, n, r) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(e) {
    const n = this.cachedData;
    return n && (this.cachedData = null, this.demux(n, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: vn(),
      id3Track: this._id3Track,
      textTrack: vn()
    };
  }
  destroy() {
    this.cachedData = null, this._audioTrack = this._id3Track = void 0;
  }
}
const y_ = (t, e, n) => {
  if (ue(t))
    return t * 90;
  const r = n ? n.baseTime * 9e4 / n.timescale : 0;
  return e * 9e4 + r;
};
let Ja = null;
const T_ = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], x_ = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], S_ = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
], A_ = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function jb(t, e, n, r, i) {
  if (n + 24 > e.length)
    return;
  const s = Kb(e, n);
  if (s && n + s.frameLength <= e.length) {
    const a = s.samplesPerFrame * 9e4 / s.sampleRate, o = r + i * a, u = {
      unit: e.subarray(n, n + s.frameLength),
      pts: o,
      dts: o
    };
    return t.config = [], t.channelCount = s.channelCount, t.samplerate = s.sampleRate, t.samples.push(u), {
      sample: u,
      length: s.frameLength,
      missing: 0
    };
  }
}
function Kb(t, e) {
  const n = t[e + 1] >> 3 & 3, r = t[e + 1] >> 1 & 3, i = t[e + 2] >> 4 & 15, s = t[e + 2] >> 2 & 3;
  if (n !== 1 && i !== 0 && i !== 15 && s !== 3) {
    const a = t[e + 2] >> 1 & 1, o = t[e + 3] >> 6, u = n === 3 ? 3 - r : r === 3 ? 3 : 4, l = T_[u * 14 + i - 1] * 1e3, d = x_[(n === 3 ? 0 : n === 2 ? 1 : 2) * 3 + s], f = o === 3 ? 1 : 2, h = S_[n][r], m = A_[r], p = h * 8 * m, g = Math.floor(h * l / d + a) * m;
    if (Ja === null) {
      const T = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      Ja = T ? parseInt(T[1]) : 0;
    }
    return !!Ja && Ja <= 87 && r === 2 && l >= 224e3 && o === 0 && (t[e + 3] = t[e + 3] | 128), {
      sampleRate: d,
      channelCount: f,
      frameLength: g,
      samplesPerFrame: p
    };
  }
}
function Cf(t, e) {
  return t[e] === 255 && (t[e + 1] & 224) === 224 && (t[e + 1] & 6) !== 0;
}
function Wb(t, e) {
  return e + 1 < t.length && Cf(t, e);
}
function v_(t, e) {
  return Cf(t, e) && 4 <= t.length - e;
}
function Yb(t, e) {
  if (e + 1 < t.length && Cf(t, e)) {
    const r = Kb(t, e);
    let i = 4;
    r != null && r.frameLength && (i = r.frameLength);
    const s = e + i;
    return s === t.length || Wb(t, s);
  }
  return !1;
}
class I_ extends If {
  constructor(e, n) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = n;
  }
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(e, n) {
    if (!e)
      return !1;
    const r = ia(e, 0);
    let i = (r == null ? void 0 : r.length) || 0;
    if (Yb(e, i))
      return !1;
    for (let s = e.length; i < s; i++)
      if (i_(e, i))
        return n.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, n) {
    return r_(e, n);
  }
  appendFrame(e, n, r) {
    Hb(e, this.observer, n, r, e.manifestCodec);
    const i = Vb(e, n, r, this.basePTS, this.frameIndex);
    if (i && i.missing === 0)
      return i;
  }
}
const Xb = (t, e) => {
  let n = 0, r = 5;
  e += r;
  const i = new Uint32Array(1), s = new Uint32Array(1), a = new Uint8Array(1);
  for (; r > 0; ) {
    a[0] = t[e];
    const o = Math.min(r, 8), u = 8 - o;
    s[0] = 4278190080 >>> 24 + u << u, i[0] = (a[0] & s[0]) >> u, n = n ? n << o | i[0] : i[0], e += 1, r -= o;
  }
  return n;
};
class C_ extends If {
  constructor(e) {
    super(), this.observer = void 0, this.observer = e;
  }
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/ac-3",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "ac3",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  canParse(e, n) {
    return n + 64 < e.length;
  }
  appendFrame(e, n, r) {
    const i = Qb(e, n, r, this.basePTS, this.frameIndex);
    if (i !== -1)
      return {
        sample: e.samples[e.samples.length - 1],
        length: i,
        missing: 0
      };
  }
  static probe(e) {
    if (!e)
      return !1;
    const n = ia(e, 0);
    if (!n)
      return !1;
    const r = n.length;
    return e[r] === 11 && e[r + 1] === 119 && vf(n) !== void 0 && // check the bsid to confirm ac-3
    Xb(e, r) < 16;
  }
}
function Qb(t, e, n, r, i) {
  if (n + 8 > e.length || e[n] !== 11 || e[n + 1] !== 119)
    return -1;
  const s = e[n + 4] >> 6;
  if (s >= 3)
    return -1;
  const o = [48e3, 44100, 32e3][s], u = e[n + 4] & 63, c = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][u * 3 + s] * 2;
  if (n + c > e.length)
    return -1;
  const d = e[n + 6] >> 5;
  let f = 0;
  d === 2 ? f += 2 : (d & 1 && d !== 1 && (f += 2), d & 4 && (f += 2));
  const h = (e[n + 6] << 8 | e[n + 7]) >> 12 - f & 1, p = [2, 1, 2, 3, 3, 4, 4, 5][d] + h, g = e[n + 5] >> 3, E = e[n + 5] & 7, y = new Uint8Array([s << 6 | g << 1 | E >> 2, (E & 3) << 6 | d << 3 | h << 2 | u >> 4, u << 4 & 224]), T = 1536 / o * 9e4, S = r + i * T, v = e.subarray(n, n + c);
  return t.config = y, t.channelCount = p, t.samplerate = o, t.samples.push({
    unit: v,
    pts: S
  }), c;
}
class L_ extends If {
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(e) {
    if (!e)
      return !1;
    const n = ia(e, 0);
    let r = (n == null ? void 0 : n.length) || 0;
    if (n && e[r] === 11 && e[r + 1] === 119 && vf(n) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
    Xb(e, r) <= 16)
      return !1;
    for (let i = e.length; r < i; r++)
      if (Yb(e, r))
        return Be.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, n) {
    return v_(e, n);
  }
  appendFrame(e, n, r) {
    if (this.basePTS !== null)
      return jb(e, n, r, this.basePTS, this.frameIndex);
  }
}
const __ = /\/emsg[-/]ID3/i;
class R_ {
  constructor(e, n) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = n;
  }
  resetTimeStamp() {
  }
  resetInitSegment(e, n, r, i) {
    const s = this.videoTrack = vn("video", 1), a = this.audioTrack = vn("audio", 1), o = this.txtTrack = vn("text", 1);
    if (this.id3Track = vn("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength))
      return;
    const u = ob(e);
    if (u.video) {
      const {
        id: l,
        timescale: c,
        codec: d,
        supplemental: f
      } = u.video;
      s.id = l, s.timescale = o.timescale = c, s.codec = d, s.supplemental = f;
    }
    if (u.audio) {
      const {
        id: l,
        timescale: c,
        codec: d
      } = u.audio;
      a.id = l, a.timescale = c, a.codec = d;
    }
    o.id = ib.text, s.sampleDuration = 0, s.duration = a.duration = i;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return CC(e);
  }
  demux(e, n) {
    this.timeOffset = n;
    let r = e;
    const i = this.videoTrack, s = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (r = an(this.remainderData, e));
      const o = PC(r);
      this.remainderData = o.remainder, i.samples = o.valid || new Uint8Array();
    } else
      i.samples = r;
    const a = this.extractID3Track(i, n);
    return s.samples = l0(n, i), {
      videoTrack: i,
      audioTrack: this.audioTrack,
      id3Track: a,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const e = this.timeOffset, n = this.videoTrack, r = this.txtTrack;
    n.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
    const i = this.extractID3Track(n, this.timeOffset);
    return r.samples = l0(e, n), {
      videoTrack: n,
      audioTrack: vn(),
      id3Track: i,
      textTrack: vn()
    };
  }
  extractID3Track(e, n) {
    const r = this.id3Track;
    if (e.samples.length) {
      const i = Ce(e.samples, ["emsg"]);
      i && i.forEach((s) => {
        const a = NC(s);
        if (__.test(a.schemeIdUri)) {
          const o = j0(a, n);
          let u = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
          u <= 1e-3 && (u = Number.POSITIVE_INFINITY);
          const l = a.payload;
          r.samples.push({
            data: l,
            len: l.byteLength,
            dts: o,
            pts: o,
            type: Xt.emsg,
            duration: u
          });
        } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
          const o = j0(a, n);
          r.samples.push({
            data: a.payload,
            len: a.payload.byteLength,
            dts: o,
            pts: o,
            type: Xt.misbklv,
            duration: Number.POSITIVE_INFINITY
          });
        }
      });
    }
    return r;
  }
  demuxSampleAes(e, n, r) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
    this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
  }
}
function j0(t, e) {
  return ue(t.presentationTime) ? t.presentationTime / t.timeScale : e + t.presentationTimeDelta / t.timeScale;
}
class k_ {
  constructor(e, n, r) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new gf(n, {
      removePKCS7Padding: !1
    });
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Ir.cbc);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(e, n, r) {
    const i = e[n].unit;
    if (i.length <= 16)
      return;
    const s = i.subarray(16, i.length - i.length % 16), a = s.buffer.slice(s.byteOffset, s.byteOffset + s.length);
    this.decryptBuffer(a).then((o) => {
      const u = new Uint8Array(o);
      i.set(u, 16), this.decrypter.isSync() || this.decryptAacSamples(e, n + 1, r);
    }).catch(r);
  }
  decryptAacSamples(e, n, r) {
    for (; ; n++) {
      if (n >= e.length) {
        r();
        return;
      }
      if (!(e[n].unit.length < 32) && (this.decryptAacSample(e, n, r), !this.decrypter.isSync()))
        return;
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(e) {
    const n = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(n);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      r.set(e.subarray(s, s + 16), i);
    return r;
  }
  getAvcDecryptedUnit(e, n) {
    const r = new Uint8Array(n);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      e.set(r.subarray(i, i + 16), s);
    return e;
  }
  decryptAvcSample(e, n, r, i, s) {
    const a = cb(s.data), o = this.getAvcEncryptedData(a);
    this.decryptBuffer(o.buffer).then((u) => {
      s.data = this.getAvcDecryptedUnit(a, u), this.decrypter.isSync() || this.decryptAvcSamples(e, n, r + 1, i);
    }).catch(i);
  }
  decryptAvcSamples(e, n, r, i) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; n++, r = 0) {
      if (n >= e.length) {
        i();
        return;
      }
      const s = e[n].units;
      for (; !(r >= s.length); r++) {
        const a = s[r];
        if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, n, r, i, a), !this.decrypter.isSync()))
          return;
      }
    }
  }
}
class Zb {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(e, n, r) {
    return {
      key: e,
      frame: !1,
      pts: n,
      dts: r,
      units: [],
      length: 0
    };
  }
  getLastNalUnit(e) {
    var n;
    let r = this.VideoSample, i;
    if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (n = r) != null && n.units) {
      const s = r.units;
      i = s[s.length - 1];
    }
    return i;
  }
  pushAccessUnit(e, n) {
    if (e.units.length && e.frame) {
      if (e.pts === void 0) {
        const r = n.samples, i = r.length;
        if (i) {
          const s = r[i - 1];
          e.pts = s.pts, e.dts = s.dts;
        } else {
          n.dropped++;
          return;
        }
      }
      n.samples.push(e);
    }
  }
  parseNALu(e, n, r) {
    const i = n.byteLength;
    let s = e.naluState || 0;
    const a = s, o = [];
    let u = 0, l, c, d, f = -1, h = 0;
    for (s === -1 && (f = 0, h = this.getNALuType(n, 0), s = 0, u = 1); u < i; ) {
      if (l = n[u++], !s) {
        s = l ? 0 : 1;
        continue;
      }
      if (s === 1) {
        s = l ? 0 : 2;
        continue;
      }
      if (!l)
        s = 3;
      else if (l === 1) {
        if (c = u - s - 1, f >= 0) {
          const m = {
            data: n.subarray(f, c),
            type: h
          };
          o.push(m);
        } else {
          const m = this.getLastNalUnit(e.samples);
          m && (a && u <= 4 - a && m.state && (m.data = m.data.subarray(0, m.data.byteLength - a)), c > 0 && (m.data = an(m.data, n.subarray(0, c)), m.state = 0));
        }
        u < i ? (d = this.getNALuType(n, u), f = u, h = d, s = 0) : s = -1;
      } else
        s = 0;
    }
    if (f >= 0 && s >= 0) {
      const m = {
        data: n.subarray(f, i),
        type: h,
        state: s
      };
      o.push(m);
    }
    if (o.length === 0) {
      const m = this.getLastNalUnit(e.samples);
      m && (m.data = an(m.data, n));
    }
    return e.naluState = s, o;
  }
}
class Ms {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const e = this.data, n = this.bytesAvailable, r = e.byteLength - n, i = new Uint8Array(4), s = Math.min(4, n);
    if (s === 0)
      throw new Error("no bytes available");
    i.set(e.subarray(r, r + s)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = s * 8, this.bytesAvailable -= s;
  }
  // (count:int):void
  skipBits(e) {
    let n;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, n = e >> 3, e -= n << 3, this.bytesAvailable -= n, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
  }
  // (size:int):uint
  readBits(e) {
    let n = Math.min(this.bitsAvailable, e);
    const r = this.word >>> 32 - n;
    if (e > 32 && Be.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= n, this.bitsAvailable > 0)
      this.word <<= n;
    else if (this.bytesAvailable > 0)
      this.loadWord();
    else
      throw new Error("no bits available");
    return n = e - n, n > 0 && this.bitsAvailable ? r << n | this.readBits(n) : r;
  }
  // ():uint
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if (this.word & 2147483648 >>> e)
        return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  // ():int
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
}
class w_ extends Zb {
  parsePES(e, n, r, i) {
    const s = this.parseNALu(e, r.data, i);
    let a = this.VideoSample, o, u = !1;
    r.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), s.forEach((l) => {
      var c, d;
      switch (l.type) {
        case 1: {
          let p = !1;
          o = !0;
          const g = l.data;
          if (u && g.length > 4) {
            const E = this.readSliceType(g);
            (E === 2 || E === 4 || E === 7 || E === 9) && (p = !0);
          }
          if (p) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.frame = !0, a.key = p;
          break;
        }
        case 5:
          o = !0, (c = a) != null && c.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 6: {
          o = !0, ff(l.data, 1, r.pts, n.samples);
          break;
        }
        case 7: {
          var h, m;
          o = !0, u = !0;
          const p = l.data, g = this.readSPS(p);
          if (!e.sps || e.width !== g.width || e.height !== g.height || ((h = e.pixelRatio) == null ? void 0 : h[0]) !== g.pixelRatio[0] || ((m = e.pixelRatio) == null ? void 0 : m[1]) !== g.pixelRatio[1]) {
            e.width = g.width, e.height = g.height, e.pixelRatio = g.pixelRatio, e.sps = [p];
            const E = p.subarray(1, 4);
            let y = "avc1.";
            for (let T = 0; T < 3; T++) {
              let S = E[T].toString(16);
              S.length < 2 && (S = "0" + S), y += S;
            }
            e.codec = y;
          }
          break;
        }
        case 8:
          o = !0, e.pps = [l.data];
          break;
        case 9:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
          break;
        case 12:
          o = !0;
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  getNALuType(e, n) {
    return e[n] & 31;
  }
  readSliceType(e) {
    const n = new Ms(e);
    return n.readUByte(), n.readUEG(), n.readUEG();
  }
  /**
   * The scaling list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(e, n) {
    let r = 8, i = 8, s;
    for (let a = 0; a < e; a++)
      i !== 0 && (s = n.readEG(), i = (r + s + 256) % 256), r = i === 0 ? r : i;
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS(e) {
    const n = new Ms(e);
    let r = 0, i = 0, s = 0, a = 0, o, u, l;
    const c = n.readUByte.bind(n), d = n.readBits.bind(n), f = n.readUEG.bind(n), h = n.readBoolean.bind(n), m = n.skipBits.bind(n), p = n.skipEG.bind(n), g = n.skipUEG.bind(n), E = this.skipScalingList.bind(this);
    c();
    const y = c();
    if (d(5), m(3), c(), g(), y === 100 || y === 110 || y === 122 || y === 244 || y === 44 || y === 83 || y === 86 || y === 118 || y === 128) {
      const D = f();
      if (D === 3 && m(1), g(), g(), m(1), h())
        for (u = D !== 3 ? 8 : 12, l = 0; l < u; l++)
          h() && (l < 6 ? E(16, n) : E(64, n));
    }
    g();
    const T = f();
    if (T === 0)
      f();
    else if (T === 1)
      for (m(1), p(), p(), o = f(), l = 0; l < o; l++)
        p();
    g(), m(1);
    const S = f(), v = f(), I = d(1);
    I === 0 && m(1), m(1), h() && (r = f(), i = f(), s = f(), a = f());
    let C = [1, 1];
    if (h() && h())
      switch (c()) {
        case 1:
          C = [1, 1];
          break;
        case 2:
          C = [12, 11];
          break;
        case 3:
          C = [10, 11];
          break;
        case 4:
          C = [16, 11];
          break;
        case 5:
          C = [40, 33];
          break;
        case 6:
          C = [24, 11];
          break;
        case 7:
          C = [20, 11];
          break;
        case 8:
          C = [32, 11];
          break;
        case 9:
          C = [80, 33];
          break;
        case 10:
          C = [18, 11];
          break;
        case 11:
          C = [15, 11];
          break;
        case 12:
          C = [64, 33];
          break;
        case 13:
          C = [160, 99];
          break;
        case 14:
          C = [4, 3];
          break;
        case 15:
          C = [3, 2];
          break;
        case 16:
          C = [2, 1];
          break;
        case 255: {
          C = [c() << 8 | c(), c() << 8 | c()];
          break;
        }
      }
    return {
      width: Math.ceil((S + 1) * 16 - r * 2 - i * 2),
      height: (2 - I) * (v + 1) * 16 - (I ? 2 : 4) * (s + a),
      pixelRatio: C
    };
  }
}
class D_ extends Zb {
  constructor(...e) {
    super(...e), this.initVPS = null;
  }
  parsePES(e, n, r, i) {
    const s = this.parseNALu(e, r.data, i);
    let a = this.VideoSample, o, u = !1;
    r.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), s.forEach((l) => {
      var c, d;
      switch (l.type) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), a.frame = !0, o = !0;
          break;
        case 16:
        case 17:
        case 18:
        case 21:
          if (o = !0, u) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 19:
        case 20:
          o = !0, (c = a) != null && c.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 39:
          o = !0, ff(
            l.data,
            2,
            // NALu header size
            r.pts,
            n.samples
          );
          break;
        case 32:
          o = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = Ge(e.params, this.readVPS(l.data)), this.initVPS = l.data), e.vps = [l.data];
          break;
        case 33:
          if (o = !0, u = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], l.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {
            const h = this.readSPS(l.data);
            e.width = h.width, e.height = h.height, e.pixelRatio = h.pixelRatio, e.codec = h.codecString, e.sps = [], typeof e.params != "object" && (e.params = {});
            for (const m in h.params)
              e.params[m] = h.params[m];
          }
          this.pushParameterSet(e.sps, l.data, e.vps), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0;
          break;
        case 34:
          if (o = !0, typeof e.params == "object") {
            if (!e.pps) {
              e.pps = [];
              const h = this.readPPS(l.data);
              for (const m in h)
                e.params[m] = h[m];
            }
            this.pushParameterSet(e.pps, l.data, e.vps);
          }
          break;
        case 35:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  pushParameterSet(e, n, r) {
    (r && r[0] === this.initVPS || !r && !e.length) && e.push(n);
  }
  getNALuType(e, n) {
    return (e[n] & 126) >>> 1;
  }
  ebsp2rbsp(e) {
    const n = new Uint8Array(e.byteLength);
    let r = 0;
    for (let i = 0; i < e.byteLength; i++)
      i >= 2 && e[i] === 3 && e[i - 1] === 0 && e[i - 2] === 0 || (n[r] = e[i], r++);
    return new Uint8Array(n.buffer, 0, r);
  }
  pushAccessUnit(e, n) {
    super.pushAccessUnit(e, n), this.initVPS && (this.initVPS = null);
  }
  readVPS(e) {
    const n = new Ms(e);
    n.readUByte(), n.readUByte(), n.readBits(4), n.skipBits(2), n.readBits(6);
    const r = n.readBits(3), i = n.readBoolean();
    return {
      numTemporalLayers: r + 1,
      temporalIdNested: i
    };
  }
  readSPS(e) {
    const n = new Ms(this.ebsp2rbsp(e));
    n.readUByte(), n.readUByte(), n.readBits(4);
    const r = n.readBits(3);
    n.readBoolean();
    const i = n.readBits(2), s = n.readBoolean(), a = n.readBits(5), o = n.readUByte(), u = n.readUByte(), l = n.readUByte(), c = n.readUByte(), d = n.readUByte(), f = n.readUByte(), h = n.readUByte(), m = n.readUByte(), p = n.readUByte(), g = n.readUByte(), E = n.readUByte(), y = [], T = [];
    for (let we = 0; we < r; we++)
      y.push(n.readBoolean()), T.push(n.readBoolean());
    if (r > 0)
      for (let we = r; we < 8; we++)
        n.readBits(2);
    for (let we = 0; we < r; we++)
      y[we] && (n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte()), T[we] && n.readUByte();
    n.readUEG();
    const S = n.readUEG();
    S == 3 && n.skipBits(1);
    const v = n.readUEG(), I = n.readUEG(), C = n.readBoolean();
    let D = 0, _ = 0, A = 0, L = 0;
    C && (D += n.readUEG(), _ += n.readUEG(), A += n.readUEG(), L += n.readUEG());
    const N = n.readUEG(), U = n.readUEG(), z = n.readUEG(), O = n.readBoolean();
    for (let we = O ? 0 : r; we <= r; we++)
      n.skipUEG(), n.skipUEG(), n.skipUEG();
    if (n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.readBoolean() && n.readBoolean())
      for (let nt = 0; nt < 4; nt++)
        for (let St = 0; St < (nt === 3 ? 2 : 6); St++)
          if (!n.readBoolean())
            n.readUEG();
          else {
            const Rt = Math.min(64, 1 << 4 + (nt << 1));
            nt > 1 && n.readEG();
            for (let fr = 0; fr < Rt; fr++)
              n.readEG();
          }
    n.readBoolean(), n.readBoolean(), n.readBoolean() && (n.readUByte(), n.skipUEG(), n.skipUEG(), n.readBoolean());
    const H = n.readUEG();
    let X = 0;
    for (let we = 0; we < H; we++) {
      let nt = !1;
      if (we !== 0 && (nt = n.readBoolean()), nt) {
        we === H && n.readUEG(), n.readBoolean(), n.readUEG();
        let St = 0;
        for (let It = 0; It <= X; It++) {
          const Rt = n.readBoolean();
          let fr = !1;
          Rt || (fr = n.readBoolean()), (Rt || fr) && St++;
        }
        X = St;
      } else {
        const St = n.readUEG(), It = n.readUEG();
        X = St + It;
        for (let Rt = 0; Rt < St; Rt++)
          n.readUEG(), n.readBoolean();
        for (let Rt = 0; Rt < It; Rt++)
          n.readUEG(), n.readBoolean();
      }
    }
    if (n.readBoolean()) {
      const we = n.readUEG();
      for (let nt = 0; nt < we; nt++) {
        for (let St = 0; St < z + 4; St++)
          n.readBits(1);
        n.readBits(1);
      }
    }
    let Q = 0, J = 1, R = 1, te = !0, he = 1, ae = 0;
    n.readBoolean(), n.readBoolean();
    let me = !1;
    if (n.readBoolean()) {
      if (n.readBoolean()) {
        const jn = n.readUByte(), Oa = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], oi = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
        jn > 0 && jn < 16 ? (J = Oa[jn - 1], R = oi[jn - 1]) : jn === 255 && (J = n.readBits(16), R = n.readBits(16));
      }
      if (n.readBoolean() && n.readBoolean(), n.readBoolean() && (n.readBits(3), n.readBoolean(), n.readBoolean() && (n.readUByte(), n.readUByte(), n.readUByte())), n.readBoolean() && (n.readUEG(), n.readUEG()), n.readBoolean(), n.readBoolean(), n.readBoolean(), me = n.readBoolean(), me && (n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG()), n.readBoolean() && (he = n.readBits(32), ae = n.readBits(32), n.readBoolean() && n.readUEG(), n.readBoolean())) {
        const oi = n.readBoolean(), Na = n.readBoolean();
        let W = !1;
        (oi || Na) && (W = n.readBoolean(), W && (n.readUByte(), n.readBits(5), n.readBoolean(), n.readBits(5)), n.readBits(4), n.readBits(4), W && n.readBits(4), n.readBits(5), n.readBits(5), n.readBits(5));
        for (let oe = 0; oe <= r; oe++) {
          te = n.readBoolean();
          const Ee = te || n.readBoolean();
          let Le = !1;
          Ee ? n.readEG() : Le = n.readBoolean();
          const Me = Le ? 1 : n.readUEG() + 1;
          if (oi)
            for (let Et = 0; Et < Me; Et++)
              n.readUEG(), n.readUEG(), W && (n.readUEG(), n.readUEG()), n.skipBits(1);
          if (Na)
            for (let Et = 0; Et < Me; Et++)
              n.readUEG(), n.readUEG(), W && (n.readUEG(), n.readUEG()), n.skipBits(1);
        }
      }
      n.readBoolean() && (n.readBoolean(), n.readBoolean(), n.readBoolean(), Q = n.readUEG());
    }
    let Pe = v, Oe = I;
    if (C) {
      let we = 1, nt = 1;
      S === 1 ? we = nt = 2 : S == 2 && (we = 2), Pe = v - we * _ - we * D, Oe = I - nt * L - nt * A;
    }
    const bt = i ? ["A", "B", "C"][i] : "", qn = o << 24 | u << 16 | l << 8 | c;
    let Ht = 0;
    for (let we = 0; we < 32; we++)
      Ht = (Ht | (qn >> we & 1) << 31 - we) >>> 0;
    let dr = Ht.toString(16);
    return a === 1 && dr === "2" && (dr = "6"), {
      codecString: `hvc1.${bt}${a}.${dr}.${s ? "H" : "L"}${E}.B0`,
      params: {
        general_tier_flag: s,
        general_profile_idc: a,
        general_profile_space: i,
        general_profile_compatibility_flags: [o, u, l, c],
        general_constraint_indicator_flags: [d, f, h, m, p, g],
        general_level_idc: E,
        bit_depth: N + 8,
        bit_depth_luma_minus8: N,
        bit_depth_chroma_minus8: U,
        min_spatial_segmentation_idc: Q,
        chroma_format_idc: S,
        frame_rate: {
          fixed: te,
          fps: ae / he
        }
      },
      width: Pe,
      height: Oe,
      pixelRatio: [J, R]
    };
  }
  readPPS(e) {
    const n = new Ms(this.ebsp2rbsp(e));
    n.readUByte(), n.readUByte(), n.skipUEG(), n.skipUEG(), n.skipBits(2), n.skipBits(3), n.skipBits(2), n.skipUEG(), n.skipUEG(), n.skipEG(), n.skipBits(2), n.readBoolean() && n.skipUEG(), n.skipEG(), n.skipEG(), n.skipBits(4);
    const i = n.readBoolean(), s = n.readBoolean();
    let a = 1;
    return s && i ? a = 0 : s ? a = 3 : i && (a = 2), {
      parallelismType: a
    };
  }
  matchSPS(e, n) {
    return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, n).substr(3);
  }
}
const mt = 188;
class Tr {
  constructor(e, n, r, i) {
    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = n, this.typeSupported = r, this.logger = i, this.videoParser = null;
  }
  static probe(e, n) {
    const r = Tr.syncOffset(e);
    return r > 0 && n.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1;
  }
  static syncOffset(e) {
    const n = e.length;
    let r = Math.min(mt * 5, n - mt) + 1, i = 0;
    for (; i < r; ) {
      let s = !1, a = -1, o = 0;
      for (let u = i; u < n; u += mt)
        if (e[u] === 71 && (n - u === mt || e[u + mt] === 71)) {
          if (o++, a === -1 && (a = u, a !== 0 && (r = Math.min(a + mt * 99, e.length - mt) + 1)), s || (s = jc(e, u) === 0), s && o > 1 && (a === 0 && o > 2 || u + mt > r))
            return a;
        } else {
          if (o)
            return -1;
          break;
        }
      i++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(e, n) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: ib[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? n : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(e, n, r, i) {
    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Tr.createTrack("video"), this._videoTrack.duration = i, this._audioTrack = Tr.createTrack("audio", i), this._id3Track = Tr.createTrack("id3"), this._txtTrack = Tr.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = n, this.videoCodec = r;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack: e,
      _videoTrack: n,
      _id3Track: r
    } = this;
    e && (e.pesData = null), n && (n.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null;
  }
  demux(e, n, r = !1, i = !1) {
    r || (this.sampleAes = null);
    let s;
    const a = this._videoTrack, o = this._audioTrack, u = this._id3Track, l = this._txtTrack;
    let c = a.pid, d = a.pesData, f = o.pid, h = u.pid, m = o.pesData, p = u.pesData, g = null, E = this.pmtParsed, y = this._pmtId, T = e.length;
    if (this.remainderData && (e = an(this.remainderData, e), T = e.length, this.remainderData = null), T < mt && !i)
      return this.remainderData = e, {
        audioTrack: o,
        videoTrack: a,
        id3Track: u,
        textTrack: l
      };
    const S = Math.max(0, Tr.syncOffset(e));
    T -= (T - S) % mt, T < e.byteLength && !i && (this.remainderData = new Uint8Array(e.buffer, T, e.buffer.byteLength - T));
    let v = 0;
    for (let C = S; C < T; C += mt)
      if (e[C] === 71) {
        const D = !!(e[C + 1] & 64), _ = jc(e, C), A = (e[C + 3] & 48) >> 4;
        let L;
        if (A > 1) {
          if (L = C + 5 + e[C + 4], L === C + mt)
            continue;
        } else
          L = C + 4;
        switch (_) {
          case c:
            D && (d && (s = hi(d, this.logger)) && (this.readyVideoParser(a.segmentCodec), this.videoParser !== null && this.videoParser.parsePES(a, l, s, !1)), d = {
              data: [],
              size: 0
            }), d && (d.data.push(e.subarray(L, C + mt)), d.size += C + mt - L);
            break;
          case f:
            if (D) {
              if (m && (s = hi(m, this.logger)))
                switch (o.segmentCodec) {
                  case "aac":
                    this.parseAACPES(o, s);
                    break;
                  case "mp3":
                    this.parseMPEGPES(o, s);
                    break;
                  case "ac3":
                    this.parseAC3PES(o, s);
                    break;
                }
              m = {
                data: [],
                size: 0
              };
            }
            m && (m.data.push(e.subarray(L, C + mt)), m.size += C + mt - L);
            break;
          case h:
            D && (p && (s = hi(p, this.logger)) && this.parseID3PES(u, s), p = {
              data: [],
              size: 0
            }), p && (p.data.push(e.subarray(L, C + mt)), p.size += C + mt - L);
            break;
          case 0:
            D && (L += e[L] + 1), y = this._pmtId = P_(e, L);
            break;
          case y: {
            D && (L += e[L] + 1);
            const N = O_(e, L, this.typeSupported, r, this.observer, this.logger);
            c = N.videoPid, c > 0 && (a.pid = c, a.segmentCodec = N.segmentVideoCodec), f = N.audioPid, f > 0 && (o.pid = f, o.segmentCodec = N.segmentAudioCodec), h = N.id3Pid, h > 0 && (u.pid = h), g !== null && !E && (this.logger.warn(`MPEG-TS PMT found at ${C} after unknown PID '${g}'. Backtracking to sync byte @${S} to parse all TS packets.`), g = null, C = S - 188), E = this.pmtParsed = !0;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            g = _;
            break;
        }
      } else
        v++;
    v > 0 && Kc(this.observer, new Error(`Found ${v} TS packet/s that do not start with 0x47`), void 0, this.logger), a.pesData = d, o.pesData = m, u.pesData = p;
    const I = {
      audioTrack: o,
      videoTrack: a,
      id3Track: u,
      textTrack: l
    };
    return i && this.extractRemainingSamples(I), I;
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let n;
    return e ? n = this.demux(e, -1, !1, !0) : n = {
      videoTrack: this._videoTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(n), this.sampleAes ? this.decrypt(n, this.sampleAes) : n;
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: n,
      videoTrack: r,
      id3Track: i,
      textTrack: s
    } = e, a = r.pesData, o = n.pesData, u = i.pesData;
    let l;
    if (a && (l = hi(a, this.logger)) ? (this.readyVideoParser(r.segmentCodec), this.videoParser !== null && (this.videoParser.parsePES(r, s, l, !0), r.pesData = null)) : r.pesData = a, o && (l = hi(o, this.logger))) {
      switch (n.segmentCodec) {
        case "aac":
          this.parseAACPES(n, l);
          break;
        case "mp3":
          this.parseMPEGPES(n, l);
          break;
        case "ac3":
          this.parseAC3PES(n, l);
          break;
      }
      n.pesData = null;
    } else
      o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), n.pesData = o;
    u && (l = hi(u, this.logger)) ? (this.parseID3PES(i, l), i.pesData = null) : i.pesData = u;
  }
  demuxSampleAes(e, n, r) {
    const i = this.demux(e, r, !0, !this.config.progressive), s = this.sampleAes = new k_(this.observer, this.config, n);
    return this.decrypt(i, s);
  }
  readyVideoParser(e) {
    this.videoParser === null && (e === "avc" ? this.videoParser = new w_() : e === "hevc" && (this.videoParser = new D_()));
  }
  decrypt(e, n) {
    return new Promise((r) => {
      const {
        audioTrack: i,
        videoTrack: s
      } = e;
      i.samples && i.segmentCodec === "aac" ? n.decryptAacSamples(i.samples, 0, () => {
        s.samples ? n.decryptAvcSamples(s.samples, 0, 0, () => {
          r(e);
        }) : r(e);
      }) : s.samples && n.decryptAvcSamples(s.samples, 0, 0, () => {
        r(e);
      });
    });
  }
  destroy() {
    this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
  }
  parseAACPES(e, n) {
    let r = 0;
    const i = this.aacOverFlow;
    let s = n.data;
    if (i) {
      this.aacOverFlow = null;
      const d = i.missing, f = i.sample.unit.byteLength;
      if (d === -1)
        s = an(i.sample.unit, s);
      else {
        const h = f - d;
        i.sample.unit.set(s.subarray(0, d), h), e.samples.push(i.sample), r = i.missing;
      }
    }
    let a, o;
    for (a = r, o = s.length; a < o - 1 && !fu(s, a); a++)
      ;
    if (a !== r) {
      let d;
      const f = a < o - 1;
      if (f ? d = `AAC PES did not start with ADTS header,offset:${a}` : d = "No ADTS header found in AAC PES", Kc(this.observer, new Error(d), f, this.logger), !f)
        return;
    }
    Hb(e, this.observer, s, a, this.audioCodec);
    let u;
    if (n.pts !== void 0)
      u = n.pts;
    else if (i) {
      const d = Gb(e.samplerate);
      u = i.sample.pts + d;
    } else {
      this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let l = 0, c;
    for (; a < o; )
      if (c = Vb(e, s, a, u, l), a += c.length, c.missing) {
        this.aacOverFlow = c;
        break;
      } else
        for (l++; a < o - 1 && !fu(s, a); a++)
          ;
  }
  parseMPEGPES(e, n) {
    const r = n.data, i = r.length;
    let s = 0, a = 0;
    const o = n.pts;
    if (o === void 0) {
      this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; a < i; )
      if (Wb(r, a)) {
        const u = jb(e, r, a, o, s);
        if (u)
          a += u.length, s++;
        else
          break;
      } else
        a++;
  }
  parseAC3PES(e, n) {
    {
      const r = n.data, i = n.pts;
      if (i === void 0) {
        this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const s = r.length;
      let a = 0, o = 0, u;
      for (; o < s && (u = Qb(e, r, o, i, a++)) > 0; )
        o += u;
    }
  }
  parseID3PES(e, n) {
    if (n.pts === void 0) {
      this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const r = Ge({}, n, {
      type: this._videoTrack ? Xt.emsg : Xt.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(r);
  }
}
function jc(t, e) {
  return ((t[e + 1] & 31) << 8) + t[e + 2];
}
function P_(t, e) {
  return (t[e + 10] & 31) << 8 | t[e + 11];
}
function O_(t, e, n, r, i, s) {
  const a = {
    audioPid: -1,
    videoPid: -1,
    id3Pid: -1,
    segmentVideoCodec: "avc",
    segmentAudioCodec: "aac"
  }, o = (t[e + 1] & 15) << 8 | t[e + 2], u = e + 3 + o - 4, l = (t[e + 10] & 15) << 8 | t[e + 11];
  for (e += 12 + l; e < u; ) {
    const c = jc(t, e), d = (t[e + 3] & 15) << 8 | t[e + 4];
    switch (t[e]) {
      case 207:
        if (!r) {
          Al("ADTS AAC", s);
          break;
        }
      case 15:
        a.audioPid === -1 && (a.audioPid = c);
        break;
      case 21:
        a.id3Pid === -1 && (a.id3Pid = c);
        break;
      case 219:
        if (!r) {
          Al("H.264", s);
          break;
        }
      case 27:
        a.videoPid === -1 && (a.videoPid = c);
        break;
      case 3:
      case 4:
        !n.mpeg && !n.mp3 ? s.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = c, a.segmentAudioCodec = "mp3");
        break;
      case 193:
        if (!r) {
          Al("AC-3", s);
          break;
        }
      case 129:
        n.ac3 ? a.audioPid === -1 && (a.audioPid = c, a.segmentAudioCodec = "ac3") : s.log("AC-3 audio found, not supported in this browser");
        break;
      case 6:
        if (a.audioPid === -1 && d > 0) {
          let f = e + 5, h = d;
          for (; h > 2; ) {
            switch (t[f]) {
              case 106:
                n.ac3 !== !0 ? s.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = c, a.segmentAudioCodec = "ac3");
                break;
            }
            const p = t[f + 1] + 2;
            f += p, h -= p;
          }
        }
        break;
      case 194:
      case 135:
        return Kc(i, new Error("Unsupported EC-3 in M2TS found"), void 0, s), a;
      case 36:
        a.videoPid === -1 && (a.videoPid = c, a.segmentVideoCodec = "hevc", s.log("HEVC in M2TS found"));
        break;
    }
    e += d + 5;
  }
  return a;
}
function Kc(t, e, n, r) {
  r.warn(`parsing error: ${e.message}`), t.emit(x.ERROR, x.ERROR, {
    type: de.MEDIA_ERROR,
    details: q.FRAG_PARSING_ERROR,
    fatal: !1,
    levelRetry: n,
    error: e,
    reason: e.message
  });
}
function Al(t, e) {
  e.log(`${t} with AES-128-CBC encryption found in unencrypted stream`);
}
function hi(t, e) {
  let n = 0, r, i, s, a, o;
  const u = t.data;
  if (!t || t.size === 0)
    return null;
  for (; u[0].length < 19 && u.length > 1; )
    u[0] = an(u[0], u[1]), u.splice(1, 1);
  if (r = u[0], (r[0] << 16) + (r[1] << 8) + r[2] === 1) {
    if (i = (r[4] << 8) + r[5], i && i > t.size - 6)
      return null;
    const c = r[7];
    c & 192 && (a = (r[9] & 14) * 536870912 + // 1 << 29
    (r[10] & 255) * 4194304 + // 1 << 22
    (r[11] & 254) * 16384 + // 1 << 14
    (r[12] & 255) * 128 + // 1 << 7
    (r[13] & 254) / 2, c & 64 ? (o = (r[14] & 14) * 536870912 + // 1 << 29
    (r[15] & 255) * 4194304 + // 1 << 22
    (r[16] & 254) * 16384 + // 1 << 14
    (r[17] & 255) * 128 + // 1 << 7
    (r[18] & 254) / 2, a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`), a = o)) : o = a), s = r[8];
    let d = s + 9;
    if (t.size <= d)
      return null;
    t.size -= d;
    const f = new Uint8Array(t.size);
    for (let h = 0, m = u.length; h < m; h++) {
      r = u[h];
      let p = r.byteLength;
      if (d)
        if (d > p) {
          d -= p;
          continue;
        } else
          r = r.subarray(d), p -= d, d = 0;
      f.set(r, n), n += p;
    }
    return i && (i -= s + 3), {
      data: f,
      pts: a,
      dts: o,
      len: i
    };
  }
  return null;
}
class N_ {
  static getSilentFrame(e, n) {
    switch (e) {
      case "mp4a.40.2":
        if (n === 1)
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (n === 2)
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (n === 3)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (n === 4)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (n === 5)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (n === 6)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      default:
        if (n === 1)
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (n === 2)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (n === 3)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break;
    }
  }
}
const hr = Math.pow(2, 32) - 1;
class G {
  static init() {
    G.types = {
      avc1: [],
      // codingname
      avcC: [],
      hvc1: [],
      hvcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in G.types)
      G.types.hasOwnProperty(e) && (G.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const n = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]), r = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    G.HDLR_TYPES = {
      video: n,
      audio: r
    };
    const i = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]), s = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    G.STTS = G.STSC = G.STCO = s, G.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]), G.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]), G.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]), G.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const a = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), u = new Uint8Array([0, 0, 0, 1]);
    G.FTYP = G.box(G.types.ftyp, a, u, a, o), G.DINF = G.box(G.types.dinf, G.box(G.types.dref, i));
  }
  static box(e, ...n) {
    let r = 8, i = n.length;
    const s = i;
    for (; i--; )
      r += n[i].byteLength;
    const a = new Uint8Array(r);
    for (a[0] = r >> 24 & 255, a[1] = r >> 16 & 255, a[2] = r >> 8 & 255, a[3] = r & 255, a.set(e, 4), i = 0, r = 8; i < s; i++)
      a.set(n[i], r), r += n[i].byteLength;
    return a;
  }
  static hdlr(e) {
    return G.box(G.types.hdlr, G.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return G.box(G.types.mdat, e);
  }
  static mdhd(e, n) {
    n *= e;
    const r = Math.floor(n / (hr + 1)), i = Math.floor(n % (hr + 1));
    return G.box(G.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(e) {
    return G.box(G.types.mdia, G.mdhd(e.timescale || 0, e.duration || 0), G.hdlr(e.type), G.minf(e));
  }
  static mfhd(e) {
    return G.box(G.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      e >> 24,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
      // sequence_number
    ]));
  }
  static minf(e) {
    return e.type === "audio" ? G.box(G.types.minf, G.box(G.types.smhd, G.SMHD), G.DINF, G.stbl(e)) : G.box(G.types.minf, G.box(G.types.vmhd, G.VMHD), G.DINF, G.stbl(e));
  }
  static moof(e, n, r) {
    return G.box(G.types.moof, G.mfhd(e), G.traf(r, n));
  }
  static moov(e) {
    let n = e.length;
    const r = [];
    for (; n--; )
      r[n] = G.trak(e[n]);
    return G.box.apply(null, [G.types.moov, G.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(r).concat(G.mvex(e)));
  }
  static mvex(e) {
    let n = e.length;
    const r = [];
    for (; n--; )
      r[n] = G.trex(e[n]);
    return G.box.apply(null, [G.types.mvex, ...r]);
  }
  static mvhd(e, n) {
    n *= e;
    const r = Math.floor(n / (hr + 1)), i = Math.floor(n % (hr + 1)), s = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return G.box(G.types.mvhd, s);
  }
  static sdtp(e) {
    const n = e.samples || [], r = new Uint8Array(4 + n.length);
    let i, s;
    for (i = 0; i < n.length; i++)
      s = n[i].flags, r[i + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy;
    return G.box(G.types.sdtp, r);
  }
  static stbl(e) {
    return G.box(G.types.stbl, G.stsd(e), G.box(G.types.stts, G.STTS), G.box(G.types.stsc, G.STSC), G.box(G.types.stsz, G.STSZ), G.box(G.types.stco, G.STCO));
  }
  static avc1(e) {
    let n = [], r = [], i, s, a;
    for (i = 0; i < e.sps.length; i++)
      s = e.sps[i], a = s.byteLength, n.push(a >>> 8 & 255), n.push(a & 255), n = n.concat(Array.prototype.slice.call(s));
    for (i = 0; i < e.pps.length; i++)
      s = e.pps[i], a = s.byteLength, r.push(a >>> 8 & 255), r.push(a & 255), r = r.concat(Array.prototype.slice.call(s));
    const o = G.box(G.types.avcC, new Uint8Array([
      1,
      // version
      n[3],
      // profile
      n[4],
      // profile compat
      n[5],
      // level
      255,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | e.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(n).concat([
      e.pps.length
      // numOfPictureParameterSets
    ]).concat(r))), u = e.width, l = e.height, c = e.pixelRatio[0], d = e.pixelRatio[1];
    return G.box(
      G.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        u >> 8 & 255,
        u & 255,
        // width
        l >> 8 & 255,
        l & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      o,
      G.box(G.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      G.box(G.types.pasp, new Uint8Array([
        c >> 24,
        // hSpacing
        c >> 16 & 255,
        c >> 8 & 255,
        c & 255,
        d >> 24,
        // vSpacing
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ]))
    );
  }
  static esds(e) {
    const n = e.config;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      25,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      17,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5,
      // descriptor_type
      2,
      // length
      ...n,
      6,
      1,
      2
      // GASpecificConfig)); // length + audio config descriptor
    ]);
  }
  static audioStsd(e) {
    const n = e.samplerate || 0;
    return new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount || 0,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      n >> 8 & 255,
      n & 255,
      //
      0,
      0
    ]);
  }
  static mp4a(e) {
    return G.box(G.types.mp4a, G.audioStsd(e), G.box(G.types.esds, G.esds(e)));
  }
  static mp3(e) {
    return G.box(G.types[".mp3"], G.audioStsd(e));
  }
  static ac3(e) {
    return G.box(G.types["ac-3"], G.audioStsd(e), G.box(G.types.dac3, e.config));
  }
  static stsd(e) {
    const {
      segmentCodec: n
    } = e;
    if (e.type === "audio") {
      if (n === "aac")
        return G.box(G.types.stsd, G.STSD, G.mp4a(e));
      if (n === "ac3" && e.config)
        return G.box(G.types.stsd, G.STSD, G.ac3(e));
      if (n === "mp3" && e.codec === "mp3")
        return G.box(G.types.stsd, G.STSD, G.mp3(e));
    } else if (e.pps && e.sps) {
      if (n === "avc")
        return G.box(G.types.stsd, G.STSD, G.avc1(e));
      if (n === "hevc" && e.vps)
        return G.box(G.types.stsd, G.STSD, G.hvc1(e));
    } else
      throw new Error("video track missing pps or sps");
    throw new Error(`unsupported ${e.type} segment codec (${n}/${e.codec})`);
  }
  static tkhd(e) {
    const n = e.id, r = (e.duration || 0) * (e.timescale || 0), i = e.width || 0, s = e.height || 0, a = Math.floor(r / (hr + 1)), o = Math.floor(r % (hr + 1));
    return G.box(G.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      n >> 24 & 255,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      a >> 24,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255,
      o >> 24,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      i >> 8 & 255,
      i & 255,
      0,
      0,
      // width
      s >> 8 & 255,
      s & 255,
      0,
      0
      // height
    ]));
  }
  static traf(e, n) {
    const r = G.sdtp(e), i = e.id, s = Math.floor(n / (hr + 1)), a = Math.floor(n % (hr + 1));
    return G.box(
      G.types.traf,
      G.box(G.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        i >> 24,
        i >> 16 & 255,
        i >> 8 & 255,
        i & 255
        // track_ID
      ])),
      G.box(G.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        s >> 24,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        a >> 24,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255
      ])),
      G.trun(e, r.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      r
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(e) {
    return e.duration = e.duration || 4294967295, G.box(G.types.trak, G.tkhd(e), G.mdia(e));
  }
  static trex(e) {
    const n = e.id;
    return G.box(G.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(e, n) {
    const r = e.samples || [], i = r.length, s = 12 + 16 * i, a = new Uint8Array(s);
    let o, u, l, c, d, f;
    for (n += 8 + s, a.set([
      e.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      i >>> 24 & 255,
      i >>> 16 & 255,
      i >>> 8 & 255,
      i & 255,
      // sample_count
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
      // data_offset
    ], 0), o = 0; o < i; o++)
      u = r[o], l = u.duration, c = u.size, d = u.flags, f = u.cts, a.set([
        l >>> 24 & 255,
        l >>> 16 & 255,
        l >>> 8 & 255,
        l & 255,
        // sample_duration
        c >>> 24 & 255,
        c >>> 16 & 255,
        c >>> 8 & 255,
        c & 255,
        // sample_size
        d.isLeading << 2 | d.dependsOn,
        d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync,
        d.degradPrio & 61440,
        d.degradPrio & 15,
        // sample_flags
        f >>> 24 & 255,
        f >>> 16 & 255,
        f >>> 8 & 255,
        f & 255
        // sample_composition_time_offset
      ], 12 + 16 * o);
    return G.box(G.types.trun, a);
  }
  static initSegment(e) {
    G.types || G.init();
    const n = G.moov(e);
    return an(G.FTYP, n);
  }
  static hvc1(e) {
    const n = e.params, r = [e.vps, e.sps, e.pps], i = 4, s = new Uint8Array([1, n.general_profile_space << 6 | (n.general_tier_flag ? 32 : 0) | n.general_profile_idc, n.general_profile_compatibility_flags[0], n.general_profile_compatibility_flags[1], n.general_profile_compatibility_flags[2], n.general_profile_compatibility_flags[3], n.general_constraint_indicator_flags[0], n.general_constraint_indicator_flags[1], n.general_constraint_indicator_flags[2], n.general_constraint_indicator_flags[3], n.general_constraint_indicator_flags[4], n.general_constraint_indicator_flags[5], n.general_level_idc, 240 | n.min_spatial_segmentation_idc >> 8, 255 & n.min_spatial_segmentation_idc, 252 | n.parallelismType, 252 | n.chroma_format_idc, 248 | n.bit_depth_luma_minus8, 248 | n.bit_depth_chroma_minus8, 0, parseInt(n.frame_rate.fps), i - 1 | n.temporal_id_nested << 2 | n.num_temporal_layers << 3 | (n.frame_rate.fixed ? 64 : 0), r.length]);
    let a = s.length;
    for (let m = 0; m < r.length; m += 1) {
      a += 3;
      for (let p = 0; p < r[m].length; p += 1)
        a += 2 + r[m][p].length;
    }
    const o = new Uint8Array(a);
    o.set(s, 0), a = s.length;
    const u = r.length - 1;
    for (let m = 0; m < r.length; m += 1) {
      o.set(new Uint8Array([32 + m | (m === u ? 128 : 0), 0, r[m].length]), a), a += 3;
      for (let p = 0; p < r[m].length; p += 1)
        o.set(new Uint8Array([r[m][p].length >> 8, r[m][p].length & 255]), a), a += 2, o.set(r[m][p], a), a += r[m][p].length;
    }
    const l = G.box(G.types.hvcC, o), c = e.width, d = e.height, f = e.pixelRatio[0], h = e.pixelRatio[1];
    return G.box(
      G.types.hvc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        c >> 8 & 255,
        c & 255,
        // width
        d >> 8 & 255,
        d & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      l,
      G.box(G.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      G.box(G.types.pasp, new Uint8Array([
        f >> 24,
        // hSpacing
        f >> 16 & 255,
        f >> 8 & 255,
        f & 255,
        h >> 24,
        // vSpacing
        h >> 16 & 255,
        h >> 8 & 255,
        h & 255
      ]))
    );
  }
}
G.types = void 0;
G.HDLR_TYPES = void 0;
G.STTS = void 0;
G.STSC = void 0;
G.STCO = void 0;
G.STSZ = void 0;
G.VMHD = void 0;
G.SMHD = void 0;
G.STSD = void 0;
G.FTYP = void 0;
G.DINF = void 0;
const Jb = 9e4;
function Lf(t, e, n = 1, r = !1) {
  const i = t * e * n;
  return r ? Math.round(i) : i;
}
function M_(t, e, n = 1, r = !1) {
  return Lf(t, e, 1 / n, r);
}
function ys(t, e = !1) {
  return Lf(t, 1e3, 1 / Jb, e);
}
function F_(t, e = 1) {
  return Lf(t, Jb, 1 / e);
}
function K0(t) {
  const {
    baseTime: e,
    timescale: n,
    trackId: r
  } = t;
  return `${e / n} (${e}/${n}) trackId: ${r}`;
}
const B_ = 10 * 1e3, U_ = 1024, $_ = 1152, H_ = 1536;
let mi = null, vl = null;
function W0(t, e, n, r) {
  return {
    duration: e,
    size: n,
    cts: r,
    flags: {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: t ? 2 : 1,
      isNonSync: t ? 0 : 1
    }
  };
}
class Oo extends on {
  constructor(e, n, r, i) {
    if (super("mp4-remuxer", i), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = n, this.typeSupported = r, this.ISGenerated = !1, mi === null) {
      const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      mi = a ? parseInt(a[1]) : 0;
    }
    if (vl === null) {
      const s = navigator.userAgent.match(/Safari\/(\d+)/i);
      vl = s ? parseInt(s[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(e) {
    const n = this._initPTS;
    (!n || !e || e.trackId !== n.trackId || e.baseTime !== n.baseTime || e.timescale !== n.timescale) && this.log(`Reset initPTS: ${n && K0(n)} > ${e && K0(e)}`), this._initPTS = this._initDTS = e;
  }
  resetNextTimestamp() {
    this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
  }
  resetInitSegment() {
    this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0;
  }
  getVideoStartPts(e) {
    let n = !1;
    const r = e[0].pts, i = e.reduce((s, a) => {
      let o = a.pts, u = o - s;
      return u < -4294967296 && (n = !0, o = Yt(o, r), u = o - s), u > 0 ? s : o;
    }, r);
    return n && this.debug("PTS rollover detected"), i;
  }
  remux(e, n, r, i, s, a, o, u) {
    let l, c, d, f, h, m, p = s, g = s;
    const E = e.pid > -1, y = n.pid > -1, T = n.samples.length, S = e.samples.length > 0, v = o && T > 0 || T > 1;
    if ((!E || S) && (!y || v) || this.ISGenerated || o) {
      if (this.ISGenerated) {
        var C, D, _, A;
        const z = this.videoTrackConfig;
        (z && (n.width !== z.width || n.height !== z.height || ((C = n.pixelRatio) == null ? void 0 : C[0]) !== ((D = z.pixelRatio) == null ? void 0 : D[0]) || ((_ = n.pixelRatio) == null ? void 0 : _[1]) !== ((A = z.pixelRatio) == null ? void 0 : A[1])) || !z && v || this.nextAudioTs === null && S) && this.resetInitSegment();
      }
      this.ISGenerated || (d = this.generateIS(e, n, s, a));
      const L = this.isVideoContiguous;
      let N = -1, U;
      if (v && (N = G_(n.samples), !L && this.config.forceKeyFrameOnDiscontinuity))
        if (m = !0, N > 0) {
          this.warn(`Dropped ${N} out of ${T} video samples due to a missing keyframe`);
          const z = this.getVideoStartPts(n.samples);
          n.samples = n.samples.slice(N), n.dropped += N, g += (n.samples[0].pts - z) / n.inputTimeScale, U = g;
        } else N === -1 && (this.warn(`No keyframe found out of ${T} video samples`), m = !1);
      if (this.ISGenerated) {
        if (S && v) {
          const z = this.getVideoStartPts(n.samples), F = (Yt(e.samples[0].pts, z) - z) / n.inputTimeScale;
          p += Math.max(0, F), g += Math.max(0, -F);
        }
        if (S) {
          if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), d = this.generateIS(e, n, s, a)), c = this.remuxAudio(e, p, this.isAudioContiguous, a, y || v || u === le.AUDIO ? g : void 0), v) {
            const z = c ? c.endPTS - c.startPTS : 0;
            n.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), d = this.generateIS(e, n, s, a)), l = this.remuxVideo(n, g, L, z);
          }
        } else v && (l = this.remuxVideo(n, g, L, 0));
        l && (l.firstKeyFrame = N, l.independent = N !== -1, l.firstKeyFramePTS = U);
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (h = eE(r, s, this._initPTS, this._initDTS)), i.samples.length && (f = tE(i, s, this._initPTS))), {
      audio: c,
      video: l,
      initSegment: d,
      independent: m,
      text: f,
      id3: h
    };
  }
  computeInitPts(e, n, r, i) {
    const s = Math.round(r * n);
    let a = Yt(e, s);
    if (a < s + n)
      for (this.log(`Adjusting PTS for rollover in timeline near ${(s - a) / n} ${i}`); a < s + n; )
        a += 8589934592;
    return a - s;
  }
  generateIS(e, n, r, i) {
    const s = e.samples, a = n.samples, o = this.typeSupported, u = {}, l = this._initPTS;
    let c = !l || i, d = "audio/mp4", f, h, m, p = -1;
    if (c && (f = h = 1 / 0), e.config && s.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          o.mpeg ? (d = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3");
          break;
        case "ac3":
          e.codec = "ac-3";
          break;
      }
      u.audio = {
        id: "audio",
        container: d,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : G.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, c && (p = e.id, m = e.inputTimeScale, !l || m !== l.timescale ? f = h = this.computeInitPts(s[0].pts, m, r, "audio") : c = !1);
    }
    if (n.sps && n.pps && a.length) {
      if (n.timescale = n.inputTimeScale, u.video = {
        id: "main",
        container: "video/mp4",
        codec: n.codec,
        initSegment: G.initSegment([n]),
        metadata: {
          width: n.width,
          height: n.height
        }
      }, c)
        if (p = n.id, m = n.inputTimeScale, !l || m !== l.timescale) {
          const g = this.getVideoStartPts(a), E = Yt(a[0].dts, g), y = this.computeInitPts(E, m, r, "video"), T = this.computeInitPts(g, m, r, "video");
          h = Math.min(h, y), f = Math.min(f, T);
        } else
          c = !1;
      this.videoTrackConfig = {
        width: n.width,
        height: n.height,
        pixelRatio: n.pixelRatio
      };
    }
    if (Object.keys(u).length)
      return this.ISGenerated = !0, c ? (l && this.warn(`Timestamps at playlist time: ${i ? "" : "~"}${r} ${f / m} != initPTS: ${l.baseTime / l.timescale} (${l.baseTime}/${l.timescale}) trackId: ${l.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${f / m} (${f}/${m}) trackId: ${p}`), this._initPTS = {
        baseTime: f,
        timescale: m,
        trackId: p
      }, this._initDTS = {
        baseTime: h,
        timescale: m,
        trackId: p
      }) : f = m = void 0, {
        tracks: u,
        initPTS: f,
        timescale: m,
        trackId: p
      };
  }
  remuxVideo(e, n, r, i) {
    const s = e.inputTimeScale, a = e.samples, o = [], u = a.length, l = this._initPTS, c = l.baseTime * s / l.timescale;
    let d = this.nextVideoTs, f = 8, h = this.videoSampleDuration, m, p, g = Number.POSITIVE_INFINITY, E = Number.NEGATIVE_INFINITY, y = !1;
    if (!r || d === null) {
      const Q = c + n * s, J = a[0].pts - Yt(a[0].dts, a[0].pts);
      mi && d !== null && Math.abs(Q - J - (d + c)) < 15e3 ? r = !0 : d = Q - J - c;
    }
    const T = d + c;
    for (let Q = 0; Q < u; Q++) {
      const J = a[Q];
      J.pts = Yt(J.pts, T), J.dts = Yt(J.dts, T), J.dts < a[Q > 0 ? Q - 1 : Q].dts && (y = !0);
    }
    y && a.sort(function(Q, J) {
      const R = Q.dts - J.dts, te = Q.pts - J.pts;
      return R || te;
    }), m = a[0].dts, p = a[a.length - 1].dts;
    const S = p - m, v = S ? Math.round(S / (u - 1)) : h || e.inputTimeScale / 30;
    if (r) {
      const Q = m - T, J = Q > v, R = Q < -1;
      if ((J || R) && (J ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${ys(Q, !0)} ms (${Q}dts) hole between fragments detected at ${n.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${ys(-Q, !0)} ms (${Q}dts) overlapping between fragments detected at ${n.toFixed(3)}`), !R || T >= a[0].pts || mi)) {
        m = T;
        const te = a[0].pts - Q;
        if (J)
          a[0].dts = m, a[0].pts = te;
        else {
          let he = !0;
          for (let ae = 0; ae < a.length && !(a[ae].dts > te && he); ae++) {
            const me = a[ae].pts;
            if (a[ae].dts -= Q, a[ae].pts -= Q, ae < a.length - 1) {
              const ke = a[ae + 1].pts, Pe = a[ae].pts, Oe = ke <= Pe, bt = ke <= me;
              he = Oe == bt;
            }
          }
        }
        this.log(`Video: Initial PTS/DTS adjusted: ${ys(te, !0)}/${ys(m, !0)}, delta: ${ys(Q, !0)} ms`);
      }
    }
    m = Math.max(0, m);
    let I = 0, C = 0, D = m;
    for (let Q = 0; Q < u; Q++) {
      const J = a[Q], R = J.units, te = R.length;
      let he = 0;
      for (let ae = 0; ae < te; ae++)
        he += R[ae].data.length;
      C += he, I += te, J.length = he, J.dts < D ? (J.dts = D, D += v / 4 | 0 || 1) : D = J.dts, g = Math.min(J.pts, g), E = Math.max(J.pts, E);
    }
    p = a[u - 1].dts;
    const _ = C + 4 * I + 8;
    let A;
    try {
      A = new Uint8Array(_);
    } catch (Q) {
      this.observer.emit(x.ERROR, x.ERROR, {
        type: de.MUX_ERROR,
        details: q.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: Q,
        bytes: _,
        reason: `fail allocating video mdat ${_}`
      });
      return;
    }
    const L = new DataView(A.buffer);
    L.setUint32(0, _), A.set(G.types.mdat, 4);
    let N = !1, U = Number.POSITIVE_INFINITY, z = Number.POSITIVE_INFINITY, O = Number.NEGATIVE_INFINITY, F = Number.NEGATIVE_INFINITY;
    for (let Q = 0; Q < u; Q++) {
      const J = a[Q], R = J.units;
      let te = 0;
      for (let me = 0, ke = R.length; me < ke; me++) {
        const Pe = R[me], Oe = Pe.data, bt = Pe.data.byteLength;
        L.setUint32(f, bt), f += 4, A.set(Oe, f), f += bt, te += 4 + bt;
      }
      let he;
      if (Q < u - 1)
        h = a[Q + 1].dts - J.dts, he = a[Q + 1].pts - J.pts;
      else {
        const me = this.config, ke = Q > 0 ? J.dts - a[Q - 1].dts : v;
        if (he = Q > 0 ? J.pts - a[Q - 1].pts : v, me.stretchShortVideoTrack && this.nextAudioTs !== null) {
          const Pe = Math.floor(me.maxBufferHole * s), Oe = (i ? g + i * s : this.nextAudioTs + c) - J.pts;
          Oe > Pe ? (h = Oe - ke, h < 0 ? h = ke : N = !0, this.log(`It is approximately ${Oe / 90} ms to the next segment; using duration ${h / 90} ms for the last video frame.`)) : h = ke;
        } else
          h = ke;
      }
      const ae = Math.round(J.pts - J.dts);
      U = Math.min(U, h), O = Math.max(O, h), z = Math.min(z, he), F = Math.max(F, he), o.push(W0(J.key, h, te, ae));
    }
    if (o.length) {
      if (mi) {
        if (mi < 70) {
          const Q = o[0].flags;
          Q.dependsOn = 2, Q.isNonSync = 0;
        }
      } else if (vl && F - z < O - U && v / O < 0.025 && o[0].cts === 0) {
        this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let Q = m;
        for (let J = 0, R = o.length; J < R; J++) {
          const te = Q + o[J].duration, he = Q + o[J].cts;
          if (J < R - 1) {
            const ae = te + o[J + 1].cts;
            o[J].duration = ae - he;
          } else
            o[J].duration = J ? o[J - 1].duration : v;
          o[J].cts = 0, Q = te;
        }
      }
    }
    h = N || !h ? v : h;
    const B = p + h;
    this.nextVideoTs = d = B - c, this.videoSampleDuration = h, this.isVideoContiguous = !0;
    const w = {
      data1: G.moof(e.sequenceNumber++, m, Ge(e, {
        samples: o
      })),
      data2: A,
      startPTS: (g - c) / s,
      endPTS: (E + h - c) / s,
      startDTS: (m - c) / s,
      endDTS: d / s,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: o.length,
      dropped: e.dropped
    };
    return e.samples = [], e.dropped = 0, w;
  }
  getSamplesPerFrame(e) {
    switch (e.segmentCodec) {
      case "mp3":
        return $_;
      case "ac3":
        return H_;
      default:
        return U_;
    }
  }
  remuxAudio(e, n, r, i, s) {
    const a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, u = a / o, l = this.getSamplesPerFrame(e), c = l * u, d = this._initPTS, f = e.segmentCodec === "mp3" && this.typeSupported.mpeg, h = [], m = s !== void 0;
    let p = e.samples, g = f ? 0 : 8, E = this.nextAudioTs || -1;
    const y = d.baseTime * a / d.timescale, T = y + n * a;
    if (this.isAudioContiguous = r = r || p.length && E > 0 && (i && Math.abs(T - (E + y)) < 9e3 || Math.abs(Yt(p[0].pts, T) - (E + y)) < 20 * c), p.forEach(function(F) {
      F.pts = Yt(F.pts, T);
    }), !r || E < 0) {
      const F = p.length;
      if (p = p.filter((B) => B.pts >= 0), F !== p.length && this.warn(`Removed ${p.length - F} of ${F} samples (initPTS ${y} / ${a})`), !p.length)
        return;
      s === 0 ? E = 0 : i && !m ? E = Math.max(0, T - y) : E = p[0].pts - y;
    }
    if (e.segmentCodec === "aac") {
      const F = this.config.maxAudioFramesDrift;
      for (let B = 0, H = E + y; B < p.length; B++) {
        const X = p[B], w = X.pts, Q = w - H, J = Math.abs(1e3 * Q / a);
        if (Q <= -F * c && m)
          B === 0 && (this.warn(`Audio frame @ ${(w / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * Q / a)} ms.`), this.nextAudioTs = E = w - y, H = w);
        else if (Q >= F * c && J < B_ && m) {
          let R = Math.round(Q / c);
          for (H = w - R * c; H < 0 && R && c; )
            R--, H += c;
          B === 0 && (this.nextAudioTs = E = H - y), this.warn(`Injecting ${R} audio frames @ ${((H - y) / a).toFixed(3)}s due to ${Math.round(1e3 * Q / a)} ms gap.`);
          for (let te = 0; te < R; te++) {
            let he = N_.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
            he || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), he = X.unit.subarray()), p.splice(B, 0, {
              unit: he,
              pts: H
            }), H += c, B++;
          }
        }
        X.pts = H, H += c;
      }
    }
    let S = null, v = null, I, C = 0, D = p.length;
    for (; D--; )
      C += p[D].unit.byteLength;
    for (let F = 0, B = p.length; F < B; F++) {
      const H = p[F], X = H.unit;
      let w = H.pts;
      if (v !== null) {
        const J = h[F - 1];
        J.duration = Math.round((w - v) / u);
      } else if (r && e.segmentCodec === "aac" && (w = E + y), S = w, C > 0) {
        C += g;
        try {
          I = new Uint8Array(C);
        } catch (J) {
          this.observer.emit(x.ERROR, x.ERROR, {
            type: de.MUX_ERROR,
            details: q.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: J,
            bytes: C,
            reason: `fail allocating audio mdat ${C}`
          });
          return;
        }
        f || (new DataView(I.buffer).setUint32(0, C), I.set(G.types.mdat, 4));
      } else
        return;
      I.set(X, g);
      const Q = X.byteLength;
      g += Q, h.push(W0(!0, l, Q, 0)), v = w;
    }
    const _ = h.length;
    if (!_)
      return;
    const A = h[h.length - 1];
    E = v - y, this.nextAudioTs = E + u * A.duration;
    const L = f ? new Uint8Array(0) : G.moof(e.sequenceNumber++, S / u, Ge({}, e, {
      samples: h
    }));
    e.samples = [];
    const N = (S - y) / a, U = E / a, O = {
      data1: L,
      data2: I,
      startPTS: N,
      endPTS: U,
      startDTS: N,
      endDTS: U,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: _
    };
    return this.isAudioContiguous = !0, O;
  }
}
function Yt(t, e) {
  let n;
  if (e === null)
    return t;
  for (e < t ? n = -8589934592 : n = 8589934592; Math.abs(t - e) > 4294967296; )
    t += n;
  return t;
}
function G_(t) {
  for (let e = 0; e < t.length; e++)
    if (t[e].key)
      return e;
  return -1;
}
function eE(t, e, n, r) {
  const i = t.samples.length;
  if (!i)
    return;
  const s = t.inputTimeScale;
  for (let o = 0; o < i; o++) {
    const u = t.samples[o];
    u.pts = Yt(u.pts - n.baseTime * s / n.timescale, e * s) / s, u.dts = Yt(u.dts - r.baseTime * s / r.timescale, e * s) / s;
  }
  const a = t.samples;
  return t.samples = [], {
    samples: a
  };
}
function tE(t, e, n) {
  const r = t.samples.length;
  if (!r)
    return;
  const i = t.inputTimeScale;
  for (let a = 0; a < r; a++) {
    const o = t.samples[a];
    o.pts = Yt(o.pts - n.baseTime * i / n.timescale, e * i) / i;
  }
  t.samples.sort((a, o) => a.pts - o.pts);
  const s = t.samples;
  return t.samples = [], {
    samples: s
  };
}
class V_ extends on {
  constructor(e, n, r, i) {
    super("passthrough-remuxer", i), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;
  }
  destroy() {
  }
  resetTimeStamp(e) {
    this.lastEndTime = null;
    const n = this.initPTS;
    n && e && n.baseTime === e.baseTime && n.timescale === e.timescale || (this.initPTS = e);
  }
  resetNextTimestamp() {
    this.isVideoContiguous = !1, this.lastEndTime = null;
  }
  resetInitSegment(e, n, r, i) {
    this.audioCodec = n, this.videoCodec = r, this.generateInitSegment(e, i), this.emitInitSegment = !0;
  }
  generateInitSegment(e, n) {
    let {
      audioCodec: r,
      videoCodec: i
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return;
    }
    const {
      audio: s,
      video: a
    } = this.initData = ob(e);
    if (n)
      kC(e, n);
    else {
      const u = s || a;
      u != null && u.encrypted && this.warn(`Init segment with encrypted track with has no key ("${u.codec}")!`);
    }
    s && (r = Y0(s, Ve.AUDIO, this)), a && (i = Y0(a, Ve.VIDEO, this));
    const o = {};
    s && a ? o.audiovideo = {
      container: "video/mp4",
      codec: r + "," + i,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : s ? o.audio = {
      container: "audio/mp4",
      codec: r,
      encrypted: s.encrypted,
      initSegment: e,
      id: "audio"
    } : a ? o.video = {
      container: "video/mp4",
      codec: i,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = o;
  }
  remux(e, n, r, i, s, a) {
    var o, u;
    let {
      initPTS: l,
      lastEndTime: c
    } = this;
    const d = {
      audio: void 0,
      video: void 0,
      text: i,
      id3: r,
      initSegment: void 0
    };
    ue(c) || (c = this.lastEndTime = s || 0);
    const f = n.samples;
    if (!f.length)
      return d;
    const h = {
      initPTS: void 0,
      timescale: void 0,
      trackId: void 0
    };
    let m = this.initData;
    if ((o = m) != null && o.length || (this.generateInitSegment(f), m = this.initData), !((u = m) != null && u.length))
      return this.warn("Failed to generate initSegment."), d;
    this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
    const p = DC(f, m, this), g = m.audio ? p[m.audio.id] : null, E = m.video ? p[m.video.id] : null, y = eo(E, 1 / 0), T = eo(g, 1 / 0), S = eo(E, 0, !0), v = eo(g, 0, !0);
    let I = s, C = 0;
    const D = g && (!E || !l && T < y || l && l.trackId === m.audio.id), _ = D ? g : E;
    if (_) {
      const H = _.timescale, X = _.start - s * H, w = D ? m.audio.id : m.video.id;
      I = _.start / H, C = D ? v - T : S - y, (a || !l) && (z_(l, I, s, C) || H !== l.timescale) && (l && this.warn(`Timestamps at playlist time: ${a ? "" : "~"}${s} ${X / H} != initPTS: ${l.baseTime / l.timescale} (${l.baseTime}/${l.timescale}) trackId: ${l.trackId}`), this.log(`Found initPTS at playlist time: ${s} offset: ${I - s} (${X}/${H}) trackId: ${w}`), l = null, h.initPTS = X, h.timescale = H, h.trackId = w);
    } else
      this.warn(`No audio or video samples found for initPTS at playlist time: ${s}`);
    l ? (h.initPTS = l.baseTime, h.timescale = l.timescale, h.trackId = l.trackId) : ((!h.timescale || h.trackId === void 0 || h.initPTS === void 0) && (this.warn("Could not set initPTS"), h.initPTS = I, h.timescale = 1, h.trackId = -1), this.initPTS = l = {
      baseTime: h.initPTS,
      timescale: h.timescale,
      trackId: h.trackId
    });
    const A = I - l.baseTime / l.timescale, L = A + C;
    C > 0 ? this.lastEndTime = L : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const N = !!m.audio, U = !!m.video;
    let z = "";
    N && (z += "audio"), U && (z += "video");
    const O = (m.audio ? m.audio.encrypted : !1) || (m.video ? m.video.encrypted : !1), F = {
      data1: f,
      startPTS: A,
      startDTS: A,
      endPTS: L,
      endDTS: L,
      type: z,
      hasAudio: N,
      hasVideo: U,
      nb: 1,
      dropped: 0,
      encrypted: O
    };
    d.audio = N && !U ? F : void 0, d.video = U ? F : void 0;
    const B = E == null ? void 0 : E.sampleCount;
    if (B) {
      const H = E.keyFrameIndex, X = H !== -1;
      F.nb = B, F.dropped = H === 0 || this.isVideoContiguous ? 0 : X ? H : B, F.independent = X, F.firstKeyFrame = H, X && E.keyFrameStart && (F.firstKeyFramePTS = (E.keyFrameStart - l.baseTime) / l.timescale), this.isVideoContiguous || (d.independent = X), this.isVideoContiguous || (this.isVideoContiguous = X), F.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${H}/${B} dropped: ${F.dropped} start: ${F.firstKeyFramePTS || "NA"}`);
    }
    return d.initSegment = h, d.id3 = eE(r, s, l, l), i.samples.length && (d.text = tE(i, s, l)), d;
  }
}
function eo(t, e, n = !1) {
  return (t == null ? void 0 : t.start) !== void 0 ? (t.start + (n ? t.duration : 0)) / t.timescale : e;
}
function z_(t, e, n, r) {
  if (t === null)
    return !0;
  const i = Math.max(r, 1), s = e - t.baseTime / t.timescale;
  return Math.abs(s - n) > i;
}
function Y0(t, e, n) {
  const r = t.codec;
  return r && r.length > 4 ? r : e === Ve.AUDIO ? r === "ec-3" || r === "ac-3" || r === "alac" ? r : r === "fLaC" || r === "Opus" ? iu(r, !1) : (n.warn(`Unhandled audio codec "${r}" in mp4 MAP`), r || "mp4a") : (n.warn(`Unhandled video codec "${r}" in mp4 MAP`), r || "avc1");
}
let er;
try {
  er = self.performance.now.bind(self.performance);
} catch {
  er = Date.now;
}
const No = [{
  demux: R_,
  remux: V_
}, {
  demux: Tr,
  remux: Oo
}, {
  demux: I_,
  remux: Oo
}, {
  demux: L_,
  remux: Oo
}];
No.splice(2, 0, {
  demux: C_,
  remux: Oo
});
class X0 {
  constructor(e, n, r, i, s, a) {
    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = n, this.config = r, this.id = s, this.logger = a;
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
  }
  push(e, n, r, i) {
    const s = r.transmuxing;
    s.executeStart = er();
    let a = new Uint8Array(e);
    const {
      currentTransmuxState: o,
      transmuxConfig: u
    } = this;
    i && (this.currentTransmuxState = i);
    const {
      contiguous: l,
      discontinuity: c,
      trackSwitch: d,
      accurateTimeOffset: f,
      timeOffset: h,
      initSegmentChange: m
    } = i || o, {
      audioCodec: p,
      videoCodec: g,
      defaultInitPts: E,
      duration: y,
      initSegmentData: T
    } = u, S = q_(a, n);
    if (S && _i(S.method)) {
      const D = this.getDecrypter(), _ = Ef(S.method);
      if (D.isSync()) {
        let A = D.softwareDecrypt(a, S.key.buffer, S.iv.buffer, _);
        if (r.part > -1) {
          const N = D.flush();
          A = N && N.buffer;
        }
        if (!A)
          return s.executeEnd = er(), Il(r);
        a = new Uint8Array(A);
      } else
        return this.asyncResult = !0, this.decryptionPromise = D.webCryptoDecrypt(a, S.key.buffer, S.iv.buffer, _).then((A) => {
          const L = this.push(A, null, r);
          return this.decryptionPromise = null, L;
        }), this.decryptionPromise;
    }
    const v = this.needsProbing(c, d);
    if (v) {
      const D = this.configureTransmuxer(a);
      if (D)
        return this.logger.warn(`[transmuxer] ${D.message}`), this.observer.emit(x.ERROR, x.ERROR, {
          type: de.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          error: D,
          reason: D.message
        }), s.executeEnd = er(), Il(r);
    }
    (c || d || m || v) && this.resetInitSegment(T, p, g, y, n), (c || m || v) && this.resetInitialTimestamp(E), l || this.resetContiguity();
    const I = this.transmux(a, S, h, f, r);
    this.asyncResult = sa(I);
    const C = this.currentTransmuxState;
    return C.contiguous = !0, C.discontinuity = !1, C.trackSwitch = !1, s.executeEnd = er(), I;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(e) {
    const n = e.transmuxing;
    n.executeStart = er();
    const {
      decrypter: r,
      currentTransmuxState: i,
      decryptionPromise: s
    } = this;
    if (s)
      return this.asyncResult = !0, s.then(() => this.flush(e));
    const a = [], {
      timeOffset: o
    } = i;
    if (r) {
      const d = r.flush();
      d && a.push(this.push(d.buffer, null, e));
    }
    const {
      demuxer: u,
      remuxer: l
    } = this;
    if (!u || !l) {
      n.executeEnd = er();
      const d = [Il(e)];
      return this.asyncResult ? Promise.resolve(d) : d;
    }
    const c = u.flush(o);
    return sa(c) ? (this.asyncResult = !0, c.then((d) => (this.flushRemux(a, d, e), a))) : (this.flushRemux(a, c, e), this.asyncResult ? Promise.resolve(a) : a);
  }
  flushRemux(e, n, r) {
    const {
      audioTrack: i,
      videoTrack: s,
      id3Track: a,
      textTrack: o
    } = n, {
      accurateTimeOffset: u,
      timeOffset: l
    } = this.currentTransmuxState;
    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${r.sn}${r.part > -1 ? " part: " + r.part : ""} of ${this.id === le.MAIN ? "level" : "track"} ${r.level}`);
    const c = this.remuxer.remux(i, s, a, o, l, u, !0, this.id);
    e.push({
      remuxResult: c,
      chunkMeta: r
    }), r.transmuxing.executeEnd = er();
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: n,
      remuxer: r
    } = this;
    !n || !r || (n.resetTimeStamp(e), r.resetTimeStamp(e));
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: n
    } = this;
    !e || !n || (e.resetContiguity(), n.resetNextTimestamp());
  }
  resetInitSegment(e, n, r, i, s) {
    const {
      demuxer: a,
      remuxer: o
    } = this;
    !a || !o || (a.resetInitSegment(e, n, r, i), o.resetInitSegment(e, n, r, s));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
  }
  transmux(e, n, r, i, s) {
    let a;
    return n && n.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, n, r, i, s) : a = this.transmuxUnencrypted(e, r, i, s), a;
  }
  transmuxUnencrypted(e, n, r, i) {
    const {
      audioTrack: s,
      videoTrack: a,
      id3Track: o,
      textTrack: u
    } = this.demuxer.demux(e, n, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(s, a, o, u, n, r, !1, this.id),
      chunkMeta: i
    };
  }
  transmuxSampleAes(e, n, r, i, s) {
    return this.demuxer.demuxSampleAes(e, n, r).then((a) => ({
      remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, r, i, !1, this.id),
      chunkMeta: s
    }));
  }
  configureTransmuxer(e) {
    const {
      config: n,
      observer: r,
      typeSupported: i
    } = this;
    let s;
    for (let d = 0, f = No.length; d < f; d++) {
      var a;
      if ((a = No[d].demux) != null && a.probe(e, this.logger)) {
        s = No[d];
        break;
      }
    }
    if (!s)
      return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer, u = this.remuxer, l = s.remux, c = s.demux;
    (!u || !(u instanceof l)) && (this.remuxer = new l(r, n, i, this.logger)), (!o || !(o instanceof c)) && (this.demuxer = new c(r, n, i, this.logger), this.probe = c.probe);
  }
  needsProbing(e, n) {
    return !this.demuxer || !this.remuxer || e || n;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new gf(this.config)), e;
  }
}
function q_(t, e) {
  let n = null;
  return t.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (n = e), n;
}
const Il = (t) => ({
  remuxResult: {},
  chunkMeta: t
});
function sa(t) {
  return "then" in t && t.then instanceof Function;
}
class j_ {
  constructor(e, n, r, i, s) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = n, this.initSegmentData = r, this.duration = i, this.defaultInitPts = s || null;
  }
}
class K_ {
  constructor(e, n, r, i, s, a) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = n, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = s, this.initSegmentChange = a;
  }
}
let Q0 = 0;
class nE {
  constructor(e, n, r, i) {
    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Q0++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (u) => {
      const l = u.data, c = this.hls;
      if (!(!c || !(l != null && l.event) || l.instanceNo !== this.instanceNo))
        switch (l.event) {
          case "init": {
            var d;
            const f = (d = this.workerContext) == null ? void 0 : d.objectURL;
            f && self.URL.revokeObjectURL(f);
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(l.data);
            break;
          }
          case "flush": {
            this.onFlush(l.data);
            break;
          }
          case "workerLog": {
            c.logger[l.data.logType] && c.logger[l.data.logType](l.data.message);
            break;
          }
          default: {
            l.data = l.data || {}, l.data.frag = this.frag, l.data.part = this.part, l.data.id = this.id, c.trigger(l.event, l.data);
            break;
          }
        }
    }, this.onWorkerError = (u) => {
      if (!this.hls)
        return;
      const l = new Error(`${u.message}  (${u.filename}:${u.lineno})`);
      this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.INTERNAL_EXCEPTION,
        fatal: !1,
        event: "demuxerWorker",
        error: l
      });
    };
    const s = e.config;
    this.hls = e, this.id = n, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = r, this.onFlush = i;
    const a = (u, l) => {
      l = l || {}, l.frag = this.frag || void 0, u === x.ERROR && (l = l, l.parent = this.id, l.part = this.part, this.error = l.error), this.hls.trigger(u, l);
    };
    this.observer = new xf(), this.observer.on(x.FRAG_DECRYPTED, a), this.observer.on(x.ERROR, a);
    const o = f0(s.preferManagedMediaSource);
    if (this.useWorker && typeof Worker < "u") {
      const u = this.hls.logger;
      if (s.workerPath || QL()) {
        try {
          s.workerPath ? (u.log(`loading Web Worker ${s.workerPath} for "${n}"`), this.workerContext = JL(s.workerPath)) : (u.log(`injecting Web Worker for "${n}"`), this.workerContext = ZL());
          const {
            worker: c
          } = this.workerContext;
          c.addEventListener("message", this.onWorkerMessage), c.addEventListener("error", this.onWorkerError), c.postMessage({
            instanceNo: this.instanceNo,
            cmd: "init",
            typeSupported: o,
            id: n,
            config: ze(s)
          });
        } catch (c) {
          u.warn(`Error setting up "${n}" Web Worker, fallback to inline`, c), this.terminateWorker(), this.error = null, this.transmuxer = new X0(this.observer, o, s, "", n, e.logger);
        }
        return;
      }
    }
    this.transmuxer = new X0(this.observer, o, s, "", n, e.logger);
  }
  reset() {
    if (this.frag = null, this.part = null, this.workerContext) {
      const e = this.instanceNo;
      this.instanceNo = Q0++;
      const n = this.hls.config, r = f0(n.preferManagedMediaSource);
      this.workerContext.worker.postMessage({
        instanceNo: this.instanceNo,
        cmd: "reset",
        resetNo: e,
        typeSupported: r,
        id: this.id,
        config: ze(n)
      });
    }
  }
  terminateWorker() {
    if (this.workerContext) {
      const {
        worker: e
      } = this.workerContext;
      this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), e_(this.hls.config.workerPath);
    }
  }
  destroy() {
    if (this.workerContext)
      this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
    else {
      const n = this.transmuxer;
      n && (n.destroy(), this.transmuxer = null);
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;
  }
  push(e, n, r, i, s, a, o, u, l, c) {
    var d, f;
    l.transmuxing.start = self.performance.now();
    const {
      instanceNo: h,
      transmuxer: m
    } = this, p = a ? a.start : s.start, g = s.decryptdata, E = this.frag, y = !(E && s.cc === E.cc), T = !(E && l.level === E.level), S = E ? l.sn - E.sn : -1, v = this.part ? l.part - this.part.index : -1, I = S === 0 && l.id > 1 && l.id === (E == null ? void 0 : E.stats.chunkCount), C = !T && (S === 1 || S === 0 && (v === 1 || I && v <= 0)), D = self.performance.now();
    (T || S || s.stats.parsing.start === 0) && (s.stats.parsing.start = D), a && (v || !C) && (a.stats.parsing.start = D);
    const _ = !(E && ((d = s.initSegment) == null ? void 0 : d.url) === ((f = E.initSegment) == null ? void 0 : f.url)), A = new K_(y, C, u, T, p, _);
    if (!C || y || _) {
      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${s.type} sn: ${l.sn}${l.part > -1 ? " part: " + l.part : ""} ${this.id === le.MAIN ? "level" : "track"}: ${l.level} id: ${l.id}
        discontinuity: ${y}
        trackSwitch: ${T}
        contiguous: ${C}
        accurateTimeOffset: ${u}
        timeOffset: ${p}
        initSegmentChange: ${_}`);
      const L = new j_(r, i, n, o, c);
      this.configureTransmuxer(L);
    }
    if (this.frag = s, this.part = a, this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: h,
        cmd: "demux",
        data: e,
        decryptdata: g,
        chunkMeta: l,
        state: A
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (m) {
      const L = m.push(e, g, l, A);
      sa(L) ? L.then((N) => {
        this.handleTransmuxComplete(N);
      }).catch((N) => {
        this.transmuxerError(N, l, "transmuxer-interface push error");
      }) : this.handleTransmuxComplete(L);
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      instanceNo: n,
      transmuxer: r
    } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: n,
        cmd: "flush",
        chunkMeta: e
      });
    else if (r) {
      const i = r.flush(e);
      sa(i) ? i.then((s) => {
        this.handleFlushResult(s, e);
      }).catch((s) => {
        this.transmuxerError(s, e, "transmuxer-interface flush error");
      }) : this.handleFlushResult(i, e);
    }
  }
  transmuxerError(e, n, r) {
    this.hls && (this.error = e, this.hls.trigger(x.ERROR, {
      type: de.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      chunkMeta: n,
      frag: this.frag || void 0,
      part: this.part || void 0,
      fatal: !1,
      error: e,
      err: e,
      reason: r
    }));
  }
  handleFlushResult(e, n) {
    e.forEach((r) => {
      this.handleTransmuxComplete(r);
    }), this.onFlush(n);
  }
  configureTransmuxer(e) {
    const {
      instanceNo: n,
      transmuxer: r
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      instanceNo: n,
      cmd: "configure",
      config: e
    }) : r && r.configure(e);
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
  }
}
const Z0 = 100;
class W_ extends Tf {
  constructor(e, n, r) {
    super(e, n, r, "audio-stream-controller", le.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
  }
  resetItem() {
    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (super.unregisterListeners(), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this));
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(e, {
    frag: n,
    id: r,
    initPTS: i,
    timescale: s,
    trackId: a
  }) {
    if (r === le.MAIN) {
      const o = n.cc, u = this.fragCurrent;
      if (this.initPTS[o] = {
        baseTime: i,
        timescale: s,
        trackId: a
      }, this.log(`InitPTS for cc: ${o} found from main: ${i / s} (${i}/${s}) trackId: ${a}`), this.mainAnchor = n, this.state === Y.WAITING_INIT_PTS) {
        const l = this.waitingData;
        (!l && !this.loadingParts || l && l.frag.cc !== o) && this.syncWithAnchor(n, l == null ? void 0 : l.frag);
      } else !this.hls.hasEnoughToStart && u && u.cc !== o ? (u.abortRequests(), this.syncWithAnchor(n, u)) : this.state === Y.IDLE && this.tick();
    }
  }
  getLoadPosition() {
    return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition();
  }
  syncWithAnchor(e, n) {
    var r;
    const i = ((r = this.mainFragLoading) == null ? void 0 : r.frag) || null;
    if (n && (i == null ? void 0 : i.cc) === n.cc)
      return;
    const s = (i || e).cc, a = this.getLevelDetails(), o = this.getLoadPosition(), u = Eb(a, s, o);
    u && (this.log(`Syncing with main frag at ${u.start} cc ${u.cc}`), this.startFragRequested = !1, this.nextLoadPosition = u.start, this.resetLoadingState(), this.state === Y.IDLE && this.doTickIdle());
  }
  startLoad(e, n) {
    if (!this.levels) {
      this.startPosition = e, this.state = Y.STOPPED;
      return;
    }
    const r = this.lastCurrentTime;
    this.stopLoad(), this.setInterval(Z0), r > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = Y.IDLE) : this.state = Y.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
  }
  doTick() {
    switch (this.state) {
      case Y.IDLE:
        this.doTickIdle();
        break;
      case Y.WAITING_TRACK: {
        const {
          levels: e,
          trackId: n
        } = this, r = e == null ? void 0 : e[n], i = r == null ? void 0 : r.details;
        if (i && !this.waitForLive(r)) {
          if (this.waitForCdnTuneIn(i))
            break;
          this.state = Y.WAITING_INIT_PTS;
        }
        break;
      }
      case Y.FRAG_LOADING_WAITING_RETRY: {
        this.checkRetryDate();
        break;
      }
      case Y.WAITING_INIT_PTS: {
        const e = this.waitingData;
        if (e) {
          const {
            frag: n,
            part: r,
            cache: i,
            complete: s
          } = e, a = this.mainAnchor;
          if (this.initPTS[n.cc] !== void 0) {
            this.waitingData = null, this.state = Y.FRAG_LOADING;
            const o = i.flush().buffer, u = {
              frag: n,
              part: r,
              payload: o,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(u), s && super._handleFragmentLoadComplete(u);
          } else a && a.cc !== e.frag.cc && this.syncWithAnchor(a, e.frag);
        } else
          this.state = Y.IDLE;
      }
    }
    this.onTickEnd();
  }
  resetLoadingState() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    var e;
    const {
      hls: n,
      levels: r,
      media: i,
      trackId: s
    } = this, a = n.config;
    if (!this.buffering || !i && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(r != null && r[s]))
      return;
    const o = r[s], u = o.details;
    if (!u || this.waitForLive(o) || this.waitForCdnTuneIn(u)) {
      this.state = Y.WAITING_TRACK, this.startFragRequested = !1;
      return;
    }
    const l = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, Ve.AUDIO, le.AUDIO));
    const c = this.getFwdBufferInfo(l, le.AUDIO);
    if (c === null)
      return;
    if (!this.switchingTrack && this._streamEnded(c, u)) {
      n.trigger(x.BUFFER_EOS, {
        type: "audio"
      }), this.state = Y.ENDED;
      return;
    }
    const d = c.len, f = n.maxBufferLength, h = u.fragments, m = h[0].start, p = this.getLoadPosition(), g = this.flushing ? p : c.end;
    if (this.switchingTrack && i) {
      const T = p;
      u.PTSKnown && T < m && (c.end > m || c.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = m + 0.05);
    }
    if (d >= f && !this.switchingTrack && g < h[h.length - 1].start)
      return;
    let E = this.getNextFragment(g, u);
    if (E && this.isLoopLoading(E, g) && (E = this.getNextFragmentLoopLoading(E, u, c, le.MAIN, f)), !E) {
      this.bufferFlushed = !0;
      return;
    }
    let y = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
    if (!this.audioOnly && this.startFragRequested && y && ct(E) && !E.endList && (!u.live || !this.loadingParts && g < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(y) === ft.OK && (this.mainFragLoading = y = null), y && ct(y))) {
      if (E.start > y.end) {
        const S = this.fragmentTracker.getFragAtPos(g, le.MAIN);
        S && S.end > y.end && (y = S, this.mainFragLoading = {
          frag: S,
          targetBufferTime: null
        });
      }
      if (E.start > y.end)
        return;
    }
    this.loadFragment(E, o, g);
  }
  onMediaDetaching(e, n) {
    this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, n);
  }
  onAudioTracksUpdated(e, {
    audioTracks: n
  }) {
    this.resetTransmuxer(), this.levels = n.map((r) => new na(r));
  }
  onAudioTrackSwitching(e, n) {
    const r = !!n.url;
    this.trackId = n.id;
    const {
      fragCurrent: i
    } = this;
    i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), r ? (this.switchingTrack = n, this.flushAudioIfNeeded(n), this.state !== Y.STOPPED && (this.setInterval(Z0), this.state = Y.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = n, this.clearInterval());
  }
  onManifestLoading() {
    super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;
  }
  onLevelLoaded(e, n) {
    this.mainDetails = n.details;
    const r = this.cachedTrackLoadedData;
    r && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(x.AUDIO_TRACK_LOADED, r));
  }
  onAudioTrackLoaded(e, n) {
    var r;
    const {
      levels: i
    } = this, {
      details: s,
      id: a,
      groupId: o,
      track: u
    } = n;
    if (!i) {
      this.warn(`Audio tracks reset while loading track ${a} "${u.name}" of "${o}"`);
      return;
    }
    const l = this.mainDetails;
    if (!l || s.endCC > l.endCC || l.expired) {
      this.cachedTrackLoadedData = n, this.state !== Y.STOPPED && (this.state = Y.WAITING_TRACK);
      return;
    }
    this.cachedTrackLoadedData = null, this.log(`Audio track ${a} "${u.name}" of "${o}" loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""},duration:${s.totalduration}`);
    const c = i[a];
    let d = 0;
    if (s.live || (r = c.details) != null && r.live) {
      if (this.checkLiveUpdate(s), s.deltaUpdateFailed)
        return;
      if (c.details) {
        var f;
        d = this.alignPlaylists(s, c.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
      }
      s.alignedSliding || (Mb(s, l), s.alignedSliding || du(s, l), d = s.fragmentStart);
    }
    c.details = s, this.levelLastLoaded = c, this.startFragRequested || this.setStartPosition(l, d), this.hls.trigger(x.AUDIO_TRACK_UPDATED, {
      details: s,
      id: a,
      groupId: n.groupId
    }), this.state === Y.WAITING_TRACK && !this.waitForCdnTuneIn(s) && (this.state = Y.IDLE), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var n;
    const r = e.frag, {
      part: i,
      payload: s
    } = e, {
      config: a,
      trackId: o,
      levels: u
    } = this;
    if (!u) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const l = u[o];
    if (!l) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const c = l.details;
    if (!c) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(r.start);
      return;
    }
    const d = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
    let f = this.transmuxer;
    f || (f = this.transmuxer = new nE(this.hls, le.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const h = this.initPTS[r.cc], m = (n = r.initSegment) == null ? void 0 : n.data;
    if (h !== void 0) {
      const g = i ? i.index : -1, E = g !== -1, y = new bf(r.level, r.sn, r.stats.chunkCount, s.byteLength, g, E);
      f.push(s, m, d, "", r, i, c.totalduration, !1, y, h);
    } else {
      this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${c.startSN} ,${c.endSN}],track ${o}`);
      const {
        cache: p
      } = this.waitingData = this.waitingData || {
        frag: r,
        part: i,
        cache: new Fb(),
        complete: !1
      };
      p.push(new Uint8Array(s)), this.state !== Y.STOPPED && (this.state = Y.WAITING_INIT_PTS);
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = null;
  }
  onBufferCreated(e, n) {
    this.bufferFlushed = this.flushing = !1;
    const r = n.tracks.audio;
    r && (this.mediaBuffer = r.buffer || null);
  }
  onFragLoading(e, n) {
    !this.audioOnly && n.frag.type === le.MAIN && ct(n.frag) && (this.mainFragLoading = n, this.state === Y.IDLE && this.tick());
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n;
    if (r.type !== le.AUDIO) {
      !this.audioOnly && r.type === le.MAIN && !r.elementaryStreams.video && !r.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null);
      return;
    }
    if (this.fragContextChanged(r)) {
      this.warn(`Fragment ${r.sn}${i ? " p: " + i.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (ct(r)) {
      this.fragPrevious = r;
      const s = this.switchingTrack;
      s && (this.bufferedTrack = s, this.switchingTrack = null, this.hls.trigger(x.AUDIO_TRACK_SWITCHED, Fe({}, s)));
    }
    this.fragBufferedComplete(r, i), this.media && this.tick();
  }
  onError(e, n) {
    var r;
    if (n.fatal) {
      this.state = Y.ERROR;
      return;
    }
    switch (n.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(le.AUDIO, n);
        break;
      case q.AUDIO_TRACK_LOAD_ERROR:
      case q.AUDIO_TRACK_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !n.levelRetry && this.state === Y.WAITING_TRACK && ((r = n.context) == null ? void 0 : r.type) === _e.AUDIO_TRACK && (this.state = Y.IDLE);
        break;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (n.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(n) || this.resetLoadingState();
        break;
      case q.BUFFER_FULL_ERROR:
        if (n.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(n) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(n);
        break;
    }
  }
  onBufferFlushing(e, {
    type: n
  }) {
    n !== Ve.VIDEO && (this.flushing = !0);
  }
  onBufferFlushed(e, {
    type: n
  }) {
    if (n !== Ve.VIDEO) {
      this.flushing = !1, this.bufferFlushed = !0, this.state === Y.ENDED && (this.state = Y.IDLE);
      const r = this.mediaBuffer || this.media;
      r && (this.afterBufferFlushed(r, n, le.AUDIO), this.tick());
    }
  }
  _handleTransmuxComplete(e) {
    var n;
    const r = "audio", {
      hls: i
    } = this, {
      remuxResult: s,
      chunkMeta: a
    } = e, o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const {
      frag: u,
      part: l,
      level: c
    } = o, {
      details: d
    } = c, {
      audio: f,
      text: h,
      id3: m,
      initSegment: p
    } = s;
    if (this.fragContextChanged(u) || !d) {
      this.fragmentTracker.removeFragment(u);
      return;
    }
    if (this.state = Y.PARSING, this.switchingTrack && f && this.completeAudioSwitch(this.switchingTrack), p != null && p.tracks) {
      const g = u.initSegment || u;
      if (this.unhandledEncryptionError(p, u))
        return;
      this._bufferInitSegment(c, p.tracks, g, a), i.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
        frag: g,
        id: r,
        tracks: p.tracks
      });
    }
    if (f) {
      const {
        startPTS: g,
        endPTS: E,
        startDTS: y,
        endDTS: T
      } = f;
      l && (l.elementaryStreams[Ve.AUDIO] = {
        startPTS: g,
        endPTS: E,
        startDTS: y,
        endDTS: T
      }), u.setElementaryStreamInfo(Ve.AUDIO, g, E, y, T), this.bufferFragmentData(f, u, l, a);
    }
    if (m != null && (n = m.samples) != null && n.length) {
      const g = Ge({
        id: r,
        frag: u,
        details: d
      }, m);
      i.trigger(x.FRAG_PARSING_METADATA, g);
    }
    if (h) {
      const g = Ge({
        id: r,
        frag: u,
        details: d
      }, h);
      i.trigger(x.FRAG_PARSING_USERDATA, g);
    }
  }
  _bufferInitSegment(e, n, r, i) {
    if (this.state !== Y.PARSING || (n.video && delete n.video, n.audiovideo && delete n.audiovideo, !n.audio))
      return;
    const s = n.audio;
    s.id = le.AUDIO;
    const a = e.audioCodec;
    this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${a}/${s.codec}]`), a && a.split(",").length === 1 && (s.levelCodec = a), this.hls.trigger(x.BUFFER_CODECS, n);
    const o = s.initSegment;
    if (o != null && o.byteLength) {
      const u = {
        type: "audio",
        frag: r,
        part: null,
        chunkMeta: i,
        parent: r.type,
        data: o
      };
      this.hls.trigger(x.BUFFER_APPENDING, u);
    }
    this.tickImmediate();
  }
  loadFragment(e, n, r) {
    const i = this.fragmentTracker.getState(e);
    if (this.switchingTrack || i === ft.NOT_LOADED || i === ft.PARTIAL) {
      var s;
      if (!ct(e))
        this._loadInitSegment(e, n);
      else if ((s = n.details) != null && s.live && !this.initPTS[e.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = Y.WAITING_INIT_PTS;
        const a = this.mainDetails;
        a && a.fragmentStart !== n.details.fragmentStart && du(n.details, a);
      } else
        super.loadFragment(e, n, r);
    } else
      this.clearTrackerIfNeeded(e);
  }
  flushAudioIfNeeded(e) {
    if (this.media && this.bufferedTrack) {
      const {
        name: n,
        lang: r,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      } = this.bufferedTrack;
      Vr({
        name: n,
        lang: r,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      }, e, Fr) || (au(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e);
    }
  }
  completeAudioSwitch(e) {
    const {
      hls: n
    } = this;
    this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, n.trigger(x.AUDIO_TRACK_SWITCHED, Fe({}, e));
  }
}
class _f extends on {
  constructor(e, n) {
    super(n, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1);
  }
  startLoad() {
    this.canLoad = !0, this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer();
  }
  switchParams(e, n, r) {
    const i = n == null ? void 0 : n.renditionReports;
    if (i) {
      let s = -1;
      for (let a = 0; a < i.length; a++) {
        const o = i[a];
        let u;
        try {
          u = new self.URL(o.URI, n.url).href;
        } catch (l) {
          this.warn(`Could not construct new URL for Rendition Report: ${l}`), u = o.URI || "";
        }
        if (u === e) {
          s = a;
          break;
        } else u === e.substring(0, u.length) && (s = a);
      }
      if (s !== -1) {
        const a = i[s], o = parseInt(a["LAST-MSN"]) || n.lastPartSn;
        let u = parseInt(a["LAST-PART"]) || n.lastPartIndex;
        if (this.hls.config.lowLatencyMode) {
          const c = Math.min(n.age - n.partTarget, n.targetduration);
          u >= 0 && c > n.partTarget && (u += 1);
        }
        const l = r && h0(r);
        return new m0(o, u >= 0 ? u : void 0, l);
      }
    }
  }
  loadPlaylist(e) {
    this.clearTimer();
  }
  loadingPlaylist(e, n) {
    this.clearTimer();
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  getUrlWithDirectives(e, n) {
    if (n)
      try {
        return n.addDirectives(e);
      } catch (r) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`);
      }
    return e;
  }
  playlistLoaded(e, n, r) {
    const {
      details: i,
      stats: s
    } = n, a = self.performance.now(), o = s.loading.first ? Math.max(0, a - s.loading.first) : 0;
    i.advancedDateTime = Date.now() - o;
    const u = this.hls.config.timelineOffset;
    if (u !== i.appliedTimelineOffset) {
      const c = Math.max(u || 0, 0);
      i.appliedTimelineOffset = c, i.fragments.forEach((d) => {
        d.setStart(d.playlistOffset + c);
      });
    }
    if (i.live || r != null && r.live) {
      const c = "levelInfo" in n ? n.levelInfo : n.track;
      if (i.reloaded(r), r && i.fragments.length > 0) {
        $L(r, i, this);
        const y = i.playlistParsingError;
        if (y) {
          this.warn(y);
          const T = this.hls;
          if (!T.config.ignorePlaylistParsingErrors) {
            var l;
            const {
              networkDetails: S
            } = n;
            T.trigger(x.ERROR, {
              type: de.NETWORK_ERROR,
              details: q.LEVEL_PARSING_ERROR,
              fatal: !1,
              url: i.url,
              error: y,
              reason: y.message,
              level: n.level || void 0,
              parent: (l = i.fragments[0]) == null ? void 0 : l.type,
              networkDetails: S,
              stats: s
            });
            return;
          }
          i.playlistParsingError = null;
        }
      }
      i.requestScheduled === -1 && (i.requestScheduled = s.loading.start);
      const d = this.hls.mainForwardBufferInfo, f = d ? d.end - d.len : 0, h = (i.edge - f) * 1e3, m = wb(i, h);
      if (i.requestScheduled + m < a ? i.requestScheduled = a : i.requestScheduled += m, this.log(`live playlist ${e} ${i.advanced ? "REFRESHED " + i.lastPartSn + "-" + i.lastPartIndex : i.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !i.live)
        return;
      let p, g, E;
      if (i.canBlockReload && i.endSN && i.advanced) {
        const y = this.hls.config.lowLatencyMode, T = i.lastPartSn, S = i.endSN, v = i.lastPartIndex, I = v !== -1, C = T === S;
        I ? C ? (g = S + 1, E = y ? 0 : v) : (g = T, E = y ? v + 1 : i.maxPartIndex) : g = S + 1;
        const D = i.age, _ = D + i.ageHeader;
        let A = Math.min(_ - i.partTarget, i.targetduration * 1.5);
        if (A > 0) {
          if (_ > i.targetduration * 3)
            this.log(`Playlist last advanced ${D.toFixed(2)}s ago. Omitting segment and part directives.`), g = void 0, E = void 0;
          else if (r != null && r.tuneInGoal && _ - i.partTarget > r.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${A} with playlist age: ${i.age}`), A = 0;
          else {
            const L = Math.floor(A / i.targetduration);
            if (g += L, E !== void 0) {
              const N = Math.round(A % i.targetduration / i.partTarget);
              E += N;
            }
            this.log(`CDN Tune-in age: ${i.ageHeader}s last advanced ${D.toFixed(2)}s goal: ${A} skip sn ${L} to part ${E}`);
          }
          i.tuneInGoal = A;
        }
        if (p = this.getDeliveryDirectives(i, n.deliveryDirectives, g, E), y || !C) {
          i.requestScheduled = a, this.loadingPlaylist(c, p);
          return;
        }
      } else (i.canBlockReload || i.canSkipUntil) && (p = this.getDeliveryDirectives(i, n.deliveryDirectives, g, E));
      p && g !== void 0 && i.canBlockReload && (i.requestScheduled = s.loading.first + Math.max(m - o * 2, m / 2)), this.scheduleLoading(c, p, i);
    } else
      this.clearTimer();
  }
  scheduleLoading(e, n, r) {
    const i = r || e.details;
    if (!i) {
      this.loadingPlaylist(e, n);
      return;
    }
    const s = self.performance.now(), a = i.requestScheduled;
    if (s >= a) {
      this.loadingPlaylist(e, n);
      return;
    }
    const o = a - s;
    this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`), this.clearTimer(), this.timer = self.setTimeout(() => this.loadingPlaylist(e, n), o);
  }
  getDeliveryDirectives(e, n, r, i) {
    let s = h0(e);
    return n != null && n.skip && e.deltaUpdateFailed && (r = n.msn, i = n.part, s = Do.No), new m0(r, i, s);
  }
  checkRetry(e) {
    const n = e.details, r = ou(e), i = e.errorAction, {
      action: s,
      retryCount: a = 0,
      retryConfig: o
    } = i || {}, u = !!i && !!o && (s === Tt.RetryRequest || !i.resolved && s === Tt.SendAlternateToPenaltyBox);
    if (u) {
      var l;
      if (a >= o.maxNumRetry)
        return !1;
      if (r && (l = e.context) != null && l.deliveryDirectives)
        this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${n}" without delivery-directives`), this.loadPlaylist();
      else {
        const c = pf(o, a);
        this.clearTimer(), this.timer = self.setTimeout(() => this.loadPlaylist(), c), this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${n}" in ${c}ms`);
      }
      e.levelRetry = !0, i.resolved = !0;
    }
    return u;
  }
}
function rE(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!aa(t[n].attrs, e[n].attrs))
      return !1;
  return !0;
}
function aa(t, e, n) {
  const r = t["STABLE-RENDITION-ID"];
  return r && !n ? r === e["STABLE-RENDITION-ID"] : !(n || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i) => t[i] !== e[i]);
}
function Wc(t, e) {
  return e.label.toLowerCase() === t.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (t.lang || "").toLowerCase());
}
class Y_ extends _f {
  constructor(e) {
    super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
  }
  onManifestLoading() {
    this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;
  }
  onManifestParsed(e, n) {
    this.tracks = n.audioTracks || [];
  }
  onAudioTrackLoaded(e, n) {
    const {
      id: r,
      groupId: i,
      details: s
    } = n, a = this.tracksInGroup[r];
    if (!a || a.groupId !== i) {
      this.warn(`Audio track with id:${r} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = n.details, this.log(`Audio track ${r} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, n, o);
  }
  onLevelLoading(e, n) {
    this.switchLevel(n.level);
  }
  onLevelSwitching(e, n) {
    this.switchLevel(n.level);
  }
  switchLevel(e) {
    const n = this.hls.levels[e];
    if (!n)
      return;
    const r = n.audioGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some((o) => (i == null ? void 0 : i.indexOf(o)) === -1)) {
      this.groupIds = r, this.trackId = -1, this.currentTrack = null;
      const o = this.tracks.filter((f) => !r || r.indexOf(f.groupId) !== -1);
      if (o.length)
        this.selectDefaultTrack && !o.some((f) => f.default) && (this.selectDefaultTrack = !1), o.forEach((f, h) => {
          f.id = h;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = o;
      const u = this.hls.config.audioPreference;
      if (!s && u) {
        const f = Rn(u, o, Fr);
        if (f > -1)
          s = o[f];
        else {
          const h = Rn(u, this.tracks);
          s = this.tracks[h];
        }
      }
      let l = this.findTrackId(s);
      l === -1 && s && (l = this.findTrackId(null));
      const c = {
        audioTracks: o
      };
      this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${r == null ? void 0 : r.join(",")}`), this.hls.trigger(x.AUDIO_TRACKS_UPDATED, c);
      const d = this.trackId;
      if (l !== -1 && d === -1)
        this.setAudioTrack(l);
      else if (o.length && d === -1) {
        var a;
        const f = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`);
        this.warn(f.message), this.hls.trigger(x.ERROR, {
          type: de.MEDIA_ERROR,
          details: q.AUDIO_TRACK_LOAD_ERROR,
          fatal: !0,
          error: f
        });
      }
    }
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === _e.AUDIO_TRACK && n.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(n.context.groupId) !== -1) && this.checkRetry(n);
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e);
  }
  setAudioOption(e) {
    const n = this.hls;
    if (n.config.audioPreference = e, e) {
      const r = this.allAudioTracks;
      if (this.selectDefaultTrack = !1, r.length) {
        const i = this.currentTrack;
        if (i && Vr(e, i, Fr))
          return i;
        const s = Rn(e, this.tracksInGroup, Fr);
        if (s > -1) {
          const a = this.tracksInGroup[s];
          return this.setAudioTrack(s), a;
        } else if (i) {
          let a = n.loadLevel;
          a === -1 && (a = n.firstAutoLevel);
          const o = oL(e, n.levels, r, a, Fr);
          if (o === -1)
            return null;
          n.nextLoadLevel = o;
        }
        if (e.channels || e.audioCodec) {
          const a = Rn(e, r);
          if (a > -1)
            return r[a];
        }
      }
    }
    return null;
  }
  setAudioTrack(e) {
    const n = this.tracksInGroup;
    if (e < 0 || e >= n.length) {
      this.warn(`Invalid audio track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const r = this.currentTrack, i = n[e], s = i.details && !i.details.live;
    if (e === this.trackId && i === r && s || (this.log(`Switching to audio-track ${e} "${i.name}" lang:${i.lang} group:${i.groupId} channels:${i.channels}`), this.trackId = e, this.currentTrack = i, this.hls.trigger(x.AUDIO_TRACK_SWITCHING, Fe({}, i)), s))
      return;
    const a = this.switchParams(i.url, r == null ? void 0 : r.details, i.details);
    this.loadPlaylist(a);
  }
  findTrackId(e) {
    const n = this.tracksInGroup;
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      if (!(this.selectDefaultTrack && !i.default) && (!e || Vr(e, i, Fr)))
        return r;
    }
    if (e) {
      const {
        name: r,
        lang: i,
        assocLang: s,
        characteristics: a,
        audioCodec: o,
        channels: u
      } = e;
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (Vr({
          name: r,
          lang: i,
          assocLang: s,
          characteristics: a,
          audioCodec: o,
          channels: u
        }, c, Fr))
          return l;
      }
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (aa(e.attrs, c.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return l;
      }
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (aa(e.attrs, c.attrs, ["LANGUAGE"]))
          return l;
      }
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const n = this.currentTrack;
    this.shouldLoadPlaylist(n) && au(n.url, this.hls) && this.scheduleLoading(n, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, n), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading audio-track ${r} "${e.name}" lang:${e.lang} group:${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(x.AUDIO_TRACK_LOADING, {
      url: s,
      id: r,
      groupId: i,
      deliveryDirectives: n || null,
      track: e
    });
  }
}
class X_ {
  constructor(e) {
    this.tracks = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.tracks = e;
  }
  destroy() {
    this.tracks = this.queues = null;
  }
  append(e, n, r) {
    if (this.queues === null || this.tracks === null)
      return;
    const i = this.queues[n];
    i.push(e), i.length === 1 && !r && this.executeNext(n);
  }
  appendBlocker(e) {
    return new Promise((n) => {
      const r = {
        label: "async-blocker",
        execute: n,
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: () => {
        }
      };
      this.append(r, e);
    });
  }
  prependBlocker(e) {
    return new Promise((n) => {
      if (this.queues) {
        const r = {
          label: "async-blocker-prepend",
          execute: n,
          onStart: () => {
          },
          onComplete: () => {
          },
          onError: () => {
          }
        };
        this.queues[e].unshift(r);
      }
    });
  }
  removeBlockers() {
    this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((e) => {
      var n;
      const r = (n = e[0]) == null ? void 0 : n.label;
      (r === "async-blocker" || r === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1));
    });
  }
  unblockAudio(e) {
    if (this.queues === null)
      return;
    this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
  }
  executeNext(e) {
    if (this.queues === null || this.tracks === null)
      return;
    const n = this.queues[e];
    if (n.length) {
      const i = n[0];
      try {
        i.execute();
      } catch (s) {
        var r;
        if (i.onError(s), this.queues === null || this.tracks === null)
          return;
        const a = (r = this.tracks[e]) == null ? void 0 : r.buffer;
        a != null && a.updating || this.shiftAndExecuteNext(e);
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
  }
  current(e) {
    var n;
    return ((n = this.queues) == null ? void 0 : n[e][0]) || null;
  }
  toString() {
    const {
      queues: e,
      tracks: n
    } = this;
    return e === null || n === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
  }
  list(e) {
    var n, r;
    return (n = this.queues) != null && n[e] || (r = this.tracks) != null && r[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "";
  }
  listSbInfo(e) {
    var n;
    const r = (n = this.tracks) == null ? void 0 : n[e], i = r == null ? void 0 : r.buffer;
    return i ? `SourceBuffer${i.updating ? " updating" : ""}${r.ended ? " ended" : ""}${r.ending ? " ending" : ""}` : "none";
  }
  listOps(e) {
    var n;
    return ((n = this.queues) == null ? void 0 : n[e].map((r) => r.label).join(", ")) || "";
  }
}
const J0 = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, iE = "HlsJsTrackRemovedError";
class Q_ extends Error {
  constructor(e) {
    super(e), this.name = iE;
  }
}
class Z_ extends on {
  constructor(e, n) {
    super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = (r) => {
      var i;
      this.hls && ((i = this.mediaSource) == null ? void 0 : i.readyState) === "open" && this.hls.pauseBuffering();
    }, this._onStartStreaming = (r) => {
      this.hls && this.hls.resumeBuffering();
    }, this._onMediaSourceOpen = (r) => {
      const {
        media: i,
        mediaSource: s
      } = this;
      r && this.log("Media source opened"), !(!i || !s) && (s.removeEventListener("sourceopen", this._onMediaSourceOpen), i.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(x.MEDIA_ATTACHED, {
        media: i,
        mediaSource: s
      }), this.mediaSource !== null && this.checkPendingTracks());
    }, this._onMediaSourceClose = () => {
      this.log("Media source closed");
    }, this._onMediaSourceEnded = () => {
      this.log("Media source ended");
    }, this._onMediaEmptied = () => {
      const {
        mediaSrc: r,
        _objectUrl: i
      } = this;
      r !== i && this.error(`Media element src was set while attaching MediaSource (${i} > ${r})`);
    }, this.hls = e, this.fragmentTracker = n, this.appendSource = TC(vr(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();
  }
  hasSourceTypes() {
    return Object.keys(this.tracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_APPENDING, this.onBufferAppending, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.BUFFER_EOS, this.onBufferEos, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.FRAG_PARSED, this.onFragParsed, this), e.on(x.FRAG_CHANGED, this.onFragChanged, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_APPENDING, this.onBufferAppending, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_EOS, this.onBufferEos, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.FRAG_PARSED, this.onFragParsed, this), e.off(x.FRAG_CHANGED, this.onFragChanged, this), e.off(x.ERROR, this.onError, this);
  }
  transferMedia() {
    const {
      media: e,
      mediaSource: n
    } = this;
    if (!e)
      return null;
    const r = {};
    if (this.operationQueue) {
      const s = this.isUpdating();
      s || this.operationQueue.removeBlockers();
      const a = this.isQueued();
      (s || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${s ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy();
    }
    const i = this.transferData;
    return !this.sourceBufferCount && i && i.mediaSource === n ? Ge(r, i.tracks) : this.sourceBuffers.forEach((s) => {
      const [a] = s;
      a && (r[a] = Ge({}, this.tracks[a]), this.removeBuffer(a)), s[0] = s[1] = null;
    }), {
      media: e,
      mediaSource: n,
      tracks: r
    };
  }
  initTracks() {
    const e = {};
    this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;
  }
  onManifestLoading() {
    this.bufferCodecEventsTotal = 0, this.details = null;
  }
  onManifestParsed(e, n) {
    var r;
    let i = 2;
    (n.audio && !n.video || !n.altAudio) && (i = 1), this.bufferCodecEventsTotal = i, this.log(`${i} bufferCodec event(s) expected.`), (r = this.transferData) != null && r.mediaSource && this.sourceBufferCount && i && this.bufferCreated();
  }
  onMediaAttaching(e, n) {
    const r = this.media = n.media;
    this.transferData = this.overrides = void 0;
    const i = vr(this.appendSource);
    if (i) {
      const s = !!n.mediaSource;
      (s || n.overrides) && (this.transferData = n, this.overrides = n.overrides);
      const a = this.mediaSource = n.mediaSource || new i();
      if (this.assignMediaSource(a), s)
        this._objectUrl = r.src, this.attachTransferred();
      else {
        const o = this._objectUrl = self.URL.createObjectURL(a);
        if (this.appendSource)
          try {
            r.removeAttribute("src");
            const u = self.ManagedMediaSource;
            r.disableRemotePlayback = r.disableRemotePlayback || u && a instanceof u, em(r), J_(r, o), r.load();
          } catch {
            r.src = o;
          }
        else
          r.src = o;
      }
      r.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  assignMediaSource(e) {
    var n, r;
    this.log(`${((n = this.transferData) == null ? void 0 : n.mediaSource) === e ? "transferred" : "created"} media source: ${(r = e.constructor) == null ? void 0 : r.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
  }
  attachTransferred() {
    const e = this.media, n = this.transferData;
    if (!n || !e)
      return;
    const r = this.tracks, i = n.tracks, s = i ? Object.keys(i) : null, a = s ? s.length : 0, o = () => {
      Promise.resolve().then(() => {
        this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
      });
    };
    if (i && s && a) {
      if (!this.tracksReady) {
        this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info");
        return;
      }
      if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${ze(r, (u, l) => u === "initSegment" ? void 0 : l)};
transfer tracks: ${ze(i, (u, l) => u === "initSegment" ? void 0 : l)}}`), !eb(i, r)) {
        n.mediaSource = null, n.tracks = void 0;
        const u = e.currentTime, l = this.details, c = Math.max(u, (l == null ? void 0 : l.fragments[0].start) || 0);
        if (c - u > 1) {
          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${u} -> ${c}`);
          return;
        }
        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(i)}"->"${Object.keys(r)}") start time: ${c} currentTime: ${u}`), this.onMediaDetaching(x.MEDIA_DETACHING, {}), this.onMediaAttaching(x.MEDIA_ATTACHING, n), e.currentTime = c;
        return;
      }
      this.transferData = void 0, s.forEach((u) => {
        const l = u, c = i[l];
        if (c) {
          const d = c.buffer;
          if (d) {
            const f = this.fragmentTracker, h = c.id;
            if (f.hasFragments(h) || f.hasParts(h)) {
              const g = ye.getBuffered(d);
              f.detectEvictedFragments(l, g, h, null, !0);
            }
            const m = Cl(l), p = [l, d];
            this.sourceBuffers[m] = p, d.updating && this.operationQueue && this.operationQueue.prependBlocker(l), this.trackSourceBuffer(l, c);
          }
        }
      }), o(), this.bufferCreated();
    } else
      this.log("attachTransferred: MediaSource w/o SourceBuffers"), o();
  }
  get mediaSourceOpenOrEnded() {
    var e;
    const n = (e = this.mediaSource) == null ? void 0 : e.readyState;
    return n === "open" || n === "ended";
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia;
    this.transferData = this.overrides = void 0;
    const {
      media: i,
      mediaSource: s,
      _objectUrl: a
    } = this;
    if (s) {
      if (this.log(`media source ${r ? "transferring" : "detaching"}`), r)
        this.sourceBuffers.forEach(([o]) => {
          o && this.removeBuffer(o);
        }), this.resetQueue();
      else {
        if (this.mediaSourceOpenOrEnded) {
          const o = s.readyState === "open";
          try {
            const u = s.sourceBuffers;
            for (let l = u.length; l--; )
              o && u[l].abort(), s.removeSourceBuffer(u[l]);
            o && s.endOfStream();
          } catch (u) {
            this.warn(`onMediaDetaching: ${u.message} while calling endOfStream`);
          }
        }
        this.sourceBufferCount && this.onBufferReset();
      }
      s.removeEventListener("sourceopen", this._onMediaSourceOpen), s.removeEventListener("sourceended", this._onMediaSourceEnded), s.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (s.removeEventListener("startstreaming", this._onStartStreaming), s.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;
    }
    i && (i.removeEventListener("emptied", this._onMediaEmptied), r || (a && self.URL.revokeObjectURL(a), this.mediaSrc === a ? (i.removeAttribute("src"), this.appendSource && em(i), i.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(x.MEDIA_DETACHED, n);
  }
  onBufferReset() {
    this.sourceBuffers.forEach(([e]) => {
      e && this.resetBuffer(e);
    }), this.initTracks();
  }
  resetBuffer(e) {
    var n;
    const r = (n = this.tracks[e]) == null ? void 0 : n.buffer;
    if (this.removeBuffer(e), r)
      try {
        var i;
        (i = this.mediaSource) != null && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(r);
      } catch (s) {
        this.warn(`onBufferReset ${e}`, s);
      }
    delete this.tracks[e];
  }
  removeBuffer(e) {
    this.removeBufferListeners(e), this.sourceBuffers[Cl(e)] = [null, null];
    const n = this.tracks[e];
    n && (n.buffer = void 0);
  }
  resetQueue() {
    this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new X_(this.tracks);
  }
  onBufferCodecs(e, n) {
    var r;
    const i = this.tracks, s = Object.keys(n);
    this.log(`BUFFER_CODECS: "${s}" (current SB count ${this.sourceBufferCount})`);
    const a = "audiovideo" in n && (i.audio || i.video) || i.audiovideo && ("audio" in n || "video" in n), o = !a && this.sourceBufferCount && this.media && s.some((u) => !i[u]);
    if (a || o) {
      this.warn(`Unsupported transition between "${Object.keys(i)}" and "${s}" SourceBuffers`);
      return;
    }
    s.forEach((u) => {
      var l, c;
      const d = n[u], {
        id: f,
        codec: h,
        levelCodec: m,
        container: p,
        metadata: g,
        supplemental: E
      } = d;
      let y = i[u];
      const T = (l = this.transferData) == null || (l = l.tracks) == null ? void 0 : l[u], S = T != null && T.buffer ? T : y, v = (S == null ? void 0 : S.pendingCodec) || (S == null ? void 0 : S.codec), I = S == null ? void 0 : S.levelCodec;
      y || (y = i[u] = {
        buffer: void 0,
        listeners: [],
        codec: h,
        supplemental: E,
        container: p,
        levelCodec: m,
        metadata: g,
        id: f
      });
      const C = wo(v, I), D = C == null ? void 0 : C.replace(J0, "$1");
      let _ = wo(h, m);
      const A = (c = _) == null ? void 0 : c.replace(J0, "$1");
      _ && C && D !== A && (u.slice(0, 5) === "audio" && (_ = iu(_, this.appendSource)), this.log(`switching codec ${v} to ${_}`), _ !== (y.pendingCodec || y.codec) && (y.pendingCodec = _), y.container = p, this.appendChangeType(u, p, _));
    }), (this.tracksReady || this.sourceBufferCount) && (n.tracks = this.sourceBufferTracks), !this.sourceBufferCount && (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !n.video && ((r = n.audio) == null ? void 0 : r.id) === "main" && (this.log("Main audio-only"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded && this.checkPendingTracks());
  }
  get sourceBufferTracks() {
    return Object.keys(this.tracks).reduce((e, n) => {
      const r = this.tracks[n];
      return e[n] = {
        id: r.id,
        container: r.container,
        codec: r.codec,
        levelCodec: r.levelCodec
      }, e;
    }, {});
  }
  appendChangeType(e, n, r) {
    const i = `${n};codecs=${r}`, s = {
      label: `change-type=${i}`,
      execute: () => {
        const a = this.tracks[e];
        if (a) {
          const o = a.buffer;
          o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${i}`), o.changeType(i), a.codec = r, a.container = n);
        }
        this.shiftAndExecuteNext(e);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (a) => {
        this.warn(`Failed to change ${e} SourceBuffer type`, a);
      }
    };
    this.append(s, e, this.isPending(this.tracks[e]));
  }
  blockAudio(e) {
    var n;
    const r = e.start, i = r + e.duration * 0.05;
    if (((n = this.fragmentTracker.getAppendedFrag(r, le.MAIN)) == null ? void 0 : n.gap) === !0)
      return;
    const a = {
      label: "block-audio",
      execute: () => {
        var o;
        const u = this.tracks.video;
        (this.lastVideoAppendEnd > i || u != null && u.buffer && ye.isBuffered(u.buffer, i) || ((o = this.fragmentTracker.getAppendedFrag(i, le.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"));
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (o) => {
        this.warn("Error executing block-audio operation", o);
      }
    };
    this.blockedAudioAppend = {
      op: a,
      frag: e
    }, this.append(a, "audio", !0);
  }
  unblockAudio() {
    const {
      blockedAudioAppend: e,
      operationQueue: n
    } = this;
    e && n && (this.blockedAudioAppend = null, n.unblockAudio(e.op));
  }
  onBufferAppending(e, n) {
    const {
      tracks: r
    } = this, {
      data: i,
      type: s,
      parent: a,
      frag: o,
      part: u,
      chunkMeta: l,
      offset: c
    } = n, d = l.buffering[s], {
      sn: f,
      cc: h
    } = o, m = self.performance.now();
    d.start = m;
    const p = o.stats.buffering, g = u ? u.stats.buffering : null;
    p.start === 0 && (p.start = m), g && g.start === 0 && (g.start = m);
    const E = r.audio;
    let y = !1;
    s === "audio" && (E == null ? void 0 : E.container) === "audio/mpeg" && (y = !this.lastMpegAudioChunk || l.id === 1 || this.lastMpegAudioChunk.sn !== l.sn, this.lastMpegAudioChunk = l);
    const T = r.video, S = T == null ? void 0 : T.buffer;
    if (S && f !== "initSegment") {
      const C = u || o, D = this.blockedAudioAppend;
      if (s === "audio" && a !== "main" && !this.blockedAudioAppend && !(T.ending || T.ended)) {
        const A = C.start + C.duration * 0.05, L = S.buffered, N = this.currentOp("video");
        !L.length && !N ? this.blockAudio(C) : !N && !ye.isBuffered(S, A) && this.lastVideoAppendEnd < A && this.blockAudio(C);
      } else if (s === "video") {
        const _ = C.end;
        if (D) {
          const A = D.frag.start;
          (_ > A || _ < this.lastVideoAppendEnd || ye.isBuffered(S, A)) && this.unblockAudio();
        }
        this.lastVideoAppendEnd = _;
      }
    }
    const v = (u || o).start, I = {
      label: `append-${s}`,
      execute: () => {
        var C;
        d.executeStart = self.performance.now();
        const D = (C = this.tracks[s]) == null ? void 0 : C.buffer;
        D && (y ? this.updateTimestampOffset(D, v, 0.1, s, f, h) : c !== void 0 && ue(c) && this.updateTimestampOffset(D, c, 1e-6, s, f, h)), this.appendExecutor(i, s);
      },
      onStart: () => {
      },
      onComplete: () => {
        const C = self.performance.now();
        d.executeEnd = d.end = C, p.first === 0 && (p.first = C), g && g.first === 0 && (g.first = C);
        const D = {};
        this.sourceBuffers.forEach(([_, A]) => {
          _ && (D[_] = ye.getBuffered(A));
        }), this.appendErrors[s] = 0, s === "audio" || s === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(x.BUFFER_APPENDED, {
          type: s,
          frag: o,
          part: u,
          chunkMeta: l,
          parent: o.type,
          timeRanges: D
        });
      },
      onError: (C) => {
        var D;
        const _ = {
          type: de.MEDIA_ERROR,
          parent: o.type,
          details: q.BUFFER_APPEND_ERROR,
          sourceBufferName: s,
          frag: o,
          part: u,
          chunkMeta: l,
          error: C,
          err: C,
          fatal: !1
        }, A = (D = this.media) == null ? void 0 : D.error;
        if (C.code === DOMException.QUOTA_EXCEEDED_ERR || C.name == "QuotaExceededError" || "quota" in C)
          _.details = q.BUFFER_FULL_ERROR;
        else if (C.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !A)
          _.errorAction = Li(!0);
        else if (C.name === iE && this.sourceBufferCount === 0)
          _.errorAction = Li(!0);
        else {
          const L = ++this.appendErrors[s];
          this.warn(`Failed ${L}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${s}" sourceBuffer (${A || "no media error"})`), (L >= this.hls.config.appendErrorMaxRetry || A) && (_.fatal = !0);
        }
        this.hls.trigger(x.ERROR, _);
      }
    };
    this.log(`queuing "${s}" append sn: ${f}${u ? " p: " + u.index : ""} of ${o.type === le.MAIN ? "level" : "track"} ${o.level} cc: ${h}`), this.append(I, s, this.isPending(this.tracks[s]));
  }
  getFlushOp(e, n, r) {
    return this.log(`queuing "${e}" remove ${n}-${r}`), {
      label: "remove",
      execute: () => {
        this.removeExecutor(e, n, r);
      },
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(x.BUFFER_FLUSHED, {
          type: e
        });
      },
      onError: (i) => {
        this.warn(`Failed to remove ${n}-${r} from "${e}" SourceBuffer`, i);
      }
    };
  }
  onBufferFlushing(e, n) {
    const {
      type: r,
      startOffset: i,
      endOffset: s
    } = n;
    r ? this.append(this.getFlushOp(r, i, s), r) : this.sourceBuffers.forEach(([a]) => {
      a && this.append(this.getFlushOp(a, i, s), a);
    });
  }
  onFragParsed(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = [], a = i ? i.elementaryStreams : r.elementaryStreams;
    a[Ve.AUDIOVIDEO] ? s.push("audiovideo") : (a[Ve.AUDIO] && s.push("audio"), a[Ve.VIDEO] && s.push("video"));
    const o = () => {
      const u = self.performance.now();
      r.stats.buffering.end = u, i && (i.stats.buffering.end = u);
      const l = i ? i.stats : r.stats;
      this.hls.trigger(x.FRAG_BUFFERED, {
        frag: r,
        part: i,
        stats: l,
        id: r.type
      });
    };
    s.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(o, s).catch((u) => {
      this.warn(`Fragment buffered callback ${u}`), this.stepOperationQueue(this.sourceBufferTypes);
    });
  }
  onFragChanged(e, n) {
    this.trimBuffers();
  }
  get bufferedToEnd() {
    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e]) => {
      if (e) {
        const n = this.tracks[e];
        if (n)
          return !n.ended || n.ending;
      }
      return !1;
    });
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(e, n) {
    var r;
    this.sourceBuffers.forEach(([a]) => {
      if (a) {
        const o = this.tracks[a];
        (!n.type || n.type === a) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${a} buffer reached EOS`)));
      }
    });
    const i = ((r = this.overrides) == null ? void 0 : r.endOfStream) !== !1;
    this.sourceBufferCount > 0 && !this.sourceBuffers.some(([a]) => {
      var o;
      return a && !((o = this.tracks[a]) != null && o.ended);
    }) ? i ? (this.log("Queueing EOS"), this.blockUntilOpen(() => {
      this.tracksEnded();
      const {
        mediaSource: a
      } = this;
      if (!a || a.readyState !== "open") {
        a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`);
        return;
      }
      this.log("Calling mediaSource.endOfStream()"), a.endOfStream(), this.hls.trigger(x.BUFFERED_TO_END, void 0);
    })) : (this.tracksEnded(), this.hls.trigger(x.BUFFERED_TO_END, void 0)) : n.type === "video" && this.unblockAudio();
  }
  tracksEnded() {
    this.sourceBuffers.forEach(([e]) => {
      if (e !== null) {
        const n = this.tracks[e];
        n && (n.ending = !1);
      }
    });
  }
  onLevelUpdated(e, {
    details: n
  }) {
    n.fragments.length && (this.details = n, this.updateDuration());
  }
  updateDuration() {
    this.blockUntilOpen(() => {
      const e = this.getDurationAndRange();
      e && this.updateMediaSource(e);
    });
  }
  onError(e, n) {
    if (n.details === q.BUFFER_APPEND_ERROR && n.frag) {
      var r;
      const i = (r = n.errorAction) == null ? void 0 : r.nextAutoLevel;
      ue(i) && i !== n.frag.level && this.resetAppendErrors();
    }
  }
  resetAppendErrors() {
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
  }
  trimBuffers() {
    const {
      hls: e,
      details: n,
      media: r
    } = this;
    if (!r || n === null || !this.sourceBufferCount)
      return;
    const i = e.config, s = r.currentTime, a = n.levelTargetDuration, o = n.live && i.liveBackBufferLength !== null ? i.liveBackBufferLength : i.backBufferLength;
    if (ue(o) && o >= 0) {
      const l = Math.max(o, a), c = Math.floor(s / a) * a - l;
      this.flushBackBuffer(s, a, c);
    }
    const u = i.frontBufferFlushThreshold;
    if (ue(u) && u > 0) {
      const l = Math.max(i.maxBufferLength, u), c = Math.max(l, a), d = Math.floor(s / a) * a + c;
      this.flushFrontBuffer(s, a, d);
    }
  }
  flushBackBuffer(e, n, r) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const o = ye.getBuffered(s);
        if (o.length > 0 && r > o.start(0)) {
          var a;
          this.hls.trigger(x.BACK_BUFFER_REACHED, {
            bufferEnd: r
          });
          const u = this.tracks[i];
          if ((a = this.details) != null && a.live)
            this.hls.trigger(x.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: r
            });
          else if (u != null && u.ended) {
            this.log(`Cannot flush ${i} back buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(x.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: r,
            type: i
          });
        }
      }
    });
  }
  flushFrontBuffer(e, n, r) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const a = ye.getBuffered(s), o = a.length;
        if (o < 2)
          return;
        const u = a.start(o - 1), l = a.end(o - 1);
        if (r > u || e >= u && e <= l)
          return;
        this.hls.trigger(x.BUFFER_FLUSHING, {
          startOffset: u,
          endOffset: 1 / 0,
          type: i
        });
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  getDurationAndRange() {
    var e;
    const {
      details: n,
      mediaSource: r
    } = this;
    if (!n || !this.media || (r == null ? void 0 : r.readyState) !== "open")
      return null;
    const i = n.edge;
    if (n.live && this.hls.config.liveDurationInfinity) {
      if (n.fragments.length && r.setLiveSeekableRange) {
        const l = Math.max(0, n.fragmentStart), c = Math.max(l, i);
        return {
          duration: 1 / 0,
          start: l,
          end: c
        };
      }
      return {
        duration: 1 / 0
      };
    }
    const s = (e = this.overrides) == null ? void 0 : e.duration;
    if (s)
      return ue(s) ? {
        duration: s
      } : null;
    const a = this.media.duration, o = ue(r.duration) ? r.duration : 0;
    return i > o && i > a || !ue(a) ? {
      duration: i
    } : null;
  }
  updateMediaSource({
    duration: e,
    start: n,
    end: r
  }) {
    const i = this.mediaSource;
    !this.media || !i || i.readyState !== "open" || (i.duration !== e && (ue(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), i.duration = e), n !== void 0 && r !== void 0 && (this.log(`MediaSource duration is set to ${i.duration}. Setting seekable range to ${n}-${r}.`), i.setLiveSeekableRange(n, r)));
  }
  get tracksReady() {
    const e = this.pendingTrackCount;
    return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsTotal: e,
      pendingTrackCount: n,
      tracks: r
    } = this;
    if (this.log(`checkPendingTracks (pending: ${n} codec events expected: ${e}) ${ze(r)}`), this.tracksReady) {
      var i;
      const s = (i = this.transferData) == null ? void 0 : i.tracks;
      s && Object.keys(s).length ? this.attachTransferred() : this.createSourceBuffers();
    }
  }
  bufferCreated() {
    if (this.sourceBufferCount) {
      const e = {};
      this.sourceBuffers.forEach(([n, r]) => {
        if (n) {
          const i = this.tracks[n];
          e[n] = {
            buffer: r,
            container: i.container,
            codec: i.codec,
            supplemental: i.supplemental,
            levelCodec: i.levelCodec,
            id: i.id,
            metadata: i.metadata
          };
        }
      }), this.hls.trigger(x.BUFFER_CREATED, {
        tracks: e
      }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([n]) => {
        this.executeNext(n);
      });
    } else {
      const e = new Error("could not create source buffer for media codec(s)");
      this.hls.trigger(x.ERROR, {
        type: de.MEDIA_ERROR,
        details: q.BUFFER_INCOMPATIBLE_CODECS_ERROR,
        fatal: !0,
        error: e,
        reason: e.message
      });
    }
  }
  createSourceBuffers() {
    const {
      tracks: e,
      sourceBuffers: n,
      mediaSource: r
    } = this;
    if (!r)
      throw new Error("createSourceBuffers called when mediaSource was null");
    for (const s in e) {
      const a = s, o = e[a];
      if (this.isPending(o)) {
        const u = this.getTrackCodec(o, a), l = `${o.container};codecs=${u}`;
        o.codec = u, this.log(`creating sourceBuffer(${l})${this.currentOp(a) ? " Queued" : ""} ${ze(o)}`);
        try {
          const c = r.addSourceBuffer(l), d = Cl(a), f = [a, c];
          n[d] = f, o.buffer = c;
        } catch (c) {
          var i;
          this.error(`error while trying to add sourceBuffer: ${c.message}`), this.shiftAndExecuteNext(a), (i = this.operationQueue) == null || i.removeBlockers(), delete this.tracks[a], this.hls.trigger(x.ERROR, {
            type: de.MEDIA_ERROR,
            details: q.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: c,
            sourceBufferName: a,
            mimeType: l,
            parent: o.id
          });
          return;
        }
        this.trackSourceBuffer(a, o);
      }
    }
    this.bufferCreated();
  }
  getTrackCodec(e, n) {
    const r = e.supplemental;
    let i = e.codec;
    r && (n === "video" || n === "audiovideo") && ea(r, "video") && (i = GC(i, r));
    const s = wo(i, e.levelCodec);
    return s ? n.slice(0, 5) === "audio" ? iu(s, this.appendSource) : s : "";
  }
  trackSourceBuffer(e, n) {
    const r = n.buffer;
    if (!r)
      return;
    const i = this.getTrackCodec(n, e);
    this.tracks[e] = {
      buffer: r,
      codec: i,
      container: n.container,
      levelCodec: n.levelCodec,
      supplemental: n.supplemental,
      metadata: n.metadata,
      id: n.id,
      listeners: []
    }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (s, a) => {
      const o = a.removedRanges;
      o != null && o.length && this.hls.trigger(x.BUFFER_FLUSHED, {
        type: s
      });
    });
  }
  get mediaSrc() {
    var e, n;
    const r = ((e = this.media) == null || (n = e.querySelector) == null ? void 0 : n.call(e, "source")) || this.media;
    return r == null ? void 0 : r.src;
  }
  onSBUpdateStart(e) {
    const n = this.currentOp(e);
    n && n.onStart();
  }
  onSBUpdateEnd(e) {
    var n;
    if (((n = this.mediaSource) == null ? void 0 : n.readyState) === "closed") {
      this.resetBuffer(e);
      return;
    }
    const r = this.currentOp(e);
    r && (r.onComplete(), this.shiftAndExecuteNext(e));
  }
  onSBUpdateError(e, n) {
    var r;
    const i = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`);
    this.error(`${i}`, n), this.hls.trigger(x.ERROR, {
      type: de.MEDIA_ERROR,
      details: q.BUFFER_APPENDING_ERROR,
      sourceBufferName: e,
      error: i,
      fatal: !1
    });
    const s = this.currentOp(e);
    s && s.onError(i);
  }
  updateTimestampOffset(e, n, r, i, s, a) {
    const o = n - e.timestampOffset;
    Math.abs(o) >= r && (this.log(`Updating ${i} SourceBuffer timestampOffset to ${n} (sn: ${s} cc: ${a})`), e.timestampOffset = n);
  }
  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
  removeExecutor(e, n, r) {
    const {
      media: i,
      mediaSource: s
    } = this, a = this.tracks[e], o = a == null ? void 0 : a.buffer;
    if (!i || !s || !o) {
      this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);
      return;
    }
    const u = ue(i.duration) ? i.duration : 1 / 0, l = ue(s.duration) ? s.duration : 1 / 0, c = Math.max(0, n), d = Math.min(r, u, l);
    d > c && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${c},${d}] from the ${e} SourceBuffer`), o.remove(c, d)) : this.shiftAndExecuteNext(e);
  }
  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
  appendExecutor(e, n) {
    const r = this.tracks[n], i = r == null ? void 0 : r.buffer;
    if (!i)
      throw new Q_(`Attempting to append to the ${n} SourceBuffer, but it does not exist`);
    r.ending = !1, r.ended = !1, i.appendBuffer(e);
  }
  blockUntilOpen(e) {
    if (this.isUpdating() || this.isQueued())
      this.blockBuffers(e).catch((n) => {
        this.warn(`SourceBuffer blocked callback ${n}`), this.stepOperationQueue(this.sourceBufferTypes);
      });
    else
      try {
        e();
      } catch (n) {
        this.warn(`Callback run without blocking ${this.operationQueue} ${n}`);
      }
  }
  isUpdating() {
    return this.sourceBuffers.some(([e, n]) => e && n.updating);
  }
  isQueued() {
    return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
  }
  isPending(e) {
    return !!e && !e.buffer;
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(e, n = this.sourceBufferTypes) {
    if (!n.length)
      return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
    const {
      operationQueue: r
    } = this, i = n.map((a) => this.appendBlocker(a));
    return n.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(i).then((a) => {
      r === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes));
    });
  }
  stepOperationQueue(e) {
    e.forEach((n) => {
      var r;
      const i = (r = this.tracks[n]) == null ? void 0 : r.buffer;
      !i || i.updating || this.shiftAndExecuteNext(n);
    });
  }
  append(e, n, r) {
    this.operationQueue && this.operationQueue.append(e, n, r);
  }
  appendBlocker(e) {
    if (this.operationQueue)
      return this.operationQueue.appendBlocker(e);
  }
  currentOp(e) {
    return this.operationQueue ? this.operationQueue.current(e) : null;
  }
  executeNext(e) {
    e && this.operationQueue && this.operationQueue.executeNext(e);
  }
  shiftAndExecuteNext(e) {
    this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
  }
  get pendingTrackCount() {
    return Object.keys(this.tracks).reduce((e, n) => e + (this.isPending(this.tracks[n]) ? 1 : 0), 0);
  }
  get sourceBufferCount() {
    return this.sourceBuffers.reduce((e, [n]) => e + (n ? 1 : 0), 0);
  }
  get sourceBufferTypes() {
    return this.sourceBuffers.map(([e]) => e).filter((e) => !!e);
  }
  addBufferListener(e, n, r) {
    const i = this.tracks[e];
    if (!i)
      return;
    const s = i.buffer;
    if (!s)
      return;
    const a = r.bind(this, e);
    i.listeners.push({
      event: n,
      listener: a
    }), s.addEventListener(n, a);
  }
  removeBufferListeners(e) {
    const n = this.tracks[e];
    if (!n)
      return;
    const r = n.buffer;
    r && (n.listeners.forEach((i) => {
      r.removeEventListener(i.event, i.listener);
    }), n.listeners.length = 0);
  }
}
function em(t) {
  const e = t.querySelectorAll("source");
  [].slice.call(e).forEach((n) => {
    t.removeChild(n);
  });
}
function J_(t, e) {
  const n = self.document.createElement("source");
  n.type = "video/mp4", n.src = e, t.appendChild(n);
}
function Cl(t) {
  return t === "audio" ? 1 : 0;
}
class Rf {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, n) {
    const r = this.hls.levels[n.droppedLevel];
    this.isLevelAllowed(r) && this.restrictedLevels.push({
      bitrate: r.bitrate,
      height: r.height,
      width: r.width
    });
  }
  onMediaAttaching(e, n) {
    this.media = n.media instanceof HTMLVideoElement ? n.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();
  }
  onManifestParsed(e, n) {
    const r = this.hls;
    this.restrictedLevels = [], this.firstLevel = n.firstLevel, r.config.capLevelToPlayerSize && n.video && this.startCapping();
  }
  onLevelsUpdated(e, n) {
    this.timer && ue(this.autoLevelCapping) && this.detectPlayerSize();
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(e, n) {
    this.hls.config.capLevelToPlayerSize && n.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping(), this.media = null;
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const e = this.hls.levels;
      if (e.length) {
        const n = this.hls, r = this.getMaxLevel(e.length - 1);
        r !== this.autoLevelCapping && n.logger.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), n.autoLevelCapping = r, n.autoLevelEnabled && n.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = n.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(e) {
    const n = this.hls.levels;
    if (!n.length)
      return -1;
    const r = n.filter((i, s) => this.isLevelAllowed(i) && s <= e);
    return this.clientRect = null, Rf.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media, n = {
      width: 0,
      height: 0
    };
    if (e) {
      const r = e.getBoundingClientRect();
      n.width = r.width, n.height = r.height, !n.width && !n.height && (n.width = r.right - r.left || e.width || 0, n.height = r.bottom - r.top || e.height || 0);
    }
    return this.clientRect = n, n;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {
      }
    return Math.min(e, this.hls.config.maxDevicePixelRatio);
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((r) => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height);
  }
  static getMaxLevelByMediaSize(e, n, r) {
    if (!(e != null && e.length))
      return -1;
    const i = (o, u) => u ? o.width !== u.width || o.height !== u.height : !0;
    let s = e.length - 1;
    const a = Math.max(n, r);
    for (let o = 0; o < e.length; o += 1) {
      const u = e[o];
      if ((u.width >= a || u.height >= a) && i(u, e[o + 1])) {
        s = o;
        break;
      }
    }
    return s;
  }
}
const e3 = {
  /**
   * text file, such as a manifest or playlist
   */
  MANIFEST: "m",
  /**
   * audio only
   */
  AUDIO: "a",
  /**
   * video only
   */
  VIDEO: "v",
  /**
   * muxed audio and video
   */
  MUXED: "av",
  /**
   * init segment
   */
  INIT: "i",
  /**
   * caption or subtitle
   */
  CAPTION: "c",
  /**
   * ISOBMFF timed text track
   */
  TIMED_TEXT: "tt",
  /**
   * cryptographic key, license or certificate.
   */
  KEY: "k",
  /**
   * other
   */
  OTHER: "o"
}, kt = e3, t3 = {
  /**
   * HTTP Live Streaming (HLS)
   */
  HLS: "h"
}, n3 = t3;
class Mn {
  constructor(e, n) {
    Array.isArray(e) && (e = e.map((r) => r instanceof Mn ? r : new Mn(r))), this.value = e, this.params = n;
  }
}
const r3 = "Dict";
function i3(t) {
  return Array.isArray(t) ? JSON.stringify(t) : t instanceof Map ? "Map{}" : t instanceof Set ? "Set{}" : typeof t == "object" ? JSON.stringify(t) : String(t);
}
function s3(t, e, n, r) {
  return new Error(`failed to ${t} "${i3(e)}" as ${n}`, {
    cause: r
  });
}
function Fn(t, e, n) {
  return s3("serialize", t, e, n);
}
class sE {
  constructor(e) {
    this.description = e;
  }
}
const tm = "Bare Item", a3 = "Boolean";
function o3(t) {
  if (typeof t != "boolean")
    throw Fn(t, a3);
  return t ? "?1" : "?0";
}
function u3(t) {
  return btoa(String.fromCharCode(...t));
}
const l3 = "Byte Sequence";
function c3(t) {
  if (ArrayBuffer.isView(t) === !1)
    throw Fn(t, l3);
  return `:${u3(t)}:`;
}
const d3 = "Integer";
function f3(t) {
  return t < -999999999999999 || 999999999999999 < t;
}
function aE(t) {
  if (f3(t))
    throw Fn(t, d3);
  return t.toString();
}
function h3(t) {
  return `@${aE(t.getTime() / 1e3)}`;
}
function oE(t, e) {
  if (t < 0)
    return -oE(-t, e);
  const n = Math.pow(10, e);
  if (Math.abs(t * n % 1 - 0.5) < Number.EPSILON) {
    const i = Math.floor(t * n);
    return (i % 2 === 0 ? i : i + 1) / n;
  } else
    return Math.round(t * n) / n;
}
const m3 = "Decimal";
function p3(t) {
  const e = oE(t, 3);
  if (Math.floor(Math.abs(e)).toString().length > 12)
    throw Fn(t, m3);
  const n = e.toString();
  return n.includes(".") ? n : `${n}.0`;
}
const g3 = "String", b3 = /[\x00-\x1f\x7f]+/;
function E3(t) {
  if (b3.test(t))
    throw Fn(t, g3);
  return `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function y3(t) {
  return t.description || t.toString().slice(7, -1);
}
const T3 = "Token";
function nm(t) {
  const e = y3(t);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
    throw Fn(e, T3);
  return e;
}
function Yc(t) {
  switch (typeof t) {
    case "number":
      if (!ue(t))
        throw Fn(t, tm);
      return Number.isInteger(t) ? aE(t) : p3(t);
    case "string":
      return E3(t);
    case "symbol":
      return nm(t);
    case "boolean":
      return o3(t);
    case "object":
      if (t instanceof Date)
        return h3(t);
      if (t instanceof Uint8Array)
        return c3(t);
      if (t instanceof sE)
        return nm(t);
    default:
      throw Fn(t, tm);
  }
}
const x3 = "Key";
function Xc(t) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(t) === !1)
    throw Fn(t, x3);
  return t;
}
function kf(t) {
  return t == null ? "" : Object.entries(t).map(([e, n]) => n === !0 ? `;${Xc(e)}` : `;${Xc(e)}=${Yc(n)}`).join("");
}
function uE(t) {
  return t instanceof Mn ? `${Yc(t.value)}${kf(t.params)}` : Yc(t);
}
function S3(t) {
  return `(${t.value.map(uE).join(" ")})${kf(t.params)}`;
}
function A3(t, e = {
  whitespace: !0
}) {
  if (typeof t != "object" || t == null)
    throw Fn(t, r3);
  const n = t instanceof Map ? t.entries() : Object.entries(t), r = e != null && e.whitespace ? " " : "";
  return Array.from(n).map(([i, s]) => {
    s instanceof Mn || (s = new Mn(s));
    let a = Xc(i);
    return s.value === !0 ? a += kf(s.params) : (a += "=", Array.isArray(s.value) ? a += S3(s) : a += uE(s)), a;
  }).join(`,${r}`);
}
function lE(t, e) {
  return A3(t, e);
}
const Tn = "CMCD-Object", et = "CMCD-Request", Or = "CMCD-Session", mr = "CMCD-Status", v3 = {
  // Object
  br: Tn,
  ab: Tn,
  d: Tn,
  ot: Tn,
  tb: Tn,
  tpb: Tn,
  lb: Tn,
  tab: Tn,
  lab: Tn,
  url: Tn,
  // Request
  pb: et,
  bl: et,
  tbl: et,
  dl: et,
  ltc: et,
  mtp: et,
  nor: et,
  nrr: et,
  rc: et,
  sn: et,
  sta: et,
  su: et,
  ttfb: et,
  ttfbb: et,
  ttlb: et,
  cmsdd: et,
  cmsds: et,
  smrt: et,
  df: et,
  cs: et,
  // TODO: Which header to put the `ts` field is not defined yet.
  ts: et,
  // Session
  cid: Or,
  pr: Or,
  sf: Or,
  sid: Or,
  st: Or,
  v: Or,
  msd: Or,
  // Status
  bs: mr,
  bsd: mr,
  cdn: mr,
  rtp: mr,
  bg: mr,
  pt: mr,
  ec: mr,
  e: mr
}, I3 = {
  /**
   * keys whose values vary with each request.
   */
  REQUEST: et
};
function C3(t) {
  return Object.keys(t).reduce((e, n) => {
    var r;
    return (r = t[n]) === null || r === void 0 || r.forEach((i) => e[i] = n), e;
  }, {});
}
function L3(t, e) {
  const n = {};
  if (!t)
    return n;
  const r = Object.keys(t), i = e ? C3(e) : {};
  return r.reduce((s, a) => {
    var o;
    const u = v3[a] || i[a] || I3.REQUEST, l = (o = s[u]) !== null && o !== void 0 ? o : s[u] = {};
    return l[a] = t[a], s;
  }, n);
}
function _3(t) {
  return ["ot", "sf", "st", "e", "sta"].includes(t);
}
function R3(t) {
  return typeof t == "number" ? ue(t) : t != null && t !== "" && t !== !1;
}
const cE = "event";
function k3(t, e) {
  const n = new URL(t), r = new URL(e);
  if (n.origin !== r.origin)
    return t;
  const i = n.pathname.split("/").slice(1), s = r.pathname.split("/").slice(1, -1);
  for (; i[0] === s[0]; )
    i.shift(), s.shift();
  for (; s.length; )
    s.shift(), i.unshift("..");
  return i.join("/") + n.search + n.hash;
}
const Mo = (t) => Math.round(t), Qc = (t, e) => Array.isArray(t) ? t.map((n) => Qc(n, e)) : t instanceof Mn && typeof t.value == "string" ? new Mn(Qc(t.value, e), t.params) : (e.baseUrl && (t = k3(t, e.baseUrl)), e.version === 1 ? encodeURIComponent(t) : t), to = (t) => Mo(t / 100) * 100, w3 = (t, e) => {
  let n = t;
  return e.version >= 2 && (t instanceof Mn && typeof t.value == "string" ? n = new Mn([t]) : typeof t == "string" && (n = [t])), Qc(n, e);
}, D3 = {
  /**
   * Bitrate (kbps) rounded integer
   */
  br: Mo,
  /**
   * Duration (milliseconds) rounded integer
   */
  d: Mo,
  /**
   * Buffer Length (milliseconds) rounded nearest 100ms
   */
  bl: to,
  /**
   * Deadline (milliseconds) rounded nearest 100ms
   */
  dl: to,
  /**
   * Measured Throughput (kbps) rounded nearest 100kbps
   */
  mtp: to,
  /**
   * Next Object Request URL encoded
   */
  nor: w3,
  /**
   * Requested maximum throughput (kbps) rounded nearest 100kbps
   */
  rtp: to,
  /**
   * Top Bitrate (kbps) rounded integer
   */
  tb: Mo
}, dE = "request", fE = "response", wf = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"], P3 = ["e"], O3 = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
function $u(t) {
  return O3.test(t);
}
function N3(t) {
  return wf.includes(t) || P3.includes(t) || $u(t);
}
const hE = ["d", "dl", "nor", "ot", "rtp", "su"];
function M3(t) {
  return wf.includes(t) || hE.includes(t) || $u(t);
}
const F3 = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"];
function B3(t) {
  return wf.includes(t) || hE.includes(t) || F3.includes(t) || $u(t);
}
const U3 = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"];
function $3(t) {
  return U3.includes(t) || $u(t);
}
const H3 = {
  [fE]: B3,
  [cE]: N3,
  [dE]: M3
};
function mE(t, e = {}) {
  const n = {};
  if (t == null || typeof t != "object")
    return n;
  const r = e.version || t.v || 1, i = e.reportingMode || dE, s = r === 1 ? $3 : H3[i];
  let a = Object.keys(t).filter(s);
  const o = e.filter;
  typeof o == "function" && (a = a.filter(o));
  const u = i === fE || i === cE;
  u && !a.includes("ts") && a.push("ts"), r > 1 && !a.includes("v") && a.push("v");
  const l = Ge({}, D3, e.formatters), c = {
    version: r,
    reportingMode: i,
    baseUrl: e.baseUrl
  };
  return a.sort().forEach((d) => {
    let f = t[d];
    const h = l[d];
    if (typeof h == "function" && (f = h(f, c)), d === "v") {
      if (r === 1)
        return;
      f = r;
    }
    d == "pr" && f === 1 || (u && d === "ts" && !ue(f) && (f = Date.now()), R3(f) && (_3(d) && typeof f == "string" && (f = new sE(f)), n[d] = f));
  }), n;
}
function G3(t, e = {}) {
  const n = {};
  if (!t)
    return n;
  const r = mE(t, e), i = L3(r, e == null ? void 0 : e.customHeaderMap);
  return Object.entries(i).reduce((s, [a, o]) => {
    const u = lE(o, {
      whitespace: !1
    });
    return u && (s[a] = u), s;
  }, n);
}
function V3(t, e, n) {
  return Ge(t, G3(e, n));
}
const z3 = "CMCD";
function q3(t, e = {}) {
  return t ? lE(mE(t, e), {
    whitespace: !1
  }) : "";
}
function j3(t, e = {}) {
  if (!t)
    return "";
  const n = q3(t, e);
  return encodeURIComponent(n);
}
function K3(t, e = {}) {
  if (!t)
    return "";
  const n = j3(t, e);
  return `${z3}=${n}`;
}
const rm = /CMCD=[^&#]+/;
function W3(t, e, n) {
  const r = K3(e, n);
  if (!r)
    return t;
  if (rm.test(t))
    return t.replace(rm, r);
  const i = t.includes("?") ? "&" : "?";
  return `${t}${i}${r}`;
}
class Y3 {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0;
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1;
    }, this.applyPlaylistData = (i) => {
      try {
        this.apply(i, {
          ot: kt.MANIFEST,
          su: !this.initialized
        });
      } catch (s) {
        this.hls.logger.warn("Could not generate manifest CMCD data.", s);
      }
    }, this.applyFragmentData = (i) => {
      try {
        const {
          frag: s,
          part: a
        } = i, o = this.hls.levels[s.level], u = this.getObjectType(s), l = {
          d: (a || s).duration * 1e3,
          ot: u
        };
        (u === kt.VIDEO || u === kt.AUDIO || u == kt.MUXED) && (l.br = o.bitrate / 1e3, l.tb = this.getTopBandwidth(u) / 1e3, l.bl = this.getBufferLength(u));
        const c = a ? this.getNextPart(a) : this.getNextFrag(s);
        c != null && c.url && c.url !== s.url && (l.nor = c.url), this.apply(i, l);
      } catch (s) {
        this.hls.logger.warn("Could not generate segment CMCD data.", s);
      }
    }, this.hls = e;
    const n = this.config = e.config, {
      cmcd: r
    } = n;
    r != null && (n.pLoader = this.createPlaylistLoader(), n.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e.sessionId, this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHED, this.onMediaDetached, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHED, this.onMediaDetached, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;
  }
  onMediaAttached(e, n) {
    this.media = n.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
  }
  onBufferCreated(e, n) {
    var r, i;
    this.audioBuffer = (r = n.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (i = n.tracks.video) == null ? void 0 : i.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var e;
    return {
      v: 1,
      sf: n3.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(e, n = {}) {
    Ge(n, this.createData());
    const r = n.ot === kt.INIT || n.ot === kt.VIDEO || n.ot === kt.MUXED;
    this.starved && r && (n.bs = !0, n.su = !0, this.starved = !1), n.su == null && (n.su = this.buffering);
    const {
      includeKeys: i
    } = this;
    i && (n = Object.keys(n).reduce((a, o) => (i.includes(o) && (a[o] = n[o]), a), {}));
    const s = {
      baseUrl: e.url
    };
    this.useHeaders ? (e.headers || (e.headers = {}), V3(e.headers, n, s)) : e.url = W3(e.url, n, s);
  }
  getNextFrag(e) {
    var n;
    const r = (n = this.hls.levels[e.level]) == null ? void 0 : n.details;
    if (r) {
      const i = e.sn - r.startSN;
      return r.fragments[i + 1];
    }
  }
  getNextPart(e) {
    var n;
    const {
      index: r,
      fragment: i
    } = e, s = (n = this.hls.levels[i.level]) == null || (n = n.details) == null ? void 0 : n.partList;
    if (s) {
      const {
        sn: a
      } = i;
      for (let o = s.length - 1; o >= 0; o--) {
        const u = s[o];
        if (u.index === r && u.fragment.sn === a)
          return s[o + 1];
      }
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(e) {
    const {
      type: n
    } = e;
    if (n === "subtitle")
      return kt.TIMED_TEXT;
    if (e.sn === "initSegment")
      return kt.INIT;
    if (n === "audio")
      return kt.AUDIO;
    if (n === "main")
      return this.hls.audioTracks.length ? kt.VIDEO : kt.MUXED;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(e) {
    let n = 0, r;
    const i = this.hls;
    if (e === kt.AUDIO)
      r = i.audioTracks;
    else {
      const s = i.maxAutoLevel, a = s > -1 ? s + 1 : i.levels.length;
      r = i.levels.slice(0, a);
    }
    return r.forEach((s) => {
      s.bitrate > n && (n = s.bitrate);
    }), n > 0 ? n : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(e) {
    const n = this.media, r = e === kt.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !r || !n ? NaN : ye.bufferInfo(r, n.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, n = this.applyPlaylistData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        n(s), this.loader.load(s, a, o);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, n = this.applyFragmentData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        n(s), this.loader.load(s, a, o);
      }
    };
  }
}
const X3 = 3e5;
class Q3 extends on {
  constructor(e) {
    super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.ERROR, this.onError, this));
  }
  pathways() {
    return (this.levels || []).reduce((e, n) => (e.indexOf(n.pathwayId) === -1 && e.push(n.pathwayId), e), []);
  }
  get pathwayPriority() {
    return this._pathwayPriority;
  }
  set pathwayPriority(e) {
    this.updatePathwayPriority(e);
  }
  startLoad() {
    if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
      if (this.updated) {
        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
        if (e > 0) {
          this.scheduleRefresh(this.uri, e);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();
  }
  clearTimeout() {
    this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(e) {
    const n = this.levels;
    n && (this.levels = n.filter((r) => r !== e));
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(e, n) {
    const {
      contentSteering: r
    } = n;
    r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad());
  }
  onManifestParsed(e, n) {
    this.audioTracks = n.audioTracks, this.subtitleTracks = n.subtitleTracks;
  }
  onError(e, n) {
    const {
      errorAction: r
    } = n;
    if ((r == null ? void 0 : r.action) === Tt.SendAlternateToPenaltyBox && r.flags === Wt.MoveAllAlternatesMatchingHost) {
      const i = this.levels;
      let s = this._pathwayPriority, a = this.pathwayId;
      if (n.context) {
        const {
          groupId: o,
          pathwayId: u,
          type: l
        } = n.context;
        o && i ? a = this.getPathwayForGroupId(o, l, a) : u && (a = u);
      }
      a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()), !s && i && (s = this.pathways()), s && s.length > 1 && (this.updatePathwayPriority(s), r.resolved = this.pathwayId !== a), n.details === q.BUFFER_APPEND_ERROR && !n.fatal ? r.resolved = !0 : r.resolved || this.warn(`Could not resolve ${n.details} ("${n.error.message}") with content-steering for Pathway: ${a} levels: ${i && i.length} priorities: ${ze(s)} penalized: ${ze(this.penalizedPathways)}`);
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let n = this.getLevelsForPathway(this.pathwayId);
    if (n.length === 0) {
      const r = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), n = this.getLevelsForPathway(r), this.pathwayId = r;
    }
    return n.length !== e.length && this.log(`Found ${n.length}/${e.length} levels in Pathway "${this.pathwayId}"`), n;
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((n) => e === n.pathwayId);
  }
  updatePathwayPriority(e) {
    this._pathwayPriority = e;
    let n;
    const r = this.penalizedPathways, i = performance.now();
    Object.keys(r).forEach((s) => {
      i - r[s] > X3 && delete r[s];
    });
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (a in r)
        continue;
      if (a === this.pathwayId)
        return;
      const o = this.hls.nextLoadLevel, u = this.hls.levels[o];
      if (n = this.getLevelsForPathway(a), n.length > 0) {
        this.log(`Setting Pathway to "${a}"`), this.pathwayId = a, Ob(n), this.hls.trigger(x.LEVELS_UPDATED, {
          levels: n
        });
        const l = this.hls.levels[o];
        u && l && this.levels && (l.attrs["STABLE-VARIANT-ID"] !== u.attrs["STABLE-VARIANT-ID"] && l.bitrate !== u.bitrate && this.log(`Unstable Pathways change from bitrate ${u.bitrate} to ${l.bitrate}`), this.hls.nextLoadLevel = o);
        break;
      }
    }
  }
  getPathwayForGroupId(e, n, r) {
    const i = this.getLevelsForPathway(r).concat(this.levels || []);
    for (let s = 0; s < i.length; s++)
      if (n === _e.AUDIO_TRACK && i[s].hasAudioGroup(e) || n === _e.SUBTITLE_TRACK && i[s].hasSubtitleGroup(e))
        return i[s].pathwayId;
    return r;
  }
  clonePathways(e) {
    const n = this.levels;
    if (!n)
      return;
    const r = {}, i = {};
    e.forEach((s) => {
      const {
        ID: a,
        "BASE-ID": o,
        "URI-REPLACEMENT": u
      } = s;
      if (n.some((c) => c.pathwayId === a))
        return;
      const l = this.getLevelsForPathway(o).map((c) => {
        const d = new Ze(c.attrs);
        d["PATHWAY-ID"] = a;
        const f = d.AUDIO && `${d.AUDIO}_clone_${a}`, h = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`;
        f && (r[d.AUDIO] = f, d.AUDIO = f), h && (i[d.SUBTITLES] = h, d.SUBTITLES = h);
        const m = pE(c.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", u), p = new na({
          attrs: d,
          audioCodec: c.audioCodec,
          bitrate: c.bitrate,
          height: c.height,
          name: c.name,
          url: m,
          videoCodec: c.videoCodec,
          width: c.width
        });
        if (c.audioGroups)
          for (let g = 1; g < c.audioGroups.length; g++)
            p.addGroupId("audio", `${c.audioGroups[g]}_clone_${a}`);
        if (c.subtitleGroups)
          for (let g = 1; g < c.subtitleGroups.length; g++)
            p.addGroupId("text", `${c.subtitleGroups[g]}_clone_${a}`);
        return p;
      });
      n.push(...l), im(this.audioTracks, r, u, a), im(this.subtitleTracks, i, u, a);
    });
  }
  loadSteeringManifest(e) {
    const n = this.hls.config, r = n.loader;
    this.loader && this.loader.destroy(), this.loader = new r(n);
    let i;
    try {
      i = new self.URL(e);
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (i.protocol !== "data:") {
      const c = (this.hls.bandwidthEstimate || n.abrEwmaDefaultEstimate) | 0;
      i.searchParams.set("_HLS_pathway", this.pathwayId), i.searchParams.set("_HLS_throughput", "" + c);
    }
    const s = {
      responseType: "json",
      url: i.href
    }, a = n.steeringManifestLoadPolicy.default, o = a.errorRetry || a.timeoutRetry || {}, u = {
      loadPolicy: a,
      timeout: a.maxLoadTimeMs,
      maxRetry: o.maxNumRetry || 0,
      retryDelay: o.retryDelayMs || 0,
      maxRetryDelay: o.maxRetryDelayMs || 0
    }, l = {
      onSuccess: (c, d, f, h) => {
        this.log(`Loaded steering manifest: "${i}"`);
        const m = c.data;
        if ((m == null ? void 0 : m.VERSION) !== 1) {
          this.log(`Steering VERSION ${m.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now(), this.timeToLoad = m.TTL;
        const {
          "RELOAD-URI": p,
          "PATHWAY-CLONES": g,
          "PATHWAY-PRIORITY": E
        } = m;
        if (p)
          try {
            this.uri = new self.URL(p, i).href;
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${p}`);
            return;
          }
        this.scheduleRefresh(this.uri || f.url), g && this.clonePathways(g);
        const y = {
          steeringManifest: m,
          url: i.toString()
        };
        this.hls.trigger(x.STEERING_MANIFEST_LOADED, y), E && this.updatePathwayPriority(E);
      },
      onError: (c, d, f, h) => {
        if (this.log(`Error loading steering manifest: ${c.code} ${c.text} (${d.url})`), this.stopLoad(), c.code === 410) {
          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);
          return;
        }
        let m = this.timeToLoad * 1e3;
        if (c.code === 429) {
          const p = this.loader;
          if (typeof (p == null ? void 0 : p.getResponseHeader) == "function") {
            const g = p.getResponseHeader("Retry-After");
            g && (m = parseFloat(g) * 1e3);
          }
          this.log(`Steering manifest ${d.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || d.url, m);
      },
      onTimeout: (c, d, f) => {
        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);
      }
    };
    this.log(`Requesting steering manifest: ${i}`), this.loader.load(s, u, l);
  }
  scheduleRefresh(e, n = this.timeToLoad * 1e3) {
    this.clearTimeout(), this.reloadTimer = self.setTimeout(() => {
      var r;
      const i = (r = this.hls) == null ? void 0 : r.media;
      if (i && !i.ended) {
        this.loadSteeringManifest(e);
        return;
      }
      this.scheduleRefresh(e, this.timeToLoad * 1e3);
    }, n);
  }
}
function im(t, e, n, r) {
  t && Object.keys(e).forEach((i) => {
    const s = t.filter((a) => a.groupId === i).map((a) => {
      const o = Ge({}, a);
      return o.details = void 0, o.attrs = new Ze(o.attrs), o.url = o.attrs.URI = pE(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", n), o.groupId = o.attrs["GROUP-ID"] = e[i], o.attrs["PATHWAY-ID"] = r, o;
    });
    t.push(...s);
  });
}
function pE(t, e, n, r) {
  const {
    HOST: i,
    PARAMS: s,
    [n]: a
  } = r;
  let o;
  e && (o = a == null ? void 0 : a[e], o && (t = o));
  const u = new self.URL(t);
  return i && !o && (u.host = i), s && Object.keys(s).sort().forEach((l) => {
    l && u.searchParams.set(l, s[l]);
  }), u.href;
}
class Ri extends on {
  constructor(e) {
    super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = Ri.CDMCleanupPromise ? [Ri.CDMCleanupPromise] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = (n) => {
      const {
        initDataType: r,
        initData: i
      } = n, s = `"${n.type}" event: init data type: "${r}"`;
      if (this.debug(s), i !== null) {
        if (!this.keyFormatPromise) {
          let a = Object.keys(this.keySystemAccessPromises);
          a.length || (a = Ds(this.config));
          const o = a.map(El).filter((u) => !!u);
          this.keyFormatPromise = this.getKeyFormatPromise(o);
        }
        this.keyFormatPromise.then((a) => {
          const o = Po(a);
          if (r !== "sinf" || o !== Je.FAIRPLAY) {
            this.log(`Ignoring "${n.type}" event with init data type: "${r}" for selected key-system ${o}`);
            return;
          }
          let u;
          try {
            const h = dt(new Uint8Array(i)), m = yf(JSON.parse(h).sinf), p = lb(m);
            if (!p)
              throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
            u = new Uint8Array(p.subarray(8, 24));
          } catch (h) {
            this.warn(`${s} Failed to parse sinf: ${h}`);
            return;
          }
          const l = Lt(u), {
            keyIdToKeySessionPromise: c,
            mediaKeySessions: d
          } = this;
          let f = c[l];
          for (let h = 0; h < d.length; h++) {
            const m = d[h], p = m.decryptdata;
            if (!p.keyId)
              continue;
            const g = Lt(p.keyId);
            if (lu(u, p.keyId) || p.uri.replace(/-/g, "").indexOf(l) !== -1) {
              if (f = c[g], !f)
                continue;
              if (p.pssh)
                break;
              delete c[g], p.pssh = new Uint8Array(i), p.keyId = u, f = c[l] = f.then(() => this.generateRequestWithPreferredKeySession(m, r, i, "encrypted-event-key-match")), f.catch((E) => this.handleError(E));
              break;
            }
          }
          f || this.handleError(new Error(`Key ID ${l} not encountered in playlist. Key-system sessions ${d.length}.`));
        }).catch((a) => this.handleError(a));
      }
    }, this.onWaitingForKey = (n) => {
      this.log(`"${n.type}" event`);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  destroy() {
    this.onDestroying(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(x.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(x.DESTROYING, this.onDestroying, this);
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: n,
      widevineLicenseUrl: r
    } = this.config, i = n == null ? void 0 : n[e];
    if (i)
      return i.licenseUrl;
    if (e === Je.WIDEVINE && r)
      return r;
  }
  getLicenseServerUrlOrThrow(e) {
    const n = this.getLicenseServerUrl(e);
    if (n === void 0)
      throw new Error(`no license server URL configured for key-system "${e}"`);
    return n;
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: n
    } = this.config, r = n == null ? void 0 : n[e];
    if (r)
      return r.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const n = this.hls.levels, r = (a, o, u) => !!a && u.indexOf(a) === o, i = n.map((a) => a.audioCodec).filter(r), s = n.map((a) => a.videoCodec).filter(r);
    return i.length + s.length === 0 && s.push("avc1.42e01e"), new Promise((a, o) => {
      const u = (l) => {
        const c = l.shift();
        this.getMediaKeysPromise(c, i, s).then((d) => a({
          keySystem: c,
          mediaKeys: d
        })).catch((d) => {
          l.length ? u(l) : d instanceof Vt ? o(d) : o(new Vt({
            type: de.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_NO_ACCESS,
            error: d,
            fatal: !0
          }, d.message));
        });
      };
      u(e);
    });
  }
  requestMediaKeySystemAccess(e, n) {
    const {
      requestMediaKeySystemAccessFunc: r
    } = this.config;
    if (typeof r != "function") {
      let i = `Configured requestMediaKeySystemAccess is not a function ${r}`;
      return Cb === null && self.location.protocol === "http:" && (i = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(i));
    }
    return r(e, n);
  }
  getMediaKeysPromise(e, n, r) {
    var i;
    const s = wL(e, n, r, this.config.drmSystemOptions || {});
    let a = this.keySystemAccessPromises[e], o = (i = a) == null ? void 0 : i.keySystemAccess;
    if (!o) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${ze(s)}`), o = this.requestMediaKeySystemAccess(e, s);
      const u = a = this.keySystemAccessPromises[e] = {
        keySystemAccess: o
      };
      return o.catch((l) => {
        this.log(`Failed to obtain access to key-system "${e}": ${l}`);
      }), o.then((l) => {
        this.log(`Access for key-system "${l.keySystem}" obtained`);
        const c = this.fetchServerCertificate(e);
        this.log(`Create media-keys for "${e}"`);
        const d = u.mediaKeys = l.createMediaKeys().then((f) => (this.log(`Media-keys created for "${e}"`), u.hasMediaKeys = !0, c.then((h) => h ? this.setMediaKeysServerCertificate(f, e, h) : f)));
        return d.catch((f) => {
          this.error(`Failed to create media-keys for "${e}"}: ${f}`);
        }), d;
      });
    }
    return o.then(() => a.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: n,
    mediaKeys: r
  }) {
    this.log(`Creating key-system session "${n}" keyId: ${Lt(e.keyId || [])} keyUri: ${e.uri}`);
    const i = r.createSession(), s = {
      decryptdata: e,
      keySystem: n,
      mediaKeys: r,
      mediaKeysSession: i,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(s), s;
  }
  renewKeySession(e) {
    const n = e.decryptdata;
    if (n.pssh) {
      const r = this.createMediaKeySessionContext(e), i = no(n), s = "cenc";
      this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(r, s, n.pssh.buffer, "expired");
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  updateKeySession(e, n) {
    const r = e.mediaKeysSession;
    return this.log(`Updating key-session "${r.sessionId}" for keyId ${Lt(e.decryptdata.keyId || [])}
      } (data length: ${n.byteLength})`), r.update(n);
  }
  getSelectedKeySystemFormats() {
    return Object.keys(this.keySystemAccessPromises).map((e) => ({
      keySystem: e,
      hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
    })).filter(({
      hasMediaKeys: e
    }) => !!e).map(({
      keySystem: e
    }) => El(e)).filter((e) => !!e);
  }
  getKeySystemAccess(e) {
    return this.getKeySystemSelectionPromise(e).then(({
      keySystem: n,
      mediaKeys: r
    }) => this.attemptSetMediaKeys(n, r));
  }
  selectKeySystem(e) {
    return new Promise((n, r) => {
      this.getKeySystemSelectionPromise(e).then(({
        keySystem: i
      }) => {
        const s = El(i);
        s ? n(s) : r(new Error(`Unable to find format for key-system "${i}"`));
      }).catch(r);
    });
  }
  selectKeySystemFormat(e) {
    const n = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${n.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(n)), this.keyFormatPromise;
  }
  getKeyFormatPromise(e) {
    const n = Ds(this.config), r = e.map(Po).filter((i) => !!i && n.indexOf(i) !== -1);
    return this.selectKeySystem(r);
  }
  getKeyStatus(e) {
    const {
      mediaKeySessions: n
    } = this;
    for (let r = 0; r < n.length; r++) {
      const i = Z3(e, n[r]);
      if (i)
        return i;
    }
  }
  loadKey(e) {
    const n = e.keyInfo.decryptdata, r = no(n), i = this.bannedKeyIds[r];
    if (i || this.getKeyStatus(n) === "internal-error") {
      const o = sm(i || "internal-error", n);
      return this.handleError(o, e.frag), Promise.reject(o);
    }
    const s = `(keyId: ${r} format: "${n.keyFormat}" method: ${n.method} uri: ${n.uri})`;
    this.log(`Starting session for key ${s}`);
    const a = this.keyIdToKeySessionPromise[r];
    if (!a) {
      const o = this.getKeySystemForKeyPromise(n).then(({
        keySystem: u,
        mediaKeys: l
      }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${s}`), this.attemptSetMediaKeys(u, l).then(() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({
        keySystem: u,
        mediaKeys: l,
        decryptdata: n
      }))))).then((u) => {
        const l = "cenc", c = n.pssh ? n.pssh.buffer : null;
        return this.generateRequestWithPreferredKeySession(u, l, c, "playlist-key");
      });
      return o.catch((u) => this.handleError(u, e.frag)), this.keyIdToKeySessionPromise[r] = o, o;
    }
    return a.catch((o) => {
      if (o instanceof Vt) {
        const u = Fe({}, o.data);
        this.getKeyStatus(n) === "internal-error" && (u.decryptdata = n);
        const l = new Vt(u, o.message);
        this.handleError(l, e.frag);
      }
    }), a;
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls)
      throw new Error("invalid state");
  }
  handleError(e, n) {
    if (this.hls)
      if (e instanceof Vt) {
        n && (e.data.frag = n);
        const r = e.data.decryptdata;
        this.error(`${e.message}${r ? ` (${Lt(r.keyId || [])})` : ""}`), this.hls.trigger(x.ERROR, e.data);
      } else
        this.error(e.message), this.hls.trigger(x.ERROR, {
          type: de.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_NO_KEYS,
          error: e,
          fatal: !0
        });
  }
  getKeySystemForKeyPromise(e) {
    const n = no(e), r = this.keyIdToKeySessionPromise[n];
    if (!r) {
      const i = Po(e.keyFormat), s = i ? [i] : Ds(this.config);
      return this.attemptKeySystemAccess(s);
    }
    return r;
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = Ds(this.config)), e.length === 0)
      throw new Vt({
        type: de.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      }, `Missing key-system license configuration options ${ze({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e);
  }
  attemptSetMediaKeys(e, n) {
    if (this.mediaKeys === n)
      return Promise.resolve();
    const r = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const i = Promise.all(r).then(() => {
      if (!this.media)
        throw this.mediaKeys = null, new Error("Attempted to set mediaKeys without media element attached");
      return this.media.setMediaKeys(n);
    });
    return this.mediaKeys = n, this.setMediaKeysQueue.push(i), i.then(() => {
      this.log(`Media-keys set for "${e}"`), r.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((s) => r.indexOf(s) === -1);
    });
  }
  generateRequestWithPreferredKeySession(e, n, r, i) {
    var s;
    const a = (s = this.config.drmSystems) == null || (s = s[e.keySystem]) == null ? void 0 : s.generateRequest;
    if (a)
      try {
        const m = a.call(this.hls, n, r, e);
        if (!m)
          throw new Error("Invalid response from configured generateRequest filter");
        n = m.initDataType, r = m.initData ? m.initData : null, e.decryptdata.pssh = r ? new Uint8Array(r) : null;
      } catch (m) {
        if (this.warn(m.message), this.hls && this.hls.config.debug)
          throw m;
      }
    if (r === null)
      return this.log(`Skipping key-session request for "${i}" (no initData)`), Promise.resolve(e);
    const o = no(e.decryptdata), u = e.decryptdata.uri;
    this.log(`Generating key-session request for "${i}" keyId: ${o} URI: ${u} (init data type: ${n} length: ${r.byteLength})`);
    const l = new xf(), c = e._onmessage = (m) => {
      const p = e.mediaKeysSession;
      if (!p) {
        l.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType: g,
        message: E
      } = m;
      this.log(`"${g}" message event for session "${p.sessionId}" message size: ${E.byteLength}`), g === "license-request" || g === "license-renewal" ? this.renewLicense(e, E).catch((y) => {
        l.eventNames().length ? l.emit("error", y) : this.handleError(y);
      }) : g === "license-release" ? e.keySystem === Je.FAIRPLAY && this.updateKeySession(e, Vc("acknowledged")).then(() => this.removeSession(e)).catch((y) => this.handleError(y)) : this.warn(`unhandled media key message type "${g}"`);
    }, d = (m, p) => {
      p.keyStatus = m;
      let g;
      m.startsWith("usable") ? l.emit("resolved") : m === "internal-error" || m === "output-restricted" || m === "output-downscaled" ? g = sm(m, p.decryptdata) : m === "expired" ? g = new Error(`key expired (keyId: ${o})`) : m === "released" ? g = new Error("key released") : m === "status-pending" || this.warn(`unhandled key status change "${m}" (keyId: ${o})`), g && (l.eventNames().length ? l.emit("error", g) : this.handleError(g));
    }, f = e._onkeystatuseschange = (m) => {
      if (!e.mediaKeysSession) {
        l.emit("error", new Error("invalid state"));
        return;
      }
      const g = this.getKeyStatuses(e);
      if (!Object.keys(g).some((S) => g[S] !== "status-pending"))
        return;
      if (g[o] === "expired") {
        this.log(`Expired key ${ze(g)} in key-session "${e.mediaKeysSession.sessionId}"`), this.renewKeySession(e);
        return;
      }
      let y = g[o];
      if (y)
        d(y, e);
      else {
        var T;
        e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (T = e.keyStatusTimeouts)[o] || (T[o] = self.setTimeout(() => {
          if (!e.mediaKeysSession || !this.mediaKeys)
            return;
          const v = this.getKeyStatus(e.decryptdata);
          if (v && v !== "status-pending")
            return this.log(`No status for keyId ${o} in key-session "${e.mediaKeysSession.sessionId}". Using session key-status ${v} from other session.`), d(v, e);
          this.log(`key status for ${o} in key-session "${e.mediaKeysSession.sessionId}" timed out after 1000ms`), y = "internal-error", d(y, e);
        }, 1e3)), this.log(`No status for keyId ${o} (${ze(g)}).`);
      }
    };
    _t(e.mediaKeysSession, "message", c), _t(e.mediaKeysSession, "keystatuseschange", f);
    const h = new Promise((m, p) => {
      l.on("error", p), l.on("resolved", m);
    });
    return e.mediaKeysSession.generateRequest(n, r).then(() => {
      this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${o} URI: ${u}`);
    }).catch((m) => {
      throw new Vt({
        type: de.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_SESSION,
        error: m,
        decryptdata: e.decryptdata,
        fatal: !1
      }, `Error generating key-session request: ${m}`);
    }).then(() => h).catch((m) => (l.removeAllListeners(), this.removeSession(e).then(() => {
      throw m;
    }))).then(() => (l.removeAllListeners(), e));
  }
  getKeyStatuses(e) {
    const n = {};
    return e.mediaKeysSession.keyStatuses.forEach((r, i) => {
      if (typeof i == "string" && typeof r == "object") {
        const o = i;
        i = r, r = o;
      }
      const s = "buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i);
      e.keySystem === Je.PLAYREADY && s.length === 16 && vb(s);
      const a = Lt(s);
      r === "internal-error" && (this.bannedKeyIds[a] = r), this.log(`key status change "${r}" for keyStatuses keyId: ${a} key-session "${e.mediaKeysSession.sessionId}"`), n[a] = r;
    }), n;
  }
  fetchServerCertificate(e) {
    const n = this.config, r = n.loader, i = new r(n), s = this.getServerCertificateUrl(e);
    return s ? (this.log(`Fetching server certificate for "${e}"`), new Promise((a, o) => {
      const u = {
        responseType: "arraybuffer",
        url: s
      }, l = n.certLoadPolicy.default, c = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, m, p) => {
          a(f.data);
        },
        onError: (f, h, m, p) => {
          o(new Vt({
            type: de.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: m,
            response: Fe({
              url: u.url,
              data: void 0
            }, f)
          }, `"${e}" certificate request failed (${s}). Status: ${f.code} (${f.text})`));
        },
        onTimeout: (f, h, m) => {
          o(new Vt({
            type: de.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: m,
            response: {
              url: u.url,
              data: void 0
            }
          }, `"${e}" certificate request timed out (${s})`));
        },
        onAbort: (f, h, m) => {
          o(new Error("aborted"));
        }
      };
      i.load(u, c, d);
    })) : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, n, r) {
    return new Promise((i, s) => {
      e.setServerCertificate(r).then((a) => {
        this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${r.byteLength}) on "${n}"`), i(e);
      }).catch((a) => {
        s(new Vt({
          type: de.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: a,
          fatal: !0
        }, a.message));
      });
    });
  }
  renewLicense(e, n) {
    return this.requestLicense(e, new Uint8Array(n)).then((r) => this.updateKeySession(e, new Uint8Array(r)).catch((i) => {
      throw new Vt({
        type: de.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        decryptdata: e.decryptdata,
        error: i,
        fatal: !1
      }, i.message);
    }));
  }
  unpackPlayReadyKeyMessage(e, n) {
    const r = String.fromCharCode.apply(null, new Uint16Array(n.buffer));
    if (!r.includes("PlayReadyKeyMessage"))
      return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), n;
    const i = new DOMParser().parseFromString(r, "application/xml"), s = i.querySelectorAll("HttpHeader");
    if (s.length > 0) {
      let c;
      for (let d = 0, f = s.length; d < f; d++) {
        var a, o;
        c = s[d];
        const h = (a = c.querySelector("name")) == null ? void 0 : a.textContent, m = (o = c.querySelector("value")) == null ? void 0 : o.textContent;
        h && m && e.setRequestHeader(h, m);
      }
    }
    const u = i.querySelector("Challenge"), l = u == null ? void 0 : u.textContent;
    if (!l)
      throw new Error("Cannot find <Challenge> in key message");
    return Vc(atob(l));
  }
  setupLicenseXHR(e, n, r, i) {
    const s = this.config.licenseXhrSetup;
    return s ? Promise.resolve().then(() => {
      if (!r.decryptdata)
        throw new Error("Key removed");
      return s.call(this.hls, e, n, r, i);
    }).catch((a) => {
      if (!r.decryptdata)
        throw a;
      return e.open("POST", n, !0), s.call(this.hls, e, n, r, i);
    }).then((a) => (e.readyState || e.open("POST", n, !0), {
      xhr: e,
      licenseChallenge: a || i
    })) : (e.open("POST", n, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: i
    }));
  }
  requestLicense(e, n) {
    const r = this.config.keyLoadPolicy.default;
    return new Promise((i, s) => {
      const a = this.getLicenseServerUrlOrThrow(e.keySystem);
      this.log(`Sending license request to URL: ${a}`);
      const o = new XMLHttpRequest();
      o.responseType = "arraybuffer", o.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession)
          return s(new Error("invalid state"));
        if (o.readyState === 4)
          if (o.status === 200) {
            this._requestLicenseFailureCount = 0;
            let u = o.response;
            this.log(`License received ${u instanceof ArrayBuffer ? u.byteLength : u}`);
            const l = this.config.licenseResponseCallback;
            if (l)
              try {
                u = l.call(this.hls, o, a, e);
              } catch (c) {
                this.error(c);
              }
            i(u);
          } else {
            const u = r.errorRetry, l = u ? u.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || o.status >= 400 && o.status < 500)
              s(new Vt({
                type: de.KEY_SYSTEM_ERROR,
                details: q.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                decryptdata: e.decryptdata,
                fatal: !0,
                networkDetails: o,
                response: {
                  url: a,
                  data: void 0,
                  code: o.status,
                  text: o.statusText
                }
              }, `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`));
            else {
              const c = l - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${c} attempts left`), this.requestLicense(e, n).then(i, s);
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, a, e, n).then(({
        xhr: u,
        licenseChallenge: l
      }) => {
        e.keySystem == Je.PLAYREADY && (l = this.unpackPlayReadyKeyMessage(u, l)), u.send(l);
      }).catch(s);
    });
  }
  onDestroying() {
    this.unregisterListeners(), this._clear();
  }
  onMediaAttached(e, n) {
    if (!this.config.emeEnabled)
      return;
    const r = n.media;
    this.media = r, _t(r, "encrypted", this.onMediaEncrypted), _t(r, "waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const e = this.media;
    e && (Ot(e, "encrypted", this.onMediaEncrypted), Ot(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null);
  }
  _clear() {
    var e;
    if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {}, !this.mediaKeys && !this.mediaKeySessions.length)
      return;
    const n = this.media, r = this.mediaKeySessions.slice();
    this.mediaKeySessions = [], this.mediaKeys = null, zr.clearKeyUriToKeyIdMap();
    const i = r.length;
    Ri.CDMCleanupPromise = Promise.all(r.map((s) => this.removeSession(s)).concat((n == null || (e = n.setMediaKeys(null)) == null ? void 0 : e.catch((s) => {
      this.log(`Could not clear media keys: ${s}`), this.hls && this.hls.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
        fatal: !1,
        error: new Error(`Could not clear media keys: ${s}`)
      });
    })) || Promise.resolve())).catch((s) => {
      this.log(`Could not close sessions and clear media keys: ${s}`), this.hls && this.hls.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
        fatal: !1,
        error: new Error(`Could not close sessions and clear media keys: ${s}`)
      });
    }).then(() => {
      i && this.log("finished closing key sessions and clearing media keys");
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null, this.bannedKeyIds = {};
  }
  onManifestLoaded(e, {
    sessionKeys: n
  }) {
    if (!(!n || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const r = n.reduce((i, s) => (i.indexOf(s.keyFormat) === -1 && i.push(s.keyFormat), i), []);
      this.log(`Selecting key-system from session-keys ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r);
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: n,
      licenseXhr: r,
      decryptdata: i
    } = e;
    if (n) {
      this.log(`Remove licenses and keys and close session "${n.sessionId}" keyId: ${Lt((i == null ? void 0 : i.keyId) || [])}`), e._onmessage && (n.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (n.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const s = this.mediaKeySessions.indexOf(e);
      s > -1 && this.mediaKeySessions.splice(s, 1);
      const {
        keyStatusTimeouts: a
      } = e;
      a && Object.keys(a).forEach((l) => self.clearTimeout(a[l]));
      const {
        drmSystemOptions: o
      } = this.config;
      return (PL(o) ? new Promise((l, c) => {
        self.setTimeout(() => c(new Error("MediaKeySession.remove() timeout")), 8e3), n.remove().then(l).catch(c);
      }) : Promise.resolve()).catch((l) => {
        this.log(`Could not remove session: ${l}`), this.hls && this.hls.trigger(x.ERROR, {
          type: de.OTHER_ERROR,
          details: q.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not remove session: ${l}`)
        });
      }).then(() => n.close()).catch((l) => {
        this.log(`Could not close session: ${l}`), this.hls && this.hls.trigger(x.ERROR, {
          type: de.OTHER_ERROR,
          details: q.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not close session: ${l}`)
        });
      });
    }
    return Promise.resolve();
  }
}
Ri.CDMCleanupPromise = void 0;
function no(t) {
  if (!t)
    throw new Error("Could not read keyId of undefined decryptdata");
  if (t.keyId === null)
    throw new Error("keyId is null");
  return Lt(t.keyId);
}
function Z3(t, e) {
  if (t.keyId && e.mediaKeysSession.keyStatuses.has(t.keyId))
    return e.mediaKeysSession.keyStatuses.get(t.keyId);
  if (t.matches(e.decryptdata))
    return e.keyStatus;
}
class Vt extends Error {
  constructor(e, n) {
    super(n), this.data = void 0, e.error || (e.error = new Error(n)), this.data = e, e.err = e.error;
  }
}
function sm(t, e) {
  const n = t === "output-restricted", r = n ? q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : q.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
  return new Vt({
    type: de.KEY_SYSTEM_ERROR,
    details: r,
    fatal: !1,
    decryptdata: e
  }, n ? "HDCP level output restricted" : `key status changed to "${t}"`);
}
class J3 {
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
  }
  onMediaAttaching(e, n) {
    const r = this.hls.config;
    if (r.capLevelOnFPSDrop) {
      const i = n.media instanceof self.HTMLVideoElement ? n.media : null;
      this.media = i, i && typeof i.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);
    }
  }
  onMediaDetaching() {
    this.media = null;
  }
  checkFPS(e, n, r) {
    const i = performance.now();
    if (n) {
      if (this.lastTime) {
        const s = i - this.lastTime, a = r - this.lastDroppedFrames, o = n - this.lastDecodedFrames, u = 1e3 * a / s, l = this.hls;
        if (l.trigger(x.FPS_DROP, {
          currentDropped: a,
          currentDecoded: o,
          totalDroppedFrames: r
        }), u > 0 && a > l.config.fpsDroppedMonitoringThreshold * o) {
          let c = l.currentLevel;
          l.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + c), c > 0 && (l.autoLevelCapping === -1 || l.autoLevelCapping >= c) && (c = c - 1, l.trigger(x.FPS_DROP_LEVEL_CAPPING, {
            level: c,
            droppedLevel: l.currentLevel
          }), l.autoLevelCapping = c, this.streamController.nextLevelSwitch());
        }
      }
      this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = n;
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const n = e.getVideoPlaybackQuality();
        this.checkFPS(e, n.totalVideoFrames, n.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
function gE(t, e) {
  let n;
  try {
    n = new Event("addtrack");
  } catch {
    n = document.createEvent("Event"), n.initEvent("addtrack", !1, !1);
  }
  n.track = t, e.dispatchEvent(n);
}
function bE(t, e) {
  const n = t.mode;
  if (n === "disabled" && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id))
    try {
      if (t.addCue(e), !t.cues.getCueById(e.id))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (r) {
      Be.debug(`[texttrack-utils]: ${r}`);
      try {
        const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
        i.id = e.id, t.addCue(i);
      } catch (i) {
        Be.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${i}`);
      }
    }
  n === "disabled" && (t.mode = n);
}
function Ii(t, e) {
  const n = t.mode;
  if (n === "disabled" && (t.mode = "hidden"), t.cues)
    for (let r = t.cues.length; r--; )
      e && t.cues[r].removeEventListener("enter", e), t.removeCue(t.cues[r]);
  n === "disabled" && (t.mode = n);
}
function Zc(t, e, n, r) {
  const i = t.mode;
  if (i === "disabled" && (t.mode = "hidden"), t.cues && t.cues.length > 0) {
    const s = tR(t.cues, e, n);
    for (let a = 0; a < s.length; a++)
      (!r || r(s[a])) && t.removeCue(s[a]);
  }
  i === "disabled" && (t.mode = i);
}
function eR(t, e) {
  if (e <= t[0].startTime)
    return 0;
  const n = t.length - 1;
  if (e > t[n].endTime)
    return -1;
  let r = 0, i = n, s;
  for (; r <= i; )
    if (s = Math.floor((i + r) / 2), e < t[s].startTime)
      i = s - 1;
    else if (e > t[s].startTime && r < n)
      r = s + 1;
    else
      return s;
  return t[r].startTime - e < e - t[i].startTime ? r : i;
}
function tR(t, e, n) {
  const r = [], i = eR(t, e);
  if (i > -1)
    for (let s = i, a = t.length; s < a; s++) {
      const o = t[s];
      if (o.startTime >= e && o.endTime <= n)
        r.push(o);
      else if (o.startTime > n)
        return r;
    }
  return r;
}
function Fo(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    (r.kind === "subtitles" || r.kind === "captions") && r.label && e.push(t[n]);
  }
  return e;
}
class nR extends _f {
  constructor(e) {
    super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => {
      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)
        return;
      let n = null;
      const r = Fo(this.media.textTracks);
      for (let s = 0; s < r.length; s++)
        if (r[s].mode === "hidden")
          n = r[s];
        else if (r[s].mode === "showing") {
          n = r[s];
          break;
        }
      const i = this.findTrackForTextTrack(n);
      this.subtitleTrack !== i && this.setSubtitleTrack(i);
    }, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(e, n) {
    this.media = n.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);
  }
  onMediaDetaching(e, n) {
    const r = this.media;
    if (!r)
      return;
    const i = !!n.transferMedia;
    if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || r.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, i)
      return;
    Fo(r.textTracks).forEach((a) => {
      Ii(a);
    });
  }
  onManifestLoading() {
    this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(e, n) {
    this.tracks = n.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, n) {
    const {
      id: r,
      groupId: i,
      details: s
    } = n, a = this.tracksInGroup[r];
    if (!a || a.groupId !== i) {
      this.warn(`Subtitle track with id:${r} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = n.details, this.log(`Subtitle track ${r} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, n, o);
  }
  onLevelLoading(e, n) {
    this.switchLevel(n.level);
  }
  onLevelSwitching(e, n) {
    this.switchLevel(n.level);
  }
  switchLevel(e) {
    const n = this.hls.levels[e];
    if (!n)
      return;
    const r = n.subtitleGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some((a) => (i == null ? void 0 : i.indexOf(a)) === -1)) {
      this.groupIds = r, this.trackId = -1, this.currentTrack = null;
      const a = this.tracks.filter((c) => !r || r.indexOf(c.groupId) !== -1);
      if (a.length)
        this.selectDefaultTrack && !a.some((c) => c.default) && (this.selectDefaultTrack = !1), a.forEach((c, d) => {
          c.id = d;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = a;
      const o = this.hls.config.subtitlePreference;
      if (!s && o) {
        this.selectDefaultTrack = !1;
        const c = Rn(o, a);
        if (c > -1)
          s = a[c];
        else {
          const d = Rn(o, this.tracks);
          s = this.tracks[d];
        }
      }
      let u = this.findTrackId(s);
      u === -1 && s && (u = this.findTrackId(null));
      const l = {
        subtitleTracks: a
      };
      this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${r == null ? void 0 : r.join(",")}" group-id`), this.hls.trigger(x.SUBTITLE_TRACKS_UPDATED, l), u !== -1 && this.trackId === -1 && this.setSubtitleTrack(u);
    }
  }
  findTrackId(e) {
    const n = this.tracksInGroup, r = this.selectDefaultTrack;
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (!(r && !s.default || !r && !e) && (!e || Vr(s, e)))
        return i;
    }
    if (e) {
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (aa(e.attrs, s.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return i;
      }
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (aa(e.attrs, s.attrs, ["LANGUAGE"]))
          return i;
      }
    }
    return -1;
  }
  findTrackForTextTrack(e) {
    if (e) {
      const n = this.tracksInGroup;
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        if (Wc(i, e))
          return r;
      }
    }
    return -1;
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === _e.SUBTITLE_TRACK && n.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(n.context.groupId) !== -1) && this.checkRetry(n);
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1, this.setSubtitleTrack(e);
  }
  setSubtitleOption(e) {
    if (this.hls.config.subtitlePreference = e, e) {
      if (e.id === -1)
        return this.setSubtitleTrack(-1), null;
      const n = this.allSubtitleTracks;
      if (this.selectDefaultTrack = !1, n.length) {
        const r = this.currentTrack;
        if (r && Vr(e, r))
          return r;
        const i = Rn(e, this.tracksInGroup);
        if (i > -1) {
          const s = this.tracksInGroup[i];
          return this.setSubtitleTrack(i), s;
        } else {
          if (r)
            return null;
          {
            const s = Rn(e, n);
            if (s > -1)
              return n[s];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, n), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading subtitle ${r} "${e.name}" lang:${e.lang} group:${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(x.SUBTITLE_TRACK_LOADING, {
      url: s,
      id: r,
      groupId: i,
      deliveryDirectives: n || null,
      track: e
    });
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = Fo(e.textTracks), r = this.currentTrack;
    let i;
    if (r && (i = n.filter((s) => Wc(r, s))[0], i || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`)), [].slice.call(n).forEach((s) => {
      s.mode !== "disabled" && s !== i && (s.mode = "disabled");
    }), i) {
      const s = this.subtitleDisplay ? "showing" : "hidden";
      i.mode !== s && (i.mode = s);
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(e) {
    const n = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (e < -1 || e >= n.length || !ue(e)) {
      this.warn(`Invalid subtitle track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const r = this.currentTrack, i = n[e] || null;
    if (this.trackId = e, this.currentTrack = i, this.toggleTrackModes(), !i) {
      this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
        id: e
      });
      return;
    }
    const s = !!i.details && !i.details.live;
    if (e === this.trackId && i === r && s)
      return;
    this.log(`Switching to subtitle-track ${e}` + (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : ""));
    const {
      id: a,
      groupId: o = "",
      name: u,
      type: l,
      url: c
    } = i;
    this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
      id: a,
      groupId: o,
      name: u,
      type: l,
      url: c
    });
    const d = this.switchParams(i.url, r == null ? void 0 : r.details, i.details);
    this.loadPlaylist(d);
  }
}
function rR() {
  try {
    return crypto.randomUUID();
  } catch {
    try {
      const e = URL.createObjectURL(new Blob()), n = e.toString();
      return URL.revokeObjectURL(e), n.slice(n.lastIndexOf("/") + 1);
    } catch {
      let n = (/* @__PURE__ */ new Date()).getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (i) => {
        const s = (n + Math.random() * 16) % 16 | 0;
        return n = Math.floor(n / 16), (i == "x" ? s : s & 3 | 8).toString(16);
      });
    }
  }
}
function Fs(t) {
  let e = 5381, n = t.length;
  for (; n; )
    e = e * 33 ^ t.charCodeAt(--n);
  return (e >>> 0).toString();
}
const ki = 0.025;
let hu = /* @__PURE__ */ function(t) {
  return t[t.Point = 0] = "Point", t[t.Range = 1] = "Range", t;
}({});
function iR(t, e, n) {
  return `${t.identifier}-${n + 1}-${Fs(e)}`;
}
class sR {
  constructor(e, n) {
    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
      skip: !1,
      jump: !1
    }, this.snapOptions = {
      out: !1,
      in: !1
    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = n, this.dateRange = e, this.setDateRange(e);
  }
  setDateRange(e) {
    this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions);
  }
  reset() {
    var e;
    this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);
  }
  isAssetPastPlayoutLimit(e) {
    var n;
    if (e > 0 && e >= this.assetList.length)
      return !0;
    const r = this.playoutLimit;
    return e <= 0 || isNaN(r) ? !1 : r === 0 ? !0 : (((n = this.assetList[e]) == null ? void 0 : n.startOffset) || 0) > r;
  }
  findAssetIndex(e) {
    return this.assetList.indexOf(e);
  }
  get identifier() {
    return this.dateRange.id;
  }
  get startDate() {
    return this.dateRange.startDate;
  }
  get startTime() {
    const e = this.dateRange.startTime;
    if (this.snapOptions.out) {
      const n = this.dateRange.tagAnchor;
      if (n)
        return Ll(e, n);
    }
    return e;
  }
  get startOffset() {
    return this.cue.pre ? 0 : this.startTime;
  }
  get startIsAligned() {
    if (this.startTime === 0 || this.snapOptions.out)
      return !0;
    const e = this.dateRange.tagAnchor;
    if (e) {
      const n = this.dateRange.startTime, r = Ll(n, e);
      return n - r < 0.1;
    }
    return !1;
  }
  get resumptionOffset() {
    const e = this.resumeOffset, n = ue(e) ? e : this.duration;
    return this.cumulativeDuration + n;
  }
  get resumeTime() {
    const e = this.startOffset + this.resumptionOffset;
    if (this.snapOptions.in) {
      const n = this.resumeAnchor;
      if (n)
        return Ll(e, n);
    }
    return e;
  }
  get appendInPlace() {
    return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < ki));
  }
  set appendInPlace(e) {
    if (this.appendInPlaceStarted) {
      this.resetOnResume = !e;
      return;
    }
    this.appendInPlaceDisabled = !e;
  }
  // Extended timeline start time
  get timelineStart() {
    return this._timelineStart !== null ? this._timelineStart : this.startTime;
  }
  set timelineStart(e) {
    this._timelineStart = e;
  }
  get duration() {
    const e = this.playoutLimit;
    let n;
    return this._duration !== null ? n = this._duration : this.dateRange.duration ? n = this.dateRange.duration : n = this.dateRange.plannedDuration || 0, !isNaN(e) && e < n && (n = e), n;
  }
  set duration(e) {
    this._duration = e;
  }
  get cue() {
    return this.dateRange.cue;
  }
  get timelineOccupancy() {
    return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? hu.Range : hu.Point;
  }
  get supplementsPrimary() {
    return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
  }
  get contentMayVary() {
    return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
  }
  get assetUrl() {
    return this.dateRange.attr["X-ASSET-URI"];
  }
  get assetListUrl() {
    return this.dateRange.attr["X-ASSET-LIST"];
  }
  get baseUrl() {
    return this.base.url;
  }
  get assetListLoaded() {
    return this.assetList.length > 0 || this.assetListResponse !== null;
  }
  toString() {
    return aR(this);
  }
}
function Ll(t, e) {
  return t - e.start < e.duration / 2 && !(Math.abs(t - (e.start + e.duration)) < ki) ? e.start : e.start + e.duration;
}
function EE(t, e, n) {
  const r = new self.URL(t, n);
  return r.protocol !== "data:" && r.searchParams.set("_HLS_primary_id", e), r;
}
function _l(t, e) {
  for (; (n = t.assetList[++e]) != null && n.error; )
    var n;
  return e;
}
function aR(t) {
  return `["${t.identifier}" ${t.cue.pre ? "<pre>" : t.cue.post ? "<post>" : ""}${t.timelineStart.toFixed(2)}-${t.resumeTime.toFixed(2)}]`;
}
function xi(t) {
  const e = t.timelineStart, n = t.duration || 0;
  return `["${t.identifier}" ${e.toFixed(2)}-${(e + n).toFixed(2)}]`;
}
class oR {
  constructor(e, n, r, i) {
    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => {
      this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(x.PLAYOUT_LIMIT_REACHED, {});
    };
    const s = this.hls = new e(n);
    this.interstitial = r, this.assetItem = i;
    const a = () => {
      this.hasDetails = !0;
    };
    s.once(x.LEVEL_LOADED, a), s.once(x.AUDIO_TRACK_LOADED, a), s.once(x.SUBTITLE_TRACK_LOADED, a), s.on(x.MEDIA_ATTACHING, (o, {
      media: u
    }) => {
      this.removeMediaListeners(), this.mediaAttached = u, this.interstitial.playoutLimit && (u.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && s.on(x.BUFFER_APPENDED, () => {
        const c = this.bufferedEnd;
        this.reachedPlayout(c) && (this._bufferedEosTime = c, s.trigger(x.BUFFERED_TO_END, void 0));
      }));
    });
  }
  get appendInPlace() {
    return this.interstitial.appendInPlace;
  }
  loadSource() {
    const e = this.hls;
    if (e)
      if (e.url)
        e.levels.length && !e.started && e.startLoad(-1, !0);
      else {
        let n = this.assetItem.uri;
        try {
          n = EE(n, e.config.primarySessionId || "").href;
        } catch {
        }
        e.loadSource(n);
      }
  }
  bufferedInPlaceToEnd(e) {
    var n;
    if (!this.appendInPlace)
      return !1;
    if ((n = this.hls) != null && n.bufferedToEnd)
      return !0;
    if (!e)
      return !1;
    const r = Math.min(this._bufferedEosTime || 1 / 0, this.duration), i = this.timelineOffset, s = ye.bufferInfo(e, i, 0);
    return this.getAssetTime(s.end) >= r - 0.02;
  }
  reachedPlayout(e) {
    const r = this.interstitial.playoutLimit;
    return this.startOffset + e >= r;
  }
  get destroyed() {
    var e;
    return !((e = this.hls) != null && e.userConfig);
  }
  get assetId() {
    return this.assetItem.identifier;
  }
  get interstitialId() {
    return this.assetItem.parentIdentifier;
  }
  get media() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.media) || null;
  }
  get bufferedEnd() {
    const e = this.media || this.mediaAttached;
    if (!e)
      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
    const n = ye.bufferInfo(e, e.currentTime, 1e-3);
    return this.getAssetTime(n.end);
  }
  get currentTime() {
    const e = this.media || this.mediaAttached;
    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
  }
  get duration() {
    const e = this.assetItem.duration;
    if (!e)
      return 0;
    const n = this.interstitial.playoutLimit;
    if (n) {
      const r = n - this.startOffset;
      if (r > 0 && r < e)
        return r;
    }
    return e;
  }
  get remaining() {
    const e = this.duration;
    return e ? Math.max(0, e - this.currentTime) : 0;
  }
  get startOffset() {
    return this.assetItem.startOffset;
  }
  get timelineOffset() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
  }
  set timelineOffset(e) {
    const n = this.timelineOffset;
    if (e !== n) {
      const r = e - n;
      if (Math.abs(r) > 1 / 9e4 && this.hls) {
        if (this.hasDetails)
          throw new Error("Cannot set timelineOffset after playlists are loaded");
        this.hls.config.timelineOffset = e;
      }
    }
  }
  getAssetTime(e) {
    const n = this.timelineOffset, r = this.duration;
    return Math.min(Math.max(0, e - n), r);
  }
  removeMediaListeners() {
    const e = this.mediaAttached;
    e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout));
  }
  bufferSnapShot() {
    if (this.mediaAttached) {
      var e;
      (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd);
    }
  }
  destroy() {
    this.removeMediaListeners(), this.hls && this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null;
  }
  attachMedia(e) {
    var n;
    this.loadSource(), (n = this.hls) == null || n.attachMedia(e);
  }
  detachMedia() {
    var e;
    this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia();
  }
  resumeBuffering() {
    var e;
    (e = this.hls) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.hls) == null || e.pauseBuffering();
  }
  transferMedia() {
    var e;
    return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null;
  }
  resetDetails() {
    const e = this.hls;
    if (e && this.hasDetails) {
      e.stopLoad();
      const n = (r) => delete r.details;
      e.levels.forEach(n), e.allAudioTracks.forEach(n), e.allSubtitleTracks.forEach(n), this.hasDetails = !1;
    }
  }
  on(e, n, r) {
    var i;
    (i = this.hls) == null || i.on(e, n);
  }
  once(e, n, r) {
    var i;
    (i = this.hls) == null || i.once(e, n);
  }
  off(e, n, r) {
    var i;
    (i = this.hls) == null || i.off(e, n);
  }
  toString() {
    var e;
    return `HlsAssetPlayer: ${xi(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
  }
}
const am = 0.033;
class uR extends on {
  constructor(e, n) {
    super("interstitials-sched", n), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
      primary: 0,
      playout: 0,
      integrated: 0
    }, this.onScheduleUpdate = e;
  }
  destroy() {
    this.reset(), this.onScheduleUpdate = null;
  }
  reset() {
    this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((e) => e.reset()), this.events = this.items = null;
  }
  resetErrorsInRange(e, n) {
    return this.events ? this.events.reduce((r, i) => e <= i.startOffset && n > i.startOffset ? (delete i.error, r + 1) : r, 0) : 0;
  }
  get duration() {
    const e = this.items;
    return e ? e[e.length - 1].end : 0;
  }
  get length() {
    return this.items ? this.items.length : 0;
  }
  getEvent(e) {
    return e && this.eventMap[e] || null;
  }
  hasEvent(e) {
    return e in this.eventMap;
  }
  findItemIndex(e, n) {
    if (e.event)
      return this.findEventIndex(e.event.identifier);
    let r = -1;
    e.nextEvent ? r = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (r = this.findEventIndex(e.previousEvent.identifier) + 1);
    const i = this.items;
    if (i)
      for (i[r] || (n === void 0 && (n = e.start), r = this.findItemIndexAtTime(n)); r >= 0 && (s = i[r]) != null && s.event; ) {
        var s;
        r--;
      }
    return r;
  }
  findItemIndexAtTime(e, n) {
    const r = this.items;
    if (r)
      for (let i = 0; i < r.length; i++) {
        let s = r[i];
        if (n && n !== "primary" && (s = s[n]), e === s.start || e > s.start && e < s.end)
          return i;
      }
    return -1;
  }
  findJumpRestrictedIndex(e, n) {
    const r = this.items;
    if (r)
      for (let i = e; i <= n && r[i]; i++) {
        const s = r[i].event;
        if (s != null && s.restrictions.jump && !s.appendInPlace)
          return i;
      }
    return -1;
  }
  findEventIndex(e) {
    const n = this.items;
    if (n)
      for (let i = n.length; i--; ) {
        var r;
        if (((r = n[i].event) == null ? void 0 : r.identifier) === e)
          return i;
      }
    return -1;
  }
  findAssetIndex(e, n) {
    const r = e.assetList, i = r.length;
    if (i > 1)
      for (let s = 0; s < i; s++) {
        const a = r[s];
        if (!a.error) {
          const o = a.timelineStart;
          if (n === o || n > o && (n < o + (a.duration || 0) || s === i - 1))
            return s;
        }
      }
    return 0;
  }
  get assetIdAtEnd() {
    var e;
    const n = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;
    if (n) {
      const r = n.assetList, i = r[r.length - 1];
      if (i)
        return i.identifier;
    }
    return null;
  }
  parseInterstitialDateRanges(e, n) {
    const r = e.main.details, {
      dateRanges: i
    } = r, s = this.events, a = this.parseDateRanges(i, {
      url: r.url
    }, n), o = Object.keys(i), u = s ? s.filter((l) => !o.includes(l.identifier)) : [];
    a.length && a.sort((l, c) => {
      const d = l.cue.pre, f = l.cue.post, h = c.cue.pre, m = c.cue.post;
      if (d && !h)
        return -1;
      if (h && !d || f && !m)
        return 1;
      if (m && !f)
        return -1;
      if (!d && !h && !f && !m) {
        const p = l.startTime, g = c.startTime;
        if (p !== g)
          return p - g;
      }
      return l.dateRange.tagOrder - c.dateRange.tagOrder;
    }), this.events = a, u.forEach((l) => {
      this.removeEvent(l);
    }), this.updateSchedule(e, u);
  }
  updateSchedule(e, n = [], r = !1) {
    const i = this.events || [];
    if (i.length || n.length || this.length < 2) {
      const s = this.items, a = this.parseSchedule(i, e);
      (r || n.length || (s == null ? void 0 : s.length) !== a.length || a.some((u, l) => Math.abs(u.playout.start - s[l].playout.start) > 5e-3 || Math.abs(u.playout.end - s[l].playout.end) > 5e-3)) && (this.items = a, this.onScheduleUpdate(n, s));
    }
  }
  parseDateRanges(e, n, r) {
    const i = [], s = Object.keys(e);
    for (let a = 0; a < s.length; a++) {
      const o = s[a], u = e[o];
      if (u.isInterstitial) {
        let l = this.eventMap[o];
        l ? l.setDateRange(u) : (l = new sR(u, n), this.eventMap[o] = l, r === !1 && (l.appendInPlace = r)), i.push(l);
      }
    }
    return i;
  }
  parseSchedule(e, n) {
    const r = [], i = n.main.details, s = i.live ? 1 / 0 : i.edge;
    let a = 0;
    if (e = e.filter((u) => !u.error && !(u.cue.once && u.hasPlayed)), e.length) {
      this.resolveOffsets(e, n);
      let u = 0, l = 0;
      if (e.forEach((c, d) => {
        const f = c.cue.pre, h = c.cue.post, m = e[d - 1] || null, p = c.appendInPlace, g = h ? s : c.startOffset, E = c.duration, y = c.timelineOccupancy === hu.Range ? E : 0, T = c.resumptionOffset, S = (m == null ? void 0 : m.startTime) === g, v = g + c.cumulativeDuration;
        let I = p ? v + E : g + T;
        if (f || !h && g <= 0) {
          const D = l;
          l += y, c.timelineStart = v;
          const _ = a;
          a += E, r.push({
            event: c,
            start: v,
            end: I,
            playout: {
              start: _,
              end: a
            },
            integrated: {
              start: D,
              end: l
            }
          });
        } else if (g <= s) {
          if (!S) {
            const A = g - u;
            if (A > am) {
              const L = u, N = l;
              l += A;
              const U = a;
              a += A;
              const z = {
                previousEvent: e[d - 1] || null,
                nextEvent: c,
                start: L,
                end: L + A,
                playout: {
                  start: U,
                  end: a
                },
                integrated: {
                  start: N,
                  end: l
                }
              };
              r.push(z);
            } else A > 0 && m && (m.cumulativeDuration += A, r[r.length - 1].end = g);
          }
          h && (I = v), c.timelineStart = v;
          const D = l;
          l += y;
          const _ = a;
          a += E, r.push({
            event: c,
            start: v,
            end: I,
            playout: {
              start: _,
              end: a
            },
            integrated: {
              start: D,
              end: l
            }
          });
        } else
          return;
        const C = c.resumeTime;
        h || C > s ? u = s : u = C;
      }), u < s) {
        var o;
        const c = u, d = l, f = s - u;
        l += f;
        const h = a;
        a += f, r.push({
          previousEvent: ((o = r[r.length - 1]) == null ? void 0 : o.event) || null,
          nextEvent: null,
          start: u,
          end: c + f,
          playout: {
            start: h,
            end: a
          },
          integrated: {
            start: d,
            end: l
          }
        });
      }
      this.setDurations(s, a, l);
    } else
      r.push({
        previousEvent: null,
        nextEvent: null,
        start: 0,
        end: s,
        playout: {
          start: 0,
          end: s
        },
        integrated: {
          start: 0,
          end: s
        }
      }), this.setDurations(s, s, s);
    return r;
  }
  setDurations(e, n, r) {
    this.durations = {
      primary: e,
      playout: n,
      integrated: r
    };
  }
  resolveOffsets(e, n) {
    const r = n.main.details, i = r.live ? 1 / 0 : r.edge;
    let s = 0, a = -1;
    e.forEach((o, u) => {
      const l = o.cue.pre, c = o.cue.post, d = l ? 0 : c ? i : o.startTime;
      this.updateAssetDurations(o), a === d ? o.cumulativeDuration = s : (s = 0, a = d), !c && o.snapOptions.in && (o.resumeAnchor = Yr(null, r.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, n) || (o.appendInPlace = !1)), !o.appendInPlace && u + 1 < e.length && e[u + 1].startTime - e[u].resumeTime < am && (e[u + 1].appendInPlace = !1, e[u + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
      const h = ue(o.resumeOffset) ? o.resumeOffset : o.duration;
      s += h;
    });
  }
  primaryCanResumeInPlaceAt(e, n) {
    const r = e.resumeTime, i = e.startTime + e.resumptionOffset;
    return Math.abs(r - i) > ki ? (this.log(`"${e.identifier}" resumption ${r} not aligned with estimated timeline end ${i}`), !1) : !Object.keys(n).some((a) => {
      const o = n[a].details, u = o.edge;
      if (r >= u)
        return this.log(`"${e.identifier}" resumption ${r} past ${a} playlist end ${u}`), !1;
      const l = Yr(null, o.fragments, r);
      if (!l)
        return this.log(`"${e.identifier}" resumption ${r} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`), !0;
      const c = a === "audio" ? 0.175 : 0;
      return Math.abs(l.start - r) < ki + c || Math.abs(l.end - r) < ki + c ? !1 : (this.log(`"${e.identifier}" resumption ${r} not aligned with ${a} fragment bounds (${l.start}-${l.end} sn: ${l.sn} cc: ${l.cc})`), !0);
    });
  }
  updateAssetDurations(e) {
    if (!e.assetListLoaded)
      return;
    const n = e.timelineStart;
    let r = 0, i = !1, s = !1;
    for (let a = 0; a < e.assetList.length; a++) {
      const o = e.assetList[a], u = n + r;
      o.startOffset = r, o.timelineStart = u, i || (i = o.duration === null), s || (s = !!o.error);
      const l = o.error ? 0 : o.duration || 0;
      r += l;
    }
    i && !s ? e.duration = Math.max(r, e.duration) : e.duration = r;
  }
  removeEvent(e) {
    e.reset(), delete this.eventMap[e.identifier];
  }
}
function cn(t) {
  return `[${t.event ? '"' + t.event.identifier + '"' : "primary"}: ${t.start.toFixed(2)}-${t.end.toFixed(2)}]`;
}
class lR {
  constructor(e) {
    this.hls = void 0, this.hls = e;
  }
  destroy() {
    this.hls = null;
  }
  loadAssetList(e, n) {
    const r = e.assetListUrl;
    let i;
    try {
      i = EE(r, this.hls.sessionId, e.baseUrl);
    } catch (f) {
      const h = this.assignAssetListError(e, q.ASSET_LIST_LOAD_ERROR, f, r);
      this.hls.trigger(x.ERROR, h);
      return;
    }
    n && i.protocol !== "data:" && i.searchParams.set("_HLS_start_offset", "" + n);
    const s = this.hls.config, a = s.loader, o = new a(s), u = {
      responseType: "json",
      url: i.href
    }, l = s.interstitialAssetListLoadPolicy.default, c = {
      loadPolicy: l,
      timeout: l.maxLoadTimeMs,
      maxRetry: 0,
      retryDelay: 0,
      maxRetryDelay: 0
    }, d = {
      onSuccess: (f, h, m, p) => {
        const g = f.data, E = g == null ? void 0 : g.ASSETS;
        if (!Array.isArray(E)) {
          const y = this.assignAssetListError(e, q.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), m.url, h, p);
          this.hls.trigger(x.ERROR, y);
          return;
        }
        e.assetListResponse = g, this.hls.trigger(x.ASSET_LIST_LOADED, {
          event: e,
          assetListResponse: g,
          networkDetails: p
        });
      },
      onError: (f, h, m, p) => {
        const g = this.assignAssetListError(e, q.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${f.code} ${f.text} (${h.url})`), h.url, p, m);
        this.hls.trigger(x.ERROR, g);
      },
      onTimeout: (f, h, m) => {
        const p = this.assignAssetListError(e, q.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${h.url})`), h.url, f, m);
        this.hls.trigger(x.ERROR, p);
      }
    };
    return o.load(u, c, d), this.hls.trigger(x.ASSET_LIST_LOADING, {
      event: e
    }), o;
  }
  assignAssetListError(e, n, r, i, s, a) {
    return e.error = r, {
      type: de.NETWORK_ERROR,
      details: n,
      fatal: !1,
      interstitial: e,
      url: i,
      error: r,
      networkDetails: a,
      stats: s
    };
  }
}
function om(t) {
  t == null || t.play().catch(() => {
  });
}
function ro(t, e) {
  return `[${t}] Advancing timeline position to ${e}`;
}
class cR extends on {
  constructor(e, n) {
    super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => {
      this.shouldPlay = !0;
    }, this.onPause = () => {
      this.shouldPlay = !1;
    }, this.onSeeking = () => {
      const r = this.currentTime;
      if (r === void 0 || this.playbackDisabled || !this.schedule)
        return;
      const i = r - this.timelinePos;
      if (Math.abs(i) < 1 / 7056e5)
        return;
      const a = i <= -0.01;
      this.timelinePos = r, this.bufferedPos = r;
      const o = this.playingItem;
      if (!o) {
        this.checkBuffer();
        return;
      }
      if (a && this.schedule.resetErrorsInRange(r, r - i) && this.updateSchedule(!0), this.checkBuffer(), a && r < o.start || r >= o.end) {
        var u;
        const h = this.findItemIndex(o);
        let m = this.schedule.findItemIndexAtTime(r);
        if (m === -1 && (m = h + (a ? -1 : 1), this.log(`seeked ${a ? "back " : ""}to position not covered by schedule ${r} (resolving from ${h} to ${m})`)), !this.isInterstitial(o) && (u = this.media) != null && u.paused && (this.shouldPlay = !1), !a && m > h) {
          const p = this.schedule.findJumpRestrictedIndex(h + 1, m);
          if (p > h) {
            this.setSchedulePosition(p);
            return;
          }
        }
        this.setSchedulePosition(m);
        return;
      }
      const l = this.playingAsset;
      if (!l) {
        if (this.playingLastItem && this.isInterstitial(o)) {
          const h = o.event.assetList[0];
          h && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(r, h));
        }
        return;
      }
      const c = l.timelineStart, d = l.duration || 0;
      if (a && r < c || r >= c + d) {
        var f;
        (f = o.event) != null && f.appendInPlace && (this.clearInterstitial(o.event, o), this.flushFrontBuffer(r)), this.setScheduleToAssetAtTime(r, l);
      }
    }, this.onTimeupdate = () => {
      const r = this.currentTime;
      if (r === void 0 || this.playbackDisabled)
        return;
      if (r > this.timelinePos)
        this.timelinePos = r, r > this.bufferedPos && this.checkBuffer();
      else
        return;
      const i = this.playingItem;
      if (!i || this.playingLastItem)
        return;
      if (r >= i.end) {
        this.timelinePos = i.end;
        const o = this.findItemIndex(i);
        this.setSchedulePosition(o + 1);
      }
      const s = this.playingAsset;
      if (!s)
        return;
      const a = s.timelineStart + (s.duration || 0);
      r >= a && this.setScheduleToAssetAtTime(r, s);
    }, this.onScheduleUpdate = (r, i) => {
      const s = this.schedule;
      if (!s)
        return;
      const a = this.playingItem, o = s.events || [], u = s.items || [], l = s.durations, c = r.map((p) => p.identifier), d = !!(o.length || c.length);
      (d || i) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${u.map((p) => cn(p))} pos: ${this.timelinePos}`), c.length && this.log(`Removed events ${c}`);
      let f = null, h = null;
      a && (f = this.updateItem(a, this.timelinePos), this.itemsMatch(a, f) ? this.playingItem = f : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
      const m = this.bufferingItem;
      if (m && (h = this.updateItem(m, this.bufferedPos), this.itemsMatch(m, h) ? this.bufferingItem = h : m.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(m.event, null))), r.forEach((p) => {
        p.assetList.forEach((g) => {
          this.clearAssetPlayer(g.identifier, null);
        });
      }), this.playerQueue.forEach((p) => {
        if (p.interstitial.appendInPlace) {
          const g = p.assetItem.timelineStart, E = p.timelineOffset - g;
          if (E)
            try {
              p.timelineOffset = g;
            } catch (y) {
              Math.abs(E) > ki && this.warn(`${y} ("${p.assetId}" ${p.timelineOffset}->${g})`);
            }
        }
      }), d || i) {
        if (this.hls.trigger(x.INTERSTITIALS_UPDATED, {
          events: o.slice(0),
          schedule: u.slice(0),
          durations: l,
          removedIds: c
        }), this.isInterstitial(a) && c.includes(a.event.identifier)) {
          this.warn(`Interstitial "${a.event.identifier}" removed while playing`), this.primaryFallback(a.event);
          return;
        }
        a && this.trimInPlace(f, a), m && h !== f && this.trimInPlace(h, m), this.checkBuffer();
      }
    }, this.hls = e, this.HlsPlayerClass = n, this.assetListLoader = new lR(e), this.schedule = new uR(this.onScheduleUpdate, e.logger), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(x.MEDIA_ENDED, this.onMediaEnded, this), e.on(x.ERROR, this.onError, this), e.on(x.DESTROYING, this.onDestroying, this));
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(x.MEDIA_ENDED, this.onMediaEnded, this), e.off(x.ERROR, this.onError, this), e.off(x.DESTROYING, this.onDestroying, this));
  }
  startLoad() {
    this.resumeBuffering();
  }
  stopLoad() {
    this.pauseBuffering();
  }
  resumeBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;
  }
  onDestroying() {
    const e = this.primaryMedia || this.media;
    e && this.removeMediaListeners(e);
  }
  removeMediaListeners(e) {
    Ot(e, "play", this.onPlay), Ot(e, "pause", this.onPause), Ot(e, "seeking", this.onSeeking), Ot(e, "timeupdate", this.onTimeupdate);
  }
  onMediaAttaching(e, n) {
    const r = this.media = n.media;
    _t(r, "seeking", this.onSeeking), _t(r, "timeupdate", this.onTimeupdate), _t(r, "play", this.onPlay), _t(r, "pause", this.onPause);
  }
  onMediaAttached(e, n) {
    const r = this.effectivePlayingItem, i = this.detachedData;
    if (this.detachedData = null, r === null)
      this.checkStart();
    else if (!i) {
      this.clearScheduleState();
      const s = this.findItemIndex(r);
      this.setSchedulePosition(s);
    }
  }
  clearScheduleState() {
    this.log("clear schedule state"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia, i = this.media;
    if (this.media = null, !r && (i && this.removeMediaListeners(i), this.detachedData)) {
      const s = this.getBufferingPlayer();
      s && (this.log(`Removing schedule state for detachedData and ${s}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, s.detachMedia()), this.shouldPlay = !1;
    }
  }
  get interstitialsManager() {
    if (!this.hls)
      return null;
    if (this.manager)
      return this.manager;
    const e = this, n = () => e.bufferingItem || e.waitingItem, r = (d) => d && e.getAssetPlayer(d.identifier), i = (d, f, h, m, p) => {
      if (d) {
        let g = d[f].start;
        const E = d.event;
        if (E) {
          if (f === "playout" || E.timelineOccupancy !== hu.Point) {
            const y = r(h);
            (y == null ? void 0 : y.interstitial) === E && (g += y.assetItem.startOffset + y[p]);
          }
        } else {
          const y = m === "bufferedPos" ? a() : e[m];
          g += y - d.start;
        }
        return g;
      }
      return 0;
    }, s = (d, f) => {
      var h;
      if (d !== 0 && f !== "primary" && (h = e.schedule) != null && h.length) {
        var m;
        const p = e.schedule.findItemIndexAtTime(d), g = (m = e.schedule.items) == null ? void 0 : m[p];
        if (g) {
          const E = g[f].start - g.start;
          return d + E;
        }
      }
      return d;
    }, a = () => {
      const d = e.bufferedPos;
      return d === Number.MAX_VALUE ? o("primary") : Math.max(d, 0);
    }, o = (d) => {
      var f, h;
      return (f = e.primaryDetails) != null && f.live ? e.primaryDetails.edge : ((h = e.schedule) == null ? void 0 : h.durations[d]) || 0;
    }, u = (d, f) => {
      var h, m;
      const p = e.effectivePlayingItem;
      if (p != null && (h = p.event) != null && h.restrictions.skip || !e.schedule)
        return;
      e.log(`seek to ${d} "${f}"`);
      const g = e.effectivePlayingItem, E = e.schedule.findItemIndexAtTime(d, f), y = (m = e.schedule.items) == null ? void 0 : m[E], T = e.getBufferingPlayer(), S = T == null ? void 0 : T.interstitial, v = S == null ? void 0 : S.appendInPlace, I = g && e.itemsMatch(g, y);
      if (g && (v || I)) {
        const C = r(e.playingAsset), D = (C == null ? void 0 : C.media) || e.primaryMedia;
        if (D) {
          const _ = f === "primary" ? D.currentTime : i(g, f, e.playingAsset, "timelinePos", "currentTime"), A = d - _, L = (v ? _ : D.currentTime) + A;
          if (L >= 0 && (!C || v || L <= C.duration)) {
            D.currentTime = L;
            return;
          }
        }
      }
      if (y) {
        let C = d;
        if (f !== "primary") {
          const _ = y[f].start, A = d - _;
          C = y.start + A;
        }
        const D = !e.isInterstitial(y);
        if ((!e.isInterstitial(g) || g.event.appendInPlace) && (D || y.event.appendInPlace)) {
          const _ = e.media || (v ? T == null ? void 0 : T.media : null);
          _ && (_.currentTime = C);
        } else if (g) {
          const _ = e.findItemIndex(g);
          if (E > _) {
            const L = e.schedule.findJumpRestrictedIndex(_ + 1, E);
            if (L > _) {
              e.setSchedulePosition(L);
              return;
            }
          }
          let A = 0;
          if (D)
            e.timelinePos = C, e.checkBuffer();
          else {
            const L = y.event.assetList, N = d - (y[f] || y).start;
            for (let U = L.length; U--; ) {
              const z = L[U];
              if (z.duration && N >= z.startOffset && N < z.startOffset + z.duration) {
                A = U;
                break;
              }
            }
          }
          e.setSchedulePosition(E, A);
        }
      }
    }, l = () => {
      const d = e.effectivePlayingItem;
      if (e.isInterstitial(d))
        return d;
      const f = n();
      return e.isInterstitial(f) ? f : null;
    }, c = {
      get bufferedEnd() {
        const d = n(), f = e.bufferingItem;
        if (f && f === d) {
          var h;
          return i(f, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - f.playout.start || ((h = e.bufferingAsset) == null ? void 0 : h.startOffset) || 0;
        }
        return 0;
      },
      get currentTime() {
        const d = l(), f = e.effectivePlayingItem;
        return f && f === d ? i(f, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - f.playout.start : 0;
      },
      set currentTime(d) {
        const f = l(), h = e.effectivePlayingItem;
        h && h === f && u(d + h.playout.start, "playout");
      },
      get duration() {
        const d = l();
        return d ? d.playout.end - d.playout.start : 0;
      },
      get assetPlayers() {
        var d;
        const f = (d = l()) == null ? void 0 : d.event.assetList;
        return f ? f.map((h) => e.getAssetPlayer(h.identifier)) : [];
      },
      get playingIndex() {
        var d;
        const f = (d = l()) == null ? void 0 : d.event;
        return f && e.effectivePlayingAsset ? f.findAssetIndex(e.effectivePlayingAsset) : -1;
      },
      get scheduleItem() {
        return l();
      }
    };
    return this.manager = {
      get events() {
        var d;
        return ((d = e.schedule) == null || (d = d.events) == null ? void 0 : d.slice(0)) || [];
      },
      get schedule() {
        var d;
        return ((d = e.schedule) == null || (d = d.items) == null ? void 0 : d.slice(0)) || [];
      },
      get interstitialPlayer() {
        return l() ? c : null;
      },
      get playerQueue() {
        return e.playerQueue.slice(0);
      },
      get bufferingAsset() {
        return e.bufferingAsset;
      },
      get bufferingItem() {
        return n();
      },
      get bufferingIndex() {
        const d = n();
        return e.findItemIndex(d);
      },
      get playingAsset() {
        return e.effectivePlayingAsset;
      },
      get playingItem() {
        return e.effectivePlayingItem;
      },
      get playingIndex() {
        const d = e.effectivePlayingItem;
        return e.findItemIndex(d);
      },
      primary: {
        get bufferedEnd() {
          return a();
        },
        get currentTime() {
          const d = e.timelinePos;
          return d > 0 ? d : 0;
        },
        set currentTime(d) {
          u(d, "primary");
        },
        get duration() {
          return o("primary");
        },
        get seekableStart() {
          var d;
          return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0;
        }
      },
      integrated: {
        get bufferedEnd() {
          return i(n(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd");
        },
        get currentTime() {
          return i(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime");
        },
        set currentTime(d) {
          u(d, "integrated");
        },
        get duration() {
          return o("integrated");
        },
        get seekableStart() {
          var d;
          return s(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, "integrated");
        }
      },
      skip: () => {
        const d = e.effectivePlayingItem, f = d == null ? void 0 : d.event;
        if (f && !f.restrictions.skip) {
          const h = e.findItemIndex(d);
          if (f.appendInPlace) {
            const m = d.playout.start + d.event.duration;
            u(m + 1e-3, "playout");
          } else
            e.advanceAfterAssetEnded(f, h, 1 / 0);
        }
      }
    };
  }
  // Schedule getters
  get effectivePlayingItem() {
    return this.waitingItem || this.playingItem || this.endedItem;
  }
  get effectivePlayingAsset() {
    return this.playingAsset || this.endedAsset;
  }
  get playingLastItem() {
    var e;
    const n = this.playingItem, r = (e = this.schedule) == null ? void 0 : e.items;
    return !this.playbackStarted || !n || !r ? !1 : this.findItemIndex(n) === r.length - 1;
  }
  get playbackStarted() {
    return this.effectivePlayingItem !== null;
  }
  // Media getters and event callbacks
  get currentTime() {
    var e, n;
    if (this.mediaSelection === null)
      return;
    const r = this.waitingItem || this.playingItem;
    if (this.isInterstitial(r) && !r.event.appendInPlace)
      return;
    let i = this.media;
    !i && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (i = this.primaryMedia);
    const s = (n = i) == null ? void 0 : n.currentTime;
    if (!(s === void 0 || !ue(s)))
      return s;
  }
  get primaryMedia() {
    var e;
    return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;
  }
  isInterstitial(e) {
    return !!(e != null && e.event);
  }
  retreiveMediaSource(e, n) {
    const r = this.getAssetPlayer(e);
    r && this.transferMediaFromPlayer(r, n);
  }
  transferMediaFromPlayer(e, n) {
    const r = e.interstitial.appendInPlace, i = e.media;
    if (r && i === this.primaryMedia) {
      if (this.bufferingAsset = null, (!n || this.isInterstitial(n) && !n.event.appendInPlace) && n && i) {
        this.detachedData = {
          media: i
        };
        return;
      }
      const s = e.transferMedia();
      this.log(`transfer MediaSource from ${e} ${ze(s)}`), this.detachedData = s;
    } else n && i && (this.shouldPlay || (this.shouldPlay = !i.paused));
  }
  transferMediaTo(e, n) {
    var r, i;
    if (e.media === n)
      return;
    let s = null;
    const a = this.hls, o = e !== a, u = o && e.interstitial.appendInPlace, l = (r = this.detachedData) == null ? void 0 : r.mediaSource;
    let c;
    if (a.media)
      u && (s = a.transferMedia(), this.detachedData = s), c = "Primary";
    else if (l) {
      const m = this.getBufferingPlayer();
      m ? (s = m.transferMedia(), c = `${m}`) : c = "detached MediaSource";
    } else
      c = "detached media";
    if (!s) {
      if (l)
        s = this.detachedData, this.log(`using detachedData: MediaSource ${ze(s)}`);
      else if (!this.detachedData || a.media === n) {
        const m = this.playerQueue;
        m.length > 1 && m.forEach((p) => {
          if (o && p.interstitial.appendInPlace !== u) {
            const g = p.interstitial;
            this.clearInterstitial(p.interstitial, null), g.appendInPlace = !1, g.appendInPlace && this.warn(`Could not change append strategy for queued assets ${g}`);
          }
        }), this.hls.detachMedia(), this.detachedData = {
          media: n
        };
      }
    }
    const d = s && "mediaSource" in s && ((i = s.mediaSource) == null ? void 0 : i.readyState) !== "closed", f = d && s ? s : n;
    this.log(`${d ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${c} (media.currentTime: ${n.currentTime})`);
    const h = this.schedule;
    if (f === s && h) {
      const m = o && e.assetId === h.assetIdAtEnd;
      f.overrides = {
        duration: h.duration,
        endOfStream: !o || m,
        cueRemoval: !o
      };
    }
    e.attachMedia(f);
  }
  onInterstitialCueEnter() {
    this.onTimeupdate();
  }
  // Scheduling methods
  checkStart() {
    const e = this.schedule, n = e == null ? void 0 : e.events;
    if (!n || this.playbackDisabled || !this.media)
      return;
    this.bufferedPos === -1 && (this.bufferedPos = 0);
    const r = this.timelinePos, i = this.effectivePlayingItem;
    if (r === -1) {
      const s = this.hls.startPosition;
      if (this.log(ro("checkStart", s)), this.timelinePos = s, n.length && n[0].cue.pre) {
        const a = e.findEventIndex(n[0].identifier);
        this.setSchedulePosition(a);
      } else if (s >= 0 || !this.primaryLive) {
        const a = this.timelinePos = s > 0 ? s : 0, o = e.findItemIndexAtTime(a);
        this.setSchedulePosition(o);
      }
    } else if (i && !this.playingItem) {
      const s = e.findItemIndex(i);
      this.setSchedulePosition(s);
    }
  }
  advanceAssetBuffering(e, n) {
    const r = e.event, i = r.findAssetIndex(n), s = _l(r, i);
    if (!r.isAssetPastPlayoutLimit(s))
      this.bufferedToEvent(e, s);
    else if (this.schedule) {
      var a;
      const o = (a = this.schedule.items) == null ? void 0 : a[this.findItemIndex(e) + 1];
      o && this.bufferedToItem(o);
    }
  }
  advanceAfterAssetEnded(e, n, r) {
    const i = _l(e, r);
    if (e.isAssetPastPlayoutLimit(i)) {
      if (this.schedule) {
        const s = this.schedule.items;
        if (s) {
          const a = n + 1, o = s.length;
          if (a >= o) {
            this.setSchedulePosition(-1);
            return;
          }
          const u = e.resumeTime;
          this.timelinePos < u && (this.log(ro("advanceAfterAssetEnded", u)), this.timelinePos = u, e.appendInPlace && this.advanceInPlace(u), this.checkBuffer(this.bufferedPos < u)), this.setSchedulePosition(a);
        }
      }
    } else {
      if (e.appendInPlace) {
        const s = e.assetList[i];
        s && this.advanceInPlace(s.timelineStart);
      }
      this.setSchedulePosition(n, i);
    }
  }
  setScheduleToAssetAtTime(e, n) {
    const r = this.schedule;
    if (!r)
      return;
    const i = n.parentIdentifier, s = r.getEvent(i);
    if (s) {
      const a = r.findEventIndex(i), o = r.findAssetIndex(s, e);
      this.advanceAfterAssetEnded(s, a, o - 1);
    }
  }
  setSchedulePosition(e, n) {
    var r;
    const i = (r = this.schedule) == null ? void 0 : r.items;
    if (!i || this.playbackDisabled)
      return;
    const s = e >= 0 ? i[e] : null;
    this.log(`setSchedulePosition ${e}, ${n} (${s && cn(s)}) pos: ${this.timelinePos}`);
    const a = this.waitingItem || this.playingItem, o = this.playingLastItem;
    if (this.isInterstitial(a)) {
      const c = a.event, d = this.playingAsset, f = d == null ? void 0 : d.identifier, h = f ? this.getAssetPlayer(f) : null;
      if (h && f && (!this.eventItemsMatch(a, s) || n !== void 0 && f !== c.assetList[n].identifier)) {
        var u;
        const m = c.findAssetIndex(d);
        if (this.log(`INTERSTITIAL_ASSET_ENDED ${m + 1}/${c.assetList.length} ${xi(d)}`), this.endedAsset = d, this.playingAsset = null, this.hls.trigger(x.INTERSTITIAL_ASSET_ENDED, {
          asset: d,
          assetListIndex: m,
          event: c,
          schedule: i.slice(0),
          scheduleIndex: e,
          player: h
        }), a !== this.playingItem) {
          this.itemsMatch(a, this.playingItem) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          !this.playingAsset && this.advanceAfterAssetEnded(c, this.findItemIndex(this.playingItem), m);
          return;
        }
        this.retreiveMediaSource(f, s), h.media && !((u = this.detachedData) != null && u.mediaSource) && h.detachMedia();
      }
      if (!this.eventItemsMatch(a, s) && (this.endedItem = a, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${c} ${cn(a)}`), c.hasPlayed = !0, this.hls.trigger(x.INTERSTITIAL_ENDED, {
        event: c,
        schedule: i.slice(0),
        scheduleIndex: e
      }), c.cue.once)) {
        var l;
        this.updateSchedule();
        const m = (l = this.schedule) == null ? void 0 : l.items;
        if (s && m) {
          const p = this.findItemIndex(s);
          this.advanceSchedule(p, m, n, a, o);
        }
        return;
      }
    }
    this.advanceSchedule(e, i, n, a, o);
  }
  advanceSchedule(e, n, r, i, s) {
    const a = this.schedule;
    if (!a)
      return;
    const o = n[e] || null, u = this.primaryMedia, l = this.playerQueue;
    if (l.length && l.forEach((c) => {
      const d = c.interstitial, f = a.findEventIndex(d.identifier);
      (f < e || f > e + 1) && this.clearInterstitial(d, o);
    }), this.isInterstitial(o)) {
      this.timelinePos = Math.min(Math.max(this.timelinePos, o.start), o.end);
      const c = o.event;
      if (r === void 0) {
        r = a.findAssetIndex(c, this.timelinePos);
        const m = _l(c, r - 1);
        if (c.isAssetPastPlayoutLimit(m) || c.appendInPlace && this.timelinePos === o.end) {
          this.advanceAfterAssetEnded(c, e, r);
          return;
        }
        r = m;
      }
      const d = this.waitingItem;
      this.assetsBuffered(o, u) || this.setBufferingItem(o);
      let f = this.preloadAssets(c, r);
      if (this.eventItemsMatch(o, d || i) || (this.waitingItem = o, this.log(`INTERSTITIAL_STARTED ${cn(o)} ${c.appendInPlace ? "append in place" : ""}`), this.hls.trigger(x.INTERSTITIAL_STARTED, {
        event: c,
        schedule: n.slice(0),
        scheduleIndex: e
      })), !c.assetListLoaded) {
        this.log(`Waiting for ASSET-LIST to complete loading ${c}`);
        return;
      }
      if (c.assetListLoader && (c.assetListLoader.destroy(), c.assetListLoader = void 0), !u) {
        this.log(`Waiting for attachMedia to start Interstitial ${c}`);
        return;
      }
      this.waitingItem = this.endedItem = null, this.playingItem = o;
      const h = c.assetList[r];
      if (!h) {
        this.advanceAfterAssetEnded(c, e, r || 0);
        return;
      }
      if (f || (f = this.getAssetPlayer(h.identifier)), f === null || f.destroyed) {
        const m = c.assetList.length;
        this.warn(`asset ${r + 1}/${m} player destroyed ${c}`), f = this.createAssetPlayer(c, h, r), f.loadSource();
      }
      if (!this.eventItemsMatch(o, this.bufferingItem) && c.appendInPlace && this.isAssetBuffered(h))
        return;
      this.startAssetPlayer(f, r, n, e, u), this.shouldPlay && om(f.media);
    } else o ? (this.resumePrimary(o, e, i), this.shouldPlay && om(this.hls.media)) : s && this.isInterstitial(i) && (this.endedItem = null, this.playingItem = i, i.event.appendInPlace || this.attachPrimary(a.durations.primary, null));
  }
  get playbackDisabled() {
    return this.hls.config.enableInterstitialPlayback === !1;
  }
  get primaryDetails() {
    var e;
    return (e = this.mediaSelection) == null ? void 0 : e.main.details;
  }
  get primaryLive() {
    var e;
    return !!((e = this.primaryDetails) != null && e.live);
  }
  resumePrimary(e, n, r) {
    var i, s;
    if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${cn(e)}`), !((i = this.detachedData) != null && i.mediaSource)) {
      let o = this.timelinePos;
      (o < e.start || o >= e.end) && (o = this.getPrimaryResumption(e, n), this.log(ro("resumePrimary", o)), this.timelinePos = o), this.attachPrimary(o, e);
    }
    if (!r)
      return;
    const a = (s = this.schedule) == null ? void 0 : s.items;
    a && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${cn(e)}`), this.hls.trigger(x.INTERSTITIALS_PRIMARY_RESUMED, {
      schedule: a.slice(0),
      scheduleIndex: n
    }), this.checkBuffer());
  }
  getPrimaryResumption(e, n) {
    const r = e.start;
    if (this.primaryLive) {
      const i = this.primaryDetails;
      if (n === 0)
        return this.hls.startPosition;
      if (i && (r < i.fragmentStart || r > i.edge))
        return this.hls.liveSyncPosition || -1;
    }
    return r;
  }
  isAssetBuffered(e) {
    const n = this.getAssetPlayer(e.identifier);
    return n != null && n.hls ? n.hls.bufferedToEnd : ye.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0);
  }
  attachPrimary(e, n, r) {
    n ? this.setBufferingItem(n) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
    const i = this.primaryMedia;
    if (!i)
      return;
    const s = this.hls;
    s.media ? this.checkBuffer() : (this.transferMediaTo(s, i), r && this.startLoadingPrimaryAt(e, r)), r || (this.log(ro("attachPrimary", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, r));
  }
  startLoadingPrimaryAt(e, n) {
    var r;
    const i = this.hls;
    !i.loadingEnabled || !i.media || Math.abs((((r = i.mainForwardBufferInfo) == null ? void 0 : r.start) || i.media.currentTime) - e) > 0.5 ? i.startLoad(e, n) : i.bufferingEnabled || i.resumeBuffering();
  }
  // HLS.js event callbacks
  onManifestLoading() {
    var e;
    this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(x.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(x.BUFFER_CODECS, this.onBufferCodecs, this);
  }
  onLevelUpdated(e, n) {
    if (n.level === -1 || !this.schedule)
      return;
    const r = this.hls.levels[n.level];
    if (!r.details)
      return;
    const i = Fe(Fe({}, this.mediaSelection || this.altSelection), {}, {
      main: r
    });
    this.mediaSelection = i, this.schedule.parseInterstitialDateRanges(i, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart();
  }
  onAudioTrackUpdated(e, n) {
    const r = this.hls.audioTracks[n.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = Fe(Fe({}, this.altSelection), {}, {
        audio: r
      });
      return;
    }
    const s = Fe(Fe({}, i), {}, {
      audio: r
    });
    this.mediaSelection = s;
  }
  onSubtitleTrackUpdated(e, n) {
    const r = this.hls.subtitleTracks[n.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = Fe(Fe({}, this.altSelection), {}, {
        subtitles: r
      });
      return;
    }
    const s = Fe(Fe({}, i), {}, {
      subtitles: r
    });
    this.mediaSelection = s;
  }
  onAudioTrackSwitching(e, n) {
    const r = g0(n);
    this.playerQueue.forEach(({
      hls: i
    }) => i && (i.setAudioOption(n) || i.setAudioOption(r)));
  }
  onSubtitleTrackSwitch(e, n) {
    const r = g0(n);
    this.playerQueue.forEach(({
      hls: i
    }) => i && (i.setSubtitleOption(n) || n.id !== -1 && i.setSubtitleOption(r)));
  }
  onBufferCodecs(e, n) {
    const r = n.tracks;
    r && (this.requiredTracks = r);
  }
  onBufferAppended(e, n) {
    this.checkBuffer();
  }
  onBufferFlushed(e, n) {
    const r = this.playingItem;
    if (r && !this.itemsMatch(r, this.bufferingItem) && !this.isInterstitial(r)) {
      const i = this.timelinePos;
      this.bufferedPos = i, this.checkBuffer();
    }
  }
  onBufferedToEnd(e) {
    if (!this.schedule)
      return;
    const n = this.schedule.events;
    if (this.bufferedPos < Number.MAX_VALUE && n) {
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (s.cue.post) {
          var r;
          const a = this.schedule.findEventIndex(s.identifier), o = (r = this.schedule.items) == null ? void 0 : r[a];
          this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0);
          break;
        }
      }
      this.bufferedPos = Number.MAX_VALUE;
    }
  }
  onMediaEnded(e) {
    const n = this.playingItem;
    if (!this.playingLastItem && n) {
      const r = this.findItemIndex(n);
      this.setSchedulePosition(r + 1);
    } else
      this.shouldPlay = !1;
  }
  updateItem(e, n) {
    var r;
    const i = (r = this.schedule) == null ? void 0 : r.items;
    if (e && i) {
      const s = this.findItemIndex(e, n);
      return i[s] || null;
    }
    return null;
  }
  trimInPlace(e, n) {
    if (this.isInterstitial(e) && e.event.appendInPlace && n.end - e.end > 0.25) {
      e.event.assetList.forEach((s, a) => {
        e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(s.identifier, null);
      });
      const r = e.end + 0.25, i = ye.bufferInfo(this.primaryMedia, r, 0);
      (i.end > r || (i.nextStart || 0) > r) && (this.log(`trim buffered interstitial ${cn(e)} (was ${cn(n)})`), this.attachPrimary(r, null, !0), this.flushFrontBuffer(r));
    }
  }
  itemsMatch(e, n) {
    return !!n && (e === n || e.event && n.event && this.eventItemsMatch(e, n) || !e.event && !n.event && this.findItemIndex(e) === this.findItemIndex(n));
  }
  eventItemsMatch(e, n) {
    var r;
    return !!n && (e === n || e.event.identifier === ((r = n.event) == null ? void 0 : r.identifier));
  }
  findItemIndex(e, n) {
    return e && this.schedule ? this.schedule.findItemIndex(e, n) : -1;
  }
  updateSchedule(e = !1) {
    var n;
    const r = this.mediaSelection;
    r && ((n = this.schedule) == null || n.updateSchedule(r, [], e));
  }
  // Schedule buffer control
  checkBuffer(e) {
    var n;
    const r = (n = this.schedule) == null ? void 0 : n.items;
    if (!r)
      return;
    const i = ye.bufferInfo(this.primaryMedia, this.timelinePos, 0);
    e && (this.bufferedPos = this.timelinePos), e || (e = i.len < 1), this.updateBufferedPos(i.end, r, e);
  }
  updateBufferedPos(e, n, r) {
    const i = this.schedule, s = this.bufferingItem;
    if (this.bufferedPos > e || !i)
      return;
    if (n.length === 1 && this.itemsMatch(n[0], s)) {
      this.bufferedPos = e;
      return;
    }
    const a = this.playingItem, o = this.findItemIndex(a);
    let u = i.findItemIndexAtTime(e);
    if (this.bufferedPos < e) {
      var l;
      const c = this.findItemIndex(s), d = Math.min(c + 1, n.length - 1), f = n[d];
      if ((u === -1 && s && e >= s.end || (l = f.event) != null && l.appendInPlace && e + 0.01 >= f.start) && (u = d), this.isInterstitial(s)) {
        const h = s.event;
        if (d - o > 1 && h.appendInPlace === !1 || h.assetList.length === 0 && h.assetListLoader)
          return;
      }
      if (this.bufferedPos = e, u > c && u > o)
        this.bufferedToItem(f);
      else {
        const h = this.primaryDetails;
        this.primaryLive && h && e > h.edge - h.targetduration && f.start < h.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(f) && this.preloadAssets(f.event, 0);
      }
    } else r && a && !this.itemsMatch(a, s) && (u === o ? this.bufferedToItem(a) : u === o + 1 && this.bufferedToItem(n[u]));
  }
  assetsBuffered(e, n) {
    return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((i) => {
      const s = this.getAssetPlayer(i.identifier);
      return !(s != null && s.bufferedInPlaceToEnd(n));
    });
  }
  setBufferingItem(e) {
    const n = this.bufferingItem, r = this.schedule;
    if (!this.itemsMatch(e, n) && r) {
      const {
        items: i,
        events: s
      } = r;
      if (!i || !s)
        return n;
      const a = this.isInterstitial(e), o = this.getBufferingPlayer();
      this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
      const u = o ? o.remaining : n ? n.end - this.timelinePos : 0;
      if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${cn(e)}` + (n ? ` (${u.toFixed(2)} remaining)` : "")), !this.playbackDisabled)
        if (a) {
          const l = r.findAssetIndex(e.event, this.bufferedPos);
          e.event.assetList.forEach((c, d) => {
            const f = this.getAssetPlayer(c.identifier);
            f && (d === l && f.loadSource(), f.resumeBuffering());
          });
        } else
          this.hls.resumeBuffering(), this.playerQueue.forEach((l) => l.pauseBuffering());
      this.hls.trigger(x.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
        events: s.slice(0),
        schedule: i.slice(0),
        bufferingIndex: this.findItemIndex(e),
        playingIndex: this.findItemIndex(this.playingItem)
      });
    } else this.bufferingItem !== e && (this.bufferingItem = e);
    return n;
  }
  bufferedToItem(e, n = 0) {
    const r = this.setBufferingItem(e);
    if (!this.playbackDisabled) {
      if (this.isInterstitial(e))
        this.bufferedToEvent(e, n);
      else if (r !== null) {
        this.bufferingAsset = null;
        const i = this.detachedData;
        i ? i.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);
      }
    }
  }
  preloadPrimary(e) {
    const n = this.findItemIndex(e), r = this.getPrimaryResumption(e, n);
    this.startLoadingPrimaryAt(r);
  }
  bufferedToEvent(e, n) {
    const r = e.event, i = r.assetList.length === 0 && !r.assetListLoader, s = r.cue.once;
    if (i || !s) {
      const a = this.preloadAssets(r, n);
      if (a != null && a.interstitial.appendInPlace) {
        const o = this.primaryMedia;
        o && this.bufferAssetPlayer(a, o);
      }
    }
  }
  preloadAssets(e, n) {
    const r = e.assetUrl, i = e.assetList.length, s = i === 0 && !e.assetListLoader, a = e.cue.once;
    if (s) {
      const u = e.timelineStart;
      if (e.appendInPlace) {
        var o;
        const f = this.playingItem;
        !this.isInterstitial(f) && (f == null || (o = f.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(u + 0.25);
      }
      let l, c = 0;
      if (!this.playingItem && this.primaryLive && (c = this.hls.startPosition, c === -1 && (c = this.hls.liveSyncPosition || 0)), c && !(e.cue.pre || e.cue.post)) {
        const f = c - u;
        f > 0 && (l = Math.round(f * 1e3) / 1e3);
      }
      if (this.log(`Load interstitial asset ${n + 1}/${r ? 1 : i} ${e}${l ? ` live-start: ${c} start-offset: ${l}` : ""}`), r)
        return this.createAsset(e, 0, 0, u, e.duration, r);
      const d = this.assetListLoader.loadAssetList(e, l);
      d && (e.assetListLoader = d);
    } else if (!a && i) {
      for (let l = n; l < i; l++) {
        const c = e.assetList[l], d = this.getAssetPlayerQueueIndex(c.identifier);
        (d === -1 || this.playerQueue[d].destroyed) && !c.error && this.createAssetPlayer(e, c, l);
      }
      const u = e.assetList[n];
      if (u) {
        const l = this.getAssetPlayer(u.identifier);
        return l && l.loadSource(), l;
      }
    }
    return null;
  }
  flushFrontBuffer(e) {
    const n = this.requiredTracks;
    if (!n)
      return;
    this.log(`Removing front buffer starting at ${e}`), Object.keys(n).forEach((i) => {
      this.hls.trigger(x.BUFFER_FLUSHING, {
        startOffset: e,
        endOffset: 1 / 0,
        type: i
      });
    });
  }
  // Interstitial Asset Player control
  getAssetPlayerQueueIndex(e) {
    const n = this.playerQueue;
    for (let r = 0; r < n.length; r++)
      if (e === n[r].assetId)
        return r;
    return -1;
  }
  getAssetPlayer(e) {
    const n = this.getAssetPlayerQueueIndex(e);
    return this.playerQueue[n] || null;
  }
  getBufferingPlayer() {
    const {
      playerQueue: e,
      primaryMedia: n
    } = this;
    if (n) {
      for (let r = 0; r < e.length; r++)
        if (e[r].media === n)
          return e[r];
    }
    return null;
  }
  createAsset(e, n, r, i, s, a) {
    const o = {
      parentIdentifier: e.identifier,
      identifier: iR(e, a, n),
      duration: s,
      startOffset: r,
      timelineStart: i,
      uri: a
    };
    return this.createAssetPlayer(e, o, n);
  }
  createAssetPlayer(e, n, r) {
    const i = this.hls, s = i.userConfig;
    let a = s.videoPreference;
    const o = i.loadLevelObj || i.levels[i.currentLevel];
    (a || o) && (a = Ge({}, a), o.videoCodec && (a.videoCodec = o.videoCodec), o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
    const u = i.audioTracks[i.audioTrack], l = i.subtitleTracks[i.subtitleTrack];
    let c = 0;
    if (this.primaryLive || e.appendInPlace) {
      const S = this.timelinePos - n.timelineStart;
      if (S > 1) {
        const v = n.duration;
        v && S < v && (c = S);
      }
    }
    const d = n.identifier, f = Fe(Fe({}, s), {}, {
      maxMaxBufferLength: Math.min(180, i.config.maxMaxBufferLength),
      autoStartLoad: !0,
      startFragPrefetch: !0,
      primarySessionId: i.sessionId,
      assetPlayerId: d,
      abrEwmaDefaultEstimate: i.bandwidthEstimate,
      interstitialsController: void 0,
      startPosition: c,
      liveDurationInfinity: !1,
      testBandwidth: !1,
      videoPreference: a,
      audioPreference: u || s.audioPreference,
      subtitlePreference: l || s.subtitlePreference
    });
    e.appendInPlace && (e.appendInPlaceStarted = !0, n.timelineStart && (f.timelineOffset = n.timelineStart));
    const h = f.cmcd;
    h != null && h.sessionId && h.contentId && (f.cmcd = Ge({}, h, {
      contentId: Fs(n.uri)
    })), this.getAssetPlayer(d) && this.warn(`Duplicate date range identifier ${e} and asset ${d}`);
    const m = new oR(this.HlsPlayerClass, f, e, n);
    this.playerQueue.push(m), e.assetList[r] = n;
    let p = !0;
    const g = (S) => {
      if (S.live) {
        var v;
        const D = new Error(`Interstitials MUST be VOD assets ${e}`), _ = {
          fatal: !0,
          type: de.OTHER_ERROR,
          details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: D
        }, A = ((v = this.schedule) == null ? void 0 : v.findEventIndex(e.identifier)) || -1;
        this.handleAssetItemError(_, e, A, r, D.message);
        return;
      }
      const I = S.edge - S.fragmentStart, C = n.duration;
      (p || C === null || I > C) && (p = !1, this.log(`Interstitial asset "${d}" duration change ${C} > ${I}`), n.duration = I, this.updateSchedule());
    };
    m.on(x.LEVEL_UPDATED, (S, {
      details: v
    }) => g(v)), m.on(x.LEVEL_PTS_UPDATED, (S, {
      details: v
    }) => g(v)), m.on(x.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter());
    const E = (S, v) => {
      const I = this.getAssetPlayer(d);
      if (I && v.tracks) {
        I.off(x.BUFFER_CODECS, E), I.tracks = v.tracks;
        const C = this.primaryMedia;
        this.bufferingAsset === I.assetItem && C && !I.media && this.bufferAssetPlayer(I, C);
      }
    };
    m.on(x.BUFFER_CODECS, E);
    const y = () => {
      var S;
      const v = this.getAssetPlayer(d);
      if (this.log(`buffered to end of asset ${v}`), !v || !this.schedule)
        return;
      const I = this.schedule.findEventIndex(e.identifier), C = (S = this.schedule.items) == null ? void 0 : S[I];
      this.isInterstitial(C) && this.advanceAssetBuffering(C, n);
    };
    m.on(x.BUFFERED_TO_END, y);
    const T = (S) => () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      this.shouldPlay = !0;
      const I = this.schedule.findEventIndex(e.identifier);
      this.advanceAfterAssetEnded(e, I, S);
    };
    return m.once(x.MEDIA_ENDED, T(r)), m.once(x.PLAYOUT_LIMIT_REACHED, T(1 / 0)), m.on(x.ERROR, (S, v) => {
      if (!this.schedule)
        return;
      const I = this.getAssetPlayer(d);
      if (v.details === q.BUFFER_STALLED_ERROR) {
        if (I != null && I.appendInPlace) {
          this.handleInPlaceStall(e);
          return;
        }
        this.onTimeupdate(), this.checkBuffer(!0);
        return;
      }
      this.handleAssetItemError(v, e, this.schedule.findEventIndex(e.identifier), r, `Asset player error ${v.error} ${e}`);
    }), m.on(x.DESTROYING, () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      const v = new Error(`Asset player destroyed unexpectedly ${d}`), I = {
        fatal: !0,
        type: de.OTHER_ERROR,
        details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
        error: v
      };
      this.handleAssetItemError(I, e, this.schedule.findEventIndex(e.identifier), r, v.message);
    }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${xi(n)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_PLAYER_CREATED, {
      asset: n,
      assetListIndex: r,
      event: e,
      player: m
    }), m;
  }
  clearInterstitial(e, n) {
    e.assetList.forEach((r) => {
      this.clearAssetPlayer(r.identifier, n);
    }), e.reset();
  }
  resetAssetPlayer(e) {
    const n = this.getAssetPlayerQueueIndex(e);
    if (n !== -1) {
      this.log(`reset asset player "${e}" after error`);
      const r = this.playerQueue[n];
      this.transferMediaFromPlayer(r, null), r.resetDetails();
    }
  }
  clearAssetPlayer(e, n) {
    const r = this.getAssetPlayerQueueIndex(e);
    if (r !== -1) {
      const i = this.playerQueue[r];
      this.log(`clear ${i} toSegment: ${n && cn(n)}`), this.transferMediaFromPlayer(i, n), this.playerQueue.splice(r, 1), i.destroy();
    }
  }
  emptyPlayerQueue() {
    let e;
    for (; e = this.playerQueue.pop(); )
      e.destroy();
    this.playerQueue = [];
  }
  startAssetPlayer(e, n, r, i, s) {
    const {
      interstitial: a,
      assetItem: o,
      assetId: u
    } = e, l = a.assetList.length, c = this.playingAsset;
    this.endedAsset = null, this.playingAsset = o, (!c || c.identifier !== u) && (c && (this.clearAssetPlayer(c.identifier, r[i]), delete c.error), this.log(`INTERSTITIAL_ASSET_STARTED ${n + 1}/${l} ${xi(o)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_STARTED, {
      asset: o,
      assetListIndex: n,
      event: a,
      schedule: r.slice(0),
      scheduleIndex: i,
      player: e
    })), this.bufferAssetPlayer(e, s);
  }
  bufferAssetPlayer(e, n) {
    var r, i;
    if (!this.schedule)
      return;
    const {
      interstitial: s,
      assetItem: a
    } = e, o = this.schedule.findEventIndex(s.identifier), u = (r = this.schedule.items) == null ? void 0 : r[o];
    if (!u)
      return;
    e.loadSource(), this.setBufferingItem(u), this.bufferingAsset = a;
    const l = this.getBufferingPlayer();
    if (l === e)
      return;
    const c = s.appendInPlace;
    if (c && (l == null ? void 0 : l.interstitial.appendInPlace) === !1)
      return;
    const d = (l == null ? void 0 : l.tracks) || ((i = this.detachedData) == null ? void 0 : i.tracks) || this.requiredTracks;
    if (c && a !== this.playingAsset) {
      if (!e.tracks) {
        this.log(`Waiting for track info before buffering ${e}`);
        return;
      }
      if (d && !eb(d, e.tracks)) {
        const f = new Error(`Asset ${xi(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`), h = {
          fatal: !0,
          type: de.OTHER_ERROR,
          details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: f
        }, m = s.findAssetIndex(a);
        this.handleAssetItemError(h, s, o, m, f.message);
        return;
      }
    }
    this.transferMediaTo(e, n);
  }
  handleInPlaceStall(e) {
    const n = this.schedule, r = this.primaryMedia;
    if (!n || !r)
      return;
    const i = r.currentTime, s = n.findAssetIndex(e, i), a = e.assetList[s];
    if (a) {
      const o = this.getAssetPlayer(a.identifier);
      if (o) {
        const u = o.currentTime || i - a.timelineStart, l = o.duration - u;
        if (this.warn(`Stalled at ${u} of ${u + l} in ${o} ${e} (media.currentTime: ${i})`), u && (l / r.playbackRate < 0.5 || o.bufferedInPlaceToEnd(r)) && o.hls) {
          const c = n.findEventIndex(e.identifier);
          this.advanceAfterAssetEnded(e, c, s);
        }
      }
    }
  }
  advanceInPlace(e) {
    const n = this.primaryMedia;
    n && n.currentTime < e && (n.currentTime = e);
  }
  handleAssetItemError(e, n, r, i, s) {
    if (e.details === q.BUFFER_STALLED_ERROR)
      return;
    const a = n.assetList[i] || null;
    if (this.warn(`INTERSTITIAL_ASSET_ERROR ${a && xi(a)} ${e.error}`), !this.schedule)
      return;
    const o = (a == null ? void 0 : a.identifier) || "", u = this.getAssetPlayerQueueIndex(o), l = this.playerQueue[u] || null, c = this.schedule.items, d = Ge({}, e, {
      fatal: !1,
      errorAction: Li(!0),
      asset: a,
      assetListIndex: i,
      event: n,
      schedule: c,
      scheduleIndex: r,
      player: l
    });
    if (this.hls.trigger(x.INTERSTITIAL_ASSET_ERROR, d), !e.fatal)
      return;
    const f = this.playingAsset, h = this.bufferingAsset, m = new Error(s);
    if (a && (this.clearAssetPlayer(o, null), a.error = m), !n.assetList.some((p) => !p.error))
      n.error = m;
    else
      for (let p = i; p < n.assetList.length; p++)
        this.resetAssetPlayer(n.assetList[p].identifier);
    this.updateSchedule(!0), n.error ? this.primaryFallback(n) : f && f.identifier === o ? this.advanceAfterAssetEnded(n, r, i) : h && h.identifier === o && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, h);
  }
  primaryFallback(e) {
    const n = e.timelineStart, r = this.effectivePlayingItem;
    if (r) {
      this.log(`Fallback to primary from event "${e.identifier}" start: ${n} pos: ${this.timelinePos} playing: ${cn(r)} error: ${e.error}`);
      let i = this.timelinePos;
      i === -1 && (i = this.hls.startPosition);
      const s = this.updateItem(r, i);
      if (this.itemsMatch(r, s) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(n, null), this.flushFrontBuffer(n)), !this.schedule)
        return;
      const a = this.schedule.findItemIndexAtTime(i);
      this.setSchedulePosition(a);
    } else
      this.checkStart();
  }
  // Asset List loading
  onAssetListLoaded(e, n) {
    var r, i;
    const s = n.event, a = s.identifier, o = n.assetListResponse.ASSETS;
    if (!((r = this.schedule) != null && r.hasEvent(a)))
      return;
    const u = s.timelineStart, l = s.duration;
    let c = 0;
    o.forEach((p, g) => {
      const E = parseFloat(p.DURATION);
      this.createAsset(s, g, c, u + c, E, p.URI), c += E;
    }), s.duration = c, this.log(`Loaded asset-list with duration: ${c} (was: ${l}) ${s}`);
    const d = this.waitingItem, f = (d == null ? void 0 : d.event.identifier) === a;
    this.updateSchedule();
    const h = (i = this.bufferingItem) == null ? void 0 : i.event;
    if (f) {
      var m;
      const p = this.schedule.findEventIndex(a), g = (m = this.schedule.items) == null ? void 0 : m[p];
      if (g) {
        if (!this.playingItem && this.timelinePos > g.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== p) {
          s.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${s}`), this.updateSchedule(!0), this.primaryFallback(s);
          return;
        }
        this.setBufferingItem(g);
      }
      this.setSchedulePosition(p);
    } else if ((h == null ? void 0 : h.identifier) === a) {
      const p = s.assetList[0];
      if (p) {
        const g = this.getAssetPlayer(p.identifier);
        if (h.appendInPlace) {
          const E = this.primaryMedia;
          g && E && this.bufferAssetPlayer(g, E);
        } else g && g.loadSource();
      }
    }
  }
  onError(e, n) {
    if (this.schedule)
      switch (n.details) {
        case q.ASSET_LIST_PARSING_ERROR:
        case q.ASSET_LIST_LOAD_ERROR:
        case q.ASSET_LIST_LOAD_TIMEOUT: {
          const r = n.interstitial;
          r && (this.updateSchedule(!0), this.primaryFallback(r));
          break;
        }
        case q.BUFFER_STALLED_ERROR: {
          const r = this.endedItem || this.waitingItem || this.playingItem;
          if (this.isInterstitial(r) && r.event.appendInPlace) {
            this.handleInPlaceStall(r.event);
            return;
          }
          this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0);
          break;
        }
      }
  }
}
const um = 500;
class dR extends Tf {
  constructor(e, n, r) {
    super(e, n, r, "subtitle-stream-controller", le.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  startLoad(e, n) {
    this.stopLoad(), this.state = Y.IDLE, this.setInterval(um), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
  }
  onManifestLoading() {
    super.onManifestLoading(), this.mainDetails = null;
  }
  onMediaDetaching(e, n) {
    this.tracksBuffered = [], super.onMediaDetaching(e, n);
  }
  onLevelLoaded(e, n) {
    this.mainDetails = n.details;
  }
  onSubtitleFragProcessed(e, n) {
    const {
      frag: r,
      success: i
    } = n;
    if (this.fragContextChanged(r) || (ct(r) && (this.fragPrevious = r), this.state = Y.IDLE), !i)
      return;
    const s = this.tracksBuffered[this.currentTrackId];
    if (!s)
      return;
    let a;
    const o = r.start;
    for (let l = 0; l < s.length; l++)
      if (o >= s[l].start && o <= s[l].end) {
        a = s[l];
        break;
      }
    const u = r.start + r.duration;
    a ? a.end = u : (a = {
      start: o,
      end: u
    }, s.push(a)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null), this.media && this.tick();
  }
  onBufferFlushing(e, n) {
    const {
      startOffset: r,
      endOffset: i
    } = n;
    if (r === 0 && i !== Number.POSITIVE_INFINITY) {
      const s = i - 1;
      if (s <= 0)
        return;
      n.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach((a) => {
        for (let o = 0; o < a.length; ) {
          if (a[o].end <= s) {
            a.shift();
            continue;
          } else if (a[o].start < s)
            a[o].start = s;
          else
            break;
          o++;
        }
      }), this.fragmentTracker.removeFragmentsInRange(r, s, le.SUBTITLE);
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(e, n) {
    const r = n.frag;
    (r == null ? void 0 : r.type) === le.SUBTITLE && (n.details === q.FRAG_GAP && this.fragmentTracker.fragBuffered(r, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== Y.STOPPED && (this.state = Y.IDLE));
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(e, {
    subtitleTracks: n
  }) {
    if (this.levels && rE(this.levels, n)) {
      this.levels = n.map((r) => new na(r));
      return;
    }
    this.tracksBuffered = [], this.levels = n.map((r) => {
      const i = new na(r);
      return this.tracksBuffered[i.id] = [], i;
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, le.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(e, n) {
    var r;
    if (this.currentTrackId = n.id, !((r = this.levels) != null && r.length) || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const i = this.levels[this.currentTrackId];
    i != null && i.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, i && this.state !== Y.STOPPED && this.setInterval(um);
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(e, n) {
    var r;
    const {
      currentTrackId: i,
      levels: s
    } = this, {
      details: a,
      id: o
    } = n;
    if (!s) {
      this.warn(`Subtitle tracks were reset while loading level ${o}`);
      return;
    }
    const u = s[o];
    if (o >= s.length || !u)
      return;
    this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
    let l = 0;
    if (a.live || (r = u.details) != null && r.live) {
      if (a.deltaUpdateFailed)
        return;
      const d = this.mainDetails;
      if (!d) {
        this.startFragRequested = !1;
        return;
      }
      const f = d.fragments[0];
      if (!u.details)
        a.hasProgramDateTime && d.hasProgramDateTime ? (du(a, d), l = a.fragmentStart) : f && (l = f.start, qc(a, l));
      else {
        var c;
        l = this.alignPlaylists(a, u.details, (c = this.levelLastLoaded) == null ? void 0 : c.details), l === 0 && f && (l = f.start, qc(a, l));
      }
      d && !this.startFragRequested && this.setStartPosition(d, l);
    }
    u.details = a, this.levelLastLoaded = u, o === i && (this.hls.trigger(x.SUBTITLE_TRACK_UPDATED, {
      details: a,
      id: o,
      groupId: n.groupId
    }), this.tick(), a.live && !this.fragCurrent && this.media && this.state === Y.IDLE && (Yr(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), u.details = void 0)));
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: n,
      payload: r
    } = e, i = n.decryptdata, s = this.hls;
    if (!this.fragContextChanged(n) && r && r.byteLength > 0 && i != null && i.key && i.iv && _i(i.method)) {
      const a = performance.now();
      this.decrypter.decrypt(new Uint8Array(r), i.key.buffer, i.iv.buffer, Ef(i.method)).catch((o) => {
        throw s.trigger(x.ERROR, {
          type: de.MEDIA_ERROR,
          details: q.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: o,
          reason: o.message,
          frag: n
        }), o;
      }).then((o) => {
        const u = performance.now();
        s.trigger(x.FRAG_DECRYPTED, {
          frag: n,
          payload: o,
          stats: {
            tstart: a,
            tdecrypt: u
          }
        });
      }).catch((o) => {
        this.warn(`${o.name}: ${o.message}`), this.state = Y.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = Y.IDLE;
      return;
    }
    if (this.state === Y.IDLE) {
      const {
        currentTrackId: e,
        levels: n
      } = this, r = n == null ? void 0 : n[e];
      if (!r || !n.length || !r.details || this.waitForLive(r))
        return;
      const {
        config: i
      } = this, s = this.getLoadPosition(), a = ye.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, i.maxBufferHole), {
        end: o,
        len: u
      } = a, l = r.details, c = this.hls.maxBufferLength + l.levelTargetDuration;
      if (u > c)
        return;
      const d = l.fragments, f = d.length, h = l.edge;
      let m = null;
      const p = this.fragPrevious;
      if (o < h) {
        const y = i.maxFragLookUpTolerance, T = o > h - y ? 0 : y;
        m = Yr(p, d, Math.max(d[0].start, o), T), !m && p && p.start < d[0].start && (m = d[0]);
      } else
        m = d[f - 1];
      if (m = this.filterReplacedPrimary(m, r.details), !m)
        return;
      const g = m.sn - l.startSN, E = d[g - 1];
      if (E && E.cc === m.cc && this.fragmentTracker.getState(E) === ft.NOT_LOADED && (m = E), this.fragmentTracker.getState(m) === ft.NOT_LOADED) {
        const y = this.mapToInitFragWhenRequired(m);
        y && this.loadFragment(y, r, o);
      }
    }
  }
  loadFragment(e, n, r) {
    ct(e) ? super.loadFragment(e, n, r) : this._loadInitSegment(e, n);
  }
  get mediaBufferTimeRanges() {
    return new fR(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class fR {
  constructor(e) {
    this.buffered = void 0;
    const n = (r, i, s) => {
      if (i = i >>> 0, i > s - 1)
        throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`);
      return e[i][r];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(r) {
        return n("end", r, e.length);
      },
      start(r) {
        return n("start", r, e.length);
      }
    };
  }
}
const hR = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
}, yE = (t) => String.fromCharCode(hR[t] || t), dn = 15, Qn = 100, mR = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}, pR = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}, gR = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}, bR = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}, ER = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class yR {
  constructor() {
    this.time = null, this.verboseLevel = 0;
  }
  log(e, n) {
    if (this.verboseLevel >= e) {
      const r = typeof n == "function" ? n() : n;
      Be.log(`${this.time} [${e}] ${r}`);
    }
  }
}
const Nr = function(e) {
  const n = [];
  for (let r = 0; r < e.length; r++)
    n.push(e[r].toString(16));
  return n;
};
class TE {
  constructor() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  setStyles(e) {
    const n = ["foreground", "underline", "italics", "background", "flash"];
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e.hasOwnProperty(i) && (this[i] = e[i]);
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}
class TR {
  constructor() {
    this.uchar = " ", this.penState = new TE();
  }
  reset() {
    this.uchar = " ", this.penState.reset();
  }
  setChar(e, n) {
    this.uchar = e, this.penState.copy(n);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class xR {
  constructor(e) {
    this.chars = [], this.pos = 0, this.currPenState = new TE(), this.cueStartTime = null, this.logger = void 0;
    for (let n = 0; n < Qn; n++)
      this.chars.push(new TR());
    this.logger = e;
  }
  equals(e) {
    for (let n = 0; n < Qn; n++)
      if (!this.chars[n].equals(e.chars[n]))
        return !1;
    return !0;
  }
  copy(e) {
    for (let n = 0; n < Qn; n++)
      this.chars[n].copy(e.chars[n]);
  }
  isEmpty() {
    let e = !0;
    for (let n = 0; n < Qn; n++)
      if (!this.chars[n].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Qn && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = Qn);
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(e) {
    const n = this.pos + e;
    if (e > 1)
      for (let r = this.pos + 1; r < n + 1; r++)
        this.chars[r].setPenState(this.currPenState);
    this.setCursor(n);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const n = yE(e);
    if (this.pos >= Qn) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + n + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(n, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let n;
    for (n = e; n < Qn; n++)
      this.chars[n].reset();
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let n = !0;
    for (let r = 0; r < Qn; r++) {
      const i = this.chars[r].uchar;
      i !== " " && (n = !1), e.push(i);
    }
    return n ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
  }
}
class Rl {
  constructor(e) {
    this.rows = [], this.currRow = dn - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
    for (let n = 0; n < dn; n++)
      this.rows.push(new xR(e));
    this.logger = e;
  }
  reset() {
    for (let e = 0; e < dn; e++)
      this.rows[e].clear();
    this.currRow = dn - 1;
  }
  equals(e) {
    let n = !0;
    for (let r = 0; r < dn; r++)
      if (!this.rows[r].equals(e.rows[r])) {
        n = !1;
        break;
      }
    return n;
  }
  copy(e) {
    for (let n = 0; n < dn; n++)
      this.rows[n].copy(e.rows[n]);
  }
  isEmpty() {
    let e = !0;
    for (let n = 0; n < dn; n++)
      if (!this.rows[n].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + ze(e));
    let n = e.row - 1;
    if (this.nrRollUpRows && n < this.nrRollUpRows - 1 && (n = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== n) {
      for (let o = 0; o < dn; o++)
        this.rows[o].clear();
      const s = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen;
      if (a) {
        const o = a.rows[s].cueStartTime, u = this.logger.time;
        if (o !== null && u !== null && o < u)
          for (let l = 0; l < this.nrRollUpRows; l++)
            this.rows[n - this.nrRollUpRows + l + 1].copy(a.rows[s + l]);
      }
    }
    this.currRow = n;
    const r = this.rows[this.currRow];
    if (e.indent !== null) {
      const s = e.indent, a = Math.max(s - 1, 0);
      r.setCursor(e.indent), e.color = r.chars[a].penState.foreground;
    }
    const i = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(i);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + ze(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows, n = this.rows.splice(e, 1)[0];
    n.clear(), this.rows.splice(this.currRow, 0, n), this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(e) {
    e = e || !1;
    const n = [];
    let r = "", i = -1;
    for (let s = 0; s < dn; s++) {
      const a = this.rows[s].getTextString();
      a && (i = s + 1, e ? n.push("Row " + i + ": '" + a + "'") : n.push(a.trim()));
    }
    return n.length > 0 && (e ? r = "[" + n.join(" | ") + "]" : r = n.join(`
`)), r;
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class lm {
  constructor(e, n, r) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = n, this.mode = null, this.verbose = 0, this.displayedMemory = new Rl(r), this.nonDisplayedMemory = new Rl(r), this.lastOutputScreen = new Rl(r), this.currRollUpRow = this.displayedMemory.rows[dn - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r;
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[dn - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
  }
  insertChars(e) {
    for (let r = 0; r < e.length; r++)
      this.writeScreen.insertChar(e[r]);
    const n = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => n + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const n = {
      flash: !1
    };
    if (n.underline = e % 2 === 1, n.italics = e >= 46, n.italics)
      n.foreground = "white";
    else {
      const r = Math.floor(e / 2) - 16, i = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      n.foreground = i[r];
    }
    this.logger.log(2, "MIDROW: " + ze(n)), this.writeScreen.setPen(n);
  }
  outputDataUpdate(e = !1) {
    const n = this.logger.time;
    n !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = n : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, n, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : n), this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
  }
}
class cm {
  constructor(e, n, r) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = AR(), this.logger = void 0;
    const i = this.logger = new yR();
    this.channels = [null, new lm(e, n, i), new lm(e + 1, r, i)];
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, n) {
    this.channels[e].setHandler(n);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(e, n) {
    this.logger.time = e;
    for (let r = 0; r < n.length; r += 2) {
      const i = n[r] & 127, s = n[r + 1] & 127;
      let a = !1, o = null;
      if (i === 0 && s === 0)
        continue;
      this.logger.log(3, () => "[" + Nr([n[r], n[r + 1]]) + "] -> (" + Nr([i, s]) + ")");
      const u = this.cmdHistory;
      if (i >= 16 && i <= 31) {
        if (SR(i, s, u)) {
          io(null, null, u), this.logger.log(3, () => "Repeated command (" + Nr([i, s]) + ") is dropped");
          continue;
        }
        io(i, s, this.cmdHistory), a = this.parseCmd(i, s), a || (a = this.parseMidrow(i, s)), a || (a = this.parsePAC(i, s)), a || (a = this.parseBackgroundAttributes(i, s));
      } else
        io(null, null, u);
      if (!a && (o = this.parseChars(i, s), o)) {
        const c = this.currentChannel;
        c && c > 0 ? this.channels[c].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
      }
      !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + Nr([i, s]) + " orig: " + Nr([n[r], n[r + 1]]));
    }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(e, n) {
    const r = (e === 20 || e === 28 || e === 21 || e === 29) && n >= 32 && n <= 47, i = (e === 23 || e === 31) && n >= 33 && n <= 35;
    if (!(r || i))
      return !1;
    const s = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[s];
    return e === 20 || e === 21 || e === 28 || e === 29 ? n === 32 ? a.ccRCL() : n === 33 ? a.ccBS() : n === 34 ? a.ccAOF() : n === 35 ? a.ccAON() : n === 36 ? a.ccDER() : n === 37 ? a.ccRU(2) : n === 38 ? a.ccRU(3) : n === 39 ? a.ccRU(4) : n === 40 ? a.ccFON() : n === 41 ? a.ccRDC() : n === 42 ? a.ccTR() : n === 43 ? a.ccRTD() : n === 44 ? a.ccEDM() : n === 45 ? a.ccCR() : n === 46 ? a.ccENM() : n === 47 && a.ccEOC() : a.ccTO(n - 32), this.currentChannel = s, !0;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(e, n) {
    let r = 0;
    if ((e === 17 || e === 25) && n >= 32 && n <= 47) {
      if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const i = this.channels[r];
      return i ? (i.ccMIDROW(n), this.logger.log(3, () => "MIDROW (" + Nr([e, n]) + ")"), !0) : !1;
    }
    return !1;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(e, n) {
    let r;
    const i = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && n >= 64 && n <= 127, s = (e === 16 || e === 24) && n >= 64 && n <= 95;
    if (!(i || s))
      return !1;
    const a = e <= 23 ? 1 : 2;
    n >= 64 && n <= 95 ? r = a === 1 ? mR[e] : gR[e] : r = a === 1 ? pR[e] : bR[e];
    const o = this.channels[a];
    return o ? (o.setPAC(this.interpretPAC(r, n)), this.currentChannel = a, !0) : !1;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(e, n) {
    let r;
    const i = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return n > 95 ? r = n - 96 : r = n - 64, i.underline = (r & 1) === 1, r <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = "white") : i.indent = Math.floor((r - 16) / 2) * 4, i;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(e, n) {
    let r, i = null, s = null;
    if (e >= 25 ? (r = 2, s = e - 8) : (r = 1, s = e), s >= 17 && s <= 19) {
      let a;
      s === 17 ? a = n + 80 : s === 18 ? a = n + 112 : a = n + 144, this.logger.log(2, () => "Special char '" + yE(a) + "' in channel " + r), i = [a];
    } else e >= 32 && e <= 127 && (i = n === 0 ? [e] : [e, n]);
    return i && this.logger.log(3, () => "Char codes =  " + Nr(i).join(",")), i;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(e, n) {
    const r = (e === 16 || e === 24) && n >= 32 && n <= 47, i = (e === 23 || e === 31) && n >= 45 && n <= 47;
    if (!(r || i))
      return !1;
    let s;
    const a = {};
    e === 16 || e === 24 ? (s = Math.floor((n - 32) / 2), a.background = ER[s], n % 2 === 1 && (a.background = a.background + "_semi")) : n === 45 ? a.background = "transparent" : (a.foreground = "black", n === 47 && (a.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(a), !0;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const n = this.channels[e];
      n && n.reset();
    }
    io(null, null, this.cmdHistory);
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(e) {
    for (let n = 0; n < this.channels.length; n++) {
      const r = this.channels[n];
      r && r.cueSplitAtTime(e);
    }
  }
}
function io(t, e, n) {
  n.a = t, n.b = e;
}
function SR(t, e, n) {
  return n.a === t && n.b === e;
}
function AR() {
  return {
    a: null,
    b: null
  };
}
var Df = function() {
  if (cu != null && cu.VTTCue)
    return self.VTTCue;
  const t = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"];
  function n(o, u) {
    if (typeof u != "string" || !Array.isArray(o))
      return !1;
    const l = u.toLowerCase();
    return ~o.indexOf(l) ? l : !1;
  }
  function r(o) {
    return n(t, o);
  }
  function i(o) {
    return n(e, o);
  }
  function s(o, ...u) {
    let l = 1;
    for (; l < arguments.length; l++) {
      const c = arguments[l];
      for (const d in c)
        o[d] = c[d];
    }
    return o;
  }
  function a(o, u, l) {
    const c = this, d = {
      enumerable: !0
    };
    c.hasBeenReset = !1;
    let f = "", h = !1, m = o, p = u, g = l, E = null, y = "", T = !0, S = "auto", v = "start", I = 50, C = "middle", D = 50, _ = "middle";
    Object.defineProperty(c, "id", s({}, d, {
      get: function() {
        return f;
      },
      set: function(A) {
        f = "" + A;
      }
    })), Object.defineProperty(c, "pauseOnExit", s({}, d, {
      get: function() {
        return h;
      },
      set: function(A) {
        h = !!A;
      }
    })), Object.defineProperty(c, "startTime", s({}, d, {
      get: function() {
        return m;
      },
      set: function(A) {
        if (typeof A != "number")
          throw new TypeError("Start time must be set to a number.");
        m = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "endTime", s({}, d, {
      get: function() {
        return p;
      },
      set: function(A) {
        if (typeof A != "number")
          throw new TypeError("End time must be set to a number.");
        p = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "text", s({}, d, {
      get: function() {
        return g;
      },
      set: function(A) {
        g = "" + A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "region", s({}, d, {
      get: function() {
        return E;
      },
      set: function(A) {
        E = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "vertical", s({}, d, {
      get: function() {
        return y;
      },
      set: function(A) {
        const L = r(A);
        if (L === !1)
          throw new SyntaxError("An invalid or illegal string was specified.");
        y = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "snapToLines", s({}, d, {
      get: function() {
        return T;
      },
      set: function(A) {
        T = !!A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "line", s({}, d, {
      get: function() {
        return S;
      },
      set: function(A) {
        if (typeof A != "number" && A !== "auto")
          throw new SyntaxError("An invalid number or illegal string was specified.");
        S = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "lineAlign", s({}, d, {
      get: function() {
        return v;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        v = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "position", s({}, d, {
      get: function() {
        return I;
      },
      set: function(A) {
        if (A < 0 || A > 100)
          throw new Error("Position must be between 0 and 100.");
        I = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "positionAlign", s({}, d, {
      get: function() {
        return C;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        C = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "size", s({}, d, {
      get: function() {
        return D;
      },
      set: function(A) {
        if (A < 0 || A > 100)
          throw new Error("Size must be between 0 and 100.");
        D = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "align", s({}, d, {
      get: function() {
        return _;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        _ = L, this.hasBeenReset = !0;
      }
    })), c.displayState = void 0;
  }
  return a.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text);
  }, a;
}();
class vR {
  decode(e, n) {
    if (!e)
      return "";
    if (typeof e != "string")
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function xE(t) {
  function e(r, i, s, a) {
    return (r | 0) * 3600 + (i | 0) * 60 + (s | 0) + parseFloat(a || 0);
  }
  const n = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return n ? parseFloat(n[2]) > 59 ? e(n[2], n[3], 0, n[4]) : e(n[1], n[2], n[3], n[4]) : null;
}
class IR {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(e, n) {
    !this.get(e) && n !== "" && (this.values[e] = n);
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(e, n, r) {
    return r ? this.has(e) ? this.values[e] : n[r] : this.has(e) ? this.values[e] : n;
  }
  // Check whether we have a value for a key.
  has(e) {
    return e in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(e, n, r) {
    for (let i = 0; i < r.length; ++i)
      if (n === r[i]) {
        this.set(e, n);
        break;
      }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(e, n) {
    /^-?\d+$/.test(n) && this.set(e, parseInt(n, 10));
  }
  // Accept a setting if its a valid percentage.
  percent(e, n) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(n)) {
      const r = parseFloat(n);
      if (r >= 0 && r <= 100)
        return this.set(e, r), !0;
    }
    return !1;
  }
}
function SE(t, e, n, r) {
  const i = r ? t.split(r) : [t];
  for (const s in i) {
    if (typeof i[s] != "string")
      continue;
    const a = i[s].split(n);
    if (a.length !== 2)
      continue;
    const o = a[0], u = a[1];
    e(o, u);
  }
}
const Jc = new Df(0, 0, ""), so = Jc.align === "middle" ? "middle" : "center";
function CR(t, e, n) {
  const r = t;
  function i() {
    const o = xE(t);
    if (o === null)
      throw new Error("Malformed timestamp: " + r);
    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function s(o, u) {
    const l = new IR();
    SE(o, function(f, h) {
      let m;
      switch (f) {
        case "region":
          for (let p = n.length - 1; p >= 0; p--)
            if (n[p].id === h) {
              l.set(f, n[p].region);
              break;
            }
          break;
        case "vertical":
          l.alt(f, h, ["rl", "lr"]);
          break;
        case "line":
          m = h.split(","), l.integer(f, m[0]), l.percent(f, m[0]) && l.set("snapToLines", !1), l.alt(f, m[0], ["auto"]), m.length === 2 && l.alt("lineAlign", m[1], ["start", so, "end"]);
          break;
        case "position":
          m = h.split(","), l.percent(f, m[0]), m.length === 2 && l.alt("positionAlign", m[1], ["start", so, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          l.percent(f, h);
          break;
        case "align":
          l.alt(f, h, ["start", so, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), u.region = l.get("region", null), u.vertical = l.get("vertical", "");
    let c = l.get("line", "auto");
    c === "auto" && Jc.line === -1 && (c = -1), u.line = c, u.lineAlign = l.get("lineAlign", "start"), u.snapToLines = l.get("snapToLines", !0), u.size = l.get("size", 100), u.align = l.get("align", so);
    let d = l.get("position", "auto");
    d === "auto" && Jc.position === 50 && (d = u.align === "start" || u.align === "left" ? 0 : u.align === "end" || u.align === "right" ? 100 : 50), u.position = d;
  }
  function a() {
    t = t.replace(/^\s+/, "");
  }
  if (a(), e.startTime = i(), a(), t.slice(0, 3) !== "-->")
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r);
  t = t.slice(3), a(), e.endTime = i(), a(), s(t, e);
}
function AE(t) {
  return t.replace(/<br(?: \/)?>/gi, `
`);
}
class LR {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new vR(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
  }
  parse(e) {
    const n = this;
    e && (n.buffer += n.decoder.decode(e, {
      stream: !0
    }));
    function r() {
      let s = n.buffer, a = 0;
      for (s = AE(s); a < s.length && s[a] !== "\r" && s[a] !== `
`; )
        ++a;
      const o = s.slice(0, a);
      return s[a] === "\r" && ++a, s[a] === `
` && ++a, n.buffer = s.slice(a), o;
    }
    function i(s) {
      SE(s, function(a, o) {
      }, /:/);
    }
    try {
      let s = "";
      if (n.state === "INITIAL") {
        if (!/\r\n|\n/.test(n.buffer))
          return this;
        s = r();
        const o = s.match(/^(Ã¯Â»Â¿)?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0]))
          throw new Error("Malformed WebVTT signature.");
        n.state = "HEADER";
      }
      let a = !1;
      for (; n.buffer; ) {
        if (!/\r\n|\n/.test(n.buffer))
          return this;
        switch (a ? a = !1 : s = r(), n.state) {
          case "HEADER":
            /:/.test(s) ? i(s) : s || (n.state = "ID");
            continue;
          case "NOTE":
            s || (n.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              n.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            if (n.cue = new Df(0, 0, ""), n.state = "CUE", s.indexOf("-->") === -1) {
              n.cue.id = s;
              continue;
            }
          case "CUE":
            if (!n.cue) {
              n.state = "BADCUE";
              continue;
            }
            try {
              CR(s, n.cue, n.regionList);
            } catch {
              n.cue = null, n.state = "BADCUE";
              continue;
            }
            n.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const o = s.indexOf("-->") !== -1;
              if (!s || o && (a = !0)) {
                n.oncue && n.cue && n.oncue(n.cue), n.cue = null, n.state = "ID";
                continue;
              }
              if (n.cue === null)
                continue;
              n.cue.text && (n.cue.text += `
`), n.cue.text += s;
            }
            continue;
          case "BADCUE":
            s || (n.state = "ID");
        }
      }
    } catch {
      n.state === "CUETEXT" && n.cue && n.oncue && n.oncue(n.cue), n.cue = null, n.state = n.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT")
        throw new Error("Malformed WebVTT signature.");
    } catch (n) {
      e.onparsingerror && e.onparsingerror(n);
    }
    return e.onflush && e.onflush(), this;
  }
}
const _R = /\r\n|\n\r|\n|\r/g, kl = function(e, n, r = 0) {
  return e.slice(r, r + n.length) === n;
}, RR = function(e) {
  let n = parseInt(e.slice(-3));
  const r = parseInt(e.slice(-6, -4)), i = parseInt(e.slice(-9, -7)), s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
  if (!ue(n) || !ue(r) || !ue(i) || !ue(s))
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
  return n += 1e3 * r, n += 60 * 1e3 * i, n += 60 * 60 * 1e3 * s, n;
};
function Pf(t, e, n) {
  return Fs(t.toString()) + Fs(e.toString()) + Fs(n);
}
const kR = function(e, n, r) {
  let i = e[n], s = e[i.prevCC];
  if (!s || !s.new && i.new) {
    e.ccOffset = e.presentationOffset = i.start, i.new = !1;
    return;
  }
  for (; (a = s) != null && a.new; ) {
    var a;
    e.ccOffset += i.start - s.start, i.new = !1, i = s, s = e[i.prevCC];
  }
  e.presentationOffset = r;
};
function wR(t, e, n, r, i, s, a) {
  const o = new LR(), u = Zt(new Uint8Array(t)).trim().replace(_R, `
`).split(`
`), l = [], c = e ? F_(e.baseTime, e.timescale) : 0;
  let d = "00:00.000", f = 0, h = 0, m, p = !0;
  o.oncue = function(g) {
    const E = n[r];
    let y = n.ccOffset;
    const T = (f - c) / 9e4;
    if (E != null && E.new && (h !== void 0 ? y = n.ccOffset = E.start : kR(n, r, T)), T) {
      if (!e) {
        m = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      y = T - n.presentationOffset;
    }
    const S = g.endTime - g.startTime, v = Yt((g.startTime + y - h) * 9e4, i * 9e4) / 9e4;
    g.startTime = Math.max(v, 0), g.endTime = Math.max(v + S, 0);
    const I = g.text.trim();
    g.text = decodeURIComponent(encodeURIComponent(I)), g.id || (g.id = Pf(g.startTime, g.endTime, I)), g.endTime > 0 && l.push(g);
  }, o.onparsingerror = function(g) {
    m = g;
  }, o.onflush = function() {
    if (m) {
      a(m);
      return;
    }
    s(l);
  }, u.forEach((g) => {
    if (p)
      if (kl(g, "X-TIMESTAMP-MAP=")) {
        p = !1, g.slice(16).split(",").forEach((E) => {
          kl(E, "LOCAL:") ? d = E.slice(6) : kl(E, "MPEGTS:") && (f = parseInt(E.slice(7)));
        });
        try {
          h = RR(d) / 1e3;
        } catch (E) {
          m = E;
        }
        return;
      } else g === "" && (p = !1);
    o.parse(g + `
`);
  }), o.flush();
}
const wl = "stpp.ttml.im1t", vE = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, IE = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, DR = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function dm(t, e, n, r) {
  const i = Ce(new Uint8Array(t), ["mdat"]);
  if (i.length === 0) {
    r(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const s = i.map((o) => Zt(o)), a = M_(e.baseTime, 1, e.timescale);
  try {
    s.forEach((o) => n(PR(o, a)));
  } catch (o) {
    r(o);
  }
}
function PR(t, e) {
  const i = new DOMParser().parseFromString(t, "text/xml").getElementsByTagName("tt")[0];
  if (!i)
    throw new Error("Invalid ttml");
  const s = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  }, a = Object.keys(s).reduce((d, f) => (d[f] = i.getAttribute(`ttp:${f}`) || s[f], d), {}), o = i.getAttribute("xml:space") !== "preserve", u = fm(Dl(i, "styling", "style")), l = fm(Dl(i, "layout", "region")), c = Dl(i, "body", "[begin]");
  return [].map.call(c, (d) => {
    const f = CE(d, o);
    if (!f || !d.hasAttribute("begin"))
      return null;
    const h = Ol(d.getAttribute("begin"), a), m = Ol(d.getAttribute("dur"), a);
    let p = Ol(d.getAttribute("end"), a);
    if (h === null)
      throw hm(d);
    if (p === null) {
      if (m === null)
        throw hm(d);
      p = h + m;
    }
    const g = new Df(h - e, p - e, f);
    g.id = Pf(g.startTime, g.endTime, g.text);
    const E = l[d.getAttribute("region")], y = u[d.getAttribute("style")], T = OR(E, y, u), {
      textAlign: S
    } = T;
    if (S) {
      const v = DR[S];
      v && (g.lineAlign = v), g.align = S;
    }
    return Ge(g, T), g;
  }).filter((d) => d !== null);
}
function Dl(t, e, n) {
  const r = t.getElementsByTagName(e)[0];
  return r ? [].slice.call(r.querySelectorAll(n)) : [];
}
function fm(t) {
  return t.reduce((e, n) => {
    const r = n.getAttribute("xml:id");
    return r && (e[r] = n), e;
  }, {});
}
function CE(t, e) {
  return [].slice.call(t.childNodes).reduce((n, r, i) => {
    var s;
    return r.nodeName === "br" && i ? n + `
` : (s = r.childNodes) != null && s.length ? CE(r, e) : e ? n + r.textContent.trim().replace(/\s+/g, " ") : n + r.textContent;
  }, "");
}
function OR(t, e, n) {
  const r = "http://www.w3.org/ns/ttml#styling";
  let i = null;
  const s = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ], a = t != null && t.hasAttribute("style") ? t.getAttribute("style") : null;
  return a && n.hasOwnProperty(a) && (i = n[a]), s.reduce((o, u) => {
    const l = Pl(e, r, u) || Pl(t, r, u) || Pl(i, r, u);
    return l && (o[u] = l), o;
  }, {});
}
function Pl(t, e, n) {
  return t && t.hasAttributeNS(e, n) ? t.getAttributeNS(e, n) : null;
}
function hm(t) {
  return new Error(`Could not parse ttml timestamp ${t}`);
}
function Ol(t, e) {
  if (!t)
    return null;
  let n = xE(t);
  return n === null && (vE.test(t) ? n = NR(t, e) : IE.test(t) && (n = MR(t, e))), n;
}
function NR(t, e) {
  const n = vE.exec(t), r = (n[4] | 0) + (n[5] | 0) / e.subFrameRate;
  return (n[1] | 0) * 3600 + (n[2] | 0) * 60 + (n[3] | 0) + r / e.frameRate;
}
function MR(t, e) {
  const n = IE.exec(t), r = Number(n[1]);
  switch (n[2]) {
    case "h":
      return r * 3600;
    case "m":
      return r * 60;
    case "ms":
      return r * 1e3;
    case "f":
      return r / e.frameRate;
    case "t":
      return r / e.tickRate;
  }
  return r;
}
class ao {
  constructor(e, n) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = n;
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
  }
  newCue(e, n, r) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = n, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [], this.startTime = null;
  }
}
class FR {
  constructor(e) {
    this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = pm(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    }, e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;
  }
  initCea608Parsers() {
    const e = new ao(this, "textTrack1"), n = new ao(this, "textTrack2"), r = new ao(this, "textTrack3"), i = new ao(this, "textTrack4");
    this.cea608Parser1 = new cm(1, e, n), this.cea608Parser2 = new cm(3, r, i);
  }
  addCues(e, n, r, i, s) {
    let a = !1;
    for (let o = s.length; o--; ) {
      const u = s[o], l = BR(u[0], u[1], n, r);
      if (l >= 0 && (u[0] = Math.min(u[0], n), u[1] = Math.max(u[1], r), a = !0, l / (r - n) > 0.5))
        return;
    }
    if (a || s.push([n, r]), this.config.renderTextTracksNatively) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, n, r, i);
    } else {
      const o = this.Cues.newCue(null, n, r, i);
      this.hls.trigger(x.CUES_PARSED, {
        type: "captions",
        cues: o,
        track: e
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(e, {
    frag: n,
    id: r,
    initPTS: i,
    timescale: s,
    trackId: a
  }) {
    const {
      unparsedVttFrags: o
    } = this;
    r === le.MAIN && (this.initPTS[n.cc] = {
      baseTime: i,
      timescale: s,
      trackId: a
    }), o.length && (this.unparsedVttFrags = [], o.forEach((u) => {
      this.initPTS[u.frag.cc] ? this.onFragLoaded(x.FRAG_LOADED, u) : this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: u.frag,
        error: new Error("Subtitle discontinuity domain does not match main")
      });
    }));
  }
  getExistingTrack(e, n) {
    const {
      media: r
    } = this;
    if (r)
      for (let i = 0; i < r.textTracks.length; i++) {
        const s = r.textTracks[i];
        if (mm(s, {
          name: e,
          lang: n,
          characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
        }))
          return s;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e])
      return;
    const {
      captionsProperties: n,
      captionsTracks: r,
      media: i
    } = this, {
      label: s,
      languageCode: a
    } = n[e], o = this.getExistingTrack(s, a);
    if (o)
      r[e] = o, Ii(r[e]), gE(r[e], i);
    else {
      const u = this.createTextTrack("captions", s, a);
      u && (u[e] = !0, r[e] = u);
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e])
      return;
    const n = this.captionsProperties[e];
    if (!n)
      return;
    const r = n.label, i = {
      _id: e,
      label: r,
      kind: "captions",
      default: n.media ? !!n.media.default : !1,
      closedCaptions: n.media
    };
    this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [i]
    });
  }
  createTextTrack(e, n, r) {
    const i = this.media;
    if (i)
      return i.addTextTrack(e, n, r);
  }
  onMediaAttaching(e, n) {
    this.media = n.media, n.mediaSource || this._cleanTracks();
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia;
    if (this.media = null, r)
      return;
    const {
      captionsTracks: i
    } = this;
    Object.keys(i).forEach((s) => {
      Ii(i[s]), delete i[s];
    }), this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = pm(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = e.textTracks;
    if (n)
      for (let r = 0; r < n.length; r++)
        Ii(n[r]);
  }
  onSubtitleTracksUpdated(e, n) {
    const r = n.subtitleTracks || [], i = r.some((s) => s.textCodec === wl);
    if (this.config.enableWebVTT || i && this.config.enableIMSC1) {
      if (rE(this.tracks, r)) {
        this.tracks = r;
        return;
      }
      if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) {
        const a = this.media, o = a ? Fo(a.textTracks) : null;
        if (this.tracks.forEach((u, l) => {
          let c;
          if (o) {
            let d = null;
            for (let f = 0; f < o.length; f++)
              if (o[f] && mm(o[f], u)) {
                d = o[f], o[f] = null;
                break;
              }
            d && (c = d);
          }
          if (c)
            Ii(c);
          else {
            const d = LE(u);
            c = this.createTextTrack(d, u.name, u.lang), c && (c.mode = "disabled");
          }
          c && this.textTracks.push(c);
        }), o != null && o.length) {
          const u = o.filter((l) => l !== null).map((l) => l.label);
          u.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${u.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
        }
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }));
        this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: a
        });
      }
    }
  }
  onManifestLoaded(e, n) {
    this.config.enableCEA708Captions && n.captions && n.captions.forEach((r) => {
      const i = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId);
      if (!i)
        return;
      const s = `textTrack${i[1]}`, a = this.captionsProperties[s];
      a && (a.label = r.name, r.lang && (a.languageCode = r.lang), a.media = r);
    });
  }
  closedCaptionsForLevel(e) {
    const n = this.hls.levels[e.level];
    return n == null ? void 0 : n.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, n) {
    if (this.enabled && n.frag.type === le.MAIN) {
      var r, i;
      const {
        cea608Parser1: s,
        cea608Parser2: a,
        lastSn: o
      } = this, {
        cc: u,
        sn: l
      } = n.frag, c = (r = (i = n.part) == null ? void 0 : i.index) != null ? r : -1;
      s && a && (l !== o + 1 || l === o && c !== this.lastPartIndex + 1 || u !== this.lastCc) && (s.reset(), a.reset()), this.lastCc = u, this.lastSn = l, this.lastPartIndex = c;
    }
  }
  onFragLoaded(e, n) {
    const {
      frag: r,
      payload: i
    } = n;
    if (r.type === le.SUBTITLE)
      if (i.byteLength) {
        const s = r.decryptdata, a = "stats" in n;
        if (s == null || !s.encrypted || a) {
          const o = this.tracks[r.level], u = this.vttCCs;
          u[r.cc] || (u[r.cc] = {
            start: r.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = r.cc), o && o.textCodec === wl ? this._parseIMSC1(r, i) : this._parseVTTs(n);
        }
      } else
        this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: r,
          error: new Error("Empty subtitle payload")
        });
  }
  _parseIMSC1(e, n) {
    const r = this.hls;
    dm(n, this.initPTS[e.cc], (i) => {
      this._appendCues(i, e.level), r.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (i) => {
      r.logger.log(`Failed to parse IMSC1: ${i}`), r.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: i
      });
    });
  }
  _parseVTTs(e) {
    var n;
    const {
      frag: r,
      payload: i
    } = e, {
      initPTS: s,
      unparsedVttFrags: a
    } = this, o = s.length - 1;
    if (!s[r.cc] && o === -1) {
      a.push(e);
      return;
    }
    const u = this.hls, l = (n = r.initSegment) != null && n.data ? an(r.initSegment.data, new Uint8Array(i)).buffer : i;
    wR(l, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, (c) => {
      this._appendCues(c, r.level), u.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: r
      });
    }, (c) => {
      const d = c.message === "Missing initPTS for VTT MPEGTS";
      d ? a.push(e) : this._fallbackToIMSC1(r, i), u.logger.log(`Failed to parse VTT cue: ${c}`), !(d && o > r.cc) && u.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: r,
        error: c
      });
    });
  }
  _fallbackToIMSC1(e, n) {
    const r = this.tracks[e.level];
    r.textCodec || dm(n, this.initPTS[e.cc], () => {
      r.textCodec = wl, this._parseIMSC1(e, n);
    }, () => {
      r.textCodec = "wvtt";
    });
  }
  _appendCues(e, n) {
    const r = this.hls;
    if (this.config.renderTextTracksNatively) {
      const i = this.textTracks[n];
      if (!i || i.mode === "disabled")
        return;
      e.forEach((s) => bE(i, s));
    } else {
      const i = this.tracks[n];
      if (!i)
        return;
      const s = i.default ? "default" : "subtitles" + n;
      r.trigger(x.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: s
      });
    }
  }
  onFragDecrypted(e, n) {
    const {
      frag: r
    } = n;
    r.type === le.SUBTITLE && this.onFragLoaded(x.FRAG_LOADED, n);
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {};
  }
  onFragParsingUserdata(e, n) {
    if (!this.enabled || !this.config.enableCEA708Captions)
      return;
    const {
      frag: r,
      samples: i
    } = n;
    if (!(r.type === le.MAIN && this.closedCaptionsForLevel(r) === "NONE"))
      for (let s = 0; s < i.length; s++) {
        const a = i[s].bytes;
        if (a) {
          this.cea608Parser1 || this.initCea608Parsers();
          const o = this.extractCea608Data(a);
          this.cea608Parser1.addData(i[s].pts, o[0]), this.cea608Parser2.addData(i[s].pts, o[1]);
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: n,
    endOffset: r,
    endOffsetSubtitles: i,
    type: s
  }) {
    const {
      media: a
    } = this;
    if (!(!a || a.currentTime < r)) {
      if (!s || s === "video") {
        const {
          captionsTracks: o
        } = this;
        Object.keys(o).forEach((u) => Zc(o[u], n, r));
      }
      if (this.config.renderTextTracksNatively && n === 0 && i !== void 0) {
        const {
          textTracks: o
        } = this;
        Object.keys(o).forEach((u) => Zc(o[u], n, i));
      }
    }
  }
  extractCea608Data(e) {
    const n = [[], []], r = e[0] & 31;
    let i = 2;
    for (let s = 0; s < r; s++) {
      const a = e[i++], o = 127 & e[i++], u = 127 & e[i++];
      if (o === 0 && u === 0)
        continue;
      if ((4 & a) !== 0) {
        const c = 3 & a;
        (c === 0 || c === 1) && (n[c].push(o), n[c].push(u));
      }
    }
    return n;
  }
}
function LE(t) {
  return t.characteristics && /transcribes-spoken-dialog/gi.test(t.characteristics) && /describes-music-and-sound/gi.test(t.characteristics) ? "captions" : "subtitles";
}
function mm(t, e) {
  return !!t && t.kind === LE(e) && Wc(e, t);
}
function BR(t, e, n, r) {
  return Math.min(e, r) - Math.max(t, n);
}
function pm() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  };
}
const UR = /\s/, $R = {
  newCue(t, e, n, r) {
    const i = [];
    let s, a, o, u, l;
    const c = self.VTTCue || self.TextTrackCue;
    for (let f = 0; f < r.rows.length; f++)
      if (s = r.rows[f], o = !0, u = 0, l = "", !s.isEmpty()) {
        var d;
        for (let p = 0; p < s.chars.length; p++)
          UR.test(s.chars[p].uchar) && o ? u++ : (l += s.chars[p].uchar, o = !1);
        s.cueStartTime = e, e === n && (n += 1e-4), u >= 16 ? u-- : u++;
        const h = AE(l.trim()), m = Pf(e, n, h);
        t != null && (d = t.cues) != null && d.getCueById(m) || (a = new c(e, n, h), a.id = m, a.line = f + 1, a.align = "left", a.position = 10 + Math.min(80, Math.floor(u * 8 / 32) * 10), i.push(a));
      }
    return t && i.length && (i.sort((f, h) => f.line === "auto" || h.line === "auto" ? 0 : f.line > 8 && h.line > 8 ? h.line - f.line : f.line - h.line), i.forEach((f) => bE(t, f))), i;
  }
};
function HR() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  )
    try {
      return new self.ReadableStream({}), !0;
    } catch {
    }
  return !1;
}
const GR = /(\d+)-(\d+)\/(\d+)/;
class gm {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || jR, this.controller = new self.AbortController(), this.stats = new df();
  }
  destroy() {
    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;
  }
  abortInternal() {
    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, n, r) {
    const i = this.stats;
    if (i.loading.start)
      throw new Error("Loader can only be used once.");
    i.loading.start = self.performance.now();
    const s = VR(e, this.controller.signal), a = e.responseType === "arraybuffer", o = a ? "byteLength" : "length", {
      maxTimeToFirstByteMs: u,
      maxLoadTimeMs: l
    } = n.loadPolicy;
    this.context = e, this.config = n, this.callbacks = r, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), n.timeout = u && ue(u) ? u : l, this.requestTimeout = self.setTimeout(() => {
      this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
    }, n.timeout), (sa(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d) => {
      var f;
      this.response = this.loader = d;
      const h = Math.max(self.performance.now(), i.loading.start);
      if (self.clearTimeout(this.requestTimeout), n.timeout = l, this.requestTimeout = self.setTimeout(() => {
        this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
      }, l - (h - i.loading.start)), !d.ok) {
        const {
          status: p,
          statusText: g
        } = d;
        throw new KR(g || "fetch, bad network response", p, d);
      }
      i.loading.first = h, i.total = qR(d.headers) || i.total;
      const m = (f = this.callbacks) == null ? void 0 : f.onProgress;
      return m && ue(n.highWaterMark) ? this.loadProgressively(d, i, e, n.highWaterMark, m) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text();
    }).then((d) => {
      var f, h;
      const m = this.response;
      if (!m)
        throw new Error("loader destroyed");
      self.clearTimeout(this.requestTimeout), i.loading.end = Math.max(self.performance.now(), i.loading.first);
      const p = d[o];
      p && (i.loaded = i.total = p);
      const g = {
        url: m.url,
        data: d,
        code: m.status
      }, E = (f = this.callbacks) == null ? void 0 : f.onProgress;
      E && !ue(n.highWaterMark) && E(i, e, d, m), (h = this.callbacks) == null || h.onSuccess(g, i, e, m);
    }).catch((d) => {
      var f;
      if (self.clearTimeout(this.requestTimeout), i.aborted)
        return;
      const h = d && d.code || 0, m = d ? d.message : null;
      (f = this.callbacks) == null || f.onError({
        code: h,
        text: m
      }, e, d ? d.details : null, i);
    });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const n = this.response.headers.get("age");
      e = n ? parseFloat(n) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, n, r, i = 0, s) {
    const a = new Fb(), o = e.body.getReader(), u = () => o.read().then((l) => {
      if (l.done)
        return a.dataLength && s(n, r, a.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));
      const c = l.value, d = c.length;
      return n.loaded += d, d < i || a.dataLength ? (a.push(c), a.dataLength >= i && s(n, r, a.flush().buffer, e)) : s(n, r, c.buffer, e), u();
    }).catch(() => Promise.reject());
    return u();
  }
}
function VR(t, e) {
  const n = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Ge({}, t.headers))
  };
  return t.rangeEnd && n.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1)), n;
}
function zR(t) {
  const e = GR.exec(t);
  if (e)
    return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function qR(t) {
  const e = t.get("Content-Range");
  if (e) {
    const r = zR(e);
    if (ue(r))
      return r;
  }
  const n = t.get("Content-Length");
  if (n)
    return parseInt(n);
}
function jR(t, e) {
  return new self.Request(t.url, e);
}
class KR extends Error {
  constructor(e, n, r) {
    super(e), this.code = void 0, this.details = void 0, this.code = n, this.details = r;
  }
}
const WR = /^age:\s*[\d.]+\s*$/im;
class _E {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new df(), this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, n, r) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = n, this.callbacks = r, this.loadInternal();
  }
  loadInternal() {
    const {
      config: e,
      context: n
    } = this;
    if (!e || !n)
      return;
    const r = this.loader = new self.XMLHttpRequest(), i = this.stats;
    i.loading.first = 0, i.loaded = 0, i.aborted = !1;
    const s = this.xhrSetup;
    s ? Promise.resolve().then(() => {
      if (!(this.loader !== r || this.stats.aborted))
        return s(r, n.url);
    }).catch((a) => {
      if (!(this.loader !== r || this.stats.aborted))
        return r.open("GET", n.url, !0), s(r, n.url);
    }).then(() => {
      this.loader !== r || this.stats.aborted || this.openAndSendXhr(r, n, e);
    }).catch((a) => {
      var o;
      (o = this.callbacks) == null || o.onError({
        code: r.status,
        text: a.message
      }, n, r, i);
    }) : this.openAndSendXhr(r, n, e);
  }
  openAndSendXhr(e, n, r) {
    e.readyState || e.open("GET", n.url, !0);
    const i = n.headers, {
      maxTimeToFirstByteMs: s,
      maxLoadTimeMs: a
    } = r.loadPolicy;
    if (i)
      for (const o in i)
        e.setRequestHeader(o, i[o]);
    n.rangeEnd && e.setRequestHeader("Range", "bytes=" + n.rangeStart + "-" + (n.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = n.responseType, self.clearTimeout(this.requestTimeout), r.timeout = s && ue(s) ? s : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();
  }
  readystatechange() {
    const {
      context: e,
      loader: n,
      stats: r
    } = this;
    if (!e || !n)
      return;
    const i = n.readyState, s = this.config;
    if (!r.aborted && i >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), i === 4)) {
      self.clearTimeout(this.requestTimeout), n.onreadystatechange = null, n.onprogress = null;
      const l = n.status, c = n.responseType === "text" ? n.responseText : null;
      if (l >= 200 && l < 300) {
        const m = c ?? n.response;
        if (m != null) {
          var a, o;
          r.loading.end = Math.max(self.performance.now(), r.loading.first);
          const p = n.responseType === "arraybuffer" ? m.byteLength : m.length;
          r.loaded = r.total = p, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first);
          const g = (a = this.callbacks) == null ? void 0 : a.onProgress;
          g && g(r, e, m, n);
          const E = {
            url: n.responseURL,
            data: m,
            code: l
          };
          (o = this.callbacks) == null || o.onSuccess(E, r, e, n);
          return;
        }
      }
      const d = s.loadPolicy.errorRetry, f = r.retry, h = {
        url: e.url,
        data: void 0,
        code: l
      };
      if (uu(d, f, !1, h))
        this.retry(d);
      else {
        var u;
        Be.error(`${l} while loading ${e.url}`), (u = this.callbacks) == null || u.onError({
          code: l,
          text: n.statusText
        }, e, n, r);
      }
    }
  }
  loadtimeout() {
    if (!this.config) return;
    const e = this.config.loadPolicy.timeoutRetry, n = this.stats.retry;
    if (uu(e, n, !0))
      this.retry(e);
    else {
      var r;
      Be.warn(`timeout while loading ${(r = this.context) == null ? void 0 : r.url}`);
      const i = this.callbacks;
      i && (this.abortInternal(), i.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const {
      context: n,
      stats: r
    } = this;
    this.retryDelay = pf(e, r.retry), r.retry++, Be.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${n == null ? void 0 : n.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(e) {
    const n = this.stats;
    n.loaded = e.loaded, e.lengthComputable && (n.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && WR.test(this.loader.getAllResponseHeaders())) {
      const n = this.loader.getResponseHeader("age");
      e = n ? parseFloat(n) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
  }
}
const YR = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
}, XR = Fe(Fe({
  autoStartLoad: !0,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: !1,
  // used by logger
  capLevelOnFPSDrop: !1,
  // used by fps-controller
  capLevelToPlayerSize: !1,
  // used by cap-level-controller
  ignoreDevicePixelRatio: !1,
  // used by cap-level-controller
  maxDevicePixelRatio: Number.POSITIVE_INFINITY,
  // used by cap-level-controller
  preferManagedMediaSource: !0,
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: 1 / 0,
  // used by buffer-controller
  frontBufferFlushThreshold: 1 / 0,
  startOnSegmentBoundary: !1,
  // used by stream-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller and gap-controller
  detectStallWithCurrentTimeMs: 1250,
  // used by gap-controller
  highBufferWatchdogPeriod: 2,
  // used by gap-controller
  nudgeOffset: 0.1,
  // used by gap-controller
  nudgeMaxRetry: 3,
  // used by gap-controller
  nudgeOnVideoHole: !0,
  // used by gap-controller
  liveSyncMode: "edge",
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveSyncOnStallIncrease: 1,
  // used by latency-controller
  liveMaxLatencyDurationCount: 1 / 0,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: !1,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: !0,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: !0,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: !1,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  ignorePlaylistParsingErrors: !1,
  loader: _E,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: uL,
  bufferController: Z_,
  capLevelController: Rf,
  errorController: hL,
  fpsController: J3,
  stretchShortVideoTrack: !1,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: !0,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrEwmaDefaultEstimateMax: 5e6,
  // 5 mbps
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: !1,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: !1,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: Cb,
  // used by eme-controller
  requireKeySystemAccessOnStart: !1,
  // used by eme-controller
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableEmsgKLVMetadata: !1,
  enableID3MetadataCues: !0,
  enableInterstitialPlayback: !0,
  interstitialAppendInPlace: !0,
  interstitialLiveLookAhead: 10,
  useMediaCapabilities: !0,
  preserveManualLevelOnError: !1,
  certLoadPolicy: {
    default: YR
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  interstitialAssetListLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 3e4,
      timeoutRetry: {
        maxNumRetry: 0,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 0,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, QR()), {}, {
  subtitleStreamController: dR,
  subtitleTrackController: nR,
  timelineController: FR,
  audioStreamController: W_,
  audioTrackController: Y_,
  emeController: Ri,
  cmcdController: Y3,
  contentSteeringController: Q3,
  interstitialsController: cR
});
function QR() {
  return {
    cueHandler: $R,
    // used by timeline-controller
    enableWebVTT: !0,
    // used by timeline-controller
    enableIMSC1: !0,
    // used by timeline-controller
    enableCEA708Captions: !0,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: !0
  };
}
function ZR(t, e, n) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const r = ed(t), i = ["manifest", "level", "frag"], s = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return i.forEach((a) => {
    const o = `${a === "level" ? "playlist" : a}LoadPolicy`, u = e[o] === void 0, l = [];
    s.forEach((c) => {
      const d = `${a}Loading${c}`, f = e[d];
      if (f !== void 0 && u) {
        l.push(d);
        const h = r[o].default;
        switch (e[o] = {
          default: h
        }, c) {
          case "TimeOut":
            h.maxLoadTimeMs = f, h.maxTimeToFirstByteMs = f;
            break;
          case "MaxRetry":
            h.errorRetry.maxNumRetry = f, h.timeoutRetry.maxNumRetry = f;
            break;
          case "RetryDelay":
            h.errorRetry.retryDelayMs = f, h.timeoutRetry.retryDelayMs = f;
            break;
          case "MaxRetryTimeout":
            h.errorRetry.maxRetryDelayMs = f, h.timeoutRetry.maxRetryDelayMs = f;
            break;
        }
      }
    }), l.length && n.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${ze(e[o])}`);
  }), Fe(Fe({}, r), e);
}
function ed(t) {
  return t && typeof t == "object" ? Array.isArray(t) ? t.map(ed) : Object.keys(t).reduce((e, n) => (e[n] = ed(t[n]), e), {}) : t;
}
function JR(t, e) {
  const n = t.loader;
  n !== gm && n !== _E ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1) : HR() && (t.loader = gm, t.progressive = !0, t.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const Bo = 2, ek = 0.1, tk = 0.05, nk = 100;
class rk extends xb {
  constructor(e, n) {
    super("gap-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => {
      this.ended = 0, this.waiting = 0;
    }, this.onMediaWaiting = () => {
      var r;
      (r = this.media) != null && r.seeking || (this.waiting = self.performance.now(), this.tick());
    }, this.onMediaEnded = () => {
      if (this.hls) {
        var r;
        this.ended = ((r = this.media) == null ? void 0 : r.currentTime) || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !1
        });
      }
    }, this.hls = e, this.fragmentTracker = n, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  destroy() {
    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;
  }
  onMediaAttached(e, n) {
    this.setInterval(nk), this.mediaSource = n.mediaSource;
    const r = this.media = n.media;
    _t(r, "playing", this.onMediaPlaying), _t(r, "waiting", this.onMediaWaiting), _t(r, "ended", this.onMediaEnded);
  }
  onMediaDetaching(e, n) {
    this.clearInterval();
    const {
      media: r
    } = this;
    r && (Ot(r, "playing", this.onMediaPlaying), Ot(r, "waiting", this.onMediaWaiting), Ot(r, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0;
  }
  onBufferAppended(e, n) {
    this.buffered = n.timeRanges;
  }
  get hasBuffered() {
    return Object.keys(this.buffered).length > 0;
  }
  tick() {
    var e;
    if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
      return;
    const n = this.media.currentTime;
    this.poll(n, this.lastCurrentTime), this.lastCurrentTime = n;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(e, n) {
    var r, i;
    const s = (r = this.hls) == null ? void 0 : r.config;
    if (!s)
      return;
    const a = this.media;
    if (!a)
      return;
    const {
      seeking: o
    } = a, u = this.seeking && !o, l = !this.seeking && o, c = a.paused && !o || a.ended || a.playbackRate === 0;
    if (this.seeking = o, e !== n) {
      n && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, s.nudgeOnVideoHole && !c && e > n && this.nudgeOnVideoHole(e, n)), this.waiting === 0 && this.stallResolved(e);
      return;
    }
    if (l || u) {
      u && this.stallResolved(e);
      return;
    }
    if (c) {
      this.nudgeRetry = 0, this.stallResolved(e), !this.ended && a.ended && this.hls && (this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
        stalled: !1
      }));
      return;
    }
    if (!ye.getBuffered(a).length) {
      this.nudgeRetry = 0;
      return;
    }
    const d = ye.bufferInfo(a, e, 0), f = d.nextStart || 0, h = this.fragmentTracker;
    if (o && h && this.hls) {
      const I = bm(this.hls.inFlightFragments, e), C = d.len > Bo, D = !f || I || f - e > Bo && !h.getPartialFragment(e);
      if (C || D)
        return;
      this.moved = !1;
    }
    const m = (i = this.hls) == null ? void 0 : i.latestLevelDetails;
    if (!this.moved && this.stalled !== null && h) {
      if (!(d.len > 0) && !f)
        return;
      const C = Math.max(f, d.start || 0) - e, _ = !!(m != null && m.live) ? m.targetduration * 2 : Bo, A = oo(e, h);
      if (C > 0 && (C <= _ || A)) {
        a.paused || this._trySkipBufferHole(A);
        return;
      }
    }
    const p = s.detectStallWithCurrentTimeMs, g = self.performance.now(), E = this.waiting;
    let y = this.stalled;
    if (y === null)
      if (E > 0 && g - E < p)
        y = this.stalled = E;
      else {
        this.stalled = g;
        return;
      }
    const T = g - y;
    if (!o && (T >= p || E) && this.hls) {
      var S;
      if (((S = this.mediaSource) == null ? void 0 : S.readyState) === "ended" && !(m != null && m.live) && Math.abs(e - ((m == null ? void 0 : m.edge) || 0)) < 1) {
        if (this.ended)
          return;
        this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !0
        });
        return;
      }
      if (this._reportStall(d), !this.media || !this.hls)
        return;
    }
    const v = ye.bufferInfo(a, e, s.maxBufferHole);
    this._tryFixBufferStall(v, T, e);
  }
  stallResolved(e) {
    const n = this.stalled;
    if (n && this.hls && (this.stalled = null, this.stallReported)) {
      const r = self.performance.now() - n;
      this.log(`playback not stuck anymore @${e}, after ${Math.round(r)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(x.STALL_RESOLVED, {});
    }
  }
  nudgeOnVideoHole(e, n) {
    var r;
    const i = this.buffered.video;
    if (this.hls && this.media && this.fragmentTracker && (r = this.buffered.audio) != null && r.length && i && i.length > 1 && e > i.end(0)) {
      const s = ye.bufferedInfo(ye.timeRangesToArray(this.buffered.audio), e, 0);
      if (s.len > 1 && n >= s.start) {
        const a = ye.timeRangesToArray(i), o = ye.bufferedInfo(a, n, 0).bufferedIndex;
        if (o > -1 && o < a.length - 1) {
          const u = ye.bufferedInfo(a, e, 0).bufferedIndex, l = a[o].end, c = a[o + 1].start;
          if ((u === -1 || u > o) && c - l < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
          e - l < 2) {
            const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${l} -> ${c} buffered index: ${u}`);
            this.warn(d.message), this.media.currentTime += 1e-6;
            let f = oo(e, this.fragmentTracker);
            f && "fragment" in f ? f = f.fragment : f || (f = void 0);
            const h = ye.bufferInfo(this.media, e, 0);
            this.hls.trigger(x.ERROR, {
              type: de.MEDIA_ERROR,
              details: q.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: d,
              reason: d.message,
              frag: f,
              buffer: h.len,
              bufferInfo: h
            });
          }
        }
      }
    }
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(e, n, r) {
    var i, s;
    const {
      fragmentTracker: a,
      media: o
    } = this, u = (i = this.hls) == null ? void 0 : i.config;
    if (!o || !a || !u)
      return;
    const l = (s = this.hls) == null ? void 0 : s.latestLevelDetails, c = oo(r, a);
    if ((c || l != null && l.live && r < l.fragmentStart) && (this._trySkipBufferHole(c) || !this.media))
      return;
    const d = e.buffered, f = this.adjacentTraversal(e, r);
    (d && d.length > 1 && e.len > u.maxBufferHole || e.nextStart && (e.nextStart - r < u.maxBufferHole || f)) && (n > u.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e));
  }
  adjacentTraversal(e, n) {
    const r = this.fragmentTracker, i = e.nextStart;
    if (r && i) {
      const s = r.getFragAtPos(n, le.MAIN), a = r.getFragAtPos(i, le.MAIN);
      if (s && a)
        return a.sn - s.sn < 2;
    }
    return !1;
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(e) {
    const {
      hls: n,
      media: r,
      stallReported: i,
      stalled: s
    } = this;
    if (!i && s !== null && r && n) {
      this.stallReported = !0;
      const a = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${ze(e)})`);
      this.warn(a.message), n.trigger(x.ERROR, {
        type: de.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: a,
        buffer: e.len,
        bufferInfo: e,
        stalled: {
          start: s
        }
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param appended - The fragment or part found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(e) {
    var n;
    const {
      fragmentTracker: r,
      media: i
    } = this, s = (n = this.hls) == null ? void 0 : n.config;
    if (!i || !r || !s)
      return 0;
    const a = i.currentTime, o = ye.bufferInfo(i, a, 0), u = a < o.start ? o.start : o.nextStart;
    if (u && this.hls) {
      const c = o.len <= s.maxBufferHole, d = o.len > 0 && o.len < 1 && i.readyState < 3, f = u - a;
      if (f > 0 && (c || d)) {
        if (f > s.maxBufferHole) {
          let m = !1;
          if (a === 0) {
            const p = r.getAppendedFrag(0, le.MAIN);
            p && u < p.end && (m = !0);
          }
          if (!m && e) {
            var l;
            if (!((l = this.hls.loadLevelObj) != null && l.details) || bm(this.hls.inFlightFragments, u))
              return 0;
            let g = !1, E = e.end;
            for (; E < u; ) {
              const y = oo(E, r);
              if (y)
                E += y.duration;
              else {
                g = !0;
                break;
              }
            }
            if (g)
              return 0;
          }
        }
        const h = Math.max(u + tk, a + ek);
        if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${h}`), this.moved = !0, i.currentTime = h, !(e != null && e.gap)) {
          const m = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${h}`), p = {
            type: de.MEDIA_ERROR,
            details: q.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: m,
            reason: m.message,
            buffer: o.len,
            bufferInfo: o
          };
          e && ("fragment" in e ? p.part = e : p.frag = e), this.hls.trigger(x.ERROR, p);
        }
        return h;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer(e) {
    const {
      hls: n,
      media: r,
      nudgeRetry: i
    } = this, s = n == null ? void 0 : n.config;
    if (!r || !s)
      return 0;
    const a = r.currentTime;
    if (this.nudgeRetry++, i < s.nudgeMaxRetry) {
      const o = a + (i + 1) * s.nudgeOffset, u = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
      this.warn(u.message), r.currentTime = o, n.trigger(x.ERROR, {
        type: de.MEDIA_ERROR,
        details: q.BUFFER_NUDGE_ON_STALL,
        error: u,
        fatal: !1,
        buffer: e.len,
        bufferInfo: e
      });
    } else {
      const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${s.nudgeMaxRetry} nudges`);
      this.error(o.message), n.trigger(x.ERROR, {
        type: de.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        error: o,
        fatal: !0,
        buffer: e.len,
        bufferInfo: e
      });
    }
  }
}
function bm(t, e) {
  const n = Em(t.main);
  if (n && n.start <= e)
    return n;
  const r = Em(t.audio);
  return r && r.start <= e ? r : null;
}
function Em(t) {
  if (!t)
    return null;
  switch (t.state) {
    case Y.IDLE:
    case Y.STOPPED:
    case Y.ENDED:
    case Y.ERROR:
      return null;
  }
  return t.frag;
}
function oo(t, e) {
  return e.getAppendedFrag(t, le.MAIN) || e.getPartialFragment(t);
}
const ik = 0.25;
function td() {
  if (!(typeof self > "u"))
    return self.VTTCue || self.TextTrackCue;
}
function Nl(t, e, n, r, i) {
  let s = new t(e, n, "");
  try {
    s.value = r, i && (s.type = i);
  } catch {
    s = new t(e, n, ze(i ? Fe({
      type: i
    }, r) : r));
  }
  return s;
}
const uo = (() => {
  const t = td();
  try {
    t && new t(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
class sk {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = () => {
      this.hls && this.hls.trigger(x.EVENT_CUE_ENTER, {});
    }, this.hls = e, this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  // Add ID3 metatadata text track.
  onMediaAttaching(e, n) {
    var r;
    this.media = n.media, ((r = n.overrides) == null ? void 0 : r.cueRemoval) === !1 && (this.removeCues = !1);
  }
  onMediaAttached() {
    var e;
    const n = (e = this.hls) == null ? void 0 : e.latestLevelDetails;
    n && this.updateDateRangeCues(n);
  }
  onMediaDetaching(e, n) {
    this.media = null, !n.transferMedia && (this.id3Track && (this.removeCues && Ii(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const n = this.getID3Track(e.textTracks);
    return n.mode = "hidden", n;
  }
  getID3Track(e) {
    if (this.media) {
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (r.kind === "metadata" && r.label === "id3")
          return gE(r, this.media), r;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, n) {
    if (!this.media || !this.hls)
      return;
    const {
      enableEmsgMetadataCues: r,
      enableID3MetadataCues: i
    } = this.hls.config;
    if (!r && !i)
      return;
    const {
      samples: s
    } = n;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = td();
    if (a)
      for (let o = 0; o < s.length; o++) {
        const u = s[o].type;
        if (u === Xt.emsg && !r || !i)
          continue;
        const l = zb(s[o].data), c = s[o].pts;
        let d = c + s[o].duration;
        d > uo && (d = uo), d - c <= 0 && (d = c + ik);
        for (let h = 0; h < l.length; h++) {
          const m = l[h];
          if (!qb(m)) {
            this.updateId3CueEnds(c, u);
            const p = Nl(a, c, d, m, u);
            p && this.id3Track.addCue(p);
          }
        }
      }
  }
  updateId3CueEnds(e, n) {
    var r;
    const i = (r = this.id3Track) == null ? void 0 : r.cues;
    if (i)
      for (let s = i.length; s--; ) {
        const a = i[s];
        a.type === n && a.startTime < e && a.endTime === uo && (a.endTime = e);
      }
  }
  onBufferFlushing(e, {
    startOffset: n,
    endOffset: r,
    type: i
  }) {
    const {
      id3Track: s,
      hls: a
    } = this;
    if (!a)
      return;
    const {
      config: {
        enableEmsgMetadataCues: o,
        enableID3MetadataCues: u
      }
    } = a;
    if (s && (o || u)) {
      let l;
      i === "audio" ? l = (c) => c.type === Xt.audioId3 && u : i === "video" ? l = (c) => c.type === Xt.emsg && o : l = (c) => c.type === Xt.audioId3 && u || c.type === Xt.emsg && o, Zc(s, n, r, l);
    }
  }
  onLevelUpdated(e, {
    details: n
  }) {
    this.updateDateRangeCues(n, !0);
  }
  onLevelPtsUpdated(e, n) {
    Math.abs(n.drift) > 0.01 && this.updateDateRangeCues(n.details);
  }
  updateDateRangeCues(e, n) {
    if (!this.hls || !this.media)
      return;
    const {
      assetPlayerId: r,
      timelineOffset: i,
      enableDateRangeMetadataCues: s,
      interstitialsController: a
    } = this.hls.config;
    if (!s)
      return;
    const o = td();
    if (r && i && !a) {
      const {
        fragmentStart: p,
        fragmentEnd: g
      } = e;
      let E = this.assetCue;
      E ? (E.startTime = p, E.endTime = g) : o && (E = this.assetCue = Nl(o, p, g, {
        assetPlayerId: this.hls.config.assetPlayerId
      }, "hlsjs.interstitial.asset"), E && (E.id = r, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(E), E.addEventListener("enter", this.onEventCueEnter)));
    }
    if (!e.hasProgramDateTime)
      return;
    const {
      id3Track: u
    } = this, {
      dateRanges: l
    } = e, c = Object.keys(l);
    let d = this.dateRangeCuesAppended;
    if (u && n) {
      var f;
      if ((f = u.cues) != null && f.length) {
        const p = Object.keys(d).filter((g) => !c.includes(g));
        for (let g = p.length; g--; ) {
          var h;
          const E = p[g], y = (h = d[E]) == null ? void 0 : h.cues;
          delete d[E], y && Object.keys(y).forEach((T) => {
            const S = y[T];
            if (S) {
              S.removeEventListener("enter", this.onEventCueEnter);
              try {
                u.removeCue(S);
              } catch {
              }
            }
          });
        }
      } else
        d = this.dateRangeCuesAppended = {};
    }
    const m = e.fragments[e.fragments.length - 1];
    if (!(c.length === 0 || !ue(m == null ? void 0 : m.programDateTime))) {
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      for (let p = 0; p < c.length; p++) {
        const g = c[p], E = l[g], y = E.startTime, T = d[g], S = (T == null ? void 0 : T.cues) || {};
        let v = (T == null ? void 0 : T.durationKnown) || !1, I = uo;
        const {
          duration: C,
          endDate: D
        } = E;
        if (D && C !== null)
          I = y + C, v = !0;
        else if (E.endOnNext && !v) {
          const A = c.reduce((L, N) => {
            if (N !== E.id) {
              const U = l[N];
              if (U.class === E.class && U.startDate > E.startDate && (!L || E.startDate < L.startDate))
                return U;
            }
            return L;
          }, null);
          A && (I = A.startTime, v = !0);
        }
        const _ = Object.keys(E.attr);
        for (let A = 0; A < _.length; A++) {
          const L = _[A];
          if (!CL(L))
            continue;
          const N = S[L];
          if (N)
            v && !(T != null && T.durationKnown) ? N.endTime = I : Math.abs(N.startTime - y) > 0.01 && (N.startTime = y, N.endTime = I);
          else if (o) {
            let U = E.attr[L];
            LL(L) && (U = tb(U));
            const O = Nl(o, y, I, {
              key: L,
              data: U
            }, Xt.dateRange);
            O && (O.id = g, this.id3Track.addCue(O), S[L] = O, a && (L === "X-ASSET-LIST" || L === "X-ASSET-URL") && O.addEventListener("enter", this.onEventCueEnter));
          }
        }
        d[g] = {
          cues: S,
          dateRange: E,
          durationKnown: v
        };
      }
    }
  }
}
class ak {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => {
      const {
        media: n
      } = this, r = this.levelDetails;
      if (!n || !r)
        return;
      this.currentTime = n.currentTime;
      const i = this.computeLatency();
      if (i === null)
        return;
      this._latency = i;
      const {
        lowLatencyMode: s,
        maxLiveSyncPlaybackRate: a
      } = this.config;
      if (!s || a === 1 || !r.live)
        return;
      const o = this.targetLatency;
      if (o === null)
        return;
      const u = i - o, l = Math.min(this.maxLatency, o + r.targetduration);
      if (u < l && u > 0.05 && this.forwardBufferLength > 1) {
        const d = Math.min(2, Math.max(1, a)), f = Math.round(2 / (1 + Math.exp(-0.75 * u - this.edgeStalled)) * 20) / 20, h = Math.min(d, Math.max(1, f));
        this.changeMediaPlaybackRate(n, h);
      } else n.playbackRate !== 1 && n.playbackRate !== 0 && this.changeMediaPlaybackRate(n, 1);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  get levelDetails() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config: e
    } = this;
    if (e.liveMaxLatencyDuration !== void 0)
      return e.liveMaxLatencyDuration;
    const n = this.levelDetails;
    return n ? e.liveMaxLatencyDurationCount * n.targetduration : 0;
  }
  get targetLatency() {
    const e = this.levelDetails;
    if (e === null || this.hls === null)
      return null;
    const {
      holdBack: n,
      partHoldBack: r,
      targetduration: i
    } = e, {
      liveSyncDuration: s,
      liveSyncDurationCount: a,
      lowLatencyMode: o
    } = this.config, u = this.hls.userConfig;
    let l = o && r || n;
    (this._targetLatencyUpdated || u.liveSyncDuration || u.liveSyncDurationCount || l === 0) && (l = s !== void 0 ? s : a * i);
    const c = i;
    return l + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, c);
  }
  set targetLatency(e) {
    this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(), n = this.targetLatency;
    if (e === null || n === null)
      return null;
    const r = this.levelDetails;
    if (r === null)
      return null;
    const i = r.edge, s = e - n - this.edgeStalled, a = i - r.totalduration, o = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
    return Math.min(Math.max(a, s), o);
  }
  get drift() {
    const e = this.levelDetails;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const e = this.levelDetails;
    if (e === null)
      return 0;
    const n = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - n, 0);
  }
  get forwardBufferLength() {
    const {
      media: e
    } = this, n = this.levelDetails;
    if (!e || !n)
      return 0;
    const r = e.buffered.length;
    return (r ? e.buffered.end(r - 1) : n.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.ERROR, this.onError, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  onMediaAttached(e, n) {
    this.media = n.media, this.media.addEventListener("timeupdate", this.onTimeupdate);
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null);
  }
  onManifestLoading() {
    this._latency = null, this.stallCount = 0;
  }
  onLevelUpdated(e, {
    details: n
  }) {
    n.advanced && this.onTimeupdate(), !n.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate);
  }
  onError(e, n) {
    var r;
    n.details === q.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (r = this.levelDetails) != null && r.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"));
  }
  changeMediaPlaybackRate(e, n) {
    var r, i;
    e.playbackRate !== n && ((r = this.hls) == null || r.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(i = this.targetLatency) == null ? void 0 : i.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${n}`), e.playbackRate = n);
  }
  estimateLiveEdge() {
    const e = this.levelDetails;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
class ok extends _f {
  constructor(e, n) {
    super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = n, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
  }
  stopLoad() {
    this._levels.forEach((n) => {
      n.loadError = 0, n.fragmentError = 0;
    }), super.stopLoad();
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;
  }
  onManifestLoading(e, n) {
    this.resetLevels();
  }
  onManifestLoaded(e, n) {
    const r = this.hls.config.preferManagedMediaSource, i = [], s = {}, a = {};
    let o = !1, u = !1, l = !1;
    n.levels.forEach((c) => {
      const d = c.attrs;
      let {
        audioCodec: f,
        videoCodec: h
      } = c;
      f && (c.audioCodec = f = iu(f, r) || void 0), h && (h = c.videoCodec = VC(h));
      const {
        width: m,
        height: p,
        unknownCodecs: g
      } = c, E = (g == null ? void 0 : g.length) || 0;
      if (o || (o = !!(m && p)), u || (u = !!h), l || (l = !!f), E || f && !this.isAudioSupported(f) || h && !this.isVideoSupported(h)) {
        this.log(`Some or all CODECS not supported "${d.CODECS}"`);
        return;
      }
      const {
        CODECS: y,
        "FRAME-RATE": T,
        "HDCP-LEVEL": S,
        "PATHWAY-ID": v,
        RESOLUTION: I,
        "VIDEO-RANGE": C
      } = d, _ = `${`${v || "."}-`}${c.bitrate}-${I}-${T}-${y}-${C}-${S}`;
      if (s[_])
        if (s[_].uri !== c.url && !c.attrs["PATHWAY-ID"]) {
          const A = a[_] += 1;
          c.attrs["PATHWAY-ID"] = new Array(A + 1).join(".");
          const L = this.createLevel(c);
          s[_] = L, i.push(L);
        } else
          s[_].addGroupId("audio", d.AUDIO), s[_].addGroupId("text", d.SUBTITLES);
      else {
        const A = this.createLevel(c);
        s[_] = A, a[_] = 1, i.push(A);
      }
    }), this.filterAndSortMediaOptions(i, n, o, u, l);
  }
  createLevel(e) {
    const n = new na(e), r = e.supplemental;
    if (r != null && r.videoCodec && !this.isVideoSupported(r.videoCodec)) {
      const i = new Error(`SUPPLEMENTAL-CODECS not supported "${r.videoCodec}"`);
      this.log(i.message), n.supportedResult = hb(i, []);
    }
    return n;
  }
  isAudioSupported(e) {
    return ea(e, "audio", this.hls.config.preferManagedMediaSource);
  }
  isVideoSupported(e) {
    return ea(e, "video", this.hls.config.preferManagedMediaSource);
  }
  filterAndSortMediaOptions(e, n, r, i, s) {
    var a;
    let o = [], u = [], l = e;
    const c = ((a = n.stats) == null ? void 0 : a.parsing) || {};
    if ((r || i) && s && (l = l.filter(({
      videoCodec: y,
      videoRange: T,
      width: S,
      height: v
    }) => (!!y || !!(S && v)) && JC(T))), l.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          let y = "no level with compatible codecs found in manifest", T = y;
          n.levels.length && (T = `one or more CODECS in variant not supported: ${ze(n.levels.map((v) => v.attrs.CODECS).filter((v, I, C) => C.indexOf(v) === I))}`, this.warn(T), y += ` (${T})`);
          const S = new Error(y);
          this.hls.trigger(x.ERROR, {
            type: de.MEDIA_ERROR,
            details: q.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: n.url,
            error: S,
            reason: T
          });
        }
      }), c.end = performance.now();
      return;
    }
    n.audioTracks && (o = n.audioTracks.filter((y) => !y.audioCodec || this.isAudioSupported(y.audioCodec)), ym(o)), n.subtitles && (u = n.subtitles, ym(u));
    const d = l.slice(0);
    l.sort((y, T) => {
      if (y.attrs["HDCP-LEVEL"] !== T.attrs["HDCP-LEVEL"])
        return (y.attrs["HDCP-LEVEL"] || "") > (T.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      if (r && y.height !== T.height)
        return y.height - T.height;
      if (y.frameRate !== T.frameRate)
        return y.frameRate - T.frameRate;
      if (y.videoRange !== T.videoRange)
        return su.indexOf(y.videoRange) - su.indexOf(T.videoRange);
      if (y.videoCodec !== T.videoCodec) {
        const S = c0(y.videoCodec), v = c0(T.videoCodec);
        if (S !== v)
          return v - S;
      }
      if (y.uri === T.uri && y.codecSet !== T.codecSet) {
        const S = ru(y.codecSet), v = ru(T.codecSet);
        if (S !== v)
          return v - S;
      }
      return y.averageBitrate !== T.averageBitrate ? y.averageBitrate - T.averageBitrate : 0;
    });
    let f = d[0];
    if (this.steering && (l = this.steering.filterParsedLevels(l), l.length !== d.length)) {
      for (let y = 0; y < d.length; y++)
        if (d[y].pathwayId === l[0].pathwayId) {
          f = d[y];
          break;
        }
    }
    this._levels = l;
    for (let y = 0; y < l.length; y++)
      if (l[y] === f) {
        var h;
        this._firstLevel = y;
        const T = f.bitrate, S = this.hls.bandwidthEstimate;
        if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${T}`), ((h = this.hls.userConfig) == null ? void 0 : h.abrEwmaDefaultEstimate) === void 0) {
          const v = Math.min(T, this.hls.config.abrEwmaDefaultEstimateMax);
          v > S && S === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = v);
        }
        break;
      }
    const m = s && !i, p = this.hls.config, g = !!(p.audioStreamController && p.audioTrackController), E = {
      levels: l,
      audioTracks: o,
      subtitleTracks: u,
      sessionData: n.sessionData,
      sessionKeys: n.sessionKeys,
      firstLevel: this._firstLevel,
      stats: n.stats,
      audio: s,
      video: i,
      altAudio: g && !m && o.some((y) => !!y.url)
    };
    c.end = performance.now(), this.hls.trigger(x.MANIFEST_PARSED, E);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get loadLevelObj() {
    return this.currentLevel;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const n = this._levels;
    if (n.length === 0)
      return;
    if (e < 0 || e >= n.length) {
      const c = new Error("invalid level idx"), d = e < 0;
      if (this.hls.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: d,
        error: c,
        reason: c.message
      }), d)
        return;
      e = Math.min(e, n.length - 1);
    }
    const r = this.currentLevelIndex, i = this.currentLevel, s = i ? i.attrs["PATHWAY-ID"] : void 0, a = n[e], o = a.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = a, r === e && i && s === o)
      return;
    this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${r}${s ? " with Pathway " + s : ""}`);
    const u = {
      level: e,
      attrs: a.attrs,
      details: a.details,
      bitrate: a.bitrate,
      averageBitrate: a.averageBitrate,
      maxBitrate: a.maxBitrate,
      realBitrate: a.realBitrate,
      width: a.width,
      height: a.height,
      codecSet: a.codecSet,
      audioCodec: a.audioCodec,
      videoCodec: a.videoCodec,
      audioGroups: a.audioGroups,
      subtitleGroups: a.subtitleGroups,
      loaded: a.loaded,
      loadError: a.loadError,
      fragmentError: a.fragmentError,
      name: a.name,
      id: a.id,
      uri: a.uri,
      url: a.url,
      urlId: 0,
      audioGroupIds: a.audioGroupIds,
      textGroupIds: a.textGroupIds
    };
    this.hls.trigger(x.LEVEL_SWITCHING, u);
    const l = a.details;
    if (!l || l.live) {
      const c = this.switchParams(a.uri, i == null ? void 0 : i.details, l);
      this.loadPlaylist(c);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  get pathways() {
    return this.steering ? this.steering.pathways() : [];
  }
  get pathwayPriority() {
    return this.steering ? this.steering.pathwayPriority : null;
  }
  set pathwayPriority(e) {
    if (this.steering) {
      const n = this.steering.pathways(), r = e.filter((i) => n.indexOf(i) !== -1);
      if (e.length < 1) {
        this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${n}`);
        return;
      }
      this.steering.pathwayPriority = r;
    }
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === _e.LEVEL && n.context.level === this.level && this.checkRetry(n);
  }
  // reset errors on the successful load of a fragment
  onFragBuffered(e, {
    frag: n
  }) {
    if (n !== void 0 && n.type === le.MAIN) {
      const r = n.elementaryStreams;
      if (!Object.keys(r).some((s) => !!r[s]))
        return;
      const i = this._levels[n.level];
      i != null && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0);
    }
  }
  onLevelLoaded(e, n) {
    var r;
    const {
      level: i,
      details: s
    } = n, a = n.levelInfo;
    if (!a) {
      var o;
      this.warn(`Invalid level index ${i}`), (o = n.deliveryDirectives) != null && o.skip && (s.deltaUpdateFailed = !0);
      return;
    }
    if (a === this.currentLevel || n.withoutMultiVariant) {
      a.fragmentError === 0 && (a.loadError = 0);
      let u = a.details;
      u === n.details && u.advanced && (u = void 0), this.playlistLoaded(i, n, u);
    } else (r = n.deliveryDirectives) != null && r.skip && (s.deltaUpdateFailed = !0);
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = this.getUrlWithDirectives(e.uri, n), i = this.currentLevelIndex, s = e.attrs["PATHWAY-ID"], a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading level index ${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${s ? " Pathway " + s : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${r}`), this.hls.trigger(x.LEVEL_LOADING, {
      url: r,
      level: i,
      levelInfo: e,
      pathwayId: e.attrs["PATHWAY-ID"],
      id: 0,
      // Deprecated Level urlId
      deliveryDirectives: n || null
    });
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e) {
    var n;
    if (this._levels.length === 1)
      return;
    const r = this._levels.filter((s, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(s), s === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, s.details && s.details.fragments.forEach((o) => o.level = -1)), !1));
    Ob(r), this._levels = r, this.currentLevelIndex > -1 && (n = this.currentLevel) != null && n.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
    const i = r.length - 1;
    this._firstLevel = Math.min(this._firstLevel, i), this._startLevel && (this._startLevel = Math.min(this._startLevel, i)), this.hls.trigger(x.LEVELS_UPDATED, {
      levels: r
    });
  }
  onLevelsUpdated(e, {
    levels: n
  }) {
    this._levels = n;
  }
  checkMaxAutoUpdated() {
    const {
      autoLevelCapping: e,
      maxAutoLevel: n,
      maxHdcpLevel: r
    } = this.hls;
    this._maxAutoLevel !== n && (this._maxAutoLevel = n, this.hls.trigger(x.MAX_AUTO_LEVEL_UPDATED, {
      autoLevelCapping: e,
      levels: this.levels,
      maxAutoLevel: n,
      minAutoLevel: this.hls.minAutoLevel,
      maxHdcpLevel: r
    }));
  }
}
function ym(t) {
  const e = {};
  t.forEach((n) => {
    const r = n.groupId || "";
    n.id = e[r] = e[r] || 0, e[r]++;
  });
}
function RE() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function kE() {
  if (!vr())
    return !1;
  const e = RE();
  return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
}
function uk() {
  if (!kE())
    return !1;
  const t = vr();
  return typeof (t == null ? void 0 : t.isTypeSupported) == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e) => t.isTypeSupported(ta(e, "video"))) || ["mp4a.40.2", "fLaC"].some((e) => t.isTypeSupported(ta(e, "audio"))));
}
function lk() {
  var t;
  const e = RE();
  return typeof (e == null || (t = e.prototype) == null ? void 0 : t.changeType) == "function";
}
const ck = 100;
class dk extends Tf {
  constructor(e, n, r) {
    super(e, n, r, "stream-controller", le.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => {
      this.tick();
    }, this.onMediaSeeked = () => {
      const i = this.media, s = i ? i.currentTime : null;
      if (s === null || !ue(s) || (this.log(`Media seeked to ${s.toFixed(3)}`), !this.getBufferedFrag(s)))
        return;
      const a = this.getFwdBufferInfoAtPos(i, s, le.MAIN, 0);
      if (a === null || a.len === 0) {
        this.warn(`Main forward buffer length at ${s} on "seeked" event ${a ? a.len : "empty"})`);
        return;
      }
      this.tick();
    }, this.registerListeners();
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();
  }
  startLoad(e, n) {
    if (this.levels) {
      const {
        lastCurrentTime: r,
        hls: i
      } = this;
      if (this.stopLoad(), this.setInterval(ck), this.level = -1, !this.startFragRequested) {
        let s = i.startLevel;
        s === -1 && (i.config.testBandwidth && this.levels.length > 1 ? (s = 0, this.bitrateTest = !0) : s = i.firstAutoLevel), i.nextLoadLevel = s, this.level = i.loadLevel, this._hasEnoughToStart = !!n;
      }
      r > 0 && e === -1 && !n && (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = Y.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
    } else
      this._forceStartLoad = !0, this.state = Y.STOPPED;
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case Y.WAITING_LEVEL: {
        const {
          levels: e,
          level: n
        } = this, r = e == null ? void 0 : e[n], i = r == null ? void 0 : r.details;
        if (i && (!i.live || this.levelLastLoaded === r && !this.waitForLive(r))) {
          if (this.waitForCdnTuneIn(i))
            break;
          this.state = Y.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = Y.IDLE;
          break;
        }
        break;
      }
      case Y.FRAG_LOADING_WAITING_RETRY:
        this.checkRetryDate();
        break;
    }
    this.state === Y.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    var e;
    super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: n,
      levels: r,
      media: i
    } = this;
    if (n === null || !i && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
      return;
    const s = this.buffering ? e.nextLoadLevel : e.loadLevel;
    if (!(r != null && r[s]))
      return;
    const a = r[s], o = this.getMainFwdBufferInfo();
    if (o === null)
      return;
    const u = this.getLevelDetails();
    if (u && this._streamEnded(o, u)) {
      const p = {};
      this.altAudio === 2 && (p.type = "video"), this.hls.trigger(x.BUFFER_EOS, p), this.state = Y.ENDED;
      return;
    }
    if (!this.buffering)
      return;
    e.loadLevel !== s && e.manualLevel === -1 && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
    const l = a.details;
    if (!l || this.state === Y.WAITING_LEVEL || this.waitForLive(a)) {
      this.level = s, this.state = Y.WAITING_LEVEL, this.startFragRequested = !1;
      return;
    }
    const c = o.len, d = this.getMaxBufferLength(a.maxBitrate);
    if (c >= d)
      return;
    this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
    const f = this.backtrackFragment ? this.backtrackFragment.start : o.end;
    let h = this.getNextFragment(f, l);
    if (this.couldBacktrack && !this.fragPrevious && h && ct(h) && this.fragmentTracker.getState(h) !== ft.OK) {
      var m;
      const g = ((m = this.backtrackFragment) != null ? m : h).sn - l.startSN, E = l.fragments[g - 1];
      E && h.cc === E.cc && (h = E, this.fragmentTracker.removeFragment(E));
    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
    if (h && this.isLoopLoading(h, f)) {
      if (!h.gap) {
        const g = this.audioOnly && !this.altAudio ? Ve.AUDIO : Ve.VIDEO, E = (g === Ve.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        E && this.afterBufferFlushed(E, g, le.MAIN);
      }
      h = this.getNextFragmentLoopLoading(h, l, o, le.MAIN, d);
    }
    h && (h.initSegment && !h.initSegment.data && !this.bitrateTest && (h = h.initSegment), this.loadFragment(h, a, f));
  }
  loadFragment(e, n, r) {
    const i = this.fragmentTracker.getState(e);
    i === ft.NOT_LOADED || i === ft.PARTIAL ? ct(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, n)) : super.loadFragment(e, n, r) : this._loadInitSegment(e, n) : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, le.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels: e,
      media: n
    } = this;
    if (n != null && n.readyState) {
      let r;
      const i = this.getAppendedFrag(n.currentTime);
      i && i.start > 1 && this.flushMainBuffer(0, i.start - 1);
      const s = this.getLevelDetails();
      if (s != null && s.live) {
        const o = this.getMainFwdBufferInfo();
        if (!o || o.len < s.targetduration * 2)
          return;
      }
      if (!n.paused && e) {
        const o = this.hls.nextLoadLevel, u = e[o], l = this.fragLastKbps;
        l && this.fragCurrent ? r = this.fragCurrent.duration * u.maxBitrate / (1e3 * l) + 1 : r = 0;
      } else
        r = 0;
      const a = this.getBufferedFrag(n.currentTime + r);
      if (a) {
        const o = this.followingBufferedFrag(a);
        if (o) {
          this.abortCurrentFrag();
          const u = o.maxStartPTS ? o.maxStartPTS : o.start, l = o.duration, c = Math.max(a.end, u + Math.min(Math.max(l - this.config.maxFragLookUpTolerance, l * (this.couldBacktrack ? 0.5 : 0.125)), l * (this.couldBacktrack ? 0.75 : 0.25)));
          this.flushMainBuffer(c, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case Y.KEY_LOADING:
      case Y.FRAG_LOADING:
      case Y.FRAG_LOADING_WAITING_RETRY:
      case Y.PARSING:
      case Y.PARSED:
        this.state = Y.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, n) {
    super.flushMainBuffer(e, n, this.altAudio === 2 ? "video" : null);
  }
  onMediaAttached(e, n) {
    super.onMediaAttached(e, n);
    const r = n.media;
    _t(r, "playing", this.onMediaPlaying), _t(r, "seeked", this.onMediaSeeked);
  }
  onMediaDetaching(e, n) {
    const {
      media: r
    } = this;
    r && (Ot(r, "playing", this.onMediaPlaying), Ot(r, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, n), !n.transferMedia && (this._hasEnoughToStart = !1);
  }
  onManifestLoading() {
    super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(x.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;
  }
  onManifestParsed(e, n) {
    let r = !1, i = !1;
    for (let s = 0; s < n.levels.length; s++) {
      const a = n.levels[s].audioCodec;
      a && (r = r || a.indexOf("mp4a.40.2") !== -1, i = i || a.indexOf("mp4a.40.5") !== -1);
    }
    this.audioCodecSwitch = r && i && !lk(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = n.levels, this.startFragRequested = !1;
  }
  onLevelLoading(e, n) {
    const {
      levels: r
    } = this;
    if (!r || this.state !== Y.IDLE)
      return;
    const i = n.levelInfo;
    (!i.details || i.details.live && (this.levelLastLoaded !== i || i.details.expired) || this.waitForCdnTuneIn(i.details)) && (this.state = Y.WAITING_LEVEL);
  }
  onLevelLoaded(e, n) {
    var r;
    const {
      levels: i,
      startFragRequested: s
    } = this, a = n.level, o = n.details, u = o.totalduration;
    if (!i) {
      this.warn(`Levels were reset while loading level ${a}`);
      return;
    }
    this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${u}`);
    const l = n.levelInfo, c = this.fragCurrent;
    c && (this.state === Y.FRAG_LOADING || this.state === Y.FRAG_LOADING_WAITING_RETRY) && c.level !== n.level && c.loader && this.abortCurrentFrag();
    let d = 0;
    if (o.live || (r = l.details) != null && r.live) {
      var f;
      if (this.checkLiveUpdate(o), o.deltaUpdateFailed)
        return;
      d = this.alignPlaylists(o, l.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
    }
    if (l.details = o, this.levelLastLoaded = l, s || this.setStartPosition(o, d), this.hls.trigger(x.LEVEL_UPDATED, {
      details: o,
      level: a
    }), this.state === Y.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(o))
        return;
      this.state = Y.IDLE;
    }
    s && o.live && this.synchronizeToLiveEdge(o), this.tick();
  }
  synchronizeToLiveEdge(e) {
    const {
      config: n,
      media: r
    } = this;
    if (!r)
      return;
    const i = this.hls.liveSyncPosition, s = this.getLoadPosition(), a = e.fragmentStart, o = e.edge, u = s >= a - n.maxFragLookUpTolerance && s <= o;
    if (i !== null && r.duration > i && (s < i || !u)) {
      const c = n.liveMaxLatencyDuration !== void 0 ? n.liveMaxLatencyDuration : n.liveMaxLatencyDurationCount * e.targetduration;
      if ((!u && r.readyState < 4 || s < o - c) && (this._hasEnoughToStart || (this.nextLoadPosition = i), r.readyState))
        if (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${i.toFixed(3)}`), this.config.liveSyncMode === "buffered") {
          var l;
          const d = ye.bufferInfo(r, i, 0);
          if (!((l = d.buffered) != null && l.length)) {
            r.currentTime = i;
            return;
          }
          if (d.start <= s) {
            r.currentTime = i;
            return;
          }
          const {
            nextStart: h
          } = ye.bufferedInfo(d.buffered, s, 0);
          h && (r.currentTime = h);
        } else
          r.currentTime = i;
    }
  }
  _handleFragmentLoadProgress(e) {
    var n;
    const r = e.frag, {
      part: i,
      payload: s
    } = e, {
      levels: a
    } = this;
    if (!a) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const o = a[r.level];
    if (!o) {
      this.warn(`Level ${r.level} not found on progress`);
      return;
    }
    const u = o.details;
    if (!u) {
      this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r);
      return;
    }
    const l = o.videoCodec, c = u.PTSKnown || !u.live, d = (n = r.initSegment) == null ? void 0 : n.data, f = this._getAudioCodec(o), h = this.transmuxer = this.transmuxer || new nE(this.hls, le.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), m = i ? i.index : -1, p = m !== -1, g = new bf(r.level, r.sn, r.stats.chunkCount, s.byteLength, m, p), E = this.initPTS[r.cc];
    h.push(s, d, f, l, r, i, u.totalduration, c, g, E);
  }
  onAudioTrackSwitching(e, n) {
    const r = this.hls, i = this.altAudio === 2;
    if (au(n.url, r))
      this.altAudio = 1;
    else {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const a = this.fragCurrent;
        a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests(), this.fragmentTracker.removeFragment(a)), this.resetTransmuxer(), this.resetLoadingState();
      } else this.audioOnly && this.resetTransmuxer();
      if (i) {
        this.fragmentTracker.removeAllFragments(), r.once(x.BUFFER_FLUSHED, () => {
          this.hls && this.hls.trigger(x.AUDIO_TRACK_SWITCHED, n);
        }), r.trigger(x.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        return;
      }
      r.trigger(x.AUDIO_TRACK_SWITCHED, n);
    }
  }
  onAudioTrackSwitched(e, n) {
    const r = au(n.url, this.hls);
    if (r) {
      const i = this.videoBuffer;
      i && this.mediaBuffer !== i && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i);
    }
    this.altAudio = r ? 2 : 0, this.tick();
  }
  onBufferCreated(e, n) {
    const r = n.tracks;
    let i, s, a = !1;
    for (const o in r) {
      const u = r[o];
      if (u.id === "main") {
        if (s = o, i = u, o === "video") {
          const l = r[o];
          l && (this.videoBuffer = l.buffer);
        }
      } else
        a = !0;
    }
    a && i ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media;
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = r.type === le.MAIN;
    if (s) {
      if (this.fragContextChanged(r)) {
        this.warn(`Fragment ${r.sn}${i ? " p: " + i.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === Y.PARSED && (this.state = Y.IDLE);
        return;
      }
      const o = i ? i.stats : r.stats;
      this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)), ct(r) && (this.fragPrevious = r), this.fragBufferedComplete(r, i);
    }
    const a = this.media;
    a && (!this._hasEnoughToStart && ye.getBuffered(a).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), s && this.tick());
  }
  get hasEnoughToStart() {
    return this._hasEnoughToStart;
  }
  onError(e, n) {
    var r;
    if (n.fatal) {
      this.state = Y.ERROR;
      return;
    }
    switch (n.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(le.MAIN, n);
        break;
      case q.LEVEL_LOAD_ERROR:
      case q.LEVEL_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !n.levelRetry && this.state === Y.WAITING_LEVEL && ((r = n.context) == null ? void 0 : r.type) === _e.LEVEL && (this.state = Y.IDLE);
        break;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (n.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(n) && this.resetLoadingState();
        break;
      case q.BUFFER_FULL_ERROR:
        if (n.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(n) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(n);
        break;
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = Y.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();
  }
  onBufferFlushed(e, {
    type: n
  }) {
    if (n !== Ve.AUDIO || !this.altAudio) {
      const r = (n === Ve.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      r && (this.afterBufferFlushed(r, n, le.MAIN), this.tick());
    }
  }
  onLevelsUpdated(e, n) {
    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = n.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = e.currentTime;
    let r = this.startPosition;
    if (r >= 0 && n < r) {
      if (e.seeking) {
        this.log(`could not seek to ${r}, already seeking at ${n}`);
        return;
      }
      const i = this.timelineOffset;
      i && r && (r += i);
      const s = this.getLevelDetails(), a = ye.getBuffered(e), o = a.length ? a.start(0) : 0, u = o - r, l = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
      (this.config.startOnSegmentBoundary || u > 0 && (u < l || this.loadingParts && u < 2 * ((s == null ? void 0 : s.partTarget) || 0))) && (this.log(`adjusting start position by ${u} to match buffer start`), r += u, this.startPosition = r), n < r && (this.log(`seek to target start position ${r} from current time ${n} buffer start ${o}`), e.currentTime = r);
    }
  }
  _getAudioCodec(e) {
    let n = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && n && (this.log("Swapping audio codec"), n.indexOf("mp4a.40.5") !== -1 ? n = "mp4a.40.2" : n = "mp4a.40.5"), n;
  }
  _loadBitrateTestFrag(e, n) {
    e.bitrateTest = !0, this._doFragLoad(e, n).then((r) => {
      const {
        hls: i
      } = this, s = r == null ? void 0 : r.frag;
      if (!s || this.fragContextChanged(s))
        return;
      n.fragmentError = 0, this.state = Y.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const a = s.stats;
      a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger(x.FRAG_LOADED, r), s.bitrateTest = !1;
    }).catch((r) => {
      this.state === Y.STOPPED || this.state === Y.ERROR || (this.warn(r), this.resetFragmentLoading(e));
    });
  }
  _handleTransmuxComplete(e) {
    const n = this.playlistType, {
      hls: r
    } = this, {
      remuxResult: i,
      chunkMeta: s
    } = e, a = this.getCurrentContext(s);
    if (!a) {
      this.resetWhenMissingContext(s);
      return;
    }
    const {
      frag: o,
      part: u,
      level: l
    } = a, {
      video: c,
      text: d,
      id3: f,
      initSegment: h
    } = i, {
      details: m
    } = l, p = this.altAudio ? void 0 : i.audio;
    if (this.fragContextChanged(o)) {
      this.fragmentTracker.removeFragment(o);
      return;
    }
    if (this.state = Y.PARSING, h) {
      const g = h.tracks;
      if (g) {
        const S = o.initSegment || o;
        if (this.unhandledEncryptionError(h, o))
          return;
        this._bufferInitSegment(l, g, S, s), r.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
          frag: S,
          id: n,
          tracks: g
        });
      }
      const E = h.initPTS, y = h.timescale, T = this.initPTS[o.cc];
      if (ue(E) && (!T || T.baseTime !== E || T.timescale !== y)) {
        const S = h.trackId;
        this.initPTS[o.cc] = {
          baseTime: E,
          timescale: y,
          trackId: S
        }, r.trigger(x.INIT_PTS_FOUND, {
          frag: o,
          id: n,
          initPTS: E,
          timescale: y,
          trackId: S
        });
      }
    }
    if (c && m) {
      p && c.type === "audiovideo" && this.logMuxedErr(o);
      const g = m.fragments[o.sn - 1 - m.startSN], E = o.sn === m.startSN, y = !g || o.cc > g.cc;
      if (i.independent !== !1) {
        const {
          startPTS: T,
          endPTS: S,
          startDTS: v,
          endDTS: I
        } = c;
        if (u)
          u.elementaryStreams[c.type] = {
            startPTS: T,
            endPTS: S,
            startDTS: v,
            endDTS: I
          };
        else if (c.firstKeyFrame && c.independent && s.id === 1 && !y && (this.couldBacktrack = !0), c.dropped && c.independent) {
          const C = this.getMainFwdBufferInfo(), D = (C ? C.end : this.getLoadPosition()) + this.config.maxBufferHole, _ = c.firstKeyFramePTS ? c.firstKeyFramePTS : T;
          if (!E && D < _ - this.config.maxBufferHole && !y) {
            this.backtrack(o);
            return;
          } else y && (o.gap = !0);
          o.setElementaryStreamInfo(c.type, o.start, S, o.start, I, !0);
        } else E && T - (m.appliedTimelineOffset || 0) > Bo && (o.gap = !0);
        o.setElementaryStreamInfo(c.type, T, S, v, I), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(c, o, u, s, E || y);
      } else if (E || y)
        o.gap = !0;
      else {
        this.backtrack(o);
        return;
      }
    }
    if (p) {
      const {
        startPTS: g,
        endPTS: E,
        startDTS: y,
        endDTS: T
      } = p;
      u && (u.elementaryStreams[Ve.AUDIO] = {
        startPTS: g,
        endPTS: E,
        startDTS: y,
        endDTS: T
      }), o.setElementaryStreamInfo(Ve.AUDIO, g, E, y, T), this.bufferFragmentData(p, o, u, s);
    }
    if (m && f != null && f.samples.length) {
      const g = {
        id: n,
        frag: o,
        details: m,
        samples: f.samples
      };
      r.trigger(x.FRAG_PARSING_METADATA, g);
    }
    if (m && d) {
      const g = {
        id: n,
        frag: o,
        details: m,
        samples: d.samples
      };
      r.trigger(x.FRAG_PARSING_USERDATA, g);
    }
  }
  logMuxedErr(e) {
    this.warn(`${ct(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`);
  }
  _bufferInitSegment(e, n, r, i) {
    if (this.state !== Y.PARSING)
      return;
    this.audioOnly = !!n.audio && !n.video, this.altAudio && !this.audioOnly && (delete n.audio, n.audiovideo && this.logMuxedErr(r));
    const {
      audio: s,
      video: a,
      audiovideo: o
    } = n;
    if (s) {
      const l = e.audioCodec;
      let c = wo(s.codec, l);
      c === "mp4a" && (c = "mp4a.40.5");
      const d = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        c && (c.indexOf("mp4a.40.5") !== -1 ? c = "mp4a.40.2" : c = "mp4a.40.5");
        const f = s.metadata;
        f && "channelCount" in f && (f.channelCount || 1) !== 1 && d.indexOf("firefox") === -1 && (c = "mp4a.40.5");
      }
      c && c.indexOf("mp4a.40.5") !== -1 && d.indexOf("android") !== -1 && s.container !== "audio/mpeg" && (c = "mp4a.40.2", this.log(`Android: force audio codec to ${c}`)), l && l !== c && this.log(`Swapping manifest audio codec "${l}" for "${c}"`), s.levelCodec = c, s.id = le.MAIN, this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${c || ""}/${l || ""}/${s.codec}]`), delete n.audiovideo;
    }
    if (a) {
      a.levelCodec = e.videoCodec, a.id = le.MAIN;
      const l = a.codec;
      if ((l == null ? void 0 : l.length) === 4)
        switch (l) {
          case "hvc1":
          case "hev1":
            a.codec = "hvc1.1.6.L120.90";
            break;
          case "av01":
            a.codec = "av01.0.04M.08";
            break;
          case "avc1":
            a.codec = "avc1.42e01e";
            break;
        }
      this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${l}]${a.codec !== l ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`), delete n.audiovideo;
    }
    o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`), delete n.video, delete n.audio);
    const u = Object.keys(n);
    if (u.length) {
      if (this.hls.trigger(x.BUFFER_CODECS, n), !this.hls)
        return;
      u.forEach((l) => {
        const d = n[l].initSegment;
        d != null && d.byteLength && this.hls.trigger(x.BUFFER_APPENDING, {
          type: l,
          data: d,
          frag: r,
          part: null,
          chunkMeta: i,
          parent: r.type
        });
      });
    }
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
    return this.getFwdBufferInfo(e, le.MAIN);
  }
  get maxBufferLength() {
    const {
      levels: e,
      level: n
    } = this, r = e == null ? void 0 : e[n];
    return r ? this.getMaxBufferLength(r.maxBitrate) : this.config.maxBufferLength;
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = Y.IDLE;
  }
  checkFragmentChanged() {
    const e = this.media;
    let n = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const r = e.currentTime;
      if (ye.isBuffered(e, r) ? n = this.getAppendedFrag(r) : ye.isBuffered(e, r + 0.1) && (n = this.getAppendedFrag(r + 0.1)), n) {
        this.backtrackFragment = null;
        const i = this.fragPlaying, s = n.level;
        (!i || n.sn !== i.sn || i.level !== s) && (this.fragPlaying = n, this.hls.trigger(x.FRAG_CHANGED, {
          frag: n
        }), (!i || i.level !== s) && this.hls.trigger(x.LEVEL_SWITCHED, {
          level: s
        }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    var e;
    if (this.fragPlaying)
      return this.fragPlaying;
    const n = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    return ue(n) ? this.getAppendedFrag(n) : null;
  }
  get currentProgramDateTime() {
    var e;
    const n = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    if (ue(n)) {
      const r = this.getLevelDetails(), i = this.currentFrag || (r ? Yr(null, r.fragments, n) : null);
      if (i) {
        const s = i.programDateTime;
        if (s !== null) {
          const a = s + (n - i.start) * 1e3;
          return new Date(a);
        }
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class fk extends on {
  constructor(e, n) {
    super("key-loader", n), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e;
  }
  abort(e) {
    for (const r in this.keyIdToKeyInfo) {
      const i = this.keyIdToKeyInfo[r].loader;
      if (i) {
        var n;
        if (e && e !== ((n = i.context) == null ? void 0 : n.frag.type))
          return;
        i.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyIdToKeyInfo) {
      const n = this.keyIdToKeyInfo[e];
      (n.mediaKeySessionContext || n.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyIdToKeyInfo) {
      const n = this.keyIdToKeyInfo[e].loader;
      n && n.destroy();
    }
    this.keyIdToKeyInfo = {};
  }
  createKeyLoadError(e, n = q.KEY_LOAD_ERROR, r, i, s) {
    return new Jn({
      type: de.NETWORK_ERROR,
      details: n,
      fatal: !1,
      frag: e,
      response: s,
      error: r,
      networkDetails: i
    });
  }
  loadClear(e, n, r) {
    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
      if (n.length)
        for (let i = 0, s = n.length; i < s; i++) {
          const a = n[i];
          if (e.cc <= a.cc && (!ct(e) || !ct(a) || e.sn < a.sn) || !r && i == s - 1)
            return this.emeController.selectKeySystemFormat(a).then((o) => {
              if (!this.emeController)
                return;
              a.setKeyFormat(o);
              const u = Po(o);
              if (u)
                return this.emeController.getKeySystemAccess([u]);
            });
        }
      if (this.config.requireKeySystemAccessOnStart) {
        const i = Ds(this.config);
        if (i.length)
          return this.emeController.getKeySystemAccess(i);
      }
    }
    return null;
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((n) => this.loadInternal(e, n)) : this.loadInternal(e);
  }
  loadInternal(e, n) {
    var r, i;
    n && e.setKeyFormat(n);
    const s = e.decryptdata;
    if (!s) {
      const l = new Error(n ? `Expected frag.decryptdata to be defined after setting format ${n}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`);
      return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, l));
    }
    const a = s.uri;
    if (!a)
      return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
    const o = Ml(s);
    let u = this.keyIdToKeyInfo[o];
    if ((r = u) != null && r.decryptdata.key)
      return s.key = u.decryptdata.key, Promise.resolve({
        frag: e,
        keyInfo: u
      });
    if (this.emeController && (i = u) != null && i.keyLoadPromise)
      switch (this.emeController.getKeyStatus(u.decryptdata)) {
        case "usable":
        case "usable-in-future":
          return u.keyLoadPromise.then((c) => {
            const {
              keyInfo: d
            } = c;
            return s.key = d.decryptdata.key, {
              frag: e,
              keyInfo: d
            };
          });
      }
    switch (this.log(`${this.keyIdToKeyInfo[o] ? "Rel" : "L"}oading${s.keyId ? " keyId: " + Lt(s.keyId) : ""} URI: ${s.uri} from ${e.type} ${e.level}`), u = this.keyIdToKeyInfo[o] = {
      decryptdata: s,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, s.method) {
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return s.keyFormat === "identity" ? this.loadKeyHTTP(u, e) : this.loadKeyEME(u, e);
      case "AES-128":
      case "AES-256":
      case "AES-256-CTR":
        return this.loadKeyHTTP(u, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`)));
    }
  }
  loadKeyEME(e, n) {
    const r = {
      frag: n,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      var i;
      if (!e.decryptdata.keyId && (i = n.initSegment) != null && i.data) {
        const a = wC(n.initSegment.data);
        if (a.length) {
          const o = a[0];
          o.some((u) => u !== 0) && (this.log(`Using keyId found in init segment ${Lt(o)}`), e.decryptdata.keyId = o, zr.setKeyIdForUri(e.decryptdata.uri, o));
        }
      }
      const s = this.emeController.loadKey(r);
      return (e.keyLoadPromise = s.then((a) => (e.mediaKeySessionContext = a, r))).catch((a) => {
        throw e.keyLoadPromise = null, "data" in a && (a.data.frag = n), a;
      });
    }
    return Promise.resolve(r);
  }
  loadKeyHTTP(e, n) {
    const r = this.config, i = r.loader, s = new i(r);
    return n.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((a, o) => {
      const u = {
        keyInfo: e,
        frag: n,
        responseType: "arraybuffer",
        url: e.decryptdata.uri
      }, l = r.keyLoadPolicy.default, c = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, m, p) => {
          const {
            frag: g,
            keyInfo: E
          } = m, y = Ml(E.decryptdata);
          if (!g.decryptdata || E !== this.keyIdToKeyInfo[y])
            return o(this.createKeyLoadError(g, q.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), p));
          E.decryptdata.key = g.decryptdata.key = new Uint8Array(f.data), g.keyLoader = null, E.loader = null, a({
            frag: g,
            keyInfo: E
          });
        },
        onError: (f, h, m, p) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.KEY_LOAD_ERROR, new Error(`HTTP Error ${f.code} loading key ${f.text}`), m, Fe({
            url: u.url,
            data: void 0
          }, f)));
        },
        onTimeout: (f, h, m) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), m));
        },
        onAbort: (f, h, m) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.INTERNAL_ABORTED, new Error("key loading aborted"), m));
        }
      };
      s.load(u, c, d);
    });
  }
  resetLoader(e) {
    const {
      frag: n,
      keyInfo: r,
      url: i
    } = e, s = r.loader;
    n.keyLoader === s && (n.keyLoader = null, r.loader = null);
    const a = Ml(r.decryptdata) || i;
    delete this.keyIdToKeyInfo[a], s && s.destroy();
  }
}
function Ml(t) {
  if (t.keyFormat !== xt.FAIRPLAY) {
    const e = t.keyId;
    if (e)
      return Lt(e);
  }
  return t.uri;
}
function Tm(t) {
  const {
    type: e
  } = t;
  switch (e) {
    case _e.AUDIO_TRACK:
      return le.AUDIO;
    case _e.SUBTITLE_TRACK:
      return le.SUBTITLE;
    default:
      return le.MAIN;
  }
}
function Fl(t, e) {
  let n = t.url;
  return (n === void 0 || n.indexOf("data:") === 0) && (n = e.url), n;
}
class hk {
  constructor(e) {
    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();
  }
  startLoad(e) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(e) {
    const n = this.hls.config, r = n.pLoader, i = n.loader, s = r || i, a = new s(n);
    return this.loaders[e.type] = a, a;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const n = this.loaders[e];
      n && n.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
  }
  onManifestLoading(e, n) {
    const {
      url: r
    } = n;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: _e.MANIFEST,
      url: r,
      deliveryDirectives: null,
      levelOrTrack: null
    });
  }
  onLevelLoading(e, n) {
    const {
      id: r,
      level: i,
      pathwayId: s,
      url: a,
      deliveryDirectives: o,
      levelInfo: u
    } = n;
    this.load({
      id: r,
      level: i,
      pathwayId: s,
      responseType: "text",
      type: _e.LEVEL,
      url: a,
      deliveryDirectives: o,
      levelOrTrack: u
    });
  }
  onAudioTrackLoading(e, n) {
    const {
      id: r,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = n;
    this.load({
      id: r,
      groupId: i,
      level: null,
      responseType: "text",
      type: _e.AUDIO_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onSubtitleTrackLoading(e, n) {
    const {
      id: r,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = n;
    this.load({
      id: r,
      groupId: i,
      level: null,
      responseType: "text",
      type: _e.SUBTITLE_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onLevelsUpdated(e, n) {
    const r = this.loaders[_e.LEVEL];
    if (r) {
      const i = r.context;
      i && !n.levels.some((s) => s === i.levelOrTrack) && (r.abort(), delete this.loaders[_e.LEVEL]);
    }
  }
  load(e) {
    var n;
    const r = this.hls.config;
    let i = this.getInternalLoader(e);
    if (i) {
      const l = this.hls.logger, c = i.context;
      if (c && c.levelOrTrack === e.levelOrTrack && (c.url === e.url || c.deliveryDirectives && !e.deliveryDirectives)) {
        c.url === e.url ? l.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : l.log(`[playlist-loader]: ignore ${e.url} in favor of ${c.url}`);
        return;
      }
      l.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort();
    }
    let s;
    if (e.type === _e.MANIFEST ? s = r.manifestLoadPolicy.default : s = Ge({}, r.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }), i = this.createInternalLoader(e), ue((n = e.deliveryDirectives) == null ? void 0 : n.part)) {
      let l;
      if (e.type === _e.LEVEL && e.level !== null ? l = this.hls.levels[e.level].details : e.type === _e.AUDIO_TRACK && e.id !== null ? l = this.hls.audioTracks[e.id].details : e.type === _e.SUBTITLE_TRACK && e.id !== null && (l = this.hls.subtitleTracks[e.id].details), l) {
        const c = l.partTarget, d = l.targetduration;
        if (c && d) {
          const f = Math.max(c * 3, d * 0.8) * 1e3;
          s = Ge({}, s, {
            maxTimeToFirstByteMs: Math.min(f, s.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(f, s.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const a = s.errorRetry || s.timeoutRetry || {}, o = {
      loadPolicy: s,
      timeout: s.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }, u = {
      onSuccess: (l, c, d, f) => {
        const h = this.getInternalLoader(d);
        this.resetInternalLoader(d.type);
        const m = l.data;
        c.parsing.start = performance.now(), kn.isMediaPlaylist(m) || d.type !== _e.MANIFEST ? this.handleTrackOrLevelPlaylist(l, c, d, f || null, h) : this.handleMasterPlaylist(l, c, d, f);
      },
      onError: (l, c, d, f) => {
        this.handleNetworkError(c, d, !1, l, f);
      },
      onTimeout: (l, c, d) => {
        this.handleNetworkError(c, d, !0, void 0, l);
      }
    };
    i.load(e, o, u);
  }
  checkAutostartLoad() {
    if (!this.hls)
      return;
    const {
      config: {
        autoStartLoad: e,
        startPosition: n
      },
      forceStartLoad: r
    } = this.hls;
    (e || r) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${n}`), this.hls.startLoad(n));
  }
  handleMasterPlaylist(e, n, r, i) {
    const s = this.hls, a = e.data, o = Fl(e, r), u = kn.parseMasterPlaylist(a, o);
    if (u.playlistParsingError) {
      n.parsing.end = performance.now(), this.handleManifestParsingError(e, r, u.playlistParsingError, i, n);
      return;
    }
    const {
      contentSteering: l,
      levels: c,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: m
    } = u;
    this.variableList = m, c.forEach((y) => {
      const {
        unknownCodecs: T
      } = y;
      if (T) {
        const {
          preferManagedMediaSource: S
        } = this.hls.config;
        let {
          audioCodec: v,
          videoCodec: I
        } = y;
        for (let C = T.length; C--; ) {
          const D = T[C];
          ea(D, "audio", S) ? (y.audioCodec = v = v ? `${v},${D}` : D, zi.audio[v.substring(0, 4)] = 2, T.splice(C, 1)) : ea(D, "video", S) && (y.videoCodec = I = I ? `${I},${D}` : D, zi.video[I.substring(0, 4)] = 2, T.splice(C, 1));
        }
      }
    });
    const {
      AUDIO: p = [],
      SUBTITLES: g,
      "CLOSED-CAPTIONS": E
    } = kn.parseMasterPlaylistMedia(a, o, u);
    p.length && !p.some((T) => !T.url) && c[0].audioCodec && !c[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), p.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new Ze({}),
      bitrate: 0,
      url: ""
    })), s.trigger(x.MANIFEST_LOADED, {
      levels: c,
      audioTracks: p,
      subtitles: g,
      captions: E,
      contentSteering: l,
      url: o,
      stats: n,
      networkDetails: i,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: m
    });
  }
  handleTrackOrLevelPlaylist(e, n, r, i, s) {
    const a = this.hls, {
      id: o,
      level: u,
      type: l
    } = r, c = Fl(e, r), d = ue(u) ? u : ue(o) ? o : 0, f = Tm(r), h = kn.parseLevelPlaylist(e.data, c, d, f, 0, this.variableList);
    if (l === _e.MANIFEST) {
      const m = {
        attrs: new Ze({}),
        bitrate: 0,
        details: h,
        name: "",
        url: c
      };
      h.requestScheduled = n.loading.start + wb(h, 0), a.trigger(x.MANIFEST_LOADED, {
        levels: [m],
        audioTracks: [],
        url: c,
        stats: n,
        networkDetails: i,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    n.parsing.end = performance.now(), r.levelDetails = h, this.handlePlaylistLoaded(h, e, n, r, i, s);
  }
  handleManifestParsingError(e, n, r, i, s) {
    this.hls.trigger(x.ERROR, {
      type: de.NETWORK_ERROR,
      details: q.MANIFEST_PARSING_ERROR,
      fatal: n.type === _e.MANIFEST,
      url: e.url,
      err: r,
      error: r,
      reason: r.message,
      response: e,
      context: n,
      networkDetails: i,
      stats: s
    });
  }
  handleNetworkError(e, n, r = !1, i, s) {
    let a = `A network ${r ? "timeout" : "error" + (i ? " (status " + i.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === _e.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === _e.AUDIO_TRACK || e.type === _e.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(a);
    this.hls.logger.warn(`[playlist-loader]: ${a}`);
    let u = q.UNKNOWN, l = !1;
    const c = this.getInternalLoader(e);
    switch (e.type) {
      case _e.MANIFEST:
        u = r ? q.MANIFEST_LOAD_TIMEOUT : q.MANIFEST_LOAD_ERROR, l = !0;
        break;
      case _e.LEVEL:
        u = r ? q.LEVEL_LOAD_TIMEOUT : q.LEVEL_LOAD_ERROR, l = !1;
        break;
      case _e.AUDIO_TRACK:
        u = r ? q.AUDIO_TRACK_LOAD_TIMEOUT : q.AUDIO_TRACK_LOAD_ERROR, l = !1;
        break;
      case _e.SUBTITLE_TRACK:
        u = r ? q.SUBTITLE_TRACK_LOAD_TIMEOUT : q.SUBTITLE_LOAD_ERROR, l = !1;
        break;
    }
    c && this.resetInternalLoader(e.type);
    const d = {
      type: de.NETWORK_ERROR,
      details: u,
      fatal: l,
      url: e.url,
      loader: c,
      context: e,
      error: o,
      networkDetails: n,
      stats: s
    };
    if (i) {
      const f = (n == null ? void 0 : n.url) || e.url;
      d.response = Fe({
        url: f,
        data: void 0
      }, i);
    }
    this.hls.trigger(x.ERROR, d);
  }
  handlePlaylistLoaded(e, n, r, i, s, a) {
    const o = this.hls, {
      type: u,
      level: l,
      levelOrTrack: c,
      id: d,
      groupId: f,
      deliveryDirectives: h
    } = i, m = Fl(n, i), p = Tm(i);
    let g = typeof i.level == "number" && p === le.MAIN ? l : void 0;
    const E = e.playlistParsingError;
    if (E) {
      if (this.hls.logger.warn(`${E} ${e.url}`), !o.config.ignorePlaylistParsingErrors) {
        o.trigger(x.ERROR, {
          type: de.NETWORK_ERROR,
          details: q.LEVEL_PARSING_ERROR,
          fatal: !1,
          url: m,
          error: E,
          reason: E.message,
          response: n,
          context: i,
          level: g,
          parent: p,
          networkDetails: s,
          stats: r
        });
        return;
      }
      e.playlistParsingError = null;
    }
    if (!e.fragments.length) {
      const y = e.playlistParsingError = new Error("No Segments found in Playlist");
      o.trigger(x.ERROR, {
        type: de.NETWORK_ERROR,
        details: q.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: m,
        error: y,
        reason: y.message,
        response: n,
        context: i,
        level: g,
        parent: p,
        networkDetails: s,
        stats: r
      });
      return;
    }
    switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), u) {
      case _e.MANIFEST:
      case _e.LEVEL:
        if (g) {
          if (!c)
            g = 0;
          else if (c !== o.levels[g]) {
            const y = o.levels.indexOf(c);
            y > -1 && (g = y);
          }
        }
        o.trigger(x.LEVEL_LOADED, {
          details: e,
          levelInfo: c || o.levels[0],
          level: g || 0,
          id: d || 0,
          stats: r,
          networkDetails: s,
          deliveryDirectives: h,
          withoutMultiVariant: u === _e.MANIFEST
        });
        break;
      case _e.AUDIO_TRACK:
        o.trigger(x.AUDIO_TRACK_LOADED, {
          details: e,
          track: c,
          id: d || 0,
          groupId: f || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
      case _e.SUBTITLE_TRACK:
        o.trigger(x.SUBTITLE_TRACK_LOADED, {
          details: e,
          track: c,
          id: d || 0,
          groupId: f || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
    }
  }
}
class rn {
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return ra;
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isMSESupported() {
    return kE();
  }
  /**
   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
   */
  static isSupported() {
    return uk();
  }
  /**
   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
   */
  static getMediaSource() {
    return vr();
  }
  static get Events() {
    return x;
  }
  static get MetadataSchema() {
    return Xt;
  }
  static get ErrorTypes() {
    return de;
  }
  static get ErrorDetails() {
    return q;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    return rn.defaultConfig ? rn.defaultConfig : XR;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(e) {
    rn.defaultConfig = e;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new xf(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
    const n = this.logger = yC(e.debug || !1, "Hls instance", e.assetPlayerId), r = this.config = ZR(rn.DefaultConfig, e, n);
    this.userConfig = e, r.progressive && JR(r, n);
    const {
      abrController: i,
      bufferController: s,
      capLevelController: a,
      errorController: o,
      fpsController: u
    } = r, l = new o(this), c = this.abrController = new i(this), d = new mL(this), f = r.interstitialsController, h = f ? this.interstitialsController = new f(this, rn) : null, m = this.bufferController = new s(this, d), p = this.capLevelController = new a(this), g = new u(this), E = new hk(this), y = r.contentSteeringController, T = y ? new y(this) : null, S = this.levelController = new ok(this, T), v = new sk(this), I = new fk(this.config, this.logger), C = this.streamController = new dk(this, d, I), D = this.gapController = new rk(this, d);
    p.setStreamController(C), g.setStreamController(C);
    const _ = [E, S, C];
    h && _.splice(1, 0, h), T && _.splice(1, 0, T), this.networkControllers = _;
    const A = [c, m, D, p, g, v, d];
    this.audioTrackController = this.createController(r.audioTrackController, _);
    const L = r.audioStreamController;
    L && _.push(this.audioStreamController = new L(this, d, I)), this.subtitleTrackController = this.createController(r.subtitleTrackController, _);
    const N = r.subtitleStreamController;
    N && _.push(this.subtititleStreamController = new N(this, d, I)), this.createController(r.timelineController, A), I.emeController = this.emeController = this.createController(r.emeController, A), this.cmcdController = this.createController(r.cmcdController, A), this.latencyController = this.createController(ak, A), this.coreComponents = A, _.push(l);
    const U = l.onErrorOut;
    typeof U == "function" && this.on(x.ERROR, U, l), this.on(x.MANIFEST_LOADED, E.onManifestLoaded, E);
  }
  createController(e, n) {
    if (e) {
      const r = new e(this);
      return n && n.push(r), r;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(e, n, r = this) {
    this._emitter.on(e, n, r);
  }
  once(e, n, r = this) {
    this._emitter.once(e, n, r);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, n, r = this, i) {
    this._emitter.off(e, n, r, i);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, n, r) {
    return this._emitter.emit(e, n, r);
  }
  trigger(e, n) {
    if (this.config.debug)
      return this.emit(e, e, n);
    try {
      return this.emit(e, e, n);
    } catch (r) {
      if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), !this.triggeringException) {
        this.triggeringException = !0;
        const i = e === x.ERROR;
        this.trigger(x.ERROR, {
          type: de.OTHER_ERROR,
          details: q.INTERNAL_EXCEPTION,
          fatal: i,
          event: e,
          error: r
        }), this.triggeringException = !1;
      }
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    this.logger.log("destroy"), this.trigger(x.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((n) => n.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((n) => n.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(e) {
    if (!e || "media" in e && !e.media) {
      const s = new Error(`attachMedia failed: invalid argument (${e})`);
      this.trigger(x.ERROR, {
        type: de.OTHER_ERROR,
        details: q.ATTACH_MEDIA_ERROR,
        fatal: !0,
        error: s
      });
      return;
    }
    this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
    const n = "media" in e, r = n ? e.media : e, i = n ? e : {
      media: r
    };
    this._media = r, this.trigger(x.MEDIA_ATTACHING, i);
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    this.logger.log("detachMedia"), this.trigger(x.MEDIA_DETACHING, {}), this._media = null;
  }
  /**
   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
   */
  transferMedia() {
    this._media = null;
    const e = this.bufferController.transferMedia();
    return this.trigger(x.MEDIA_DETACHING, {
      transferMedia: e
    }), e;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(e) {
    this.stopLoad();
    const n = this.media, r = this._url, i = this._url = cf.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${i}`), n && r && (r !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(n)), this.trigger(x.MANIFEST_LOADING, {
      url: e
    });
  }
  /**
   * Gets the currently loaded URL
   */
  get url() {
    return this._url;
  }
  /**
   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
   */
  get hasEnoughToStart() {
    return this.streamController.hasEnoughToStart;
  }
  /**
   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
   */
  get startPosition() {
    return this.streamController.startPositionValue;
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(e = -1, n) {
    this.logger.log(`startLoad(${e + (n ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering();
    for (let r = 0; r < this.networkControllers.length && (this.networkControllers[r].startLoad(e, n), !(!this.started || !this.networkControllers)); r++)
      ;
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    this.logger.log("stopLoad"), this.started = !1;
    for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++)
      ;
  }
  /**
   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
   */
  get loadingEnabled() {
    return this.started;
  }
  /**
   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
   */
  get bufferingEnabled() {
    return this.streamController.bufferingEnabled;
  }
  /**
   * Resumes stream controller segment loading after `pauseBuffering` has been called.
   */
  resumeBuffering() {
    this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((e) => {
      e.resumeBuffering && e.resumeBuffering();
    }));
  }
  /**
   * Prevents stream controller from loading new segments until `resumeBuffering` is called.
   * This allows for media buffering to be paused without interupting playlist loading.
   */
  pauseBuffering() {
    this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((e) => {
      e.pauseBuffering && e.pauseBuffering();
    }));
  }
  get inFlightFragments() {
    const e = {
      [le.MAIN]: this.streamController.inFlightFrag
    };
    return this.audioStreamController && (e[le.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[le.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    this.logger.log("recoverMediaError");
    const e = this._media, n = e == null ? void 0 : e.currentTime;
    this.detachMedia(), e && (this.attachMedia(e), n && this.startLoad(n));
  }
  removeLevel(e) {
    this.levelController.removeLevel(e);
  }
  /**
   * @returns a UUID for this player instance
   */
  get sessionId() {
    let e = this._sessionId;
    return e || (e = this._sessionId = rR()), e;
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
   */
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  /**
   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
   */
  get latestLevelDetails() {
    return this.streamController.getLevelDetails() || null;
  }
  /**
   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
   */
  get loadLevelObj() {
    return this.levelController.loadLevelObj;
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(e) {
    this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(e) {
    this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(e) {
    this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(e) {
    this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
  }
  /**
   * Return the desired start level for the first fragment that will be loaded.
   * The default value of -1 indicates automatic start level selection.
   * Setting hls.nextAutoLevel without setting a startLevel will result in
   * the nextAutoLevel value being used for one fragment load.
   */
  get startLevel() {
    const e = this.levelController.startLevel;
    return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(e) {
    this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(e) {
    const n = !!e;
    n !== this.config.capLevelToPlayerSize && (n ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = n);
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  set bandwidthEstimate(e) {
    this.abrController.resetEstimator(e);
  }
  get abrEwmaDefaultEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.defaultEstimate : NaN;
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    ZC(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: n
      }
    } = this;
    if (!e) return 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      if (e[i].maxBitrate >= n)
        return i;
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: n,
      maxHdcpLevel: r
    } = this;
    let i;
    if (n === -1 && e != null && e.length ? i = e.length - 1 : i = n, r)
      for (let s = i; s--; ) {
        const a = e[s].attrs["HDCP-LEVEL"];
        if (a && a <= r)
          return s;
      }
    return i;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = e;
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  get maxBufferLength() {
    return this.streamController.maxBufferLength;
  }
  /**
   * Find and select the best matching audio track, making a level switch when a Group change is necessary.
   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
   */
  setAudioOption(e) {
    var n;
    return ((n = this.audioTrackController) == null ? void 0 : n.setAudioOption(e)) || null;
  }
  /**
   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
   */
  setSubtitleOption(e) {
    var n;
    return ((n = this.subtitleTrackController) == null ? void 0 : n.setSubtitleOption(e)) || null;
  }
  /**
   * Get the complete list of audio tracks across all media groups
   */
  get allAudioTracks() {
    const e = this.audioTrackController;
    return e ? e.allAudioTracks : [];
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(e) {
    const n = this.audioTrackController;
    n && (n.audioTrack = e);
  }
  /**
   * get the complete list of subtitle tracks across all media groups
   */
  get allSubtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.allSubtitleTracks : [];
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(e) {
    const n = this.subtitleTrackController;
    n && (n.subtitleTrack = e);
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(e) {
    const n = this.subtitleTrackController;
    n && (n.subtitleDisplay = e);
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  set targetLatency(e) {
    this.latencyController.targetLatency = e;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
  /**
   * ContentSteering pathways getter
   */
  get pathways() {
    return this.levelController.pathways;
  }
  /**
   * ContentSteering pathwayPriority getter/setter
   */
  get pathwayPriority() {
    return this.levelController.pathwayPriority;
  }
  set pathwayPriority(e) {
    this.levelController.pathwayPriority = e;
  }
  /**
   * returns true when all SourceBuffers are buffered to the end
   */
  get bufferedToEnd() {
    var e;
    return !!((e = this.bufferController) != null && e.bufferedToEnd);
  }
  /**
   * returns Interstitials Program Manager
   */
  get interstitialsManager() {
    var e;
    return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;
  }
  /**
   * returns mediaCapabilities.decodingInfo for a variant/rendition
   */
  getMediaDecodingInfo(e, n = this.allAudioTracks) {
    const r = gb(n);
    return mb(e, r, navigator.mediaCapabilities);
  }
}
rn.defaultConfig = void 0;
const mk = (t, e = "200,", n = "full") => {
  Array.isArray(t) && (t = t[0]);
  const { id: r, service: i } = t;
  let s;
  if (!i) return r;
  if (Array.isArray(t.service) && t.service.length > 0 && (s = i[0]), s) {
    if (s["@id"])
      return `${s["@id"]}/${n}/${e}/0/default.jpg`;
    if (s.id)
      return `${s.id}/${n}/${e}/0/default.jpg`;
  }
}, xm = fe("img", { objectFit: "cover" }), pk = (t) => {
  const e = Ji(null), { contentResource: n, altAsLabel: r, region: i = "full" } = t;
  let s;
  r && (s = Ru(r));
  const o = Aa(t, ["contentResource", "altAsLabel"]), { type: u, id: l, width: c = 200, height: d = 200, duration: f } = n;
  lt(() => {
    if (!l && !e.current || ["Image"].includes(u) || !l.includes("m3u8")) return;
    const p = new rn();
    return e.current && (p.attachMedia(e.current), p.on(rn.Events.MEDIA_ATTACHED, function() {
      p.loadSource(l);
    })), p.on(rn.Events.ERROR, function(g, E) {
      if (E.fatal)
        switch (E.type) {
          case rn.ErrorTypes.NETWORK_ERROR:
            console.error(
              `fatal ${g} network error encountered, try to recover`
            ), p.startLoad();
            break;
          case rn.ErrorTypes.MEDIA_ERROR:
            console.error(
              `fatal ${g} media error encountered, try to recover`
            ), p.recoverMediaError();
            break;
          default:
            p.destroy();
            break;
        }
    }), () => {
      p && (p.detachMedia(), p.destroy());
    };
  }, [l, u]);
  const h = Fg(() => {
    if (!e.current) return;
    let p = 0, g = 30;
    if (f && (g = f), !l.split("#t=") && f && (p = f * 0.1), l.split("#t=").pop()) {
      const y = l.split("#t=").pop();
      y && (p = parseInt(y.split(",")[0]));
    }
    const E = e.current;
    E.autoplay = !0, E.currentTime = p, setTimeout(() => h(), g * 1e3);
  }, [f, l]);
  lt(() => h(), [h]);
  const m = mk(
    n,
    `${c},${d}`,
    i
  );
  switch (u) {
    case "Image":
      return /* @__PURE__ */ $.createElement(
        xm,
        {
          as: "img",
          alt: s,
          css: { width: c, height: d },
          key: l,
          src: m,
          ...o
        }
      );
    case "Video":
      return /* @__PURE__ */ $.createElement(
        xm,
        {
          as: "video",
          css: { width: c, height: d },
          disablePictureInPicture: !0,
          key: l,
          loop: !0,
          muted: !0,
          onPause: h,
          ref: e,
          src: l
        }
      );
    default:
      return console.warn(
        `Resource type: ${u} is not valid or not yet supported in Primitives.`
      ), /* @__PURE__ */ $.createElement($.Fragment, null);
  }
};
fe("a", {});
const gk = {
  delimiter: ", "
}, Of = Hd(void 0), bk = () => {
  const t = $n(Of);
  if (t === void 0)
    throw new Error(
      "usePrimitivesContext must be used with a PrimitivesProvider"
    );
  return t;
}, Ek = ({
  children: t,
  initialState: e = gk
}) => {
  const n = yk(e, "delimiter");
  return /* @__PURE__ */ $.createElement(Of.Provider, { value: { delimiter: n } }, t);
}, yk = (t, e) => Object.hasOwn(t, e) ? t[e].toString() : void 0, Tk = fe("span", {}), Sm = (t) => {
  const { as: e, markup: n } = t, { delimiter: r } = bk();
  if (!n) return /* @__PURE__ */ $.createElement($.Fragment, null);
  const s = Aa(t, ["as", "markup"]), a = DI(
    Ru(n, s.lang, r)
  );
  return /* @__PURE__ */ $.createElement(Tk, { as: e, ...s, dangerouslySetInnerHTML: a });
}, xk = (t) => $.useContext(Of) ? /* @__PURE__ */ $.createElement(Sm, { ...t }) : /* @__PURE__ */ $.createElement(Ek, null, /* @__PURE__ */ $.createElement(Sm, { ...t }));
fe("span", {});
fe("dl", {});
fe("li", {});
fe("ul", {});
fe("li", {});
fe("ul", {});
fe("dl", {});
fe("li", {});
fe("ul", {});
const Sk = (t) => {
  const { as: e, summary: n } = t, i = Aa(t, ["as", "customValueDelimiter", "summary"]);
  return /* @__PURE__ */ $.createElement(xk, { as: e, markup: n, ...i });
}, Ak = (t) => {
  const { thumbnail: e, region: n } = t, i = Aa(t, ["thumbnail"]);
  return /* @__PURE__ */ $.createElement($.Fragment, null, e && e.map((s) => /* @__PURE__ */ $.createElement(
    pk,
    {
      contentResource: s,
      key: s.id,
      region: n,
      ...i
    }
  )));
}, vk = fe("div", {
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  background: "$primary",
  filter: "drop-shadow(2px 2px 5px #0002)",
  borderRadius: "2rem"
}), Ik = fe("div", {
  position: "absolute",
  zIndex: 10,
  overflow: "hidden",
  height: "2rem",
  justifyContent: "space-between"
}), Ck = fe("header", {
  fontSize: "1",
  paddingBottom: "1.618rem",
  position: "relative",
  display: "flex",
  justifyContent: "space-between",
  zIndex: 2,
  ".clover-scroll-header-label": {
    fontWeight: "400",
    fontSize: "1.25rem"
  }
}), Lk = fe("section", {
  margin: "0",
  gap: "1rem",
  position: "relative",
  zIndex: 0
});
function Am(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function wE(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((i) => {
      const s = Am(i, e);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : Am(t[i], null);
        }
      };
  };
}
function Gn(...t) {
  return V.useCallback(wE(...t), t);
}
function Nf(t, e = []) {
  let n = [];
  function r(s, a) {
    const o = V.createContext(a), u = n.length;
    n = [...n, a];
    const l = (d) => {
      var E;
      const { scope: f, children: h, ...m } = d, p = ((E = f == null ? void 0 : f[t]) == null ? void 0 : E[u]) || o, g = V.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ xe(p.Provider, { value: g, children: h });
    };
    l.displayName = s + "Provider";
    function c(d, f) {
      var p;
      const h = ((p = f == null ? void 0 : f[t]) == null ? void 0 : p[u]) || o, m = V.useContext(h);
      if (m) return m;
      if (a !== void 0) return a;
      throw new Error(`\`${d}\` must be used within \`${s}\``);
    }
    return [l, c];
  }
  const i = () => {
    const s = n.map((a) => V.createContext(a));
    return function(o) {
      const u = (o == null ? void 0 : o[t]) || s;
      return V.useMemo(
        () => ({ [`__scope${t}`]: { ...o, [t]: u } }),
        [o, u]
      );
    };
  };
  return i.scopeName = t, [r, _k(i, ...e)];
}
function _k(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const a = r.reduce((o, { useScope: u, scopeName: l }) => {
        const d = u(s)[`__scope${l}`];
        return { ...o, ...d };
      }, {});
      return V.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
function Pn(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (t == null || t(i), n === !1 || !i.defaultPrevented)
      return e == null ? void 0 : e(i);
  };
}
var Xr = globalThis != null && globalThis.document ? V.useLayoutEffect : () => {
}, Rk = V[" useInsertionEffect ".trim().toString()] || Xr;
function DE({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, s, a] = kk({
    defaultProp: e,
    onChange: n
  }), o = t !== void 0, u = o ? t : i;
  {
    const c = V.useRef(t !== void 0);
    V.useEffect(() => {
      const d = c.current;
      d !== o && console.warn(
        `${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), c.current = o;
    }, [o, r]);
  }
  const l = V.useCallback(
    (c) => {
      var d;
      if (o) {
        const f = wk(c) ? c(t) : c;
        f !== t && ((d = a.current) == null || d.call(a, f));
      } else
        s(c);
    },
    [o, t, s, a]
  );
  return [u, l];
}
function kk({
  defaultProp: t,
  onChange: e
}) {
  const [n, r] = V.useState(t), i = V.useRef(n), s = V.useRef(e);
  return Rk(() => {
    s.current = e;
  }, [e]), V.useEffect(() => {
    var a;
    i.current !== n && ((a = s.current) == null || a.call(s, n), i.current = n);
  }, [n, i]), [n, r, s];
}
function wk(t) {
  return typeof t == "function";
}
function Dk(t) {
  const e = V.useRef({ value: t, previous: t });
  return V.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
function PE(t) {
  const [e, n] = V.useState(void 0);
  return Xr(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let a, o;
        if ("borderBoxSize" in s) {
          const u = s.borderBoxSize, l = Array.isArray(u) ? u[0] : u;
          a = l.inlineSize, o = l.blockSize;
        } else
          a = t.offsetWidth, o = t.offsetHeight;
        n({ width: a, height: o });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
function Pk(t, e) {
  return V.useReducer((n, r) => e[n][r] ?? n, t);
}
var Mf = (t) => {
  const { present: e, children: n } = t, r = Ok(e), i = typeof n == "function" ? n({ present: r.isPresent }) : V.Children.only(n), s = Gn(r.ref, Nk(i));
  return typeof n == "function" || r.isPresent ? V.cloneElement(i, { ref: s }) : null;
};
Mf.displayName = "Presence";
function Ok(t) {
  const [e, n] = V.useState(), r = V.useRef(null), i = V.useRef(t), s = V.useRef("none"), a = t ? "mounted" : "unmounted", [o, u] = Pk(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return V.useEffect(() => {
    const l = lo(r.current);
    s.current = o === "mounted" ? l : "none";
  }, [o]), Xr(() => {
    const l = r.current, c = i.current;
    if (c !== t) {
      const f = s.current, h = lo(l);
      t ? u("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? u("UNMOUNT") : u(c && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), i.current = t;
    }
  }, [t, u]), Xr(() => {
    if (e) {
      let l;
      const c = e.ownerDocument.defaultView ?? window, d = (h) => {
        const p = lo(r.current).includes(CSS.escape(h.animationName));
        if (h.target === e && p && (u("ANIMATION_END"), !i.current)) {
          const g = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = c.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = g);
          });
        }
      }, f = (h) => {
        h.target === e && (s.current = lo(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        c.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      u("ANIMATION_END");
  }, [e, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(o),
    ref: V.useCallback((l) => {
      r.current = l ? getComputedStyle(l) : null, n(l);
    }, [])
  };
}
function lo(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function Nk(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
// @__NO_SIDE_EFFECTS__
function OE(t) {
  const e = /* @__PURE__ */ Mk(t), n = V.forwardRef((r, i) => {
    const { children: s, ...a } = r, o = V.Children.toArray(s), u = o.find(Bk);
    if (u) {
      const l = u.props.children, c = o.map((d) => d === u ? V.Children.count(l) > 1 ? V.Children.only(null) : V.isValidElement(l) ? l.props.children : null : d);
      return /* @__PURE__ */ xe(e, { ...a, ref: i, children: V.isValidElement(l) ? V.cloneElement(l, void 0, c) : null });
    }
    return /* @__PURE__ */ xe(e, { ...a, ref: i, children: s });
  });
  return n.displayName = `${t}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Mk(t) {
  const e = V.forwardRef((n, r) => {
    const { children: i, ...s } = n;
    if (V.isValidElement(i)) {
      const a = $k(i), o = Uk(s, i.props);
      return i.type !== V.Fragment && (o.ref = r ? wE(r, a) : a), V.cloneElement(i, o);
    }
    return V.Children.count(i) > 1 ? V.Children.only(null) : null;
  });
  return e.displayName = `${t}.SlotClone`, e;
}
var Fk = Symbol("radix.slottable");
function Bk(t) {
  return V.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === Fk;
}
function Uk(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r], s = e[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...o) => {
      const u = s(...o);
      return i(...o), u;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function $k(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Hk = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], un = Hk.reduce((t, e) => {
  const n = /* @__PURE__ */ OE(`Primitive.${e}`), r = V.forwardRef((i, s) => {
    const { asChild: a, ...o } = i, u = a ? n : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ xe(u, { ...o, ref: s });
  });
  return r.displayName = `Primitive.${e}`, { ...t, [e]: r };
}, {});
function Gk(t, e) {
  t && Ug.flushSync(() => t.dispatchEvent(e));
}
var Hu = "Checkbox", [Vk] = Nf(Hu), [zk, Ff] = Vk(Hu);
function qk(t) {
  const {
    __scopeCheckbox: e,
    checked: n,
    children: r,
    defaultChecked: i,
    disabled: s,
    form: a,
    name: o,
    onCheckedChange: u,
    required: l,
    value: c = "on",
    // @ts-expect-error
    internal_do_not_use_render: d
  } = t, [f, h] = DE({
    prop: n,
    defaultProp: i ?? !1,
    onChange: u,
    caller: Hu
  }), [m, p] = V.useState(null), [g, E] = V.useState(null), y = V.useRef(!1), T = m ? !!a || !!m.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), S = {
    checked: f,
    disabled: s,
    setChecked: h,
    control: m,
    setControl: p,
    name: o,
    form: a,
    value: c,
    hasConsumerStoppedPropagationRef: y,
    required: l,
    defaultChecked: Ar(i) ? !1 : i,
    isFormControl: T,
    bubbleInput: g,
    setBubbleInput: E
  };
  return /* @__PURE__ */ xe(
    zk,
    {
      scope: e,
      ...S,
      children: jk(d) ? d(S) : r
    }
  );
}
var NE = "CheckboxTrigger", ME = V.forwardRef(
  ({ __scopeCheckbox: t, onKeyDown: e, onClick: n, ...r }, i) => {
    const {
      control: s,
      value: a,
      disabled: o,
      checked: u,
      required: l,
      setControl: c,
      setChecked: d,
      hasConsumerStoppedPropagationRef: f,
      isFormControl: h,
      bubbleInput: m
    } = Ff(NE, t), p = Gn(i, c), g = V.useRef(u);
    return V.useEffect(() => {
      const E = s == null ? void 0 : s.form;
      if (E) {
        const y = () => d(g.current);
        return E.addEventListener("reset", y), () => E.removeEventListener("reset", y);
      }
    }, [s, d]), /* @__PURE__ */ xe(
      un.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": Ar(u) ? "mixed" : u,
        "aria-required": l,
        "data-state": GE(u),
        "data-disabled": o ? "" : void 0,
        disabled: o,
        value: a,
        ...r,
        ref: p,
        onKeyDown: Pn(e, (E) => {
          E.key === "Enter" && E.preventDefault();
        }),
        onClick: Pn(n, (E) => {
          d((y) => Ar(y) ? !0 : !y), m && h && (f.current = E.isPropagationStopped(), f.current || E.stopPropagation());
        })
      }
    );
  }
);
ME.displayName = NE;
var FE = V.forwardRef(
  (t, e) => {
    const {
      __scopeCheckbox: n,
      name: r,
      checked: i,
      defaultChecked: s,
      required: a,
      disabled: o,
      value: u,
      onCheckedChange: l,
      form: c,
      ...d
    } = t;
    return /* @__PURE__ */ xe(
      qk,
      {
        __scopeCheckbox: n,
        checked: i,
        defaultChecked: s,
        disabled: o,
        required: a,
        onCheckedChange: l,
        name: r,
        form: c,
        value: u,
        internal_do_not_use_render: ({ isFormControl: f }) => /* @__PURE__ */ t2(n2, { children: [
          /* @__PURE__ */ xe(
            ME,
            {
              ...d,
              ref: e,
              __scopeCheckbox: n
            }
          ),
          f && /* @__PURE__ */ xe(
            HE,
            {
              __scopeCheckbox: n
            }
          )
        ] })
      }
    );
  }
);
FE.displayName = Hu;
var BE = "CheckboxIndicator", UE = V.forwardRef(
  (t, e) => {
    const { __scopeCheckbox: n, forceMount: r, ...i } = t, s = Ff(BE, n);
    return /* @__PURE__ */ xe(
      Mf,
      {
        present: r || Ar(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ xe(
          un.span,
          {
            "data-state": GE(s.checked),
            "data-disabled": s.disabled ? "" : void 0,
            ...i,
            ref: e,
            style: { pointerEvents: "none", ...t.style }
          }
        )
      }
    );
  }
);
UE.displayName = BE;
var $E = "CheckboxBubbleInput", HE = V.forwardRef(
  ({ __scopeCheckbox: t, ...e }, n) => {
    const {
      control: r,
      hasConsumerStoppedPropagationRef: i,
      checked: s,
      defaultChecked: a,
      required: o,
      disabled: u,
      name: l,
      value: c,
      form: d,
      bubbleInput: f,
      setBubbleInput: h
    } = Ff($E, t), m = Gn(n, h), p = Dk(s), g = PE(r);
    V.useEffect(() => {
      const y = f;
      if (!y) return;
      const T = window.HTMLInputElement.prototype, v = Object.getOwnPropertyDescriptor(
        T,
        "checked"
      ).set, I = !i.current;
      if (p !== s && v) {
        const C = new Event("click", { bubbles: I });
        y.indeterminate = Ar(s), v.call(y, Ar(s) ? !1 : s), y.dispatchEvent(C);
      }
    }, [f, p, s, i]);
    const E = V.useRef(Ar(s) ? !1 : s);
    return /* @__PURE__ */ xe(
      un.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: a ?? E.current,
        required: o,
        disabled: u,
        name: l,
        value: c,
        form: d,
        ...e,
        tabIndex: -1,
        ref: m,
        style: {
          ...e.style,
          ...g,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
HE.displayName = $E;
function jk(t) {
  return typeof t == "function";
}
function Ar(t) {
  return t === "indeterminate";
}
function GE(t) {
  return Ar(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function ji(t) {
  const e = V.useRef(t);
  return V.useEffect(() => {
    e.current = t;
  }), V.useMemo(() => (...n) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...n);
  }, []);
}
function Kk(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = ji(t);
  V.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var Wk = "DismissableLayer", nd = "dismissableLayer.update", Yk = "dismissableLayer.pointerDownOutside", Xk = "dismissableLayer.focusOutside", vm, VE = V.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), zE = V.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: a,
      onDismiss: o,
      ...u
    } = t, l = V.useContext(VE), [c, d] = V.useState(null), f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = V.useState({}), m = Gn(e, (C) => d(C)), p = Array.from(l.layers), [g] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), E = p.indexOf(g), y = c ? p.indexOf(c) : -1, T = l.layersWithOutsidePointerEventsDisabled.size > 0, S = y >= E, v = Jk((C) => {
      const D = C.target, _ = [...l.branches].some((A) => A.contains(D));
      !S || _ || (i == null || i(C), a == null || a(C), C.defaultPrevented || o == null || o());
    }, f), I = ew((C) => {
      const D = C.target;
      [...l.branches].some((A) => A.contains(D)) || (s == null || s(C), a == null || a(C), C.defaultPrevented || o == null || o());
    }, f);
    return Kk((C) => {
      y === l.layers.size - 1 && (r == null || r(C), !C.defaultPrevented && o && (C.preventDefault(), o()));
    }, f), V.useEffect(() => {
      if (c)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (vm = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(c)), l.layers.add(c), Im(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = vm);
        };
    }, [c, f, n, l]), V.useEffect(() => () => {
      c && (l.layers.delete(c), l.layersWithOutsidePointerEventsDisabled.delete(c), Im());
    }, [c, l]), V.useEffect(() => {
      const C = () => h({});
      return document.addEventListener(nd, C), () => document.removeEventListener(nd, C);
    }, []), /* @__PURE__ */ xe(
      un.div,
      {
        ...u,
        ref: m,
        style: {
          pointerEvents: T ? S ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Pn(t.onFocusCapture, I.onFocusCapture),
        onBlurCapture: Pn(t.onBlurCapture, I.onBlurCapture),
        onPointerDownCapture: Pn(
          t.onPointerDownCapture,
          v.onPointerDownCapture
        )
      }
    );
  }
);
zE.displayName = Wk;
var Qk = "DismissableLayerBranch", Zk = V.forwardRef((t, e) => {
  const n = V.useContext(VE), r = V.useRef(null), i = Gn(e, r);
  return V.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ xe(un.div, { ...t, ref: i });
});
Zk.displayName = Qk;
function Jk(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = ji(t), r = V.useRef(!1), i = V.useRef(() => {
  });
  return V.useEffect(() => {
    const s = (o) => {
      if (o.target && !r.current) {
        let u = function() {
          qE(
            Yk,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: o };
        o.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = u, e.addEventListener("click", i.current, { once: !0 })) : u();
      } else
        e.removeEventListener("click", i.current);
      r.current = !1;
    }, a = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(a), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function ew(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = ji(t), r = V.useRef(!1);
  return V.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && qE(Xk, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Im() {
  const t = new CustomEvent(nd);
  document.dispatchEvent(t);
}
function qE(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target, s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? Gk(i, s) : i.dispatchEvent(s);
}
var Bl = 0;
function tw() {
  V.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? Cm()), document.body.insertAdjacentElement("beforeend", t[1] ?? Cm()), Bl++, () => {
      Bl === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), Bl--;
    };
  }, []);
}
function Cm() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var Ul = "focusScope.autoFocusOnMount", $l = "focusScope.autoFocusOnUnmount", Lm = { bubbles: !1, cancelable: !0 }, nw = "FocusScope", jE = V.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...a
  } = t, [o, u] = V.useState(null), l = ji(i), c = ji(s), d = V.useRef(null), f = Gn(e, (p) => u(p)), h = V.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  V.useEffect(() => {
    if (r) {
      let p = function(T) {
        if (h.paused || !o) return;
        const S = T.target;
        o.contains(S) ? d.current = S : gr(d.current, { select: !0 });
      }, g = function(T) {
        if (h.paused || !o) return;
        const S = T.relatedTarget;
        S !== null && (o.contains(S) || gr(d.current, { select: !0 }));
      }, E = function(T) {
        if (document.activeElement === document.body)
          for (const v of T)
            v.removedNodes.length > 0 && gr(o);
      };
      document.addEventListener("focusin", p), document.addEventListener("focusout", g);
      const y = new MutationObserver(E);
      return o && y.observe(o, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", g), y.disconnect();
      };
    }
  }, [r, o, h.paused]), V.useEffect(() => {
    if (o) {
      Rm.add(h);
      const p = document.activeElement;
      if (!o.contains(p)) {
        const E = new CustomEvent(Ul, Lm);
        o.addEventListener(Ul, l), o.dispatchEvent(E), E.defaultPrevented || (rw(uw(KE(o)), { select: !0 }), document.activeElement === p && gr(o));
      }
      return () => {
        o.removeEventListener(Ul, l), setTimeout(() => {
          const E = new CustomEvent($l, Lm);
          o.addEventListener($l, c), o.dispatchEvent(E), E.defaultPrevented || gr(p ?? document.body, { select: !0 }), o.removeEventListener($l, c), Rm.remove(h);
        }, 0);
      };
    }
  }, [o, l, c, h]);
  const m = V.useCallback(
    (p) => {
      if (!n && !r || h.paused) return;
      const g = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, E = document.activeElement;
      if (g && E) {
        const y = p.currentTarget, [T, S] = iw(y);
        T && S ? !p.shiftKey && E === S ? (p.preventDefault(), n && gr(T, { select: !0 })) : p.shiftKey && E === T && (p.preventDefault(), n && gr(S, { select: !0 })) : E === y && p.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ xe(un.div, { tabIndex: -1, ...a, ref: f, onKeyDown: m });
});
jE.displayName = nw;
function rw(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (gr(r, { select: e }), document.activeElement !== n) return;
}
function iw(t) {
  const e = KE(t), n = _m(e, t), r = _m(e.reverse(), t);
  return [n, r];
}
function KE(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function _m(t, e) {
  for (const n of t)
    if (!sw(n, { upTo: e })) return n;
}
function sw(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function aw(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function gr(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && aw(t) && e && t.select();
  }
}
var Rm = ow();
function ow() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = km(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = km(t, e), (n = t[0]) == null || n.resume();
    }
  };
}
function km(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function uw(t) {
  return t.filter((e) => e.tagName !== "A");
}
var lw = V[" useId ".trim().toString()] || (() => {
}), cw = 0;
function dw(t) {
  const [e, n] = V.useState(lw());
  return Xr(() => {
    n((r) => r ?? String(cw++));
  }, [t]), t || (e ? `radix-${e}` : "");
}
const fw = ["top", "right", "bottom", "left"], Cr = Math.min, Qt = Math.max, mu = Math.round, co = Math.floor, On = (t) => ({
  x: t,
  y: t
}), hw = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, mw = {
  start: "end",
  end: "start"
};
function rd(t, e, n) {
  return Qt(t, Cr(e, n));
}
function sr(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function ar(t) {
  return t.split("-")[0];
}
function ns(t) {
  return t.split("-")[1];
}
function Bf(t) {
  return t === "x" ? "y" : "x";
}
function Uf(t) {
  return t === "y" ? "height" : "width";
}
const pw = /* @__PURE__ */ new Set(["top", "bottom"]);
function wn(t) {
  return pw.has(ar(t)) ? "y" : "x";
}
function $f(t) {
  return Bf(wn(t));
}
function gw(t, e, n) {
  n === void 0 && (n = !1);
  const r = ns(t), i = $f(t), s = Uf(i);
  let a = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (a = pu(a)), [a, pu(a)];
}
function bw(t) {
  const e = pu(t);
  return [id(t), e, id(e)];
}
function id(t) {
  return t.replace(/start|end/g, (e) => mw[e]);
}
const wm = ["left", "right"], Dm = ["right", "left"], Ew = ["top", "bottom"], yw = ["bottom", "top"];
function Tw(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? Dm : wm : e ? wm : Dm;
    case "left":
    case "right":
      return e ? Ew : yw;
    default:
      return [];
  }
}
function xw(t, e, n, r) {
  const i = ns(t);
  let s = Tw(ar(t), n === "start", r);
  return i && (s = s.map((a) => a + "-" + i), e && (s = s.concat(s.map(id)))), s;
}
function pu(t) {
  return t.replace(/left|right|bottom|top/g, (e) => hw[e]);
}
function Sw(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function WE(t) {
  return typeof t != "number" ? Sw(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function gu(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: i
  } = t;
  return {
    width: r,
    height: i,
    top: n,
    left: e,
    right: e + r,
    bottom: n + i,
    x: e,
    y: n
  };
}
function Pm(t, e, n) {
  let {
    reference: r,
    floating: i
  } = t;
  const s = wn(e), a = $f(e), o = Uf(a), u = ar(e), l = s === "y", c = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[o] / 2 - i[o] / 2;
  let h;
  switch (u) {
    case "top":
      h = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      h = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (ns(e)) {
    case "start":
      h[a] -= f * (n && l ? -1 : 1);
      break;
    case "end":
      h[a] += f * (n && l ? -1 : 1);
      break;
  }
  return h;
}
const Aw = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: a
  } = n, o = s.filter(Boolean), u = await (a.isRTL == null ? void 0 : a.isRTL(e));
  let l = await a.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: d
  } = Pm(l, r, u), f = r, h = {}, m = 0;
  for (let p = 0; p < o.length; p++) {
    const {
      name: g,
      fn: E
    } = o[p], {
      x: y,
      y: T,
      data: S,
      reset: v
    } = await E({
      x: c,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: h,
      rects: l,
      platform: a,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = y ?? c, d = T ?? d, h = {
      ...h,
      [g]: {
        ...h[g],
        ...S
      }
    }, v && m <= 50 && (m++, typeof v == "object" && (v.placement && (f = v.placement), v.rects && (l = v.rects === !0 ? await a.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : v.rects), {
      x: c,
      y: d
    } = Pm(l, f, u)), p = -1);
  }
  return {
    x: c,
    y: d,
    placement: f,
    strategy: i,
    middlewareData: h
  };
};
async function oa(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: a,
    elements: o,
    strategy: u
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = sr(e, t), m = WE(h), g = o[f ? d === "floating" ? "reference" : "floating" : d], E = gu(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(g))) == null || n ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(o.floating)),
    boundary: l,
    rootBoundary: c,
    strategy: u
  })), y = d === "floating" ? {
    x: r,
    y: i,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, T = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(o.floating)), S = await (s.isElement == null ? void 0 : s.isElement(T)) ? await (s.getScale == null ? void 0 : s.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, v = gu(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: y,
    offsetParent: T,
    strategy: u
  }) : y);
  return {
    top: (E.top - v.top + m.top) / S.y,
    bottom: (v.bottom - E.bottom + m.bottom) / S.y,
    left: (E.left - v.left + m.left) / S.x,
    right: (v.right - E.right + m.right) / S.x
  };
}
const vw = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: s,
      platform: a,
      elements: o,
      middlewareData: u
    } = e, {
      element: l,
      padding: c = 0
    } = sr(t, e) || {};
    if (l == null)
      return {};
    const d = WE(c), f = {
      x: n,
      y: r
    }, h = $f(i), m = Uf(h), p = await a.getDimensions(l), g = h === "y", E = g ? "top" : "left", y = g ? "bottom" : "right", T = g ? "clientHeight" : "clientWidth", S = s.reference[m] + s.reference[h] - f[h] - s.floating[m], v = f[h] - s.reference[h], I = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(l));
    let C = I ? I[T] : 0;
    (!C || !await (a.isElement == null ? void 0 : a.isElement(I))) && (C = o.floating[T] || s.floating[m]);
    const D = S / 2 - v / 2, _ = C / 2 - p[m] / 2 - 1, A = Cr(d[E], _), L = Cr(d[y], _), N = A, U = C - p[m] - L, z = C / 2 - p[m] / 2 + D, O = rd(N, z, U), F = !u.arrow && ns(i) != null && z !== O && s.reference[m] / 2 - (z < N ? A : L) - p[m] / 2 < 0, B = F ? z < N ? z - N : z - U : 0;
    return {
      [h]: f[h] + B,
      data: {
        [h]: O,
        centerOffset: z - O - B,
        ...F && {
          alignmentOffset: B
        }
      },
      reset: F
    };
  }
}), Iw = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        middlewareData: s,
        rects: a,
        initialPlacement: o,
        platform: u,
        elements: l
      } = e, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: p = !0,
        ...g
      } = sr(t, e);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const E = ar(i), y = wn(o), T = ar(o) === o, S = await (u.isRTL == null ? void 0 : u.isRTL(l.floating)), v = f || (T || !p ? [pu(o)] : bw(o)), I = m !== "none";
      !f && I && v.push(...xw(o, p, m, S));
      const C = [o, ...v], D = await oa(e, g), _ = [];
      let A = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (c && _.push(D[E]), d) {
        const z = gw(i, a, S);
        _.push(D[z[0]], D[z[1]]);
      }
      if (A = [...A, {
        placement: i,
        overflows: _
      }], !_.every((z) => z <= 0)) {
        var L, N;
        const z = (((L = s.flip) == null ? void 0 : L.index) || 0) + 1, O = C[z];
        if (O && (!(d === "alignment" ? y !== wn(O) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        A.every((H) => wn(H.placement) === y ? H.overflows[0] > 0 : !0)))
          return {
            data: {
              index: z,
              overflows: A
            },
            reset: {
              placement: O
            }
          };
        let F = (N = A.filter((B) => B.overflows[0] <= 0).sort((B, H) => B.overflows[1] - H.overflows[1])[0]) == null ? void 0 : N.placement;
        if (!F)
          switch (h) {
            case "bestFit": {
              var U;
              const B = (U = A.filter((H) => {
                if (I) {
                  const X = wn(H.placement);
                  return X === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  X === "y";
                }
                return !0;
              }).map((H) => [H.placement, H.overflows.filter((X) => X > 0).reduce((X, w) => X + w, 0)]).sort((H, X) => H[1] - X[1])[0]) == null ? void 0 : U[0];
              B && (F = B);
              break;
            }
            case "initialPlacement":
              F = o;
              break;
          }
        if (i !== F)
          return {
            reset: {
              placement: F
            }
          };
      }
      return {};
    }
  };
};
function Om(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function Nm(t) {
  return fw.some((e) => t[e] >= 0);
}
const Cw = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = sr(t, e);
      switch (r) {
        case "referenceHidden": {
          const s = await oa(e, {
            ...i,
            elementContext: "reference"
          }), a = Om(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: Nm(a)
            }
          };
        }
        case "escaped": {
          const s = await oa(e, {
            ...i,
            altBoundary: !0
          }), a = Om(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: Nm(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, YE = /* @__PURE__ */ new Set(["left", "top"]);
async function Lw(t, e) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = ar(n), o = ns(n), u = wn(n) === "y", l = YE.has(a) ? -1 : 1, c = s && u ? -1 : 1, d = sr(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return o && typeof m == "number" && (h = o === "end" ? m * -1 : m), u ? {
    x: h * c,
    y: f * l
  } : {
    x: f * l,
    y: h * c
  };
}
const _w = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: i,
        y: s,
        placement: a,
        middlewareData: o
      } = e, u = await Lw(e, t);
      return a === ((n = o.offset) == null ? void 0 : n.placement) && (r = o.arrow) != null && r.alignmentOffset ? {} : {
        x: i + u.x,
        y: s + u.y,
        data: {
          ...u,
          placement: a
        }
      };
    }
  };
}, Rw = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: (g) => {
            let {
              x: E,
              y
            } = g;
            return {
              x: E,
              y
            };
          }
        },
        ...u
      } = sr(t, e), l = {
        x: n,
        y: r
      }, c = await oa(e, u), d = wn(ar(i)), f = Bf(d);
      let h = l[f], m = l[d];
      if (s) {
        const g = f === "y" ? "top" : "left", E = f === "y" ? "bottom" : "right", y = h + c[g], T = h - c[E];
        h = rd(y, h, T);
      }
      if (a) {
        const g = d === "y" ? "top" : "left", E = d === "y" ? "bottom" : "right", y = m + c[g], T = m - c[E];
        m = rd(y, m, T);
      }
      const p = o.fn({
        ...e,
        [f]: h,
        [d]: m
      });
      return {
        ...p,
        data: {
          x: p.x - n,
          y: p.y - r,
          enabled: {
            [f]: s,
            [d]: a
          }
        }
      };
    }
  };
}, kw = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: s,
        middlewareData: a
      } = e, {
        offset: o = 0,
        mainAxis: u = !0,
        crossAxis: l = !0
      } = sr(t, e), c = {
        x: n,
        y: r
      }, d = wn(i), f = Bf(d);
      let h = c[f], m = c[d];
      const p = sr(o, e), g = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (u) {
        const T = f === "y" ? "height" : "width", S = s.reference[f] - s.floating[T] + g.mainAxis, v = s.reference[f] + s.reference[T] - g.mainAxis;
        h < S ? h = S : h > v && (h = v);
      }
      if (l) {
        var E, y;
        const T = f === "y" ? "width" : "height", S = YE.has(ar(i)), v = s.reference[d] - s.floating[T] + (S && ((E = a.offset) == null ? void 0 : E[d]) || 0) + (S ? 0 : g.crossAxis), I = s.reference[d] + s.reference[T] + (S ? 0 : ((y = a.offset) == null ? void 0 : y[d]) || 0) - (S ? g.crossAxis : 0);
        m < v ? m = v : m > I && (m = I);
      }
      return {
        [f]: h,
        [d]: m
      };
    }
  };
}, ww = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        rects: s,
        platform: a,
        elements: o
      } = e, {
        apply: u = () => {
        },
        ...l
      } = sr(t, e), c = await oa(e, l), d = ar(i), f = ns(i), h = wn(i) === "y", {
        width: m,
        height: p
      } = s.floating;
      let g, E;
      d === "top" || d === "bottom" ? (g = d, E = f === (await (a.isRTL == null ? void 0 : a.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (E = d, g = f === "end" ? "top" : "bottom");
      const y = p - c.top - c.bottom, T = m - c.left - c.right, S = Cr(p - c[g], y), v = Cr(m - c[E], T), I = !e.middlewareData.shift;
      let C = S, D = v;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (D = T), (r = e.middlewareData.shift) != null && r.enabled.y && (C = y), I && !f) {
        const A = Qt(c.left, 0), L = Qt(c.right, 0), N = Qt(c.top, 0), U = Qt(c.bottom, 0);
        h ? D = m - 2 * (A !== 0 || L !== 0 ? A + L : Qt(c.left, c.right)) : C = p - 2 * (N !== 0 || U !== 0 ? N + U : Qt(c.top, c.bottom));
      }
      await u({
        ...e,
        availableWidth: D,
        availableHeight: C
      });
      const _ = await a.getDimensions(o.floating);
      return m !== _.width || p !== _.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Gu() {
  return typeof window < "u";
}
function rs(t) {
  return XE(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Jt(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Vn(t) {
  var e;
  return (e = (XE(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function XE(t) {
  return Gu() ? t instanceof Node || t instanceof Jt(t).Node : !1;
}
function mn(t) {
  return Gu() ? t instanceof Element || t instanceof Jt(t).Element : !1;
}
function Bn(t) {
  return Gu() ? t instanceof HTMLElement || t instanceof Jt(t).HTMLElement : !1;
}
function Mm(t) {
  return !Gu() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Jt(t).ShadowRoot;
}
const Dw = /* @__PURE__ */ new Set(["inline", "contents"]);
function va(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = pn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !Dw.has(i);
}
const Pw = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Ow(t) {
  return Pw.has(rs(t));
}
const Nw = [":popover-open", ":modal"];
function Vu(t) {
  return Nw.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const Mw = ["transform", "translate", "scale", "rotate", "perspective"], Fw = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Bw = ["paint", "layout", "strict", "content"];
function Hf(t) {
  const e = Gf(), n = mn(t) ? pn(t) : t;
  return Mw.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || Fw.some((r) => (n.willChange || "").includes(r)) || Bw.some((r) => (n.contain || "").includes(r));
}
function Uw(t) {
  let e = Lr(t);
  for (; Bn(e) && !Ki(e); ) {
    if (Hf(e))
      return e;
    if (Vu(e))
      return null;
    e = Lr(e);
  }
  return null;
}
function Gf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const $w = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Ki(t) {
  return $w.has(rs(t));
}
function pn(t) {
  return Jt(t).getComputedStyle(t);
}
function zu(t) {
  return mn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Lr(t) {
  if (rs(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Mm(t) && t.host || // Fallback.
    Vn(t)
  );
  return Mm(e) ? e.host : e;
}
function QE(t) {
  const e = Lr(t);
  return Ki(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Bn(e) && va(e) ? e : QE(e);
}
function ua(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = QE(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), a = Jt(i);
  if (s) {
    const o = sd(a);
    return e.concat(a, a.visualViewport || [], va(i) ? i : [], o && n ? ua(o) : []);
  }
  return e.concat(i, ua(i, [], n));
}
function sd(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function ZE(t) {
  const e = pn(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Bn(t), s = i ? t.offsetWidth : n, a = i ? t.offsetHeight : r, o = mu(n) !== s || mu(r) !== a;
  return o && (n = s, r = a), {
    width: n,
    height: r,
    $: o
  };
}
function Vf(t) {
  return mn(t) ? t : t.contextElement;
}
function wi(t) {
  const e = Vf(t);
  if (!Bn(e))
    return On(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = ZE(e);
  let a = (s ? mu(n.width) : n.width) / r, o = (s ? mu(n.height) : n.height) / i;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
const Hw = /* @__PURE__ */ On(0);
function JE(t) {
  const e = Jt(t);
  return !Gf() || !e.visualViewport ? Hw : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function Gw(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Jt(t) ? !1 : e;
}
function Qr(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), s = Vf(t);
  let a = On(1);
  e && (r ? mn(r) && (a = wi(r)) : a = wi(t));
  const o = Gw(s, n, r) ? JE(s) : On(0);
  let u = (i.left + o.x) / a.x, l = (i.top + o.y) / a.y, c = i.width / a.x, d = i.height / a.y;
  if (s) {
    const f = Jt(s), h = r && mn(r) ? Jt(r) : r;
    let m = f, p = sd(m);
    for (; p && r && h !== m; ) {
      const g = wi(p), E = p.getBoundingClientRect(), y = pn(p), T = E.left + (p.clientLeft + parseFloat(y.paddingLeft)) * g.x, S = E.top + (p.clientTop + parseFloat(y.paddingTop)) * g.y;
      u *= g.x, l *= g.y, c *= g.x, d *= g.y, u += T, l += S, m = Jt(p), p = sd(m);
    }
  }
  return gu({
    width: c,
    height: d,
    x: u,
    y: l
  });
}
function qu(t, e) {
  const n = zu(t).scrollLeft;
  return e ? e.left + n : Qr(Vn(t)).left + n;
}
function ey(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - qu(t, n), i = n.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function Vw(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: i
  } = t;
  const s = i === "fixed", a = Vn(r), o = e ? Vu(e.floating) : !1;
  if (r === a || o && s)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = On(1);
  const c = On(0), d = Bn(r);
  if ((d || !d && !s) && ((rs(r) !== "body" || va(a)) && (u = zu(r)), Bn(r))) {
    const h = Qr(r);
    l = wi(r), c.x = h.x + r.clientLeft, c.y = h.y + r.clientTop;
  }
  const f = a && !d && !s ? ey(a, u) : On(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - u.scrollLeft * l.x + c.x + f.x,
    y: n.y * l.y - u.scrollTop * l.y + c.y + f.y
  };
}
function zw(t) {
  return Array.from(t.getClientRects());
}
function qw(t) {
  const e = Vn(t), n = zu(t), r = t.ownerDocument.body, i = Qt(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = Qt(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + qu(t);
  const o = -n.scrollTop;
  return pn(r).direction === "rtl" && (a += Qt(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: a,
    y: o
  };
}
const Fm = 25;
function jw(t, e) {
  const n = Jt(t), r = Vn(t), i = n.visualViewport;
  let s = r.clientWidth, a = r.clientHeight, o = 0, u = 0;
  if (i) {
    s = i.width, a = i.height;
    const c = Gf();
    (!c || c && e === "fixed") && (o = i.offsetLeft, u = i.offsetTop);
  }
  const l = qu(r);
  if (l <= 0) {
    const c = r.ownerDocument, d = c.body, f = getComputedStyle(d), h = c.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, m = Math.abs(r.clientWidth - d.clientWidth - h);
    m <= Fm && (s -= m);
  } else l <= Fm && (s += l);
  return {
    width: s,
    height: a,
    x: o,
    y: u
  };
}
const Kw = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Ww(t, e) {
  const n = Qr(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, s = Bn(t) ? wi(t) : On(1), a = t.clientWidth * s.x, o = t.clientHeight * s.y, u = i * s.x, l = r * s.y;
  return {
    width: a,
    height: o,
    x: u,
    y: l
  };
}
function Bm(t, e, n) {
  let r;
  if (e === "viewport")
    r = jw(t, n);
  else if (e === "document")
    r = qw(Vn(t));
  else if (mn(e))
    r = Ww(e, n);
  else {
    const i = JE(t);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return gu(r);
}
function ty(t, e) {
  const n = Lr(t);
  return n === e || !mn(n) || Ki(n) ? !1 : pn(n).position === "fixed" || ty(n, e);
}
function Yw(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = ua(t, [], !1).filter((o) => mn(o) && rs(o) !== "body"), i = null;
  const s = pn(t).position === "fixed";
  let a = s ? Lr(t) : t;
  for (; mn(a) && !Ki(a); ) {
    const o = pn(a), u = Hf(a);
    !u && o.position === "fixed" && (i = null), (s ? !u && !i : !u && o.position === "static" && !!i && Kw.has(i.position) || va(a) && !u && ty(t, a)) ? r = r.filter((c) => c !== a) : i = o, a = Lr(a);
  }
  return e.set(t, r), r;
}
function Xw(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = t;
  const a = [...n === "clippingAncestors" ? Vu(e) ? [] : Yw(e, this._c) : [].concat(n), r], o = a[0], u = a.reduce((l, c) => {
    const d = Bm(e, c, i);
    return l.top = Qt(d.top, l.top), l.right = Cr(d.right, l.right), l.bottom = Cr(d.bottom, l.bottom), l.left = Qt(d.left, l.left), l;
  }, Bm(e, o, i));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function Qw(t) {
  const {
    width: e,
    height: n
  } = ZE(t);
  return {
    width: e,
    height: n
  };
}
function Zw(t, e, n) {
  const r = Bn(e), i = Vn(e), s = n === "fixed", a = Qr(t, !0, s, e);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = On(0);
  function l() {
    u.x = qu(i);
  }
  if (r || !r && !s)
    if ((rs(e) !== "body" || va(i)) && (o = zu(e)), r) {
      const h = Qr(e, !0, s, e);
      u.x = h.x + e.clientLeft, u.y = h.y + e.clientTop;
    } else i && l();
  s && !r && i && l();
  const c = i && !r && !s ? ey(i, o) : On(0), d = a.left + o.scrollLeft - u.x - c.x, f = a.top + o.scrollTop - u.y - c.y;
  return {
    x: d,
    y: f,
    width: a.width,
    height: a.height
  };
}
function Hl(t) {
  return pn(t).position === "static";
}
function Um(t, e) {
  if (!Bn(t) || pn(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Vn(t) === n && (n = n.ownerDocument.body), n;
}
function ny(t, e) {
  const n = Jt(t);
  if (Vu(t))
    return n;
  if (!Bn(t)) {
    let i = Lr(t);
    for (; i && !Ki(i); ) {
      if (mn(i) && !Hl(i))
        return i;
      i = Lr(i);
    }
    return n;
  }
  let r = Um(t, e);
  for (; r && Ow(r) && Hl(r); )
    r = Um(r, e);
  return r && Ki(r) && Hl(r) && !Hf(r) ? n : r || Uw(t) || n;
}
const Jw = async function(t) {
  const e = this.getOffsetParent || ny, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: Zw(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function eD(t) {
  return pn(t).direction === "rtl";
}
const tD = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Vw,
  getDocumentElement: Vn,
  getClippingRect: Xw,
  getOffsetParent: ny,
  getElementRects: Jw,
  getClientRects: zw,
  getDimensions: Qw,
  getScale: wi,
  isElement: mn,
  isRTL: eD
};
function ry(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function nD(t, e) {
  let n = null, r;
  const i = Vn(t);
  function s() {
    var o;
    clearTimeout(r), (o = n) == null || o.disconnect(), n = null;
  }
  function a(o, u) {
    o === void 0 && (o = !1), u === void 0 && (u = 1), s();
    const l = t.getBoundingClientRect(), {
      left: c,
      top: d,
      width: f,
      height: h
    } = l;
    if (o || e(), !f || !h)
      return;
    const m = co(d), p = co(i.clientWidth - (c + f)), g = co(i.clientHeight - (d + h)), E = co(c), T = {
      rootMargin: -m + "px " + -p + "px " + -g + "px " + -E + "px",
      threshold: Qt(0, Cr(1, u)) || 1
    };
    let S = !0;
    function v(I) {
      const C = I[0].intersectionRatio;
      if (C !== u) {
        if (!S)
          return a();
        C ? a(!1, C) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      C === 1 && !ry(l, t.getBoundingClientRect()) && a(), S = !1;
    }
    try {
      n = new IntersectionObserver(v, {
        ...T,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(v, T);
    }
    n.observe(t);
  }
  return a(!0), s;
}
function rD(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = r, l = Vf(t), c = i || s ? [...l ? ua(l) : [], ...ua(e)] : [];
  c.forEach((E) => {
    i && E.addEventListener("scroll", n, {
      passive: !0
    }), s && E.addEventListener("resize", n);
  });
  const d = l && o ? nD(l, n) : null;
  let f = -1, h = null;
  a && (h = new ResizeObserver((E) => {
    let [y] = E;
    y && y.target === l && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var T;
      (T = h) == null || T.observe(e);
    })), n();
  }), l && !u && h.observe(l), h.observe(e));
  let m, p = u ? Qr(t) : null;
  u && g();
  function g() {
    const E = Qr(t);
    p && !ry(p, E) && n(), p = E, m = requestAnimationFrame(g);
  }
  return n(), () => {
    var E;
    c.forEach((y) => {
      i && y.removeEventListener("scroll", n), s && y.removeEventListener("resize", n);
    }), d == null || d(), (E = h) == null || E.disconnect(), h = null, u && cancelAnimationFrame(m);
  };
}
const iD = _w, sD = Rw, aD = Iw, oD = ww, uD = Cw, $m = vw, lD = kw, cD = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: tD,
    ...n
  }, s = {
    ...i.platform,
    _c: r
  };
  return Aw(t, e, {
    ...i,
    platform: s
  });
};
var dD = typeof document < "u", fD = function() {
}, Uo = dD ? JS : fD;
function bu(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, i;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!bu(t[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && t.$$typeof) && !bu(t[s], e[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function iy(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Hm(t, e) {
  const n = iy(t);
  return Math.round(e * n) / n;
}
function Gl(t) {
  const e = V.useRef(t);
  return Uo(() => {
    e.current = t;
  }), e;
}
function hD(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: a
    } = {},
    transform: o = !0,
    whileElementsMounted: u,
    open: l
  } = t, [c, d] = V.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = V.useState(r);
  bu(f, r) || h(r);
  const [m, p] = V.useState(null), [g, E] = V.useState(null), y = V.useCallback((H) => {
    H !== I.current && (I.current = H, p(H));
  }, []), T = V.useCallback((H) => {
    H !== C.current && (C.current = H, E(H));
  }, []), S = s || m, v = a || g, I = V.useRef(null), C = V.useRef(null), D = V.useRef(c), _ = u != null, A = Gl(u), L = Gl(i), N = Gl(l), U = V.useCallback(() => {
    if (!I.current || !C.current)
      return;
    const H = {
      placement: e,
      strategy: n,
      middleware: f
    };
    L.current && (H.platform = L.current), cD(I.current, C.current, H).then((X) => {
      const w = {
        ...X,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: N.current !== !1
      };
      z.current && !bu(D.current, w) && (D.current = w, Ug.flushSync(() => {
        d(w);
      }));
    });
  }, [f, e, n, L, N]);
  Uo(() => {
    l === !1 && D.current.isPositioned && (D.current.isPositioned = !1, d((H) => ({
      ...H,
      isPositioned: !1
    })));
  }, [l]);
  const z = V.useRef(!1);
  Uo(() => (z.current = !0, () => {
    z.current = !1;
  }), []), Uo(() => {
    if (S && (I.current = S), v && (C.current = v), S && v) {
      if (A.current)
        return A.current(S, v, U);
      U();
    }
  }, [S, v, U, A, _]);
  const O = V.useMemo(() => ({
    reference: I,
    floating: C,
    setReference: y,
    setFloating: T
  }), [y, T]), F = V.useMemo(() => ({
    reference: S,
    floating: v
  }), [S, v]), B = V.useMemo(() => {
    const H = {
      position: n,
      left: 0,
      top: 0
    };
    if (!F.floating)
      return H;
    const X = Hm(F.floating, c.x), w = Hm(F.floating, c.y);
    return o ? {
      ...H,
      transform: "translate(" + X + "px, " + w + "px)",
      ...iy(F.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: X,
      top: w
    };
  }, [n, o, F.floating, c.x, c.y]);
  return V.useMemo(() => ({
    ...c,
    update: U,
    refs: O,
    elements: F,
    floatingStyles: B
  }), [c, U, O, F, B]);
}
const mD = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? $m({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? $m({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, pD = (t, e) => ({
  ...iD(t),
  options: [t, e]
}), gD = (t, e) => ({
  ...sD(t),
  options: [t, e]
}), bD = (t, e) => ({
  ...lD(t),
  options: [t, e]
}), ED = (t, e) => ({
  ...aD(t),
  options: [t, e]
}), yD = (t, e) => ({
  ...oD(t),
  options: [t, e]
}), TD = (t, e) => ({
  ...uD(t),
  options: [t, e]
}), xD = (t, e) => ({
  ...mD(t),
  options: [t, e]
});
var SD = "Arrow", sy = V.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: i = 5, ...s } = t;
  return /* @__PURE__ */ xe(
    un.svg,
    {
      ...s,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ xe("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
sy.displayName = SD;
var AD = sy, zf = "Popper", [ay, oy] = Nf(zf), [vD, uy] = ay(zf), ly = (t) => {
  const { __scopePopper: e, children: n } = t, [r, i] = V.useState(null);
  return /* @__PURE__ */ xe(vD, { scope: e, anchor: r, onAnchorChange: i, children: n });
};
ly.displayName = zf;
var cy = "PopperAnchor", dy = V.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...i } = t, s = uy(cy, n), a = V.useRef(null), o = Gn(e, a), u = V.useRef(null);
    return V.useEffect(() => {
      const l = u.current;
      u.current = (r == null ? void 0 : r.current) || a.current, l !== u.current && s.onAnchorChange(u.current);
    }), r ? null : /* @__PURE__ */ xe(un.div, { ...i, ref: o });
  }
);
dy.displayName = cy;
var qf = "PopperContent", [ID, CD] = ay(qf), fy = V.forwardRef(
  (t, e) => {
    var me, ke, Pe, Oe, bt, qn;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: a = 0,
      arrowPadding: o = 0,
      avoidCollisions: u = !0,
      collisionBoundary: l = [],
      collisionPadding: c = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: m,
      ...p
    } = t, g = uy(qf, n), [E, y] = V.useState(null), T = Gn(e, (Ht) => y(Ht)), [S, v] = V.useState(null), I = PE(S), C = (I == null ? void 0 : I.width) ?? 0, D = (I == null ? void 0 : I.height) ?? 0, _ = r + (s !== "center" ? "-" + s : ""), A = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c }, L = Array.isArray(l) ? l : [l], N = L.length > 0, U = {
      padding: A,
      boundary: L.filter(_D),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: N
    }, { refs: z, floatingStyles: O, placement: F, isPositioned: B, middlewareData: H } = hD({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: _,
      whileElementsMounted: (...Ht) => rD(...Ht, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        pD({ mainAxis: i + D, alignmentAxis: a }),
        u && gD({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? bD() : void 0,
          ...U
        }),
        u && ED({ ...U }),
        yD({
          ...U,
          apply: ({ elements: Ht, rects: dr, availableWidth: hs, availableHeight: we }) => {
            const { width: nt, height: St } = dr.reference, It = Ht.floating.style;
            It.setProperty("--radix-popper-available-width", `${hs}px`), It.setProperty("--radix-popper-available-height", `${we}px`), It.setProperty("--radix-popper-anchor-width", `${nt}px`), It.setProperty("--radix-popper-anchor-height", `${St}px`);
          }
        }),
        S && xD({ element: S, padding: o }),
        RD({ arrowWidth: C, arrowHeight: D }),
        f && TD({ strategy: "referenceHidden", ...U })
      ]
    }), [X, w] = py(F), Q = ji(m);
    Xr(() => {
      B && (Q == null || Q());
    }, [B, Q]);
    const J = (me = H.arrow) == null ? void 0 : me.x, R = (ke = H.arrow) == null ? void 0 : ke.y, te = ((Pe = H.arrow) == null ? void 0 : Pe.centerOffset) !== 0, [he, ae] = V.useState();
    return Xr(() => {
      E && ae(window.getComputedStyle(E).zIndex);
    }, [E]), /* @__PURE__ */ xe(
      "div",
      {
        ref: z.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...O,
          transform: B ? O.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            (Oe = H.transformOrigin) == null ? void 0 : Oe.x,
            (bt = H.transformOrigin) == null ? void 0 : bt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((qn = H.hide) == null ? void 0 : qn.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ xe(
          ID,
          {
            scope: n,
            placedSide: X,
            onArrowChange: v,
            arrowX: J,
            arrowY: R,
            shouldHideArrow: te,
            children: /* @__PURE__ */ xe(
              un.div,
              {
                "data-side": X,
                "data-align": w,
                ...p,
                ref: T,
                style: {
                  ...p.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: B ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
fy.displayName = qf;
var hy = "PopperArrow", LD = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, my = V.forwardRef(function(e, n) {
  const { __scopePopper: r, ...i } = e, s = CD(hy, r), a = LD[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ xe(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [a]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ xe(
          AD,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
my.displayName = hy;
function _D(t) {
  return t !== null;
}
var RD = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var g, E, y;
    const { placement: n, rects: r, middlewareData: i } = e, a = ((g = i.arrow) == null ? void 0 : g.centerOffset) !== 0, o = a ? 0 : t.arrowWidth, u = a ? 0 : t.arrowHeight, [l, c] = py(n), d = { start: "0%", center: "50%", end: "100%" }[c], f = (((E = i.arrow) == null ? void 0 : E.x) ?? 0) + o / 2, h = (((y = i.arrow) == null ? void 0 : y.y) ?? 0) + u / 2;
    let m = "", p = "";
    return l === "bottom" ? (m = a ? d : `${f}px`, p = `${-u}px`) : l === "top" ? (m = a ? d : `${f}px`, p = `${r.floating.height + u}px`) : l === "right" ? (m = `${-u}px`, p = a ? d : `${h}px`) : l === "left" && (m = `${r.floating.width + u}px`, p = a ? d : `${h}px`), { data: { x: m, y: p } };
  }
});
function py(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var kD = ly, gy = dy, wD = fy, DD = my, PD = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, pi = /* @__PURE__ */ new WeakMap(), fo = /* @__PURE__ */ new WeakMap(), ho = {}, Vl = 0, by = function(t) {
  return t && (t.host || by(t.parentNode));
}, OD = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = by(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, ND = function(t, e, n, r) {
  var i = OD(e, Array.isArray(t) ? t : [t]);
  ho[n] || (ho[n] = /* @__PURE__ */ new WeakMap());
  var s = ho[n], a = [], o = /* @__PURE__ */ new Set(), u = new Set(i), l = function(d) {
    !d || o.has(d) || (o.add(d), l(d.parentNode));
  };
  i.forEach(l);
  var c = function(d) {
    !d || u.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (o.has(f))
        c(f);
      else
        try {
          var h = f.getAttribute(r), m = h !== null && h !== "false", p = (pi.get(f) || 0) + 1, g = (s.get(f) || 0) + 1;
          pi.set(f, p), s.set(f, g), a.push(f), p === 1 && m && fo.set(f, !0), g === 1 && f.setAttribute(n, "true"), m || f.setAttribute(r, "true");
        } catch (E) {
          console.error("aria-hidden: cannot operate on ", f, E);
        }
    });
  };
  return c(e), o.clear(), Vl++, function() {
    a.forEach(function(d) {
      var f = pi.get(d) - 1, h = s.get(d) - 1;
      pi.set(d, f), s.set(d, h), f || (fo.has(d) || d.removeAttribute(r), fo.delete(d)), h || d.removeAttribute(n);
    }), Vl--, Vl || (pi = /* @__PURE__ */ new WeakMap(), pi = /* @__PURE__ */ new WeakMap(), fo = /* @__PURE__ */ new WeakMap(), ho = {});
  };
}, MD = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), i = PD(t);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), ND(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Ln = function() {
  return Ln = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Ln.apply(this, arguments);
};
function Ey(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function FD(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, i = e.length, s; r < i; r++)
    (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var $o = "right-scroll-bar-position", Ho = "width-before-scroll-bar", BD = "with-scroll-bars-hidden", UD = "--removed-body-scroll-bar-size";
function zl(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function $D(t, e) {
  var n = sn(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var HD = typeof window < "u" ? V.useLayoutEffect : V.useEffect, Gm = /* @__PURE__ */ new WeakMap();
function GD(t, e) {
  var n = $D(null, function(r) {
    return t.forEach(function(i) {
      return zl(i, r);
    });
  });
  return HD(function() {
    var r = Gm.get(n);
    if (r) {
      var i = new Set(r), s = new Set(t), a = n.current;
      i.forEach(function(o) {
        s.has(o) || zl(o, null);
      }), s.forEach(function(o) {
        i.has(o) || zl(o, a);
      });
    }
    Gm.set(n, t);
  }, [t]), n;
}
function VD(t) {
  return t;
}
function zD(t, e) {
  e === void 0 && (e = VD);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(s) {
      var a = e(s, r);
      return n.push(a), function() {
        n = n.filter(function(o) {
          return o !== a;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(s);
      }
      n = {
        push: function(o) {
          return s(o);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var a = [];
      if (n.length) {
        var o = n;
        n = [], o.forEach(s), a = n;
      }
      var u = function() {
        var c = a;
        a = [], c.forEach(s);
      }, l = function() {
        return Promise.resolve().then(u);
      };
      l(), n = {
        push: function(c) {
          a.push(c), l();
        },
        filter: function(c) {
          return a = a.filter(c), n;
        }
      };
    }
  };
  return i;
}
function qD(t) {
  t === void 0 && (t = {});
  var e = zD(null);
  return e.options = Ln({ async: !0, ssr: !1 }, t), e;
}
var yy = function(t) {
  var e = t.sideCar, n = Ey(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return V.createElement(r, Ln({}, n));
};
yy.isSideCarExport = !0;
function jD(t, e) {
  return t.useMedium(e), yy;
}
var Ty = qD(), ql = function() {
}, ju = V.forwardRef(function(t, e) {
  var n = V.useRef(null), r = V.useState({
    onScrollCapture: ql,
    onWheelCapture: ql,
    onTouchMoveCapture: ql
  }), i = r[0], s = r[1], a = t.forwardProps, o = t.children, u = t.className, l = t.removeScrollBar, c = t.enabled, d = t.shards, f = t.sideCar, h = t.noRelative, m = t.noIsolation, p = t.inert, g = t.allowPinchZoom, E = t.as, y = E === void 0 ? "div" : E, T = t.gapMode, S = Ey(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), v = f, I = GD([n, e]), C = Ln(Ln({}, S), i);
  return V.createElement(
    V.Fragment,
    null,
    c && V.createElement(v, { sideCar: Ty, removeScrollBar: l, shards: d, noRelative: h, noIsolation: m, inert: p, setCallbacks: s, allowPinchZoom: !!g, lockRef: n, gapMode: T }),
    a ? V.cloneElement(V.Children.only(o), Ln(Ln({}, C), { ref: I })) : V.createElement(y, Ln({}, C, { className: u, ref: I }), o)
  );
});
ju.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
ju.classNames = {
  fullWidth: Ho,
  zeroRight: $o
};
var KD = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function WD() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = KD();
  return e && t.setAttribute("nonce", e), t;
}
function YD(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function XD(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var QD = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = WD()) && (YD(e, n), XD(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, ZD = function() {
  var t = QD();
  return function(e, n) {
    V.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, xy = function() {
  var t = ZD(), e = function(n) {
    var r = n.styles, i = n.dynamic;
    return t(r, i), null;
  };
  return e;
}, JD = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, jl = function(t) {
  return parseInt(t || "", 10) || 0;
}, e6 = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], i = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [jl(n), jl(r), jl(i)];
}, t6 = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return JD;
  var e = e6(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, n6 = xy(), Di = "data-scroll-locked", r6 = function(t, e, n, r) {
  var i = t.left, s = t.top, a = t.right, o = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(BD, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(o, "px ").concat(r, `;
  }
  body[`).concat(Di, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(o, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(o, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat($o, ` {
    right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat(Ho, ` {
    margin-right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat($o, " .").concat($o, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Ho, " .").concat(Ho, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Di, `] {
    `).concat(UD, ": ").concat(o, `px;
  }
`);
}, Vm = function() {
  var t = parseInt(document.body.getAttribute(Di) || "0", 10);
  return isFinite(t) ? t : 0;
}, i6 = function() {
  V.useEffect(function() {
    return document.body.setAttribute(Di, (Vm() + 1).toString()), function() {
      var t = Vm() - 1;
      t <= 0 ? document.body.removeAttribute(Di) : document.body.setAttribute(Di, t.toString());
    };
  }, []);
}, s6 = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, i = r === void 0 ? "margin" : r;
  i6();
  var s = V.useMemo(function() {
    return t6(i);
  }, [i]);
  return V.createElement(n6, { styles: r6(s, !e, i, n ? "" : "!important") });
}, ad = !1;
if (typeof window < "u")
  try {
    var mo = Object.defineProperty({}, "passive", {
      get: function() {
        return ad = !0, !0;
      }
    });
    window.addEventListener("test", mo, mo), window.removeEventListener("test", mo, mo);
  } catch {
    ad = !1;
  }
var gi = ad ? { passive: !1 } : !1, a6 = function(t) {
  return t.tagName === "TEXTAREA";
}, Sy = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !a6(t) && n[e] === "visible")
  );
}, o6 = function(t) {
  return Sy(t, "overflowY");
}, u6 = function(t) {
  return Sy(t, "overflowX");
}, zm = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = Ay(t, r);
    if (i) {
      var s = vy(t, r), a = s[1], o = s[2];
      if (a > o)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, l6 = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, c6 = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, Ay = function(t, e) {
  return t === "v" ? o6(e) : u6(e);
}, vy = function(t, e) {
  return t === "v" ? l6(e) : c6(e);
}, d6 = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, f6 = function(t, e, n, r, i) {
  var s = d6(t, window.getComputedStyle(e).direction), a = s * r, o = n.target, u = e.contains(o), l = !1, c = a > 0, d = 0, f = 0;
  do {
    if (!o)
      break;
    var h = vy(t, o), m = h[0], p = h[1], g = h[2], E = p - g - s * m;
    (m || E) && Ay(t, o) && (d += E, f += m);
    var y = o.parentNode;
    o = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
  } while (
    // portaled content
    !u && o !== document.body || // self content
    u && (e.contains(o) || e === o)
  );
  return (c && Math.abs(d) < 1 || !c && Math.abs(f) < 1) && (l = !0), l;
}, po = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, qm = function(t) {
  return [t.deltaX, t.deltaY];
}, jm = function(t) {
  return t && "current" in t ? t.current : t;
}, h6 = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, m6 = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, p6 = 0, bi = [];
function g6(t) {
  var e = V.useRef([]), n = V.useRef([0, 0]), r = V.useRef(), i = V.useState(p6++)[0], s = V.useState(xy)[0], a = V.useRef(t);
  V.useEffect(function() {
    a.current = t;
  }, [t]), V.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var p = FD([t.lockRef.current], (t.shards || []).map(jm), !0).filter(Boolean);
      return p.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), p.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var o = V.useCallback(function(p, g) {
    if ("touches" in p && p.touches.length === 2 || p.type === "wheel" && p.ctrlKey)
      return !a.current.allowPinchZoom;
    var E = po(p), y = n.current, T = "deltaX" in p ? p.deltaX : y[0] - E[0], S = "deltaY" in p ? p.deltaY : y[1] - E[1], v, I = p.target, C = Math.abs(T) > Math.abs(S) ? "h" : "v";
    if ("touches" in p && C === "h" && I.type === "range")
      return !1;
    var D = zm(C, I);
    if (!D)
      return !0;
    if (D ? v = C : (v = C === "v" ? "h" : "v", D = zm(C, I)), !D)
      return !1;
    if (!r.current && "changedTouches" in p && (T || S) && (r.current = v), !v)
      return !0;
    var _ = r.current || v;
    return f6(_, g, p, _ === "h" ? T : S);
  }, []), u = V.useCallback(function(p) {
    var g = p;
    if (!(!bi.length || bi[bi.length - 1] !== s)) {
      var E = "deltaY" in g ? qm(g) : po(g), y = e.current.filter(function(v) {
        return v.name === g.type && (v.target === g.target || g.target === v.shadowParent) && h6(v.delta, E);
      })[0];
      if (y && y.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!y) {
        var T = (a.current.shards || []).map(jm).filter(Boolean).filter(function(v) {
          return v.contains(g.target);
        }), S = T.length > 0 ? o(g, T[0]) : !a.current.noIsolation;
        S && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = V.useCallback(function(p, g, E, y) {
    var T = { name: p, delta: g, target: E, should: y, shadowParent: b6(E) };
    e.current.push(T), setTimeout(function() {
      e.current = e.current.filter(function(S) {
        return S !== T;
      });
    }, 1);
  }, []), c = V.useCallback(function(p) {
    n.current = po(p), r.current = void 0;
  }, []), d = V.useCallback(function(p) {
    l(p.type, qm(p), p.target, o(p, t.lockRef.current));
  }, []), f = V.useCallback(function(p) {
    l(p.type, po(p), p.target, o(p, t.lockRef.current));
  }, []);
  V.useEffect(function() {
    return bi.push(s), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", u, gi), document.addEventListener("touchmove", u, gi), document.addEventListener("touchstart", c, gi), function() {
      bi = bi.filter(function(p) {
        return p !== s;
      }), document.removeEventListener("wheel", u, gi), document.removeEventListener("touchmove", u, gi), document.removeEventListener("touchstart", c, gi);
    };
  }, []);
  var h = t.removeScrollBar, m = t.inert;
  return V.createElement(
    V.Fragment,
    null,
    m ? V.createElement(s, { styles: m6(i) }) : null,
    h ? V.createElement(s6, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function b6(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const E6 = jD(Ty, g6);
var Iy = V.forwardRef(function(t, e) {
  return V.createElement(ju, Ln({}, t, { ref: e, sideCar: E6 }));
});
Iy.classNames = ju.classNames;
var Ku = "Popover", [Cy] = Nf(Ku, [
  oy
]), Ia = oy(), [y6, ei] = Cy(Ku), Ly = (t) => {
  const {
    __scopePopover: e,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: a = !1
  } = t, o = Ia(e), u = V.useRef(null), [l, c] = V.useState(!1), [d, f] = DE({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Ku
  });
  return /* @__PURE__ */ xe(kD, { ...o, children: /* @__PURE__ */ xe(
    y6,
    {
      scope: e,
      contentId: dw(),
      triggerRef: u,
      open: d,
      onOpenChange: f,
      onOpenToggle: V.useCallback(() => f((h) => !h), [f]),
      hasCustomAnchor: l,
      onCustomAnchorAdd: V.useCallback(() => c(!0), []),
      onCustomAnchorRemove: V.useCallback(() => c(!1), []),
      modal: a,
      children: n
    }
  ) });
};
Ly.displayName = Ku;
var _y = "PopoverAnchor", T6 = V.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = ei(_y, n), s = Ia(n), { onCustomAnchorAdd: a, onCustomAnchorRemove: o } = i;
    return V.useEffect(() => (a(), () => o()), [a, o]), /* @__PURE__ */ xe(gy, { ...s, ...r, ref: e });
  }
);
T6.displayName = _y;
var Ry = "PopoverTrigger", ky = V.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = ei(Ry, n), s = Ia(n), a = Gn(e, i.triggerRef), o = /* @__PURE__ */ xe(
      un.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": My(i.open),
        ...r,
        ref: a,
        onClick: Pn(t.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? o : /* @__PURE__ */ xe(gy, { asChild: !0, ...s, children: o });
  }
);
ky.displayName = Ry;
var x6 = "PopoverPortal", [xq, S6] = Cy(x6, {
  forceMount: void 0
}), Wi = "PopoverContent", wy = V.forwardRef(
  (t, e) => {
    const n = S6(Wi, t.__scopePopover), { forceMount: r = n.forceMount, ...i } = t, s = ei(Wi, t.__scopePopover);
    return /* @__PURE__ */ xe(Mf, { present: r || s.open, children: s.modal ? /* @__PURE__ */ xe(v6, { ...i, ref: e }) : /* @__PURE__ */ xe(I6, { ...i, ref: e }) });
  }
);
wy.displayName = Wi;
var A6 = /* @__PURE__ */ OE("PopoverContent.RemoveScroll"), v6 = V.forwardRef(
  (t, e) => {
    const n = ei(Wi, t.__scopePopover), r = V.useRef(null), i = Gn(e, r), s = V.useRef(!1);
    return V.useEffect(() => {
      const a = r.current;
      if (a) return MD(a);
    }, []), /* @__PURE__ */ xe(Iy, { as: A6, allowPinchZoom: !0, children: /* @__PURE__ */ xe(
      Dy,
      {
        ...t,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Pn(t.onCloseAutoFocus, (a) => {
          var o;
          a.preventDefault(), s.current || (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Pn(
          t.onPointerDownOutside,
          (a) => {
            const o = a.detail.originalEvent, u = o.button === 0 && o.ctrlKey === !0, l = o.button === 2 || u;
            s.current = l;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Pn(
          t.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), I6 = V.forwardRef(
  (t, e) => {
    const n = ei(Wi, t.__scopePopover), r = V.useRef(!1), i = V.useRef(!1);
    return /* @__PURE__ */ xe(
      Dy,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var a, o;
          (a = t.onCloseAutoFocus) == null || a.call(t, s), s.defaultPrevented || (r.current || (o = n.triggerRef.current) == null || o.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var u, l;
          (u = t.onInteractOutside) == null || u.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const a = s.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(a)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), Dy = V.forwardRef(
  (t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEscapeKeyDown: o,
      onPointerDownOutside: u,
      onFocusOutside: l,
      onInteractOutside: c,
      ...d
    } = t, f = ei(Wi, n), h = Ia(n);
    return tw(), /* @__PURE__ */ xe(
      jE,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ xe(
          zE,
          {
            asChild: !0,
            disableOutsidePointerEvents: a,
            onInteractOutside: c,
            onEscapeKeyDown: o,
            onPointerDownOutside: u,
            onFocusOutside: l,
            onDismiss: () => f.onOpenChange(!1),
            children: /* @__PURE__ */ xe(
              wD,
              {
                "data-state": My(f.open),
                role: "dialog",
                id: f.contentId,
                ...h,
                ...d,
                ref: e,
                style: {
                  ...d.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), Py = "PopoverClose", Oy = V.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = ei(Py, n);
    return /* @__PURE__ */ xe(
      un.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Pn(t.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
Oy.displayName = Py;
var C6 = "PopoverArrow", Ny = V.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = Ia(n);
    return /* @__PURE__ */ xe(DD, { ...i, ...r, ref: e });
  }
);
Ny.displayName = C6;
function My(t) {
  return t ? "open" : "closed";
}
var L6 = Ly, _6 = ky, R6 = wy, k6 = Oy, w6 = Ny;
const D6 = Z1({
  "0%": { opacity: 0, transform: "translateY(1rem)" },
  "100%": { opacity: 1, transform: "translateY(0)" }
}), P6 = Z1({
  "0%": { opacity: 0, transform: "translateY(1rem)" },
  "100%": { opacity: 1, transform: "translateY(0)" }
}), Fy = fe(w6, {
  fill: "$secondaryAlt"
}), O6 = fe(k6, {
  position: "absolute",
  right: "0",
  top: "0",
  padding: "0.5rem",
  margin: "0",
  cursor: "pointer",
  border: "none",
  background: "none",
  fill: "inherit",
  "&:hover": {
    opacity: "0.75"
  }
}), By = fe(R6, {
  border: "none",
  backgroundColor: "white",
  fill: "inhrerit",
  padding: "1rem 2rem 1rem 1rem",
  width: "auto",
  minWidth: "200px",
  maxWidth: "350px",
  borderRadius: "3px",
  boxShadow: "5px 5px 13px #0002",
  /**
   * Animate toggle
   */
  animationDuration: "0.3s",
  animationTimingFunction: "cubic-bezier(0.16, 1, 0.3, 1)",
  '&[data-side="top"]': { animationName: P6 },
  '&[data-side="bottom"]': { animationName: D6 },
  /**
   *
   */
  '&[data-align="end"]': {
    [`& ${Fy}`]: {
      margin: "0 0.7rem"
    }
  }
}), Uy = fe(_6, {
  display: "inline-flex",
  padding: "0.5rem 0",
  margin: "0 0.5rem 0 0",
  cursor: "pointer",
  border: "none",
  background: "none",
  "> button, > span": {
    margin: "0"
  }
}), N6 = fe(L6, {
  boxSizing: "content-box"
}), M6 = fe("div", {
  width: "2rem",
  height: "2rem",
  [`${Uy}`]: {
    background: "$primary",
    width: "inherit",
    height: "inherit",
    display: "flex",
    justifyContent: "center",
    borderRadius: "2rem",
    padding: "0",
    justifyItems: "center",
    flexDirection: "column",
    alignItems: "center",
    "&:hover": {
      background: "$accent"
    },
    svg: {
      fill: "$secondary"
    }
  },
  [`${By}`]: {
    "> label": {
      fontSize: "0.8333rem",
      display: "flex",
      marginBottom: "0.5rem"
    }
  }
}), $y = fe("div", {
  width: "1rem",
  height: "1rem",
  borderRadius: "3px",
  backgroundColor: "$secondaryMuted",
  border: "1px solid $secondaryAlt",
  display: "inline-flex",
  fontSize: "0.7222rem",
  alignContent: "center",
  justifyContent: "center",
  textAlign: "center",
  flexDirection: "column"
}), F6 = fe(UE, {
  marginTop: "-1px"
}), B6 = fe(FE, {
  display: "flex",
  alignContent: "center",
  alignItems: "center",
  gap: "0.5rem",
  backgroundColor: "transparent",
  border: "none",
  fontFamily: "inherit",
  fontSize: "1rem",
  marginTop: "0.25rem",
  "&[data-state='checked']": {
    [`${$y}`]: {
      backgroundColor: "$accent",
      borderColor: "$accent",
      color: "$secondary"
    }
  }
}), U6 = ({
  lang: t,
  isChecked: e
}) => {
  var c;
  const { state: n, dispatch: r } = $n(gn), { activeLanguages: i, options: s } = n, { language: a } = s, u = (((c = a == null ? void 0 : a.options) == null ? void 0 : c.find((d) => Object.keys(d)[0] === t)) || t)[t] || t, l = (d) => {
    const f = d && i !== void 0 ? [...i, t] : i == null ? void 0 : i.filter((h) => h !== t);
    r({
      type: "updateActiveLanguages",
      payload: f
    });
  };
  return /* @__PURE__ */ $.createElement(
    B6,
    {
      checked: e,
      onCheckedChange: l
    },
    /* @__PURE__ */ $.createElement($y, null, /* @__PURE__ */ $.createElement(F6, null, "âœ“")),
    u
  );
}, $6 = () => /* @__PURE__ */ $.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M256 112v288M400 256H112"
  }
), H6 = () => /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement("path", { d: "M232 416a23.88 23.88 0 01-14.2-4.68 8.27 8.27 0 01-.66-.51L125.76 336H56a24 24 0 01-24-24V200a24 24 0 0124-24h69.75l91.37-74.81a8.27 8.27 0 01.66-.51A24 24 0 01256 120v272a24 24 0 01-24 24zm-106.18-80zm-.27-159.86zM320 336a16 16 0 01-14.29-23.19c9.49-18.87 14.3-38 14.3-56.81 0-19.38-4.66-37.94-14.25-56.73a16 16 0 0128.5-14.54C346.19 208.12 352 231.44 352 256c0 23.86-6 47.81-17.7 71.19A16 16 0 01320 336z" }), /* @__PURE__ */ $.createElement("path", { d: "M368 384a16 16 0 01-13.86-24C373.05 327.09 384 299.51 384 256c0-44.17-10.93-71.56-29.82-103.94a16 16 0 0127.64-16.12C402.92 172.11 416 204.81 416 256c0 50.43-13.06 83.29-34.13 120a16 16 0 01-13.87 8z" }), /* @__PURE__ */ $.createElement("path", { d: "M416 432a16 16 0 01-13.39-24.74C429.85 365.47 448 323.76 448 256c0-66.5-18.18-108.62-45.49-151.39a16 16 0 1127-17.22C459.81 134.89 480 181.74 480 256c0 64.75-14.66 113.63-50.6 168.74A16 16 0 01416 432z" })), G6 = () => /* @__PURE__ */ $.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" }), V6 = () => /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
  "path",
  {
    d: "M336 176h40a40 40 0 0140 40v208a40 40 0 01-40 40H136a40 40 0 01-40-40V216a40 40 0 0140-40h40",
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32"
  }
), /* @__PURE__ */ $.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M176 272l80 80 80-80M256 48v288"
  }
)), z6 = () => /* @__PURE__ */ $.createElement("path", { d: "M416 64H96a64.07 64.07 0 00-64 64v256a64.07 64.07 0 0064 64h320a64.07 64.07 0 0064-64V128a64.07 64.07 0 00-64-64zm-80 64a48 48 0 11-48 48 48.05 48.05 0 0148-48zM96 416a32 32 0 01-32-32v-67.63l94.84-84.3a48.06 48.06 0 0165.8 1.9l64.95 64.81L172.37 416zm352-32a32 32 0 01-32 32H217.63l121.42-121.42a47.72 47.72 0 0161.64-.16L448 333.84z" }), q6 = () => /* @__PURE__ */ $.createElement("path", { d: "M464 384.39a32 32 0 01-13-2.77 15.77 15.77 0 01-2.71-1.54l-82.71-58.22A32 32 0 01352 295.7v-79.4a32 32 0 0113.58-26.16l82.71-58.22a15.77 15.77 0 012.71-1.54 32 32 0 0145 29.24v192.76a32 32 0 01-32 32zM268 400H84a68.07 68.07 0 01-68-68V180a68.07 68.07 0 0168-68h184.48A67.6 67.6 0 01336 179.52V332a68.07 68.07 0 01-68 68z" }), Hy = fe("svg", {
  display: "inline-flex",
  variants: {
    isLarge: {
      true: {
        height: "4rem",
        width: "4rem"
      }
    },
    isMedium: {
      true: {
        height: "2rem",
        width: "2rem"
      }
    },
    isSmall: {
      true: {
        height: "1rem",
        width: "1rem"
      }
    }
  }
}), j6 = ({ children: t }) => /* @__PURE__ */ $.createElement("title", null, t), or = (t) => /* @__PURE__ */ $.createElement(
  Hy,
  {
    ...t,
    "data-testid": "icon-svg",
    role: "img",
    viewBox: "0 0 512 512",
    xmlns: "http://www.w3.org/2000/svg"
  },
  t.children
);
or.Title = j6;
or.Add = $6;
or.Audio = H6;
or.Close = G6;
or.Download = V6;
or.Image = z6;
or.Video = q6;
const K6 = (t) => /* @__PURE__ */ $.createElement(Uy, { ...t }, t.children), W6 = (t) => /* @__PURE__ */ $.createElement(By, { ...t, sideOffset: 5, collisionPadding: 21 }, /* @__PURE__ */ $.createElement(Fy, null), /* @__PURE__ */ $.createElement(O6, null, /* @__PURE__ */ $.createElement(or, { isSmall: !0 }, /* @__PURE__ */ $.createElement(or.Close, null))), t.children), Bs = ({ children: t }) => /* @__PURE__ */ $.createElement(N6, null, t);
Bs.Trigger = K6;
Bs.Content = W6;
fe("div", {
  // Reset
  boxSizing: "border-box",
  // Custom
  display: "inline-flex",
  alignItems: "center",
  borderRadius: "2px",
  padding: "$1",
  marginBottom: "$2",
  marginRight: "$2",
  backgroundColor: "$lightGrey",
  color: "$richBlack50",
  textTransform: "uppercase",
  fontSize: "$2",
  objectFit: "contain",
  lineHeight: "1em !important",
  "&:last-child": {
    marginRight: "0"
  },
  [`${Hy}`]: {
    position: "absolute",
    left: "$1",
    height: "$3",
    width: "$3"
  },
  variants: {
    isIcon: {
      true: { position: "relative", paddingLeft: "$5" }
    }
  }
});
const Y6 = (t) => {
  var r;
  if (!t) return "LTR";
  const e = [
    "ar",
    "fa",
    "ur",
    "ps",
    "dv",
    "sd",
    "ug",
    "ku",
    "he",
    "yi",
    "jrb",
    "jpr",
    "nqo"
  ], n = Array.isArray(t) ? (r = t[0]) == null ? void 0 : r.split("-")[0] : t == null ? void 0 : t.split("-")[0];
  return e.includes(n) ? "RTL" : "LTR";
}, X6 = (t) => {
  var n, r, i, s, a;
  let e = {
    id: typeof t == "string" ? t : t.source
  };
  if (typeof t == "string") {
    if (t.includes("#xywh=")) {
      const o = t.split("#xywh=");
      if (o && o[1]) {
        const [u, l, c, d] = o[1].split(",").map((f) => Number(f));
        e = {
          id: o[0],
          rect: {
            x: u,
            y: l,
            w: c,
            h: d
          }
        };
      }
    } else if (t.includes("#t=")) {
      const o = t.split("#t=");
      o && o[1] && (e = {
        id: o[0],
        t: o[1]
      });
    }
  } else if (typeof t == "object") {
    if (((n = t.selector) == null ? void 0 : n.type) === "PointSelector")
      e = {
        id: t.source,
        point: {
          x: t.selector.x,
          y: t.selector.y
        }
      };
    else if (((r = t.selector) == null ? void 0 : r.type) === "SvgSelector")
      e = {
        id: t.source,
        svg: t.selector.value
      };
    else if (((i = t.selector) == null ? void 0 : i.type) === "FragmentSelector" && (s = t.selector) != null && s.value.includes("xywh=") && t.source.type == "Canvas" && t.source.id) {
      const o = (a = t.selector) == null ? void 0 : a.value.split("xywh=");
      if (o && o[1]) {
        const [u, l, c, d] = o[1].split(",").map((f) => Number(f));
        e = {
          id: t.source.id,
          rect: {
            x: u,
            y: l,
            w: c,
            h: d
          }
        };
      }
    }
  }
  return e;
};
function Q6(t) {
  return t ? Array.isArray(t) ? t : [t] : [];
}
function Z6(t, e) {
  if (!t) return !1;
  if (!e) return !0;
  if (e.length === 0) return !1;
  const n = Q6(t.motivation);
  return n.length === 0 ? !1 : n.some(
    (r) => e.includes(r)
  );
}
function J6(t, e) {
  return !t || t.length === 0 ? [] : e ? e.length === 0 ? [] : t.filter(
    (n) => Z6(n, e)
  ) : t.filter(Boolean);
}
function Gy(t) {
  const e = /* @__PURE__ */ new Set();
  function n(r) {
    Array.isArray(r) ? r.forEach(n) : r && typeof r == "object" && (r.language && e.add(r.language), Object.values(r).forEach(n));
  }
  return n(t), Array.from(e);
}
const eP = ({
  title: t,
  style: e = {}
}) => /* @__PURE__ */ $.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", style: e }, /* @__PURE__ */ $.createElement("title", null, t), /* @__PURE__ */ $.createElement("path", { d: "m455.77,49.65c-.53-.94-1.53-1.52-2.61-1.52h-1.46c-.9,0-1.76.41-2.33,1.11-7.48,9.2-14.92,20.42-22.14,33.34-.49.87-.51,1.93-.05,2.82,14.51,28.46,28.67,57.32,28.8,70.41-.1.12-.38.35-.96.57-.05.02-.1.04-.15.06-11.86,5.21-25.25,8.74-37.93,11.77-35.75,8.37-68.11,12.45-98.93,12.45-37.86,0-69.49-6.59-91.47-19.05-24.29-13.77-36.6-34.28-36.6-60.96,0-12.24,2.79-26.82,8.29-43.33.49-1.48-.23-3.1-1.67-3.71l-11.65-4.95c-1.43-.61-3.09-.02-3.82,1.35-11.8,22.23-17.54,45.74-17.54,71.9,0,35.09,14.3,62.03,42.49,80.08,24.82,15.89,60.52,24.29,103.24,24.29,57.18,0,132.5-18.87,159.14-35.1.42-.25.77-.61,1.02-1.03,8.99-15.08,15.86-28.36,15.86-50.18,0-35.58-22.59-78.13-29.52-90.32Z" }), /* @__PURE__ */ $.createElement("path", { d: "m321.24,273.28c-1.26-.92-3.01-.72-4.03.45-8.38,9.62-16.7,20.51-23.73,29.88-.95,1.27-.75,3.06.46,4.09,2.19,1.86,4.38,3.71,6.55,5.54,9.53,8.05,18.54,15.66,27.7,24.35.58.55,1.32.82,2.06.82.69,0,1.38-.24,1.95-.72,9.71-8.28,17.81-17.85,24.79-29.26.71-1.16.55-2.65-.39-3.63-11.73-12.33-23.62-22.94-35.36-31.52Z" }), /* @__PURE__ */ $.createElement("path", { d: "m256.38,433.6l-90-218c-4.64-11.23-17.5-16.58-28.73-11.94-5.41,2.23-9.71,6.53-11.94,11.94l-90,218c-4.69,11.21.59,24.1,11.8,28.79,11.21,4.69,24.1-.59,28.79-11.8.03-.07.06-.14.08-.2l18.33-44.39h102.67l18.33,44.39c3.4,8.24,11.43,13.61,20.34,13.61,12.15,0,21.99-9.86,21.99-22.01,0-2.88-.57-5.73-1.67-8.39h0Zm-143.5-71.6l33.17-80.35,33.17,80.35h-66.34Z" })), tP = () => {
  const { state: t } = $n(gn), { activeLanguages: e, annotations: n } = t, r = n ? Gy(n) : [];
  return /* @__PURE__ */ $.createElement(M6, null, /* @__PURE__ */ $.createElement(Bs, null, /* @__PURE__ */ $.createElement(Bs.Trigger, null, /* @__PURE__ */ $.createElement(
    eP,
    {
      title: "language",
      style: { width: "18px", height: "18px" }
    }
  )), /* @__PURE__ */ $.createElement(Bs.Content, null, /* @__PURE__ */ $.createElement("label", null, "Language"), r.map((i) => /* @__PURE__ */ $.createElement(
    U6,
    {
      isChecked: e == null ? void 0 : e.includes(i),
      key: i,
      lang: i
    }
  )))));
};
var tt;
function Go(t) {
  return typeof t < "u" ? t : !0;
}
function Km(t) {
  const e = Array(t);
  for (let n = 0; n < t; n++) e[n] = Qe();
  return e;
}
function Qe() {
  return /* @__PURE__ */ Object.create(null);
}
function nP(t, e) {
  return e.length - t.length;
}
function At(t) {
  return typeof t == "string";
}
function _r(t) {
  return typeof t == "object";
}
function jf(t) {
  return typeof t == "function";
}
function Vy(t, e) {
  var n = rP;
  if (t && (e && (t = Vo(t, e)), this.H && (t = Vo(t, this.H)), this.J && 1 < t.length && (t = Vo(t, this.J)), n || n === "")) {
    if (e = t.split(n), this.filter) {
      t = this.filter, n = e.length;
      const r = [];
      for (let i = 0, s = 0; i < n; i++) {
        const a = e[i];
        a && !t[a] && (r[s++] = a);
      }
      t = r;
    } else t = e;
    return t;
  }
  return t;
}
const rP = /[\p{Z}\p{S}\p{P}\p{C}]+/u, iP = /[\u0300-\u036f]/g;
function Wm(t, e) {
  const n = Object.keys(t), r = n.length, i = [];
  let s = "", a = 0;
  for (let o = 0, u, l; o < r; o++) u = n[o], (l = t[u]) ? (i[a++] = rt(e ? "(?!\\b)" + u + "(\\b|_)" : u), i[a++] = l) : s += (s ? "|" : "") + u;
  return s && (i[a++] = rt(e ? "(?!\\b)(" + s + ")(\\b|_)" : "(" + s + ")"), i[a] = ""), i;
}
function Vo(t, e) {
  for (let n = 0, r = e.length; n < r && (t = t.replace(e[n], e[n + 1]), t); n += 2) ;
  return t;
}
function rt(t) {
  return new RegExp(t, "g");
}
function zy(t) {
  let e = "", n = "";
  for (let r = 0, i = t.length, s; r < i; r++) (s = t[r]) !== n && (e += n = s);
  return e;
}
var sP = { encode: qy, F: !1, G: "" };
function qy(t) {
  return Vy.call(this, ("" + t).toLowerCase(), !1);
}
const aP = {}, is = {};
function jy(t) {
  Ts(t, "add"), Ts(t, "append"), Ts(t, "search"), Ts(t, "update"), Ts(t, "remove");
}
function Ts(t, e) {
  t[e + "Async"] = function() {
    const n = this, r = arguments;
    var i = r[r.length - 1];
    let s;
    return jf(i) && (s = i, delete r[r.length - 1]), i = new Promise(function(a) {
      setTimeout(function() {
        n.async = !0;
        const o = n[e].apply(n, r);
        n.async = !1, a(o);
      });
    }), s ? (i.then(s), this) : i;
  };
}
function Ky(t, e, n, r) {
  const i = t.length;
  let s = [], a, o, u = 0;
  r && (r = []);
  for (let l = i - 1; 0 <= l; l--) {
    const c = t[l], d = c.length, f = Qe();
    let h = !a;
    for (let m = 0; m < d; m++) {
      const p = c[m], g = p.length;
      if (g) for (let E = 0, y, T; E < g; E++) if (T = p[E], a) {
        if (a[T]) {
          if (!l) {
            if (n) n--;
            else if (s[u++] = T, u === e) return s;
          }
          (l || r) && (f[T] = 1), h = !0;
        }
        if (r && (y = (o[T] || 0) + 1, o[T] = y, y < i)) {
          const S = r[y - 2] || (r[y - 2] = []);
          S[S.length] = T;
        }
      } else f[T] = 1;
    }
    if (r) a || (o = f);
    else if (!h) return [];
    a = f;
  }
  if (r) for (let l = r.length - 1, c, d; 0 <= l; l--) {
    c = r[l], d = c.length;
    for (let f = 0, h; f < d; f++) if (h = c[f], !a[h]) {
      if (n) n--;
      else if (s[u++] = h, u === e) return s;
      a[h] = 1;
    }
  }
  return s;
}
function oP(t, e) {
  const n = Qe(), r = Qe(), i = [];
  for (let s = 0; s < t.length; s++) n[t[s]] = 1;
  for (let s = 0, a; s < e.length; s++) {
    a = e[s];
    for (let o = 0, u; o < a.length; o++) u = a[o], n[u] && !r[u] && (r[u] = 1, i[i.length] = u);
  }
  return i;
}
function Wu(t) {
  this.l = t !== !0 && t, this.cache = Qe(), this.h = [];
}
function Wy(t, e, n) {
  _r(t) && (t = t.query);
  let r = this.cache.get(t);
  return r || (r = this.search(t, e, n), this.cache.set(t, r)), r;
}
Wu.prototype.set = function(t, e) {
  if (!this.cache[t]) {
    var n = this.h.length;
    for (n === this.l ? delete this.cache[this.h[n - 1]] : n++, --n; 0 < n; n--) this.h[n] = this.h[n - 1];
    this.h[0] = t;
  }
  this.cache[t] = e;
};
Wu.prototype.get = function(t) {
  const e = this.cache[t];
  if (this.l && e && (t = this.h.indexOf(t))) {
    const n = this.h[t - 1];
    this.h[t - 1] = this.h[t], this.h[t] = n;
  }
  return e;
};
const uP = { memory: { charset: "latin:extra", D: 3, B: 4, m: !1 }, performance: { D: 3, B: 3, s: !1, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, default: {} };
function Yy(t, e, n, r, i, s, a, o) {
  setTimeout(function() {
    const u = t(n ? n + "." + r : r, JSON.stringify(a));
    u && u.then ? u.then(function() {
      e.export(t, e, n, i, s + 1, o);
    }) : e.export(t, e, n, i, s + 1, o);
  });
}
function Yi(t, e) {
  if (!(this instanceof Yi)) return new Yi(t);
  var n;
  if (t) {
    At(t) ? t = uP[t] : (n = t.preset) && (t = Object.assign({}, n[n], t)), n = t.charset;
    var r = t.lang;
    At(n) && (n.indexOf(":") === -1 && (n += ":default"), n = is[n]), At(r) && (r = aP[r]);
  } else t = {};
  let i, s, a = t.context || {};
  if (this.encode = t.encode || n && n.encode || qy, this.register = e || Qe(), this.D = i = t.resolution || 9, this.G = e = n && n.G || t.tokenize || "strict", this.depth = e === "strict" && a.depth, this.l = Go(a.bidirectional), this.s = s = Go(t.optimize), this.m = Go(t.fastupdate), this.B = t.minlength || 1, this.C = t.boost, this.map = s ? Km(i) : Qe(), this.A = i = a.resolution || 1, this.h = s ? Km(i) : Qe(), this.F = n && n.F || t.rtl, this.H = (e = t.matcher || r && r.H) && Wm(e, !1), this.J = (e = t.stemmer || r && r.J) && Wm(e, !0), n = e = t.filter || r && r.filter) {
    n = e, r = Qe();
    for (let o = 0, u = n.length; o < u; o++) r[n[o]] = 1;
    n = r;
  }
  this.filter = n, this.cache = (e = t.cache) && new Wu(e);
}
tt = Yi.prototype;
tt.append = function(t, e) {
  return this.add(t, e, !0);
};
tt.add = function(t, e, n, r) {
  if (e && (t || t === 0)) {
    if (!r && !n && this.register[t]) return this.update(t, e);
    if (e = this.encode(e), r = e.length) {
      const l = Qe(), c = Qe(), d = this.depth, f = this.D;
      for (let h = 0; h < r; h++) {
        let m = e[this.F ? r - 1 - h : h];
        var i = m.length;
        if (m && i >= this.B && (d || !c[m])) {
          var s = go(f, r, h), a = "";
          switch (this.G) {
            case "full":
              if (2 < i) {
                for (s = 0; s < i; s++) for (var o = i; o > s; o--) if (o - s >= this.B) {
                  var u = go(f, r, h, i, s);
                  a = m.substring(s, o), xs(this, c, a, u, t, n);
                }
                break;
              }
            case "reverse":
              if (1 < i) {
                for (o = i - 1; 0 < o; o--) a = m[o] + a, a.length >= this.B && xs(
                  this,
                  c,
                  a,
                  go(f, r, h, i, o),
                  t,
                  n
                );
                a = "";
              }
            case "forward":
              if (1 < i) {
                for (o = 0; o < i; o++) a += m[o], a.length >= this.B && xs(this, c, a, s, t, n);
                break;
              }
            default:
              if (this.C && (s = Math.min(s / this.C(e, m, h) | 0, f - 1)), xs(this, c, m, s, t, n), d && 1 < r && h < r - 1) {
                for (i = Qe(), a = this.A, s = m, o = Math.min(d + 1, r - h), i[s] = 1, u = 1; u < o; u++) if ((m = e[this.F ? r - 1 - h - u : h + u]) && m.length >= this.B && !i[m]) {
                  i[m] = 1;
                  const p = this.l && m > s;
                  xs(this, l, p ? s : m, go(a + (r / 2 > a ? 0 : 1), r, h, o - 1, u - 1), t, n, p ? m : s);
                }
              }
          }
        }
      }
      this.m || (this.register[t] = 1);
    }
  }
  return this;
};
function go(t, e, n, r, i) {
  return n && 1 < t ? e + (r || 0) <= t ? n + (i || 0) : (t - 1) / (e + (r || 0)) * (n + (i || 0)) + 1 | 0 : 0;
}
function xs(t, e, n, r, i, s, a) {
  let o = a ? t.h : t.map;
  (!e[n] || a && !e[n][a]) && (t.s && (o = o[r]), a ? (e = e[n] || (e[n] = Qe()), e[a] = 1, o = o[a] || (o[a] = Qe())) : e[n] = 1, o = o[n] || (o[n] = []), t.s || (o = o[r] || (o[r] = [])), s && o.includes(i) || (o[o.length] = i, t.m && (t = t.register[i] || (t.register[i] = []), t[t.length] = o)));
}
tt.search = function(t, e, n) {
  n || (!e && _r(t) ? (n = t, t = n.query) : _r(e) && (n = e));
  let r = [], i, s, a = 0;
  if (n) {
    t = n.query || t, e = n.limit, a = n.offset || 0;
    var o = n.context;
    s = n.suggest;
  }
  if (t && (t = this.encode("" + t), i = t.length, 1 < i)) {
    n = Qe();
    var u = [];
    for (let c = 0, d = 0, f; c < i; c++) if ((f = t[c]) && f.length >= this.B && !n[f]) if (this.s || s || this.map[f]) u[d++] = f, n[f] = 1;
    else return r;
    t = u, i = t.length;
  }
  if (!i) return r;
  e || (e = 100), o = this.depth && 1 < i && o !== !1, n = 0;
  let l;
  o ? (l = t[0], n = 1) : 1 < i && t.sort(nP);
  for (let c, d; n < i; n++) {
    if (d = t[n], o ? (c = Ym(
      this,
      r,
      s,
      e,
      a,
      i === 2,
      d,
      l
    ), s && c === !1 && r.length || (l = d)) : c = Ym(this, r, s, e, a, i === 1, d), c) return c;
    if (s && n === i - 1) {
      if (u = r.length, !u) {
        if (o) {
          o = 0, n = -1;
          continue;
        }
        return r;
      }
      if (u === 1) return Xy(r[0], e, a);
    }
  }
  return Ky(r, e, a, s);
};
function Ym(t, e, n, r, i, s, a, o) {
  let u = [], l = o ? t.h : t.map;
  if (t.s || (l = Xm(l, a, o, t.l)), l) {
    let c = 0;
    const d = Math.min(l.length, o ? t.A : t.D);
    for (let f = 0, h = 0, m, p; f < d && !((m = l[f]) && (t.s && (m = Xm(m, a, o, t.l)), i && m && s && (p = m.length, p <= i ? (i -= p, m = null) : (m = m.slice(i), i = 0)), m && (u[c++] = m, s && (h += m.length, h >= r)))); f++) ;
    if (c) {
      if (s) return Xy(u, r, 0);
      e[e.length] = u;
      return;
    }
  }
  return !n && u;
}
function Xy(t, e, n) {
  return t = t.length === 1 ? t[0] : [].concat.apply([], t), n || t.length > e ? t.slice(n, n + e) : t;
}
function Xm(t, e, n, r) {
  return n ? (r = r && e > n, t = (t = t[r ? e : n]) && t[r ? n : e]) : t = t[e], t;
}
tt.contain = function(t) {
  return !!this.register[t];
};
tt.update = function(t, e) {
  return this.remove(t).add(t, e);
};
tt.remove = function(t, e) {
  const n = this.register[t];
  if (n) {
    if (this.m) for (let r = 0, i; r < n.length; r++) i = n[r], i.splice(i.indexOf(t), 1);
    else Eu(this.map, t, this.D, this.s), this.depth && Eu(this.h, t, this.A, this.s);
    if (e || delete this.register[t], this.cache) {
      e = this.cache;
      for (let r = 0, i, s; r < e.h.length; r++) s = e.h[r], i = e.cache[s], i.includes(t) && (e.h.splice(r--, 1), delete e.cache[s]);
    }
  }
  return this;
};
function Eu(t, e, n, r, i) {
  let s = 0;
  if (t.constructor === Array) if (i) e = t.indexOf(e), e !== -1 ? 1 < t.length && (t.splice(e, 1), s++) : s++;
  else {
    i = Math.min(t.length, n);
    for (let a = 0, o; a < i; a++) (o = t[a]) && (s = Eu(o, e, n, r, i), r || s || delete t[a]);
  }
  else for (let a in t) (s = Eu(t[a], e, n, r, i)) || delete t[a];
  return s;
}
tt.searchCache = Wy;
tt.export = function(t, e, n, r, i, s) {
  let a = !0;
  typeof s > "u" && (a = new Promise((l) => {
    s = l;
  }));
  let o, u;
  switch (i || (i = 0)) {
    case 0:
      if (o = "reg", this.m) {
        u = Qe();
        for (let l in this.register) u[l] = 1;
      } else u = this.register;
      break;
    case 1:
      o = "cfg", u = { doc: 0, opt: this.s ? 1 : 0 };
      break;
    case 2:
      o = "map", u = this.map;
      break;
    case 3:
      o = "ctx", u = this.h;
      break;
    default:
      typeof n > "u" && s && s();
      return;
  }
  return Yy(t, e || this, n, o, r, i, u, s), a;
};
tt.import = function(t, e) {
  if (e) switch (At(e) && (e = JSON.parse(e)), t) {
    case "cfg":
      this.s = !!e.opt;
      break;
    case "reg":
      this.m = !1, this.register = e;
      break;
    case "map":
      this.map = e;
      break;
    case "ctx":
      this.h = e;
  }
};
jy(Yi.prototype);
function lP(t) {
  t = t.data;
  var e = self._index;
  const n = t.args;
  var r = t.task;
  switch (r) {
    case "init":
      r = t.options || {}, t = t.factory, e = r.encode, r.cache = !1, e && e.indexOf("function") === 0 && (r.encode = Function("return " + e)()), t ? (Function("return " + t)()(self), self._index = new self.FlexSearch.Index(r), delete self.FlexSearch) : self._index = new Yi(r);
      break;
    default:
      t = t.id, e = e[r].apply(e, n), postMessage(r === "search" ? { id: t, msg: e } : { id: t });
  }
}
let Qm = 0;
function la(t) {
  if (!(this instanceof la)) return new la(t);
  var e;
  t ? jf(e = t.encode) && (t.encode = e.toString()) : t = {}, (e = (self || window)._factory) && (e = e.toString());
  const n = typeof window > "u" && self.exports, r = this;
  this.o = cP(e, n, t.worker), this.h = Qe(), this.o && (n ? this.o.on("message", function(i) {
    r.h[i.id](i.msg), delete r.h[i.id];
  }) : this.o.onmessage = function(i) {
    i = i.data, r.h[i.id](i.msg), delete r.h[i.id];
  }, this.o.postMessage({ task: "init", factory: e, options: t }));
}
Ca("add");
Ca("append");
Ca("search");
Ca("update");
Ca("remove");
function Ca(t) {
  la.prototype[t] = la.prototype[t + "Async"] = function() {
    const e = this, n = [].slice.call(arguments);
    var r = n[n.length - 1];
    let i;
    return jf(r) && (i = r, n.splice(n.length - 1, 1)), r = new Promise(function(s) {
      setTimeout(function() {
        e.h[++Qm] = s, e.o.postMessage({ task: t, id: Qm, args: n });
      });
    }), i ? (r.then(i), this) : r;
  };
}
function cP(t, e, n) {
  let r;
  try {
    r = e ? new (require("worker_threads")).Worker(__dirname + "/node/node.js") : t ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + lP.toString()], { type: "text/javascript" }))) : new Worker(At(n) ? n : "worker/worker.js", { type: "module" });
  } catch {
  }
  return r;
}
function ca(t) {
  if (!(this instanceof ca)) return new ca(t);
  var e = t.document || t.doc || t, n;
  this.K = [], this.h = [], this.A = [], this.register = Qe(), this.key = (n = e.key || e.id) && bo(n, this.A) || "id", this.m = Go(t.fastupdate), this.C = (n = e.store) && n !== !0 && [], this.store = n && Qe(), this.I = (n = e.tag) && bo(n, this.A), this.l = n && Qe(), this.cache = (n = t.cache) && new Wu(n), t.cache = !1, this.o = t.worker, this.async = !1, n = Qe();
  let r = e.index || e.field || e;
  At(r) && (r = [r]);
  for (let i = 0, s, a; i < r.length; i++) s = r[i], At(s) || (a = s, s = s.field), a = _r(a) ? Object.assign({}, t, a) : t, this.o && (n[s] = new la(a), n[s].o || (this.o = !1)), this.o || (n[s] = new Yi(a, this.register)), this.K[i] = bo(s, this.A), this.h[i] = s;
  if (this.C) for (t = e.store, At(t) && (t = [t]), e = 0; e < t.length; e++) this.C[e] = bo(t[e], this.A);
  this.index = n;
}
function bo(t, e) {
  const n = t.split(":");
  let r = 0;
  for (let i = 0; i < n.length; i++) t = n[i], 0 <= t.indexOf("[]") && (t = t.substring(0, t.length - 2)) && (e[r] = !0), t && (n[r++] = t);
  return r < n.length && (n.length = r), 1 < r ? n : n[0];
}
function od(t, e) {
  if (At(e)) t = t[e];
  else for (let n = 0; t && n < e.length; n++) t = t[e[n]];
  return t;
}
function ud(t, e, n, r, i) {
  if (t = t[i], r === n.length - 1) e[i] = t;
  else if (t) if (t.constructor === Array) for (e = e[i] = Array(t.length), i = 0; i < t.length; i++) ud(t, e, n, r, i);
  else e = e[i] || (e[i] = Qe()), i = n[++r], ud(t, e, n, r, i);
}
function ld(t, e, n, r, i, s, a, o) {
  if (t = t[a]) if (r === e.length - 1) {
    if (t.constructor === Array) {
      if (n[r]) {
        for (e = 0; e < t.length; e++) i.add(s, t[e], !0, !0);
        return;
      }
      t = t.join(" ");
    }
    i.add(s, t, o, !0);
  } else if (t.constructor === Array) for (a = 0; a < t.length; a++) ld(t, e, n, r, i, s, a, o);
  else a = e[++r], ld(t, e, n, r, i, s, a, o);
}
tt = ca.prototype;
tt.add = function(t, e, n) {
  if (_r(t) && (e = t, t = od(e, this.key)), e && (t || t === 0)) {
    if (!n && this.register[t]) return this.update(t, e);
    for (let r = 0, i, s; r < this.h.length; r++) s = this.h[r], i = this.K[r], At(i) && (i = [i]), ld(e, i, this.A, 0, this.index[s], t, i[0], n);
    if (this.I) {
      let r = od(e, this.I), i = Qe();
      At(r) && (r = [r]);
      for (let s = 0, a, o; s < r.length; s++) if (a = r[s], !i[a] && (i[a] = 1, o = this.l[a] || (this.l[a] = []), !n || !o.includes(t)) && (o[o.length] = t, this.m)) {
        const u = this.register[t] || (this.register[t] = []);
        u[u.length] = o;
      }
    }
    if (this.store && (!n || !this.store[t])) {
      let r;
      if (this.C) {
        r = Qe();
        for (let i = 0, s; i < this.C.length; i++) s = this.C[i], At(s) ? r[s] = e[s] : ud(e, r, s, 0, s[0]);
      }
      this.store[t] = r || e;
    }
  }
  return this;
};
tt.append = function(t, e) {
  return this.add(t, e, !0);
};
tt.update = function(t, e) {
  return this.remove(t).add(t, e);
};
tt.remove = function(t) {
  if (_r(t) && (t = od(t, this.key)), this.register[t]) {
    for (var e = 0; e < this.h.length && (this.index[this.h[e]].remove(t, !this.o), !this.m); e++) ;
    if (this.I && !this.m) for (let n in this.l) {
      e = this.l[n];
      const r = e.indexOf(t);
      r !== -1 && (1 < e.length ? e.splice(r, 1) : delete this.l[n]);
    }
    this.store && delete this.store[t], delete this.register[t];
  }
  return this;
};
tt.search = function(t, e, n, r) {
  n || (!e && _r(t) ? (n = t, t = "") : _r(e) && (n = e, e = 0));
  let i = [], s = [], a, o, u, l, c, d, f = 0;
  if (n) if (n.constructor === Array) u = n, n = null;
  else {
    if (t = n.query || t, u = (a = n.pluck) || n.index || n.field, l = n.tag, o = this.store && n.enrich, c = n.bool === "and", e = n.limit || e || 100, d = n.offset || 0, l && (At(l) && (l = [l]), !t)) {
      for (let m = 0, p; m < l.length; m++) (p = dP.call(this, l[m], e, d, o)) && (i[i.length] = p, f++);
      return f ? i : [];
    }
    At(u) && (u = [u]);
  }
  u || (u = this.h), c = c && (1 < u.length || l && 1 < l.length);
  const h = !r && (this.o || this.async) && [];
  for (let m = 0, p, g, E; m < u.length; m++) {
    let y;
    if (g = u[m], At(g) || (y = g, g = y.field, t = y.query || t, e = y.limit || e, o = y.enrich || o), h) h[m] = this.index[g].searchAsync(t, e, y || n);
    else {
      if (r ? p = r[m] : p = this.index[g].search(t, e, y || n), E = p && p.length, l && E) {
        const T = [];
        let S = 0;
        c && (T[0] = [p]);
        for (let v = 0, I, C; v < l.length; v++) I = l[v], (E = (C = this.l[I]) && C.length) && (S++, T[T.length] = c ? [C] : C);
        S && (p = c ? Ky(T, e || 100, d || 0) : oP(p, T), E = p.length);
      }
      if (E) s[f] = g, i[f++] = p;
      else if (c) return [];
    }
  }
  if (h) {
    const m = this;
    return new Promise(function(p) {
      Promise.all(h).then(function(g) {
        p(m.search(
          t,
          e,
          n,
          g
        ));
      });
    });
  }
  if (!f) return [];
  if (a && (!o || !this.store)) return i[0];
  for (let m = 0, p; m < s.length; m++) {
    if (p = i[m], p.length && o && (p = Qy.call(this, p)), a) return p;
    i[m] = { field: s[m], result: p };
  }
  return i;
};
function dP(t, e, n, r) {
  let i = this.l[t], s = i && i.length - n;
  if (s && 0 < s)
    return (s > e || n) && (i = i.slice(n, n + e)), r && (i = Qy.call(this, i)), { tag: t, result: i };
}
function Qy(t) {
  const e = Array(t.length);
  for (let n = 0, r; n < t.length; n++) r = t[n], e[n] = { id: r, doc: this.store[r] };
  return e;
}
tt.contain = function(t) {
  return !!this.register[t];
};
tt.get = function(t) {
  return this.store[t];
};
tt.set = function(t, e) {
  return this.store[t] = e, this;
};
tt.searchCache = Wy;
tt.export = function(t, e, n, r, i, s) {
  let a;
  if (typeof s > "u" && (a = new Promise((o) => {
    s = o;
  })), i || (i = 0), r || (r = 0), r < this.h.length) {
    const o = this.h[r], u = this.index[o];
    e = this, setTimeout(function() {
      u.export(t, e, i ? o : "", r, i++, s) || (r++, i = 1, e.export(t, e, o, r, i, s));
    });
  } else {
    let o, u;
    switch (i) {
      case 1:
        o = "tag", u = this.l, n = null;
        break;
      case 2:
        o = "store", u = this.store, n = null;
        break;
      default:
        s();
        return;
    }
    Yy(t, this, n, o, r, i, u, s);
  }
  return a;
};
tt.import = function(t, e) {
  if (e) switch (At(e) && (e = JSON.parse(e)), t) {
    case "tag":
      this.l = e;
      break;
    case "reg":
      this.m = !1, this.register = e;
      for (let r = 0, i; r < this.h.length; r++) i = this.index[this.h[r]], i.register = e, i.m = !1;
      break;
    case "store":
      this.store = e;
      break;
    default:
      t = t.split(".");
      const n = t[0];
      t = t[1], n && t && this.index[n].import(t, e);
  }
};
jy(ca.prototype);
var fP = { encode: Zy, F: !1, G: "" };
const hP = [rt("[Ã Ã¡Ã¢Ã£Ã¤Ã¥]"), "a", rt("[Ã¨Ã©ÃªÃ«]"), "e", rt("[Ã¬Ã­Ã®Ã¯]"), "i", rt("[Ã²Ã³Ã´ÃµÃ¶Å‘]"), "o", rt("[Ã¹ÃºÃ»Ã¼Å±]"), "u", rt("[Ã½Å·Ã¿]"), "y", rt("Ã±"), "n", rt("[Ã§c]"), "k", rt("ÃŸ"), "s", rt(" & "), " and "];
function Zy(t) {
  var e = t = "" + t;
  return e.normalize && (e = e.normalize("NFD").replace(iP, "")), Vy.call(this, e.toLowerCase(), !t.normalize && hP);
}
var mP = { encode: Jy, F: !1, G: "strict" };
const pP = /[^a-z0-9]+/, Zm = { b: "p", v: "f", w: "f", z: "s", x: "s", ÃŸ: "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
function Jy(t) {
  t = Zy.call(this, t).join(" ");
  const e = [];
  if (t) {
    const n = t.split(pP), r = n.length;
    for (let i = 0, s, a = 0; i < r; i++) if ((t = n[i]) && (!this.filter || !this.filter[t])) {
      s = t[0];
      let o = Zm[s] || s, u = o;
      for (let l = 1; l < t.length; l++) {
        s = t[l];
        const c = Zm[s] || s;
        c && c !== u && (o += c, u = c);
      }
      e[a++] = o;
    }
  }
  return e;
}
var gP = { encode: eT, F: !1, G: "" };
const bP = [rt("ae"), "a", rt("oe"), "o", rt("sh"), "s", rt("th"), "t", rt("ph"), "f", rt("pf"), "f", rt("(?![aeo])h(?![aeo])"), "", rt("(?!^[aeo])h(?!^[aeo])"), ""];
function eT(t, e) {
  return t && (t = Jy.call(this, t).join(" "), 2 < t.length && (t = Vo(t, bP)), e || (1 < t.length && (t = zy(t)), t && (t = t.split(" ")))), t || [];
}
var EP = { encode: TP, F: !1, G: "" };
const yP = rt("(?!\\b)[aeo]");
function TP(t) {
  return t && (t = eT.call(this, t, !0), 1 < t.length && (t = t.replace(yP, "")), 1 < t.length && (t = zy(t)), t && (t = t.split(" "))), t || [];
}
is["latin:default"] = sP;
is["latin:simple"] = fP;
is["latin:balance"] = mP;
is["latin:advanced"] = gP;
is["latin:extra"] = EP;
const xP = { Document: ca }, Kl = "255, 197, 32";
fe("span", {
  fontWeight: "700"
});
fe("div", {
  display: "flex",
  gap: "0.25rem"
});
const SP = fe("div", {
  fontSize: "0.9rem !important",
  color: "$secondaryAlt",
  margin: "0 0.5em"
});
fe("div", {
  display: "flex",
  flexDirection: "column",
  button: {
    backgroundColor: "#6660",
    opacity: "0.7",
    transition: "$all",
    padding: "0.5rem 0.618rem",
    fontSize: "0.9rem",
    lineHeight: "1.1rem",
    textAlign: "left",
    borderRadius: "2rem",
    border: "1px solid #6662",
    display: "flex",
    flexDirection: "column",
    gap: "0.25rem",
    "&:hover": {
      opacity: "1",
      boxShadow: "5px 5px 13px #6662"
    },
    "&[data-result=true]": {
      backgroundColor: `rgba(${Kl}, 0.2)`,
      borderColor: `rgba(${Kl}, 0.2)`,
      opacity: "1",
      "&:hover": {
        backgroundColor: `rgba(${Kl}, 0.2)`
      }
    }
  }
});
const cd = fe("input", {
  margin: "0",
  background: "none",
  zIndex: "2",
  justifyContent: "center",
  display: "flex",
  alignItems: "center",
  fontSize: "1rem",
  fontFamily: "inherit",
  outline: "none !important",
  border: "none !important",
  color: "$secondary",
  cursor: "pointer",
  boxSizing: "content-box !important",
  flexGrow: "0",
  width: "2rem"
}), dd = fe("button", {
  position: "absolute",
  zIndex: "3",
  border: "none",
  background: "transparent",
  color: "$secondary !important",
  fill: "$secondary !important",
  stroke: "$secondary !important",
  transition: "$all",
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  borderRadius: "2rem",
  height: "2rem",
  width: "2rem",
  svg: {
    color: "inherit",
    fill: "inherit",
    stroke: "inherit"
  }
}), AP = fe("button", {
  opacity: "1",
  alignSelf: "center",
  margin: "0 0.25rem",
  fill: "$secondary",
  flexShrink: "0",
  border: "none",
  background: "transparent",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  flexDirection: "column",
  borderRadius: "2rem",
  height: "2rem",
  width: "2rem",
  svg: {
    color: "inherit",
    fill: "inherit"
  },
  '&[aria-disabled="true"]': {
    opacity: "0",
    display: "none"
  }
}), vP = fe("form", {
  display: "flex",
  justifyContent: "space-between",
  transition: "$all",
  flexGrow: "1",
  height: "2rem",
  variants: {
    isPanelExpanded: {
      true: {
        [`${dd}`]: {
          marginLeft: "0",
          cursor: "text"
        },
        [`${cd}`]: {
          width: "100%",
          padding: "0 1rem 0 2rem",
          cursor: "text"
        }
      },
      false: {
        "&:hover": {
          backgroundColor: "$accent !important",
          borderRadius: "2rem"
        },
        [`${dd}`]: { cursor: "pointer" },
        [`${cd}`]: {
          cursor: "pointer",
          "&::placeholder": {
            color: "transparent !important"
          }
        }
      }
    }
  }
}), IP = fe("div", {
  display: "flex",
  alignItems: "center",
  gap: "0.25rem",
  "&[data-active=true]": {
    paddingRight: "0.5rem"
  },
  button: {
    fontSize: "0.9em",
    fill: "$secondary",
    color: "$secondary",
    stroke: "$secondary",
    backgroundColor: "transparent",
    border: "none",
    svg: {
      fill: "inherit",
      color: "inherit",
      stroke: "inherit",
      width: "1.25em"
    }
  }
}), CP = ({ activeIndex: t, searchString: e, total: n }) => {
  const r = n === 0 ? /* @__PURE__ */ $.createElement($.Fragment, null, "No results for ", /* @__PURE__ */ $.createElement("strong", null, e)) : /* @__PURE__ */ $.createElement($.Fragment, null, t + 1, " of ", n, " results for ", /* @__PURE__ */ $.createElement("strong", null, e));
  return /* @__PURE__ */ $.createElement(SP, null, r);
}, Jm = ({
  title: t,
  style: e = {}
}) => /* @__PURE__ */ $.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", style: e }, /* @__PURE__ */ $.createElement("title", null, t), /* @__PURE__ */ $.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M244 400L100 256l144-144M120 256h292"
  }
)), LP = {
  charset: "latin:extra, arabic:extra, cyrillic:extra, cjk:extra",
  optimize: !0,
  tokenize: "full",
  resolution: 9,
  document: {
    id: "id",
    index: "content"
  }
}, _P = () => {
  const [t, e] = sn(0), { dispatch: n, state: r } = $n(gn), { activeLanguages: i, annotations: s, searchString: a = "" } = r, o = new xP.Document(LP), u = [];
  s == null || s.forEach((g) => {
    var E;
    (E = g == null ? void 0 : g.body) == null || E.forEach((y) => {
      var S;
      if (!(i != null && i.includes(String(y.language)))) return;
      const T = (S = y == null ? void 0 : y.value) == null ? void 0 : S.replace(/\n/g, "");
      u.push(y == null ? void 0 : y.id), o.add({
        id: y == null ? void 0 : y.id,
        content: T
      });
    });
  });
  const l = o == null ? void 0 : o.search(a).reduce((g, E) => [.../* @__PURE__ */ new Set([...g, ...E.result])], []), c = h(
    f(l),
    a
  ), d = c.matches.flatMap((g) => Object.values(g).flat());
  lt(() => {
    e(0), n({
      type: "updateSearchMatches",
      payload: c
    }), n({
      type: "updateSearchActiveMatch",
      payload: void 0
    });
  }, [a]), lt(() => {
    n({
      type: "updateSearchActiveMatch",
      payload: d[t]
    });
  }, [t, a]);
  function f(g) {
    return g.map((E) => s == null ? void 0 : s.filter((y) => y.body.find((T) => T.id === E)).map((y) => {
      const T = y.body.findIndex((S) => S.id === E);
      return {
        ...y,
        body: y.body[T]
      };
    }).shift());
  }
  function h(g, E) {
    const y = new RegExp(E, "gi"), T = { total: 0, matches: [] };
    return g.forEach((S) => {
      const v = S.body.id, I = S.body.value, C = [];
      let D = 0, _;
      for (console.log(_); (_ = y.exec(I)) !== null; )
        D++, C.push(`${v}/${D}`);
      D > 0 && (T.total += D, T.matches.push({ [v]: C }));
    }), T;
  }
  const m = () => e(
    (g) => g < d.length - 1 ? g + 1 : 0
  ), p = () => e(
    (g) => g > 0 ? g - 1 : d.length - 1
  );
  return /* @__PURE__ */ $.createElement(IP, { "data-active": !!a }, a && /* @__PURE__ */ $.createElement(
    CP,
    {
      activeIndex: t,
      searchString: a,
      total: c.total
    }
  ), (c == null ? void 0 : c.total) !== 0 && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement("button", { onClick: p }, /* @__PURE__ */ $.createElement(
    Jm,
    {
      title: "previous",
      style: { transform: "rotate(90deg)" }
    }
  )), /* @__PURE__ */ $.createElement("button", { onClick: m }, /* @__PURE__ */ $.createElement(Jm, { title: "next", style: { transform: "rotate(270deg)" } }))));
}, RP = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    style: { width: "16px", height: "16px" },
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  },
  /* @__PURE__ */ $.createElement("title", null, "search"),
  /* @__PURE__ */ $.createElement("path", { d: "M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z" })
), kP = () => /* @__PURE__ */ $.createElement(
  "svg",
  {
    style: { width: "16px", height: "16px" },
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  },
  /* @__PURE__ */ $.createElement("title", null, "close"),
  /* @__PURE__ */ $.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" })
), wP = ({
  togglePanel: t,
  isPanelExpanded: e
}) => {
  const { dispatch: n, state: r } = $n(gn), { searchString: i } = r, s = Ji(null), a = () => s.current === document.activeElement && t(!0), o = (h) => {
    var m;
    h.preventDefault(), (m = s == null ? void 0 : s.current) == null || m.focus();
  }, u = () => {
    var h;
    (h = s.current) == null || h.blur(), l(), t(!1), n({
      payload: "",
      type: "updateSearchString"
    }), n({
      payload: void 0,
      type: "updateSearchActiveMatch"
    });
  }, l = () => {
    s.current && (s.current.value = "");
  }, c = (h) => {
    h.preventDefault(), u();
  }, d = (h) => {
    h.key === "Escape" && (h.preventDefault(), u());
  };
  lt(() => (document == null || document.addEventListener("keydown", d), () => {
    document == null || document.removeEventListener("keydown", d);
  }), []), lt(() => {
    if (s != null && s.current)
      return s.current.addEventListener("focus", a), s.current.addEventListener("blur", a), () => {
        s.current && (s.current.removeEventListener("focus", a), s.current.removeEventListener("blur", a));
      };
  }, []);
  const f = (h) => {
    var m;
    n({
      payload: (m = h == null ? void 0 : h.target) == null ? void 0 : m.value,
      type: "updateSearchString"
    });
  };
  return /* @__PURE__ */ $.createElement(
    vP,
    {
      id: "scroll-search",
      autoComplete: "off",
      isPanelExpanded: e,
      "data-testid": "scroll-panel-search-form"
    },
    /* @__PURE__ */ $.createElement(dd, { onClick: o }, /* @__PURE__ */ $.createElement(RP, null)),
    /* @__PURE__ */ $.createElement(
      cd,
      {
        ref: s,
        name: "clover-search",
        type: "text",
        placeholder: "Search...",
        defaultValue: i,
        onChange: f
      }
    ),
    /* @__PURE__ */ $.createElement(
      AP,
      {
        "aria-disabled": !e,
        "aria-label": "Close search panel",
        onClick: c,
        disabled: !e
      },
      /* @__PURE__ */ $.createElement(kP, null)
    )
  );
}, DP = fe("div", {
  display: "flex",
  position: "relative",
  zIndex: "1",
  maxWidth: "100%",
  transition: "$all",
  variants: {
    isPanelExpanded: {
      true: {
        zIndex: 1,
        opacity: 1,
        transform: "translateX(0)"
      },
      false: {
        zIndex: -1,
        opacity: 0,
        transform: "translateX(-2.618rem)",
        transitionDelay: "0",
        transition: "none"
      }
    }
  }
}), PP = ({ width: t, isFixed: e, hasDefinedLanguages: n }) => {
  const r = Ji(null), [i, s] = $.useState(!1), { state: a } = $n(gn), { options: o } = a, { offset: u, language: l } = o, c = e ? {
    position: "fixed",
    top: e ? u : 0
  } : {};
  function d(m) {
    s(m);
  }
  const f = l == null ? void 0 : l.enabled, h = f ? 4.5 : 2;
  return /* @__PURE__ */ $.createElement(
    Ik,
    {
      ref: r,
      "data-testid": "scroll-panel",
      style: {
        display: i ? "unset" : "inline-flex",
        left: i || e ? "unset" : `calc(${t}px - ${h}rem)`,
        marginLeft: i ? `-${t}px` : e ? `-${h}rem` : "unset",
        width: i ? t : `${h}rem`,
        ...c
      }
    },
    !i && f && n && /* @__PURE__ */ $.createElement(tP, null),
    /* @__PURE__ */ $.createElement(vk, null, /* @__PURE__ */ $.createElement(
      wP,
      {
        togglePanel: d,
        isPanelExpanded: i
      }
    ), /* @__PURE__ */ $.createElement(
      DP,
      {
        "data-testid": "scroll-panel-results",
        "data-panel-expanded": i,
        isPanelExpanded: i
      },
      i && /* @__PURE__ */ $.createElement(_P, null)
    ))
  );
}, OP = ({
  label: t,
  hasDefinedLanguages: e
}) => {
  const { state: n } = $n(gn), { options: r } = n, i = r.offset ?? Cn.options.offset ?? 0, s = Ji(null), [a, o] = sn(0), [u, l] = sn(!1);
  return lt(() => {
    const c = s.current;
    if (!c) return;
    const d = new ResizeObserver((f) => {
      for (const h of f)
        h.contentRect && o(h.contentRect.width);
    });
    return d.observe(c), () => {
      d.disconnect();
    };
  }, []), lt(() => {
    const c = () => {
      const d = s.current;
      if (!d) return;
      d.getBoundingClientRect().top <= i ? l(!0) : l(!1);
    };
    return window.addEventListener("scroll", c), () => {
      window.removeEventListener("scroll", c);
    };
  }, []), /* @__PURE__ */ $.createElement(Ck, { ref: s }, /* @__PURE__ */ $.createElement(
    J1,
    {
      label: t,
      className: "clover-scroll-header-label"
    }
  ), /* @__PURE__ */ $.createElement("div", null, /* @__PURE__ */ $.createElement(
    PP,
    {
      width: a,
      isFixed: u,
      hasDefinedLanguages: e
    }
  )));
}, NP = fe("article", {
  transition: "all 0.382s ease-in-out",
  display: "flex",
  flexDirection: "row",
  flexWrap: "nowrap",
  gap: "2.618rem"
}), tT = fe("div", {
  transition: "$all",
  flexShrink: 0
}), MP = fe("div", {
  display: "flex",
  flexGrow: 1,
  flexDirection: "column",
  justifyContent: "flex-start",
  "> div": {
    display: "flex",
    flexDirection: "row",
    gap: "2.618rem",
    width: "100%"
  }
}), FP = fe("div", {
  width: "calc(100% / var(--num-items, 1))",
  boxSizing: "border-box",
  display: "flex",
  flexDirection: "column",
  gap: "1rem",
  minWidth: 0
}), BP = fe("hr", {
  margin: "0",
  borderColor: "transparent",
  height: "1.618rem",
  position: "relative",
  width: "61.8%",
  zIndex: 0,
  marginLeft: "38.2%",
  display: "flex",
  justifyContent: "flex-end",
  "&::before": {
    content: "attr(aria-label)",
    position: "absolute",
    right: "1.618rem",
    bottom: "0",
    zIndex: 1,
    display: "flex",
    fontSize: "0.7222rem",
    fontWeight: "400",
    lineHeight: "1rem",
    background: "inherit",
    opacity: 0.7
  },
  "&::after": {
    content: "",
    width: "calc(100% -  2.618em)",
    position: "absolute",
    zIndex: 0,
    height: "1px",
    background: "#6662"
  }
}), UP = fe("div", {
  display: "flex",
  flexDirection: "column",
  gap: "2.618rem",
  "&[data-figures-visible='true']": {
    [`& ${tT}`]: {
      opacity: 1,
      zIndex: 0,
      transform: "translateX(0)"
    }
  }
});
var $P = "AspectRatio", nT = V.forwardRef(
  (t, e) => {
    const { ratio: n = 1 / 1, style: r, ...i } = t;
    return /* @__PURE__ */ xe(
      "div",
      {
        style: {
          // ensures inner element is contained
          position: "relative",
          // ensures padding bottom trick maths works
          width: "100%",
          paddingBottom: `${100 / n}%`
        },
        "data-radix-aspect-ratio-wrapper": "",
        children: /* @__PURE__ */ xe(
          un.div,
          {
            ...i,
            ref: e,
            style: {
              ...r,
              // ensures children expand in ratio
              position: "absolute",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          }
        )
      }
    );
  }
);
nT.displayName = $P;
const HP = fe(nT, {}), GP = fe("figure", {
  figcaption: {
    display: "flex",
    flexDirection: "column",
    margin: "1.618rem 0 0",
    opacity: 0.9,
    gap: "0.382rem",
    em: {
      fontSize: "0.9em",
      fontStyle: "normal",
      opacity: 0.7
    }
  }
}), VP = ({
  canvas: t,
  canvasInfo: { current: e, total: n }
}) => /* @__PURE__ */ $.createElement("figcaption", null, /* @__PURE__ */ $.createElement("em", null, e, " / ", n), (t == null ? void 0 : t.label) && /* @__PURE__ */ $.createElement(J1, { label: t == null ? void 0 : t.label }), (t == null ? void 0 : t.summary) && /* @__PURE__ */ $.createElement(Sk, { summary: t == null ? void 0 : t.summary, as: "p" }));
let qr = window.OpenSeadragon;
if (!qr && (qr = Rs, !qr))
  throw new Error("OpenSeadragon is missing.");
const ep = "http://www.w3.org/2000/svg";
qr.Viewer && (qr.Viewer.prototype.svgOverlay = function() {
  return this._svgOverlayInfo ? this._svgOverlayInfo : (this._svgOverlayInfo = new rT(this), this._svgOverlayInfo);
});
const rT = function(t) {
  const e = this;
  this._viewer = t, this._containerWidth = 0, this._containerHeight = 0, this._svg = document.createElementNS(ep, "svg"), this._svg.style.position = "absolute", this._svg.style.left = 0, this._svg.style.top = 0, this._svg.style.width = "100%", this._svg.style.height = "100%", this._viewer.canvas.appendChild(this._svg), this._node = document.createElementNS(ep, "g"), this._svg.appendChild(this._node), this._viewer.addHandler("animation", function() {
    e.resize();
  }), this._viewer.addHandler("open", function() {
    e.resize();
  }), this._viewer.addHandler("rotate", function() {
    e.resize();
  }), this._viewer.addHandler("flip", function() {
    e.resize();
  }), this._viewer.addHandler("resize", function() {
    e.resize();
  }), this.resize();
};
rT.prototype = {
  // ----------
  node: function() {
    return this._node;
  },
  // ----------
  resize: function() {
    this._containerWidth !== this._viewer.container.clientWidth && (this._containerWidth = this._viewer.container.clientWidth, this._svg.setAttribute("width", this._containerWidth)), this._containerHeight !== this._viewer.container.clientHeight && (this._containerHeight = this._viewer.container.clientHeight, this._svg.setAttribute("height", this._containerHeight));
    const t = this._viewer.viewport.pixelFromPoint(new qr.Point(0, 0), !0), e = this._viewer.viewport.getZoom(!0), n = this._viewer.viewport.getRotation(), r = this._viewer.viewport.getFlip(), i = this._viewer.viewport._containerInnerSize.x;
    let s = i * e;
    const a = s;
    r && (s = -s, t.x = -t.x + i), this._node.setAttribute(
      "transform",
      "translate(" + t.x + "," + t.y + ") scale(" + s + "," + a + ") rotate(" + n + ")"
    );
  },
  // ----------
  onClick: function(t, e) {
    new qr.MouseTracker({
      element: t,
      clickHandler: e
    }).setTracking(!0);
  }
};
const zP = (t) => fetch(`${t.replace(/\/$/, "")}/info.json`).then((e) => e.json()).then((e) => e).catch((e) => {
  console.error(
    `The IIIF tilesource ${t.replace(
      /\/$/,
      ""
    )}/info.json failed to load: ${e}`
  );
}), qP = (t) => {
  let e, n;
  if (Array.isArray(t) && (e = t[0], e)) {
    let r;
    "@id" in e ? r = e["@id"] : r = e.id, n = r;
  }
  return n;
};
var en = /* @__PURE__ */ ((t) => (t.TiledImage = "tiledImage", t.SimpleImage = "simpleImage", t))(en || {});
const jP = (t) => {
  const e = Array.isArray(t == null ? void 0 : t.service) && (t == null ? void 0 : t.service.length) > 0, n = e ? qP(t == null ? void 0 : t.service) : t == null ? void 0 : t.id, r = e ? en.TiledImage : en.SimpleImage;
  return {
    uri: n,
    imageType: r
  };
}, KP = (t, e) => {
  const n = e ? en.TiledImage : en.SimpleImage;
  return {
    uri: t,
    imageType: n
  };
}, WP = Hd(null), Wl = {
  didCatch: !1,
  error: null
};
class YP extends e2 {
  constructor(e) {
    super(e), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = Wl;
  }
  static getDerivedStateFromError(e) {
    return {
      didCatch: !0,
      error: e
    };
  }
  resetErrorBoundary() {
    const {
      error: e
    } = this.state;
    if (e !== null) {
      for (var n, r, i = arguments.length, s = new Array(i), a = 0; a < i; a++)
        s[a] = arguments[a];
      (n = (r = this.props).onReset) === null || n === void 0 || n.call(r, {
        args: s,
        reason: "imperative-api"
      }), this.setState(Wl);
    }
  }
  componentDidCatch(e, n) {
    var r, i;
    (r = (i = this.props).onError) === null || r === void 0 || r.call(i, e, n);
  }
  componentDidUpdate(e, n) {
    const {
      didCatch: r
    } = this.state, {
      resetKeys: i
    } = this.props;
    if (r && n.error !== null && XP(e.resetKeys, i)) {
      var s, a;
      (s = (a = this.props).onReset) === null || s === void 0 || s.call(a, {
        next: i,
        prev: e.resetKeys,
        reason: "keys"
      }), this.setState(Wl);
    }
  }
  render() {
    const {
      children: e,
      fallbackRender: n,
      FallbackComponent: r,
      fallback: i
    } = this.props, {
      didCatch: s,
      error: a
    } = this.state;
    let o = e;
    if (s) {
      const u = {
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof n == "function")
        o = n(u);
      else if (r)
        o = Sh(r, u);
      else if (i !== void 0)
        o = i;
      else
        throw a;
    }
    return Sh(WP.Provider, {
      value: {
        didCatch: s,
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, o);
  }
}
function XP() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return t.length !== e.length || t.some((n, r) => !Object.is(n, e[r]));
}
const QP = fe("div", {
  display: "flex",
  flexDirection: "column",
  alignItems: "center"
}), ZP = fe("p", {
  fontWeight: "bold",
  fontSize: "x-large"
}), JP = fe("span", {
  fontSize: "medium"
}), eO = ({ error: t }) => {
  const { message: e } = t;
  return /* @__PURE__ */ $.createElement(QP, { role: "alert" }, /* @__PURE__ */ $.createElement(ZP, { "data-testid": "headline" }, "Something went wrong"), e && /* @__PURE__ */ $.createElement(JP, null, `Error message: ${e}`, " "));
}, fd = fe("div", {
  position: "absolute !important",
  zIndex: "1",
  top: "1rem",
  left: "1rem",
  width: "161.8px",
  height: "100px",
  backgroundColor: "#000D",
  boxShadow: "5px 5px 5px #0002",
  borderRadius: "3px",
  ".displayregion": {
    border: " 3px solid $accent !important",
    boxShadow: "0 0 3px #0006"
  },
  "@sm": {
    width: "123px",
    height: "76px"
  },
  "@xs": {
    width: "100px",
    height: "61.8px"
  }
}), tO = fe("div", {
  position: "relative",
  width: "100%",
  height: "100%",
  zIndex: "0",
  ".clover-iiif-image-openseadragon-annotation": {
    position: "relative",
    backgroundColor: "transparent",
    border: "2px solid #0003",
    boxSizing: "content-box",
    borderRadius: "3px",
    boxShadow: "0 0 38vw 38vw transparent",
    transition: "box-shadow 100ms ease-in-out",
    zIndex: "0",
    label: {
      opacity: 0,
      position: "absolute",
      lineHeight: "1.47rem",
      pointerEvents: "none",
      textAlign: "center",
      minWidth: "300px",
      maxWidth: "20vw",
      padding: "0.5rem",
      borderRadius: "3px",
      top: "calc(100% + 0.5rem)",
      left: "50%",
      transform: "translate(-50%, 0)",
      backgroundColor: "$primary",
      color: "$secondary",
      transition: "opacity 100ms ease-in-out"
    },
    "&[data-active=true]": {
      border: "2px solid $accent !important",
      boxShadow: "0 0 38vw 38vw #0003",
      zIndex: "99999999",
      label: {
        opacity: 1
      }
    }
  }
}), nO = fe("div", {
  width: "100%",
  height: "100%",
  maxHeight: "100vh",
  background: "transparent",
  backgroundSize: "contain",
  color: "white",
  position: "relative",
  zIndex: "0",
  overflow: "hidden",
  variants: {
    hasNavigator: {
      true: {
        [`${fd}`]: {
          display: "block"
        }
      },
      false: {
        [`${fd}`]: {
          display: "none"
        }
      }
    }
  }
});
let Eo;
const rO = new Uint8Array(16);
function iO() {
  if (!Eo && (Eo = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Eo))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Eo(rO);
}
const yt = [];
for (let t = 0; t < 256; ++t)
  yt.push((t + 256).toString(16).slice(1));
function sO(t, e = 0) {
  return yt[t[e + 0]] + yt[t[e + 1]] + yt[t[e + 2]] + yt[t[e + 3]] + "-" + yt[t[e + 4]] + yt[t[e + 5]] + "-" + yt[t[e + 6]] + yt[t[e + 7]] + "-" + yt[t[e + 8]] + yt[t[e + 9]] + "-" + yt[t[e + 10]] + yt[t[e + 11]] + yt[t[e + 12]] + yt[t[e + 13]] + yt[t[e + 14]] + yt[t[e + 15]];
}
const aO = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), tp = {
  randomUUID: aO
};
function iT(t, e, n) {
  if (tp.randomUUID && !t)
    return tp.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || iO)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, sO(r);
}
const sT = {
  behavior: "smooth",
  block: "center"
}, Nn = {
  annotationOverlays: {
    backgroundColor: "#6666ff",
    borderColor: "#000099",
    borderType: "solid",
    borderWidth: "1px",
    opacity: "0.5",
    renderOverlays: !0,
    zoomLevel: 2
  },
  annotations: {
    motivations: void 0
  },
  background: "transparent",
  canvasBackgroundColor: "#6662",
  canvasHeight: "500px",
  contentSearch: {
    searchResultsLimit: 20,
    overlays: {
      backgroundColor: "#ff6666",
      borderColor: "#990000",
      borderType: "solid",
      borderWidth: "1px",
      opacity: "0.5",
      renderOverlays: !0,
      zoomLevel: 4
    }
  },
  crossOrigin: "anonymous",
  ignoreCaptionLabels: [],
  informationPanel: {
    vtt: {
      autoScroll: {
        enabled: !0,
        settings: sT
      }
    },
    open: !0,
    renderAbout: !0,
    renderSupplementing: !0,
    renderToggle: !0,
    renderAnnotation: !0,
    renderContentSearch: !0
  },
  openSeadragon: {},
  requestHeaders: { "Content-Type": "application/json" },
  showDownload: !0,
  showIIIFBadge: !0,
  showTitle: !0,
  withCredentials: !1
}, oO = (t = Nn) => hd(t);
function hd(t) {
  return Array.isArray(t) ? t.map((e) => hd(e)) : t && typeof t == "object" ? Object.entries(t).reduce(
    (e, [n, r]) => (e[n] = hd(r), e),
    {}
  ) : t;
}
function uO(t) {
  const n = (() => {
    var a, o;
    return ((o = (a = Nn == null ? void 0 : Nn.informationPanel) == null ? void 0 : a.vtt) == null ? void 0 : o.autoScroll) || {
      enabled: !0,
      settings: sT
    };
  })();
  if (t == null)
    return {
      enabled: n.enabled,
      settings: { ...n.settings }
    };
  if (typeof t == "boolean")
    return {
      enabled: t,
      settings: { ...n.settings }
    };
  if ("enabled" in t) {
    const s = t;
    return {
      enabled: s.enabled,
      settings: { ...s.settings }
    };
  }
  const i = {
    enabled: !0,
    settings: { ...t }
  };
  return lO(i.settings), i;
}
function lO({ behavior: t, block: e }) {
  const n = ["auto", "instant", "smooth"], r = ["center", "end", "nearest", "start"];
  if (!n.includes(t))
    throw TypeError(`'${t}' not in ${n.join(" | ")}`);
  if (!r.includes(e))
    throw TypeError(`'${e}' not in ${r.join(" | ")}`);
}
var Ng, Mg;
const cO = uO(
  (Mg = (Ng = Nn == null ? void 0 : Nn.informationPanel) == null ? void 0 : Ng.vtt) == null ? void 0 : Mg.autoScroll
), dO = () => {
  var t;
  return {
    activeCanvas: "",
    activeManifest: "",
    activePlayer: null,
    activeSelector: void 0,
    OSDImageLoaded: !1,
    collection: {},
    configOptions: oO(),
    customDisplays: [],
    plugins: [],
    isAutoScrollEnabled: cO.enabled,
    isAutoScrolling: !1,
    // Respect explicit false; default to true only when undefined
    isInformationOpen: ((t = Nn == null ? void 0 : Nn.informationPanel) == null ? void 0 : t.open) ?? !0,
    isLoaded: !1,
    isPaged: !1,
    isUserScrolling: void 0,
    sequence: [[], []],
    vault: new Bg(),
    viewingDirection: "left-to-right",
    openSeadragonViewer: null,
    viewerId: iT(),
    visibleCanvases: [],
    visibleAnnotations: []
  };
}, aT = dO(), fO = $.createContext(aT), hO = $.createContext(aT);
function np() {
  const t = $.useContext(fO);
  if (t === void 0)
    throw new Error("useViewerState must be used within a ViewerProvider");
  return t;
}
function oT() {
  const t = $.useContext(hO);
  if (t === void 0)
    throw new Error("useViewerDispatch must be used within a ViewerProvider");
  return t;
}
const mO = fe("button", {
  display: "flex",
  height: "2rem",
  width: "2rem",
  borderRadius: "2rem",
  padding: "0",
  margin: "0",
  fontFamily: "inherit",
  background: "none",
  backgroundColor: "$primary",
  border: "none",
  color: "white",
  cursor: "pointer",
  marginLeft: "0.618rem",
  filter: "drop-shadow(2px 2px 5px #0003)",
  transition: "$all",
  boxSizing: "content-box !important",
  "&:first-child": {
    marginLeft: "0"
  },
  "@xs": {
    marginBottom: "0.618rem",
    marginLeft: "0",
    "&:last-child": {
      marginBottom: "0"
    }
  },
  svg: {
    height: "60%",
    width: "60%",
    padding: "20%",
    fill: "$secondary",
    stroke: "$secondary",
    filter: "drop-shadow(2px 2px 5px #0003)",
    transition: "$all",
    boxSizing: "inherit"
  },
  "&:hover, &:focus": {
    backgroundColor: "$accent"
  },
  "&[data-button=rotate-right]": {
    "&:hover, &:focus": {
      svg: {
        rotate: "45deg"
      }
    }
  },
  "&[data-button=rotate-left]": {
    transform: "scaleX(-1)",
    "&:hover, &:focus": {
      svg: {
        rotate: "45deg"
      }
    }
  },
  "&[data-button=reset]": {
    "&:hover, &:focus": {
      svg: {
        rotate: "-15deg"
      }
    }
  }
}), Ei = ({ className: t, id: e, label: n, children: r }) => {
  const s = e.split("-")[0].replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  return /* @__PURE__ */ $.createElement(
    mO,
    {
      id: e,
      className: t,
      "data-testid": "openseadragon-button",
      "data-button": s
    },
    /* @__PURE__ */ $.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        "aria-labelledby": `${e}-svg-title`,
        "data-testid": "openseadragon-button-svg",
        focusable: "false",
        viewBox: "0 0 512 512",
        role: "img"
      },
      /* @__PURE__ */ $.createElement("title", { id: `${e}-svg-title` }, n),
      r
    )
  );
}, pO = fe("div", {
  position: "absolute",
  zIndex: "1",
  top: "1rem",
  right: "1rem",
  display: "flex",
  "@xs": {
    flexDirection: "column",
    zIndex: "2"
  },
  variants: {
    hasPlaceholder: {
      true: {
        right: "3.618rem",
        "@xs": {
          top: "3.618rem",
          right: "1rem"
        }
      },
      false: {
        right: "1rem",
        "@xs": {
          top: "1rem",
          right: "1rem"
        }
      }
    }
  }
}), gO = "Close", bO = "Next", EO = "Open", yO = "Previous", TO = "Search", xO = "Search...", SO = "Share", AO = "View All", vO = "Failed", IO = "Copied", CO = "Loading...", LO = "Search", _O = "No Results", RO = "More Results", kO = "Full screen", wO = "Reset zoom", DO = "Rotate left", PO = "Rotate right", OO = "Zoom in", NO = "Zoom out", MO = "Select", FO = "Viewer", BO = "About", UO = "Annotations", $O = "Search", HO = "More Information", GO = "View Collection", VO = "Copy Collection URL", zO = "View Manifest", qO = "Copy Manifest URL", uT = {
  commonClose: gO,
  commonNext: bO,
  commonOpen: EO,
  commonPrevious: yO,
  commonSearch: TO,
  commonSearchPlaceholder: xO,
  commonShare: SO,
  commonViewAll: AO,
  copyFailure: vO,
  copySuccess: IO,
  contentSearchLoading: CO,
  contentSearchPlaceholder: LO,
  contentSearchResultsNone: _O,
  contentSearchResultsMore: RO,
  imageFullScreen: kO,
  imageResetZoom: wO,
  imageRotateLeft: DO,
  imageRotateRight: PO,
  imageZoomIn: OO,
  imageZoomOut: NO,
  informationPanelTabs: MO,
  informationPanelTabsClose: FO,
  informationPanelTabsAbout: BO,
  informationPanelTabsAnnotations: UO,
  informationPanelTabsSearch: $O,
  informationPanelToggle: HO,
  shareCollectionJson: GO,
  shareCollectionCopy: VO,
  shareManifestJson: zO,
  shareManifestCopy: qO
}, jO = "Sulje", KO = "Seuraava", WO = "Edellinen", YO = "Hae", XO = "Hae...", QO = "Jaa", ZO = "NÃ¤ytÃ¤ kaikki", JO = "Kopiointi epÃ¤onnistui", e4 = "Kopioitu", t4 = "Ladataan...", n4 = "Haku", r4 = "Ei osumia", i4 = "LisÃ¤Ã¤ osumia", s4 = "Valitse", a4 = "Katselu", o4 = "Tiedot", u4 = "Annotaatiot", l4 = "Haku", c4 = "LisÃ¤tiedot", d4 = "NÃ¤ytÃ¤ kokoelma", f4 = "Kopioi kokoelman osoite", h4 = "NÃ¤ytÃ¤ manifesti", m4 = "Kopioi manifestin osoite", p4 = {
  commonClose: jO,
  commonNext: KO,
  commonPrevious: WO,
  commonSearch: YO,
  commonSearchPlaceholder: XO,
  commonShare: QO,
  commonViewAll: ZO,
  copyFailure: JO,
  copySuccess: e4,
  contentSearchLoading: t4,
  contentSearchPlaceholder: n4,
  contentSearchResultsNone: r4,
  contentSearchResultsMore: i4,
  informationPanelTabs: s4,
  informationPanelTabsClose: a4,
  informationPanelTabsAbout: o4,
  informationPanelTabsAnnotations: u4,
  informationPanelTabsSearch: l4,
  informationPanelToggle: c4,
  shareCollectionJson: d4,
  shareCollectionCopy: f4,
  shareManifestJson: h4,
  shareManifestCopy: m4
}, g4 = "Fermer", b4 = "Suivant", E4 = "Ouvrir", y4 = "PrÃ©cÃ©dent", T4 = "Rechercher", x4 = "Rechercherâ€¦", S4 = "Partager", A4 = "Tout afficher", v4 = "Ã‰chec", I4 = "CopiÃ©", C4 = "Chargementâ€¦", L4 = "Rechercher", _4 = "Aucun rÃ©sultat", R4 = "Plus de rÃ©sultats", k4 = "Plein Ã©cran", w4 = "RÃ©initialiser le zoom", D4 = "Rotation Ã  gauche", P4 = "Rotation Ã  droite", O4 = "Zoom avant", N4 = "Zoom arriÃ¨re", M4 = "SÃ©lectionner", F4 = "Visionneuse", B4 = "Ã€ propos", U4 = "Annotations", $4 = "Recherche", H4 = "Plus dâ€™informations", G4 = "Afficher la collection", V4 = "Copier lâ€™URL de la collection", z4 = "Afficher le manifeste", q4 = "Copier lâ€™URL du manifeste", j4 = {
  commonClose: g4,
  commonNext: b4,
  commonOpen: E4,
  commonPrevious: y4,
  commonSearch: T4,
  commonSearchPlaceholder: x4,
  commonShare: S4,
  commonViewAll: A4,
  copyFailure: v4,
  copySuccess: I4,
  contentSearchLoading: C4,
  contentSearchPlaceholder: L4,
  contentSearchResultsNone: _4,
  contentSearchResultsMore: R4,
  imageFullScreen: k4,
  imageResetZoom: w4,
  imageRotateLeft: D4,
  imageRotateRight: P4,
  imageZoomIn: O4,
  imageZoomOut: N4,
  informationPanelTabs: M4,
  informationPanelTabsClose: F4,
  informationPanelTabsAbout: B4,
  informationPanelTabsAnnotations: U4,
  informationPanelTabsSearch: $4,
  informationPanelToggle: H4,
  shareCollectionJson: G4,
  shareCollectionCopy: V4,
  shareManifestJson: z4,
  shareManifestCopy: q4
}, K4 = "Lukk", W4 = "Neste", Y4 = "Forrige", X4 = "SÃ¸k", Q4 = "SÃ¸k...", Z4 = "Del", J4 = "Se alle", eN = "Feilet", tN = "Kopiert", nN = "Laster inn...", rN = "SÃ¸k", iN = "Ingen resultat", sN = "Flere resultat", aN = "Velg", oN = "Viewer", uN = "Om", lN = "Annoteringer", cN = "SÃ¸k", dN = "Mer informasjon", fN = "Se samlingen", hN = "KopiÃ©r samlingens URL", mN = "Se manifestet", pN = "KopiÃ©r manifestets URL", gN = {
  commonClose: K4,
  commonNext: W4,
  commonPrevious: Y4,
  commonSearch: X4,
  commonSearchPlaceholder: Q4,
  commonShare: Z4,
  commonViewAll: J4,
  copyFailure: eN,
  copySuccess: tN,
  contentSearchLoading: nN,
  contentSearchPlaceholder: rN,
  contentSearchResultsNone: iN,
  contentSearchResultsMore: sN,
  informationPanelTabs: aN,
  informationPanelTabsClose: oN,
  informationPanelTabsAbout: uN,
  informationPanelTabsAnnotations: lN,
  informationPanelTabsSearch: cN,
  informationPanelToggle: dN,
  shareCollectionJson: fN,
  shareCollectionCopy: hN,
  shareManifestJson: mN,
  shareManifestCopy: pN
}, bN = "Lukk", EN = "Neste", yN = "FÃ¸rre", TN = "SÃ¸k", xN = "SÃ¸k...", SN = "Del", AN = "SjÃ¥ alle", vN = "Feila", IN = "Kopiert", CN = "Laster inn...", LN = "SÃ¸k", _N = "Ingen resultat", RN = "Fleire resultat", kN = "Vel", wN = "Viewer", DN = "Om", PN = "Annoteringa", ON = "SÃ¸k", NN = "Meir informasjon", MN = "SjÃ¥ samlinga", FN = "KopiÃ©r samlingas URL", BN = "SjÃ¥ manifestet", UN = "KopiÃ©r manifestets URL", $N = {
  commonClose: bN,
  commonNext: EN,
  commonPrevious: yN,
  commonSearch: TN,
  commonSearchPlaceholder: xN,
  commonShare: SN,
  commonViewAll: AN,
  copyFailure: vN,
  copySuccess: IN,
  contentSearchLoading: CN,
  contentSearchPlaceholder: LN,
  contentSearchResultsNone: _N,
  contentSearchResultsMore: RN,
  informationPanelTabs: kN,
  informationPanelTabsClose: wN,
  informationPanelTabsAbout: DN,
  informationPanelTabsAnnotations: PN,
  informationPanelTabsSearch: ON,
  informationPanelToggle: NN,
  shareCollectionJson: MN,
  shareCollectionCopy: FN,
  shareManifestJson: BN,
  shareManifestCopy: UN
}, HN = "Lukk", GN = "Neste", VN = "Forrige", zN = "SÃ¸k", qN = "SÃ¸k...", jN = "Del", KN = "Se alle", WN = "Feilet", YN = "Kopiert", XN = "Laster inn...", QN = "SÃ¸k", ZN = "Ingen resultat", JN = "Flere resultat", e8 = "Velg", t8 = "Viewer", n8 = "Om", r8 = "Annoteringer", i8 = "SÃ¸k", s8 = "Mer informasjon", a8 = "Se samlingen", o8 = "KopiÃ©r samlingens URL", u8 = "Se manifestet", l8 = "KopiÃ©r manifestets URL", c8 = {
  commonClose: HN,
  commonNext: GN,
  commonPrevious: VN,
  commonSearch: zN,
  commonSearchPlaceholder: qN,
  commonShare: jN,
  commonViewAll: KN,
  copyFailure: WN,
  copySuccess: YN,
  contentSearchLoading: XN,
  contentSearchPlaceholder: QN,
  contentSearchResultsNone: ZN,
  contentSearchResultsMore: JN,
  informationPanelTabs: e8,
  informationPanelTabsClose: t8,
  informationPanelTabsAbout: n8,
  informationPanelTabsAnnotations: r8,
  informationPanelTabsSearch: i8,
  informationPanelToggle: s8,
  shareCollectionJson: a8,
  shareCollectionCopy: o8,
  shareManifestJson: u8,
  shareManifestCopy: l8
}, d8 = {}, f8 = {
  en: uT,
  fi: p4,
  fr: j4,
  nb: gN,
  nn: $N,
  no: c8,
  pt: d8
}, yu = "clover", h8 = Object.fromEntries(
  Object.entries(f8).map(([t, e]) => [
    t,
    { [yu]: e }
  ])
), Ss = {
  defaultNS: yu,
  fallbackLng: "en",
  ns: [yu],
  resources: { ...h8 }
}, m8 = (t, e) => ({
  ...t || {},
  ...e || {}
});
let rp = !1;
function p8(t) {
  if (t) {
    for (const [e, n] of Object.entries(t))
      if (n)
        for (const [r, i] of Object.entries(n))
          i && ks.addResourceBundle(e, r, i, !0, !0);
  }
}
function g8(t = {}) {
  if (rp)
    p8(t.resources), t.lng && ks.changeLanguage(t.lng), t.fallbackLng && (ks.options.fallbackLng = t.fallbackLng);
  else {
    const e = m8(Ss.resources, t.resources);
    ks.use(s2).use(r2).init({
      ...Ss,
      ...t,
      resources: e,
      // Preserve our namespace defaults unless explicitly overridden.
      ns: t.ns ?? Ss.ns,
      defaultNS: t.defaultNS ?? Ss.defaultNS,
      fallbackLng: t.fallbackLng ?? Ss.fallbackLng
    }), rp = !0;
  }
  return ks;
}
g8();
const b8 = uT;
function E8(t) {
  return b8[t] ?? t;
}
function y8(t = yu) {
  const e = i2(t), { t: n } = e, r = Fg(
    (i, s) => {
      const a = n(i, s);
      return typeof a != "string" || a === i ? E8(i) : a;
    },
    [n]
  );
  return {
    ...e,
    t: r
  };
}
const T8 = () => /* @__PURE__ */ $.createElement(
  "path",
  {
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M256 112v288M400 256H112"
  }
), x8 = () => /* @__PURE__ */ $.createElement(
  "path",
  {
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M400 256H112"
  }
), S8 = () => /* @__PURE__ */ $.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M432 320v112H320M421.8 421.77L304 304M80 192V80h112M90.2 90.23L208 208M320 80h112v112M421.77 90.2L304 208M192 432H80V320M90.23 421.8L208 304"
  }
), A8 = () => /* @__PURE__ */ $.createElement("path", { d: "M448 440a16 16 0 01-12.61-6.15c-22.86-29.27-44.07-51.86-73.32-67C335 352.88 301 345.59 256 344.23V424a16 16 0 01-27 11.57l-176-168a16 16 0 010-23.14l176-168A16 16 0 01256 88v80.36c74.14 3.41 129.38 30.91 164.35 81.87C449.32 292.44 464 350.9 464 424a16 16 0 01-16 16z" }), ip = () => /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
  "path",
  {
    fill: "none",
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M400 148l-21.12-24.57A191.43 191.43 0 00240 64C134 64 48 150 48 256s86 192 192 192a192.09 192.09 0 00181.07-128"
  }
), /* @__PURE__ */ $.createElement("path", { d: "M464 97.42V208a16 16 0 01-16 16H337.42c-14.26 0-21.4-17.23-11.32-27.31L436.69 86.1C446.77 76 464 83.16 464 97.42z" })), v8 = ({
  _cloverViewerHasPlaceholder: t,
  config: e
}) => {
  const { t: n } = y8(), r = np(), { activeCanvas: i, plugins: s, vault: a, openSeadragonViewer: o } = r, u = a.get({
    id: i,
    type: "Canvas"
  });
  function l() {
    return s.filter((c) => {
      var d;
      return (d = c.imageViewer) == null ? void 0 : d.controls;
    }).map((c, d) => {
      var h, m, p, g;
      const f = (m = (h = c.imageViewer) == null ? void 0 : h.controls) == null ? void 0 : m.component;
      return /* @__PURE__ */ $.createElement(
        f,
        {
          key: d,
          ...(g = (p = c == null ? void 0 : c.imageViewer) == null ? void 0 : p.controls) == null ? void 0 : g.componentProps,
          canvas: u,
          useViewerDispatch: oT,
          useViewerState: np
        }
      );
    });
  }
  return lt(() => {
    if (!o) return;
    const c = o.viewport.getRotation();
    o.addHandler("home", () => {
      o.viewport.setRotation(c);
    });
  }, [o]), /* @__PURE__ */ $.createElement(
    pO,
    {
      "data-testid": "clover-iiif-image-openseadragon-controls",
      hasPlaceholder: t
    },
    e.showZoomControl && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(Ei, { id: e.zoomInButton, label: n("imageZoomIn") }, /* @__PURE__ */ $.createElement(T8, null)), /* @__PURE__ */ $.createElement(Ei, { id: e.zoomOutButton, label: n("imageZoomOut") }, /* @__PURE__ */ $.createElement(x8, null))),
    e.showFullPageControl && /* @__PURE__ */ $.createElement(
      Ei,
      {
        id: e.fullPageButton,
        label: n("imageFullScreen")
      },
      /* @__PURE__ */ $.createElement(S8, null)
    ),
    e.showRotationControl && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
      Ei,
      {
        id: e.rotateRightButton,
        label: n("imageRotateRight")
      },
      /* @__PURE__ */ $.createElement(ip, null)
    ), /* @__PURE__ */ $.createElement(
      Ei,
      {
        id: e.rotateLeftButton,
        label: n("imageRotateLeft")
      },
      /* @__PURE__ */ $.createElement(ip, null)
    )),
    e.showHomeControl && /* @__PURE__ */ $.createElement(Ei, { id: e.homeButton, label: n("imageResetZoom") }, /* @__PURE__ */ $.createElement(A8, null)),
    l()
  );
};
async function lT(t, e = 3, n = 500) {
  try {
    return await t();
  } catch (r) {
    if (e <= 0) throw r;
    return await new Promise((i) => setTimeout(i, n)), lT(t, e - 1, n);
  }
}
const I8 = (t) => new Promise((e) => setTimeout(e, t)), sp = async (t, e, n = 3, r = 300) => {
  for (let i = 0; i < n; i++) {
    const s = e ? e - 1 : 0, a = t.getItemAt(s);
    if (a) return a;
    await I8(r);
  }
  throw new Error("No base item found at index 0 after retries");
}, C8 = ({
  annotations: t,
  ariaLabel: e,
  config: n,
  uri: r,
  _cloverViewerHasPlaceholder: i,
  imageType: s,
  openSeadragonCallback: a
}) => {
  const [o, u] = sn([]), [l, c] = sn([]), [d, f] = sn(), [h, m] = sn([]), p = oT(), g = Ji(!1), E = "clover-iiif-image-openseadragon-annotation", y = n.gestureSettingsMouse.scrollToZoom === !1;
  lt(() => (g.current || (g.current = !0, d || f(Rs(n))), () => d == null ? void 0 : d.destroy()), []), lt(() => {
    T();
  }, [d, a]), lt(() => {
    d && JSON.stringify(r) !== JSON.stringify(l) && (d.forceRedraw(), y && d.addHandler("canvas-scroll", function(S) {
      S.preventDefault = !1;
    }), c(r));
  }, [y, d, l, r]), lt(() => {
    if (!l.length || !d) return;
    d.close(), (async () => {
      switch (s) {
        case "simpleImage":
          let v = 1, I = 0;
          for (let C = 0; C < l.length; C++) {
            const D = l[C];
            if (t) {
              const _ = new Image();
              _.src = D, await _.decode(), m((A) => [
                ...A,
                { width: _ == null ? void 0 : _.width, height: _ == null ? void 0 : _.height }
              ]);
            }
            try {
              if (C !== 0) {
                const A = (await sp(
                  d.world,
                  C
                )).getBounds();
                I = A.x + A.width, v = A.height;
              }
              d.addSimpleImage({
                url: D,
                x: I,
                y: 0,
                height: v,
                success: () => {
                  u((_) => [..._, D]), typeof p == "function" && p({
                    type: "updateOSDImageLoaded",
                    OSDImageLoaded: !0
                  });
                }
              });
            } catch (_) {
              console.error(`Failed to load image at ${D}:`, _);
            }
          }
          break;
        case "tiledImage": {
          let C = 1, D = 0;
          for (let _ = 0; _ < l.length; _++) {
            const A = l[_];
            try {
              const L = await lT(
                () => zP(A),
                3,
                1e3
              );
              if (!L) throw new Error(`No tile source for ${A}`);
              if (_ !== 0) {
                const U = (await sp(
                  d.world,
                  _
                )).getBounds();
                D = U.x + U.width, C = U.height;
              }
              d.addTiledImage({
                tileSource: L,
                x: D,
                y: 0,
                height: C,
                success: () => {
                  u((N) => [...N, A]), typeof p == "function" && p({
                    type: "updateOSDImageLoaded",
                    OSDImageLoaded: !0
                  });
                }
              });
            } catch (L) {
              console.error(`Failed to load tile at ${A}:`, L);
            }
          }
          break;
        }
        default:
          console.warn(`Unsupported imageType: "${s}"`);
          break;
      }
    })().catch((v) => console.error("Error drawing tiles", v));
  }, [l, s, d]), lt(() => {
    if (o) {
      let v = 0;
      const I = () => {
        if (v < 3) {
          const C = d == null ? void 0 : d.world.getHomeBounds();
          C && (d == null || d.viewport.fitBounds(C, !0)), v++, setTimeout(I, 50);
        }
      };
      I(), d == null || d.addHandler("canvas-click", (C) => {
        const D = d == null ? void 0 : d.getOverlayById(
          C.originalTarget.id
        );
        if (D) {
          const _ = D == null ? void 0 : D.getBounds(d.viewport);
          return _.x -= 0.1, _.y -= 0.1, _.width += 0.2, _.height += 0.2, d == null || d.viewport.fitBounds(_, !1), C.preventDefaultAction = !0;
        }
      });
    }
  }, [o]), lt(() => {
    function S(v, I, C) {
      let D = v * C;
      if (I === 0) return D;
      for (; I > 0; ) {
        const _ = d == null ? void 0 : d.world.getItemAt(I - 1);
        if (_) {
          const A = _.getBounds().width;
          D += A, I--;
        } else
          break;
      }
      return D;
    }
    t && (d == null || d.clearOverlays(), t.forEach((v) => {
      var U, z, O, F;
      const { annotation: I, targetIndex: C } = v, D = ((z = (U = d == null ? void 0 : d.viewport) == null ? void 0 : U.getBounds()) == null ? void 0 : z.width) || 1, _ = d == null ? void 0 : d.world.getItemAt(C), A = _ ? (_ == null ? void 0 : _.getBounds().width) / (_ == null ? void 0 : _.getContentSize().x) : ((O = h[C]) == null ? void 0 : O.width) / D, L = X6(
        I == null ? void 0 : I.target
      ), N = I != null && I.body ? (F = I == null ? void 0 : I.body[0]) == null ? void 0 : F.value : void 0;
      if (L != null && L.rect) {
        const { x: B, y: H, w: X, h: w } = L == null ? void 0 : L.rect, Q = S(B, C, A), J = new Rs.Rect(
          Q,
          H * A,
          X * A,
          w * A
        ), R = document.createElement("button");
        if (R.classList.add(E), R.id = I.id, R.setAttribute("tabindex", "0"), R.setAttribute("role", "button"), R.setAttribute("data-active", "true"), R.setAttribute("tabindex", "0"), R.setAttribute("role", "button"), R.setAttribute("data-active", "false"), N) {
          R.setAttribute("aria-label", N);
          const te = document.createElement("label");
          te.innerHTML = N, R.appendChild(te);
        }
        R.addEventListener("mousedown", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), R.addEventListener("touchstart", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), R.addEventListener("click", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), R.addEventListener("keydown", (te) => {
          if (te.key === "Enter") {
            te.stopPropagation(), te.preventDefault();
            const he = new Rs.Rect(
              J.x - 0.1,
              J.y - 0.1,
              J.width + 0.2,
              J.height + 0.2
            );
            d == null || d.viewport.fitBounds(he, !1);
          }
        }), R.addEventListener("focus", () => {
          R.setAttribute("data-active", "true");
        }), R.addEventListener("mouseover", () => {
          R.setAttribute("data-active", "true");
        }), R.addEventListener("mouseout", () => {
          R.removeAttribute("data-active");
        }), R.addEventListener("blur", () => {
          R.removeAttribute("data-active");
        }), d == null || d.addOverlay(R, J, Rs.Placement.CENTER);
      }
    }), T());
  }, [o, t]);
  function T() {
    d && (a == null || a(d));
  }
  return /* @__PURE__ */ $.createElement(
    nO,
    {
      className: "clover-iiif-image-openseadragon",
      "data-testid": "clover-iiif-image-openseadragon",
      "data-openseadragon-instance": n.id,
      hasNavigator: n.showNavigator
    },
    /* @__PURE__ */ $.createElement(
      v8,
      {
        _cloverViewerHasPlaceholder: i,
        config: n
      }
    ),
    n.showNavigator && /* @__PURE__ */ $.createElement(
      fd,
      {
        id: n.navigatorId,
        "data-testid": "clover-iiif-image-openseadragon-navigator"
      }
    ),
    /* @__PURE__ */ $.createElement(
      tO,
      {
        id: n.id,
        "data-testid": "clover-iiif-image-openseadragon-viewport",
        role: "img",
        ...e && { "aria-label": e }
      }
    )
  );
};
function L8(t) {
  return {
    id: `openseadragon-${t}`,
    navigatorId: `openseadragon-navigator-${t}`,
    loadTilesWithAjax: !0,
    fullPageButton: `fullPage-${t}`,
    homeButton: `reset-${t}`,
    rotateLeftButton: `rotateLeft-${t}`,
    rotateRightButton: `rotateRight-${t}`,
    zoomInButton: `zoomIn-${t}`,
    zoomOutButton: `zoomOut-${t}`,
    showNavigator: !0,
    showFullPageControl: !0,
    showHomeControl: !0,
    showRotationControl: !0,
    showZoomControl: !0,
    navigatorBorderColor: "transparent",
    gestureSettingsMouse: {
      clickToZoom: !0,
      dblClickToZoom: !0,
      pinchToZoom: !0,
      scrollToZoom: !1
    }
  };
}
const _8 = ({
  _cloverViewerHasPlaceholder: t = !1,
  annotations: e,
  body: n,
  instanceId: r,
  isTiledImage: i = !1,
  label: s,
  src: a = "",
  openSeadragonCallback: o,
  openSeadragonConfig: u = {}
}) => {
  const l = r ?? iT(), c = typeof s == "string" ? s : Ru(s), d = {
    ...L8(l),
    ...u
  }, f = Array.isArray(n) ? n : n ? [n] : [], h = Array.isArray(a) ? a : a ? [a] : [];
  let m = [], p = en.SimpleImage;
  if (f.length) {
    const E = f.map(jP);
    m = E.map((y) => y.uri).filter(Boolean), p = E.some(
      (y) => y.imageType === en.TiledImage
    ) ? en.TiledImage : en.SimpleImage;
  } else if (h.length) {
    const E = h.map((y) => KP(y, i));
    m = E.map((y) => y.uri).filter(Boolean), p = E.some(
      (y) => y.imageType === en.TiledImage
    ) ? en.TiledImage : en.SimpleImage;
  }
  if (!m.length) return null;
  const g = (E) => {
    o == null || o(E);
  };
  return /* @__PURE__ */ $.createElement(YP, { FallbackComponent: eO }, /* @__PURE__ */ $.createElement(
    C8,
    {
      _cloverViewerHasPlaceholder: t,
      annotations: e,
      ariaLabel: c,
      config: d,
      imageType: p,
      key: l,
      uri: m,
      openSeadragonCallback: g
    }
  ));
}, R8 = fe("div", {
  width: "100%",
  height: "100%",
  background: "#6662",
  backgroundSize: "contain",
  color: "white",
  position: "relative",
  zIndex: "1",
  overflow: "hidden"
}), k8 = ({
  body: t,
  thumbnail: e,
  label: n,
  display: r
}) => {
  let i = t;
  return e != null && e.length && (i = {
    id: e[0].id,
    type: "Image"
  }), /* @__PURE__ */ $.createElement(R8, { "data-testid": "scroll-figure" }, r === "thumbnail" ? /* @__PURE__ */ $.createElement(
    Ak,
    {
      "data-testid": "scroll-figure-thumbnail",
      thumbnail: [i],
      style: {
        width: "100%",
        height: "100%",
        objectFit: "contain",
        objectPosition: "center"
      },
      altAsLabel: n
    }
  ) : /* @__PURE__ */ $.createElement(
    _8,
    {
      "data-testid": "scroll-figure-image",
      body: t,
      openSeadragonConfig: { showNavigator: !1, showHomeControl: !1 },
      ...n && { label: n }
    }
  ));
}, w8 = $.memo(k8), D8 = (t, e, n, r) => {
  var a, o;
  const i = {
    canvas: void 0,
    accompanyingCanvas: void 0,
    annotationPage: void 0,
    annotations: []
  }, s = (u) => {
    if (u) {
      if (!u.body || !u.motivation) {
        console.error(
          "Invalid annotation after Hyperion parsing: missing either 'body' or 'motivation'",
          u
        );
        return;
      }
      let l = u.body;
      Array.isArray(l) && (l = l[0]);
      const c = t.get(l.id);
      if (!c) return;
      switch (n) {
        case "painting":
          return u.target === e.id && u.motivation && u.motivation[0] === "painting" && r.includes(c.type) && (u.body = c), !!u;
        case "supplementing":
          return;
        default:
          throw new Error("Invalid annotation motivation.");
      }
    }
  };
  if (i.canvas = t.get(e), i.canvas && (i.annotationPage = t.get(i.canvas.items[0]), i.accompanyingCanvas = (a = i.canvas) != null && a.accompanyingCanvas ? t.get((o = i.canvas) == null ? void 0 : o.accompanyingCanvas) : void 0), i.annotationPage) {
    const u = t.get(i.annotationPage.items).map((c) => ({
      body: t.get(c.body[0].id),
      motivation: c.motivation,
      type: "Annotation"
    })), l = [];
    u.forEach((c) => {
      c.body.type === "Choice" ? c.body.items.forEach(
        (d) => l.push({
          ...c,
          id: d.id,
          body: t.get(d.id)
        })
      ) : l.push(c);
    }), i.annotations = l.filter(s);
  }
  return i;
}, P8 = (t, e) => {
  const n = D8(
    t,
    { id: e, type: "Canvas" },
    "painting",
    ["Image", "Sound", "Video"]
  );
  if (n.annotations.length !== 0 && n.annotations && n.annotations)
    return n.annotations.map(
      (r) => r == null ? void 0 : r.body
    );
}, O8 = ({ canvas: t, canvasInfo: e }) => {
  var l, c;
  const { state: n } = $n(gn), { vault: r, options: i } = n, s = i.figure || {}, a = s.display || ((l = Cn.options.figure) == null ? void 0 : l.display) || "image-viewer", o = s.aspectRatio || ((c = Cn.options.figure) == null ? void 0 : c.aspectRatio) || 100 / 61.8, u = P8(r, t.id);
  return u ? /* @__PURE__ */ $.createElement(GP, null, u == null ? void 0 : u.map((d) => /* @__PURE__ */ $.createElement(HP, { ratio: o, key: d == null ? void 0 : d.id }, /* @__PURE__ */ $.createElement(
    w8,
    {
      body: d,
      thumbnail: t.thumbnail,
      label: t == null ? void 0 : t.label,
      display: a
    }
  ))), /* @__PURE__ */ $.createElement(VP, { canvas: t, canvasInfo: e })) : null;
}, Yl = "255, 197, 32", N8 = fe("div", {
  opacity: "1",
  "&[dir=rtl]": {
    textAlign: "right"
  },
  "&[data-active-language=false]": {
    opacity: "0",
    width: "0",
    height: "0"
  },
  ul: {
    padding: "1rem"
  },
  li: {
    listStyleType: "disc",
    li: {
      listStyleType: "circle"
    }
  },
  "span.clover-scroll-highlight": {
    position: "relative",
    fontWeight: "bold",
    "&.active": {
      "&::before": {
        top: "0",
        position: "absolute",
        display: "inline",
        content: "",
        width: "calc(100% + 4px)",
        height: "calc(100% + 2px) ",
        marginLeft: "-2px",
        borderRadius: "3px",
        border: `1px solid rgba(${Yl}, 0.2)`,
        borderBottom: `1px solid rgba(${Yl}, 0.618)`,
        boxShadow: "1px 1px 1px #6661"
      },
      "&::after": {
        left: "0",
        top: "0",
        position: "absolute",
        display: "inline",
        content: "",
        width: "calc(100% + 4px)",
        height: "calc(100% + 2px) ",
        marginLeft: "-2px",
        marginTop: "-1px",
        borderRadius: "3px",
        backgroundColor: `rgba(${Yl}, 0.2)`,
        zIndex: -1
      }
    },
    "&::before": {
      top: "0",
      position: "absolute",
      display: "inline",
      content: "",
      width: "calc(100% + 4px)",
      height: "calc(100% + 2px) ",
      marginLeft: "-2px",
      borderRadius: "3px",
      border: "1px solid #6663",
      borderBottom: "1px solid #6664",
      boxShadow: "1px 1px 1px #6661"
    },
    "&::after": {
      left: "0",
      top: "0",
      position: "absolute",
      display: "inline",
      content: "",
      width: "calc(100% + 4px)",
      height: "calc(100% + 2px) ",
      marginLeft: "-2px",
      marginTop: "-1px",
      borderRadius: "3px",
      backgroundColor: "#6661",
      zIndex: -1
    }
  }
}), M8 = ({
  searchString: t = "",
  content: e,
  stringLength: n = 150
}) => {
  const r = e.toLowerCase().indexOf(t.toLowerCase());
  if (r !== -1) {
    let i = Math.max(0, r - n / 2), s = Math.min(
      e.length,
      r + t.length + n / 2
    );
    if (i > 0) {
      const a = e.lastIndexOf(" ", i + 1);
      i = a > 0 ? a + 1 : i;
    }
    if (s < e.length) {
      const a = e.indexOf(" ", s - 1);
      s = a > -1 ? a : s;
    }
    e = (i > 0 ? "... " : "") + e.substring(i, s) + (s < e.length ? " ..." : "");
  } else
    e = e.substring(0, n) + "...";
  return e;
}, cT = -1, Yu = 0, Us = 1, Tu = 2, Kf = 3, Wf = 4, Yf = 5, Xf = 6, dT = 7, fT = 8, ap = typeof self == "object" ? self : globalThis, F8 = (t, e) => {
  const n = (i, s) => (t.set(s, i), i), r = (i) => {
    if (t.has(i))
      return t.get(i);
    const [s, a] = e[i];
    switch (s) {
      case Yu:
      case cT:
        return n(a, i);
      case Us: {
        const o = n([], i);
        for (const u of a)
          o.push(r(u));
        return o;
      }
      case Tu: {
        const o = n({}, i);
        for (const [u, l] of a)
          o[r(u)] = r(l);
        return o;
      }
      case Kf:
        return n(new Date(a), i);
      case Wf: {
        const { source: o, flags: u } = a;
        return n(new RegExp(o, u), i);
      }
      case Yf: {
        const o = n(/* @__PURE__ */ new Map(), i);
        for (const [u, l] of a)
          o.set(r(u), r(l));
        return o;
      }
      case Xf: {
        const o = n(/* @__PURE__ */ new Set(), i);
        for (const u of a)
          o.add(r(u));
        return o;
      }
      case dT: {
        const { name: o, message: u } = a;
        return n(new ap[o](u), i);
      }
      case fT:
        return n(BigInt(a), i);
      case "BigInt":
        return n(Object(BigInt(a)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(a).buffer, a);
      case "DataView": {
        const { buffer: o } = new Uint8Array(a);
        return n(new DataView(o), a);
      }
    }
    return n(new ap[s](a), i);
  };
  return r;
}, op = (t) => F8(/* @__PURE__ */ new Map(), t)(0), yi = "", { toString: B8 } = {}, { keys: U8 } = Object, As = (t) => {
  const e = typeof t;
  if (e !== "object" || !t)
    return [Yu, e];
  const n = B8.call(t).slice(8, -1);
  switch (n) {
    case "Array":
      return [Us, yi];
    case "Object":
      return [Tu, yi];
    case "Date":
      return [Kf, yi];
    case "RegExp":
      return [Wf, yi];
    case "Map":
      return [Yf, yi];
    case "Set":
      return [Xf, yi];
    case "DataView":
      return [Us, n];
  }
  return n.includes("Array") ? [Us, n] : n.includes("Error") ? [dT, n] : [Tu, n];
}, yo = ([t, e]) => t === Yu && (e === "function" || e === "symbol"), $8 = (t, e, n, r) => {
  const i = (a, o) => {
    const u = r.push(a) - 1;
    return n.set(o, u), u;
  }, s = (a) => {
    if (n.has(a))
      return n.get(a);
    let [o, u] = As(a);
    switch (o) {
      case Yu: {
        let c = a;
        switch (u) {
          case "bigint":
            o = fT, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (t)
              throw new TypeError("unable to serialize " + u);
            c = null;
            break;
          case "undefined":
            return i([cT], a);
        }
        return i([o, c], a);
      }
      case Us: {
        if (u) {
          let f = a;
          return u === "DataView" ? f = new Uint8Array(a.buffer) : u === "ArrayBuffer" && (f = new Uint8Array(a)), i([u, [...f]], a);
        }
        const c = [], d = i([o, c], a);
        for (const f of a)
          c.push(s(f));
        return d;
      }
      case Tu: {
        if (u)
          switch (u) {
            case "BigInt":
              return i([u, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([u, a.valueOf()], a);
          }
        if (e && "toJSON" in a)
          return s(a.toJSON());
        const c = [], d = i([o, c], a);
        for (const f of U8(a))
          (t || !yo(As(a[f]))) && c.push([s(f), s(a[f])]);
        return d;
      }
      case Kf:
        return i([o, a.toISOString()], a);
      case Wf: {
        const { source: c, flags: d } = a;
        return i([o, { source: c, flags: d }], a);
      }
      case Yf: {
        const c = [], d = i([o, c], a);
        for (const [f, h] of a)
          (t || !(yo(As(f)) || yo(As(h)))) && c.push([s(f), s(h)]);
        return d;
      }
      case Xf: {
        const c = [], d = i([o, c], a);
        for (const f of a)
          (t || !yo(As(f))) && c.push(s(f));
        return d;
      }
    }
    const { message: l } = a;
    return i([o, { name: u, message: l }], a);
  };
  return s;
}, up = (t, { json: e, lossy: n } = {}) => {
  const r = [];
  return $8(!(e || n), !!e, /* @__PURE__ */ new Map(), r)(t), r;
}, Xi = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (t, e) => e && ("json" in e || "lossy" in e) ? op(up(t, e)) : structuredClone(t)
) : (t, e) => op(up(t, e));
let La = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
La.prototype.normal = {};
La.prototype.property = {};
La.prototype.space = void 0;
function hT(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new La(n, r, e);
}
function da(t) {
  return t.toLowerCase();
}
let Ft = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
};
Ft.prototype.attribute = "";
Ft.prototype.booleanish = !1;
Ft.prototype.boolean = !1;
Ft.prototype.commaOrSpaceSeparated = !1;
Ft.prototype.commaSeparated = !1;
Ft.prototype.defined = !1;
Ft.prototype.mustUseProperty = !1;
Ft.prototype.number = !1;
Ft.prototype.overloadedBoolean = !1;
Ft.prototype.property = "";
Ft.prototype.spaceSeparated = !1;
Ft.prototype.space = void 0;
let H8 = 0;
const Ae = ti(), st = ti(), md = ti(), ne = ti(), qe = ti(), Pi = ti(), zt = ti();
function ti() {
  return 2 ** ++H8;
}
const pd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Ae,
  booleanish: st,
  commaOrSpaceSeparated: zt,
  commaSeparated: Pi,
  number: ne,
  overloadedBoolean: md,
  spaceSeparated: qe
}, Symbol.toStringTag, { value: "Module" })), Xl = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(pd)
);
let Qf = class extends Ft {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), lp(this, "space", i), typeof r == "number")
      for (; ++s < Xl.length; ) {
        const a = Xl[s];
        lp(this, Xl[s], (r & pd[a]) === pd[a]);
      }
  }
};
Qf.prototype.defined = !0;
function lp(t, e, n) {
  n && (t[e] = n);
}
function ss(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new Qf(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[da(r)] = r, n[da(s.attribute)] = r;
  }
  return new La(e, n, t.space);
}
const mT = ss({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: st,
    ariaAutoComplete: null,
    ariaBusy: st,
    ariaChecked: st,
    ariaColCount: ne,
    ariaColIndex: ne,
    ariaColSpan: ne,
    ariaControls: qe,
    ariaCurrent: null,
    ariaDescribedBy: qe,
    ariaDetails: null,
    ariaDisabled: st,
    ariaDropEffect: qe,
    ariaErrorMessage: null,
    ariaExpanded: st,
    ariaFlowTo: qe,
    ariaGrabbed: st,
    ariaHasPopup: null,
    ariaHidden: st,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: qe,
    ariaLevel: ne,
    ariaLive: null,
    ariaModal: st,
    ariaMultiLine: st,
    ariaMultiSelectable: st,
    ariaOrientation: null,
    ariaOwns: qe,
    ariaPlaceholder: null,
    ariaPosInSet: ne,
    ariaPressed: st,
    ariaReadOnly: st,
    ariaRelevant: null,
    ariaRequired: st,
    ariaRoleDescription: qe,
    ariaRowCount: ne,
    ariaRowIndex: ne,
    ariaRowSpan: ne,
    ariaSelected: st,
    ariaSetSize: ne,
    ariaSort: null,
    ariaValueMax: ne,
    ariaValueMin: ne,
    ariaValueNow: ne,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function pT(t, e) {
  return e in t ? t[e] : e;
}
function gT(t, e) {
  return pT(t, e.toLowerCase());
}
const G8 = ss({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Pi,
    acceptCharset: qe,
    accessKey: qe,
    action: null,
    allow: null,
    allowFullScreen: Ae,
    allowPaymentRequest: Ae,
    allowUserMedia: Ae,
    alt: null,
    as: null,
    async: Ae,
    autoCapitalize: null,
    autoComplete: qe,
    autoFocus: Ae,
    autoPlay: Ae,
    blocking: qe,
    capture: null,
    charSet: null,
    checked: Ae,
    cite: null,
    className: qe,
    cols: ne,
    colSpan: null,
    content: null,
    contentEditable: st,
    controls: Ae,
    controlsList: qe,
    coords: ne | Pi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Ae,
    defer: Ae,
    dir: null,
    dirName: null,
    disabled: Ae,
    download: md,
    draggable: st,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Ae,
    formTarget: null,
    headers: qe,
    height: ne,
    hidden: md,
    high: ne,
    href: null,
    hrefLang: null,
    htmlFor: qe,
    httpEquiv: qe,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Ae,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Ae,
    itemId: null,
    itemProp: qe,
    itemRef: qe,
    itemScope: Ae,
    itemType: qe,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Ae,
    low: ne,
    manifest: null,
    max: null,
    maxLength: ne,
    media: null,
    method: null,
    min: null,
    minLength: ne,
    multiple: Ae,
    muted: Ae,
    name: null,
    nonce: null,
    noModule: Ae,
    noValidate: Ae,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Ae,
    optimum: ne,
    pattern: null,
    ping: qe,
    placeholder: null,
    playsInline: Ae,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Ae,
    referrerPolicy: null,
    rel: qe,
    required: Ae,
    reversed: Ae,
    rows: ne,
    rowSpan: ne,
    sandbox: qe,
    scope: null,
    scoped: Ae,
    seamless: Ae,
    selected: Ae,
    shadowRootClonable: Ae,
    shadowRootDelegatesFocus: Ae,
    shadowRootMode: null,
    shape: null,
    size: ne,
    sizes: null,
    slot: null,
    span: ne,
    spellCheck: st,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ne,
    step: null,
    style: null,
    tabIndex: ne,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Ae,
    useMap: null,
    value: st,
    width: ne,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: qe,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ne,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ne,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Ae,
    // Lists. Use CSS to reduce space between items instead
    declare: Ae,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ne,
    // `<img>` and `<object>`
    leftMargin: ne,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ne,
    // `<body>`
    marginWidth: ne,
    // `<body>`
    noResize: Ae,
    // `<frame>`
    noHref: Ae,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Ae,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Ae,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ne,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: st,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ne,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ne,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Ae,
    disableRemotePlayback: Ae,
    prefix: null,
    property: null,
    results: ne,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: gT
}), V8 = ss({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: zt,
    accentHeight: ne,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ne,
    amplitude: ne,
    arabicForm: null,
    ascent: ne,
    attributeName: null,
    attributeType: null,
    azimuth: ne,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ne,
    by: null,
    calcMode: null,
    capHeight: ne,
    className: qe,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ne,
    diffuseConstant: ne,
    direction: null,
    display: null,
    dur: null,
    divisor: ne,
    dominantBaseline: null,
    download: Ae,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ne,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ne,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ne,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Pi,
    g2: Pi,
    glyphName: Pi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ne,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ne,
    horizOriginX: ne,
    horizOriginY: ne,
    id: null,
    ideographic: ne,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ne,
    k: ne,
    k1: ne,
    k2: ne,
    k3: ne,
    k4: ne,
    kernelMatrix: zt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ne,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ne,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ne,
    overlineThickness: ne,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ne,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: qe,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ne,
    pointsAtY: ne,
    pointsAtZ: ne,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: zt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: zt,
    rev: zt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: zt,
    requiredFeatures: zt,
    requiredFonts: zt,
    requiredFormats: zt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ne,
    specularExponent: ne,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ne,
    strikethroughThickness: ne,
    string: null,
    stroke: null,
    strokeDashArray: zt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ne,
    strokeOpacity: ne,
    strokeWidth: null,
    style: null,
    surfaceScale: ne,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: zt,
    tabIndex: ne,
    tableValues: null,
    target: null,
    targetX: ne,
    targetY: ne,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: zt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ne,
    underlineThickness: ne,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ne,
    values: null,
    vAlphabetic: ne,
    vMathematical: ne,
    vectorEffect: null,
    vHanging: ne,
    vIdeographic: ne,
    version: null,
    vertAdvY: ne,
    vertOriginX: ne,
    vertOriginY: ne,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ne,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: pT
}), bT = ss({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), ET = ss({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: gT
}), yT = ss({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), z8 = /[A-Z]/g, cp = /-[a-z]/g, q8 = /^data[-\w.:]+$/i;
function j8(t, e) {
  const n = da(e);
  let r = e, i = Ft;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && q8.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(cp, W8);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!cp.test(s)) {
        let a = s.replace(z8, K8);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = Qf;
  }
  return new i(r, e);
}
function K8(t) {
  return "-" + t.toLowerCase();
}
function W8(t) {
  return t.charAt(1).toUpperCase();
}
const Y8 = hT([mT, G8, bT, ET, yT], "html"), X8 = hT([mT, V8, bT, ET, yT], "svg");
function dp(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), i = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = n.length, s = !0);
    const a = n.slice(i, r).trim();
    (a || !s) && e.push(a), i = r + 1, r = n.indexOf(",", i);
  }
  return e;
}
function TT(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const fp = /[#.]/g;
function Q8(t, e) {
  const n = t || "", r = {};
  let i = 0, s, a;
  for (; i < n.length; ) {
    fp.lastIndex = i;
    const o = fp.exec(n), u = n.slice(i, o ? o.index : n.length);
    u && (s ? s === "#" ? r.id = u : Array.isArray(r.className) ? r.className.push(u) : r.className = [u] : a = u, i += u.length), o && (s = o[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: a || e || "div",
    properties: r,
    children: []
  };
}
function hp(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function xT(t) {
  return t.join(" ").trim();
}
function ST(t, e, n) {
  const r = n ? tM(n) : void 0;
  function i(s, a, ...o) {
    let u;
    if (s == null) {
      u = { type: "root", children: [] };
      const l = (
        /** @type {Child} */
        a
      );
      o.unshift(l);
    } else {
      u = Q8(s, e);
      const l = u.tagName.toLowerCase(), c = r ? r.get(l) : void 0;
      if (u.tagName = c || l, Z8(a))
        o.unshift(a);
      else
        for (const [d, f] of Object.entries(a))
          J8(t, u.properties, d, f);
    }
    for (const l of o)
      gd(u.children, l);
    return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
  }
  return i;
}
function Z8(t) {
  if (t === null || typeof t != "object" || Array.isArray(t))
    return !0;
  if (typeof t.type != "string") return !1;
  const e = (
    /** @type {Record<string, unknown>} */
    t
  ), n = Object.keys(t);
  for (const r of n) {
    const i = e[r];
    if (i && typeof i == "object") {
      if (!Array.isArray(i)) return !0;
      const s = (
        /** @type {ReadonlyArray<unknown>} */
        i
      );
      for (const a of s)
        if (typeof a != "number" && typeof a != "string")
          return !0;
    }
  }
  return !!("children" in t && Array.isArray(t.children));
}
function J8(t, e, n, r) {
  const i = j8(t, n);
  let s;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      s = r;
    } else typeof r == "boolean" ? s = r : typeof r == "string" ? i.spaceSeparated ? s = hp(r) : i.commaSeparated ? s = dp(r) : i.commaOrSpaceSeparated ? s = hp(dp(r).join(" ")) : s = mp(i, i.property, r) : Array.isArray(r) ? s = [...r] : s = i.property === "style" ? eM(r) : String(r);
    if (Array.isArray(s)) {
      const a = [];
      for (const o of s)
        a.push(
          /** @type {number | string} */
          mp(i, i.property, o)
        );
      s = a;
    }
    i.property === "className" && Array.isArray(e.className) && (s = e.className.concat(
      /** @type {Array<number | string> | number | string} */
      s
    )), e[i.property] = s;
  }
}
function gd(t, e) {
  if (e != null) if (typeof e == "number" || typeof e == "string")
    t.push({ type: "text", value: String(e) });
  else if (Array.isArray(e))
    for (const n of e)
      gd(t, n);
  else if (typeof e == "object" && "type" in e)
    e.type === "root" ? gd(t, e.children) : t.push(e);
  else
    throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function mp(t, e, n) {
  if (typeof n == "string") {
    if (t.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((t.boolean || t.overloadedBoolean) && (n === "" || da(n) === da(e)))
      return !0;
  }
  return n;
}
function eM(t) {
  const e = [];
  for (const [n, r] of Object.entries(t))
    e.push([n, r].join(": "));
  return e.join("; ");
}
function tM(t) {
  const e = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.toLowerCase(), n);
  return e;
}
const nM = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], rM = ST(Y8, "div"), iM = ST(X8, "g", nM);
let _a = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
_a.prototype.normal = {};
_a.prototype.property = {};
_a.prototype.space = void 0;
function AT(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new _a(n, r, e);
}
function bd(t) {
  return t.toLowerCase();
}
let Bt = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
};
Bt.prototype.attribute = "";
Bt.prototype.booleanish = !1;
Bt.prototype.boolean = !1;
Bt.prototype.commaOrSpaceSeparated = !1;
Bt.prototype.commaSeparated = !1;
Bt.prototype.defined = !1;
Bt.prototype.mustUseProperty = !1;
Bt.prototype.number = !1;
Bt.prototype.overloadedBoolean = !1;
Bt.prototype.property = "";
Bt.prototype.spaceSeparated = !1;
Bt.prototype.space = void 0;
let sM = 0;
const ve = ni(), at = ni(), Ed = ni(), re = ni(), je = ni(), Oi = ni(), qt = ni();
function ni() {
  return 2 ** ++sM;
}
const yd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ve,
  booleanish: at,
  commaOrSpaceSeparated: qt,
  commaSeparated: Oi,
  number: re,
  overloadedBoolean: Ed,
  spaceSeparated: je
}, Symbol.toStringTag, { value: "Module" })), Ql = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(yd)
);
let Zf = class extends Bt {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), pp(this, "space", i), typeof r == "number")
      for (; ++s < Ql.length; ) {
        const a = Ql[s];
        pp(this, Ql[s], (r & yd[a]) === yd[a]);
      }
  }
};
Zf.prototype.defined = !0;
function pp(t, e, n) {
  n && (t[e] = n);
}
function as(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new Zf(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[bd(r)] = r, n[bd(s.attribute)] = r;
  }
  return new _a(e, n, t.space);
}
const vT = as({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: at,
    ariaAutoComplete: null,
    ariaBusy: at,
    ariaChecked: at,
    ariaColCount: re,
    ariaColIndex: re,
    ariaColSpan: re,
    ariaControls: je,
    ariaCurrent: null,
    ariaDescribedBy: je,
    ariaDetails: null,
    ariaDisabled: at,
    ariaDropEffect: je,
    ariaErrorMessage: null,
    ariaExpanded: at,
    ariaFlowTo: je,
    ariaGrabbed: at,
    ariaHasPopup: null,
    ariaHidden: at,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: je,
    ariaLevel: re,
    ariaLive: null,
    ariaModal: at,
    ariaMultiLine: at,
    ariaMultiSelectable: at,
    ariaOrientation: null,
    ariaOwns: je,
    ariaPlaceholder: null,
    ariaPosInSet: re,
    ariaPressed: at,
    ariaReadOnly: at,
    ariaRelevant: null,
    ariaRequired: at,
    ariaRoleDescription: je,
    ariaRowCount: re,
    ariaRowIndex: re,
    ariaRowSpan: re,
    ariaSelected: at,
    ariaSetSize: re,
    ariaSort: null,
    ariaValueMax: re,
    ariaValueMin: re,
    ariaValueNow: re,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function IT(t, e) {
  return e in t ? t[e] : e;
}
function CT(t, e) {
  return IT(t, e.toLowerCase());
}
const aM = as({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Oi,
    acceptCharset: je,
    accessKey: je,
    action: null,
    allow: null,
    allowFullScreen: ve,
    allowPaymentRequest: ve,
    allowUserMedia: ve,
    alt: null,
    as: null,
    async: ve,
    autoCapitalize: null,
    autoComplete: je,
    autoFocus: ve,
    autoPlay: ve,
    blocking: je,
    capture: null,
    charSet: null,
    checked: ve,
    cite: null,
    className: je,
    cols: re,
    colSpan: null,
    content: null,
    contentEditable: at,
    controls: ve,
    controlsList: je,
    coords: re | Oi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ve,
    defer: ve,
    dir: null,
    dirName: null,
    disabled: ve,
    download: Ed,
    draggable: at,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ve,
    formTarget: null,
    headers: je,
    height: re,
    hidden: Ed,
    high: re,
    href: null,
    hrefLang: null,
    htmlFor: je,
    httpEquiv: je,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: ve,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ve,
    itemId: null,
    itemProp: je,
    itemRef: je,
    itemScope: ve,
    itemType: je,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ve,
    low: re,
    manifest: null,
    max: null,
    maxLength: re,
    media: null,
    method: null,
    min: null,
    minLength: re,
    multiple: ve,
    muted: ve,
    name: null,
    nonce: null,
    noModule: ve,
    noValidate: ve,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ve,
    optimum: re,
    pattern: null,
    ping: je,
    placeholder: null,
    playsInline: ve,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: ve,
    referrerPolicy: null,
    rel: je,
    required: ve,
    reversed: ve,
    rows: re,
    rowSpan: re,
    sandbox: je,
    scope: null,
    scoped: ve,
    seamless: ve,
    selected: ve,
    shadowRootClonable: ve,
    shadowRootDelegatesFocus: ve,
    shadowRootMode: null,
    shape: null,
    size: re,
    sizes: null,
    slot: null,
    span: re,
    spellCheck: at,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: re,
    step: null,
    style: null,
    tabIndex: re,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ve,
    useMap: null,
    value: at,
    width: re,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: je,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: re,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: re,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ve,
    // Lists. Use CSS to reduce space between items instead
    declare: ve,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: re,
    // `<img>` and `<object>`
    leftMargin: re,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: re,
    // `<body>`
    marginWidth: re,
    // `<body>`
    noResize: ve,
    // `<frame>`
    noHref: ve,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ve,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ve,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: re,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: at,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: re,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: re,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ve,
    disableRemotePlayback: ve,
    prefix: null,
    property: null,
    results: re,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: CT
}), oM = as({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: qt,
    accentHeight: re,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: re,
    amplitude: re,
    arabicForm: null,
    ascent: re,
    attributeName: null,
    attributeType: null,
    azimuth: re,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: re,
    by: null,
    calcMode: null,
    capHeight: re,
    className: je,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: re,
    diffuseConstant: re,
    direction: null,
    display: null,
    dur: null,
    divisor: re,
    dominantBaseline: null,
    download: ve,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: re,
    enableBackground: null,
    end: null,
    event: null,
    exponent: re,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: re,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Oi,
    g2: Oi,
    glyphName: Oi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: re,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: re,
    horizOriginX: re,
    horizOriginY: re,
    id: null,
    ideographic: re,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: re,
    k: re,
    k1: re,
    k2: re,
    k3: re,
    k4: re,
    kernelMatrix: qt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: re,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: re,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: re,
    overlineThickness: re,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: re,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: je,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: re,
    pointsAtY: re,
    pointsAtZ: re,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: qt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: qt,
    rev: qt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: qt,
    requiredFeatures: qt,
    requiredFonts: qt,
    requiredFormats: qt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: re,
    specularExponent: re,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: re,
    strikethroughThickness: re,
    string: null,
    stroke: null,
    strokeDashArray: qt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: re,
    strokeOpacity: re,
    strokeWidth: null,
    style: null,
    surfaceScale: re,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: qt,
    tabIndex: re,
    tableValues: null,
    target: null,
    targetX: re,
    targetY: re,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: qt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: re,
    underlineThickness: re,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: re,
    values: null,
    vAlphabetic: re,
    vMathematical: re,
    vectorEffect: null,
    vHanging: re,
    vIdeographic: re,
    version: null,
    vertAdvY: re,
    vertOriginX: re,
    vertOriginY: re,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: re,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: IT
}), LT = as({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), _T = as({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: CT
}), RT = as({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), uM = /[A-Z]/g, gp = /-[a-z]/g, lM = /^data[-\w.:]+$/i;
function cM(t, e) {
  const n = bd(e);
  let r = e, i = Bt;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && lM.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(gp, fM);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!gp.test(s)) {
        let a = s.replace(uM, dM);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = Zf;
  }
  return new i(r, e);
}
function dM(t) {
  return "-" + t.toLowerCase();
}
function fM(t) {
  return t.charAt(1).toUpperCase();
}
const kT = AT([vT, aM, LT, _T, RT], "html"), wT = AT([vT, oM, LT, _T, RT], "svg");
function hM(t) {
  const e = String(t), n = [];
  return { toOffset: i, toPoint: r };
  function r(s) {
    if (typeof s == "number" && s > -1 && s <= e.length) {
      let a = 0;
      for (; ; ) {
        let o = n[a];
        if (o === void 0) {
          const u = bp(e, n[a - 1]);
          o = u === -1 ? e.length + 1 : u + 1, n[a] = o;
        }
        if (o > s)
          return {
            line: a + 1,
            column: s - (a > 0 ? n[a - 1] : 0) + 1,
            offset: s
          };
        a++;
      }
    }
  }
  function i(s) {
    if (s && typeof s.line == "number" && typeof s.column == "number" && !Number.isNaN(s.line) && !Number.isNaN(s.column)) {
      for (; n.length < s.line; ) {
        const o = n[n.length - 1], u = bp(e, o), l = u === -1 ? e.length + 1 : u + 1;
        if (o === l) break;
        n.push(l);
      }
      const a = (s.line > 1 ? n[s.line - 2] : 0) + s.column - 1;
      if (a < n[s.line - 1]) return a;
    }
  }
}
function bp(t, e) {
  const n = t.indexOf("\r", e), r = t.indexOf(`
`, e);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const $r = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, DT = {}.hasOwnProperty, mM = Object.prototype;
function pM(t, e) {
  const n = e || {};
  return Jf(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? wT : kT,
      verbose: n.verbose || !1
    },
    t
  );
}
function Jf(t, e) {
  let n;
  switch (e.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        e
      );
      return n = { type: "comment", value: r.data }, zo(t, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        e
      ), i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: PT(t, e.childNodes),
        data: { quirksMode: i }
      }, t.file && t.location) {
        const s = String(t.file), a = hM(s), o = a.toPoint(0), u = a.toPoint(s.length);
        n.position = { start: o, end: u };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        e
      );
      return n = { type: "doctype" }, zo(t, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        e
      );
      return n = { type: "text", value: r.value }, zo(t, r, n), n;
    }
    default:
      return n = gM(
        t,
        /** @type {DefaultTreeAdapterMap['element']} */
        e
      ), n;
  }
}
function PT(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; ) {
    const i = (
      /** @type {RootContent} */
      Jf(t, e[n])
    );
    r.push(i);
  }
  return r;
}
function gM(t, e) {
  const n = t.schema;
  t.schema = e.namespaceURI === $r.svg ? wT : kT;
  let r = -1;
  const i = {};
  for (; ++r < e.attrs.length; ) {
    const o = e.attrs[r], u = (o.prefix ? o.prefix + ":" : "") + o.name;
    DT.call(mM, u) || (i[u] = o.value);
  }
  const a = (t.schema.space === "svg" ? iM : rM)(e.tagName, i, PT(t, e.childNodes));
  if (zo(t, e, a), a.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      e
    ), u = o.sourceCodeLocation, l = u && u.startTag && Ci(u.startTag), c = u && u.endTag && Ci(u.endTag), d = (
      /** @type {Root} */
      Jf(t, o.content)
    );
    l && c && t.file && (d.position = { start: l.end, end: c.start }), a.content = d;
  }
  return t.schema = n, a;
}
function zo(t, e, n) {
  if ("sourceCodeLocation" in e && e.sourceCodeLocation && t.file) {
    const r = bM(t, n, e.sourceCodeLocation);
    r && (t.location = !0, n.position = r);
  }
}
function bM(t, e, n) {
  const r = Ci(n);
  if (e.type === "element") {
    const i = e.children[e.children.length - 1];
    if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), t.verbose) {
      const s = {};
      let a;
      if (n.attrs)
        for (a in n.attrs)
          DT.call(n.attrs, a) && (s[cM(t.schema, a).property] = Ci(
            n.attrs[a]
          ));
      n.startTag;
      const o = Ci(n.startTag), u = n.endTag ? Ci(n.endTag) : void 0, l = { opening: o };
      u && (l.closing = u), l.properties = s, e.data = { position: l };
    }
  }
  return r;
}
function Ci(t) {
  const e = Ep({
    line: t.startLine,
    column: t.startCol,
    offset: t.startOffset
  }), n = Ep({
    line: t.endLine,
    column: t.endCol,
    offset: t.endOffset
  });
  return e || n ? { start: e, end: n } : void 0;
}
function Ep(t) {
  return t.line && t.column ? t : void 0;
}
let Ra = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(e, n, r) {
    this.property = e, this.normal = n, r && (this.space = r);
  }
};
Ra.prototype.property = {};
Ra.prototype.normal = {};
Ra.prototype.space = null;
function OT(t, e) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < t.length; )
    Object.assign(n, t[i].property), Object.assign(r, t[i].normal);
  return new Ra(n, r, e);
}
function Td(t) {
  return t.toLowerCase();
}
let ln = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(e, n) {
    this.property = e, this.attribute = n;
  }
};
ln.prototype.space = null;
ln.prototype.boolean = !1;
ln.prototype.booleanish = !1;
ln.prototype.overloadedBoolean = !1;
ln.prototype.number = !1;
ln.prototype.commaSeparated = !1;
ln.prototype.spaceSeparated = !1;
ln.prototype.commaOrSpaceSeparated = !1;
ln.prototype.mustUseProperty = !1;
ln.prototype.defined = !1;
let EM = 0;
const Te = ri(), ot = ri(), NT = ri(), ie = ri(), Ke = ri(), Ni = ri(), jt = ri();
function ri() {
  return 2 ** ++EM;
}
const xd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Te,
  booleanish: ot,
  commaOrSpaceSeparated: jt,
  commaSeparated: Ni,
  number: ie,
  overloadedBoolean: NT,
  spaceSeparated: Ke
}, Symbol.toStringTag, { value: "Module" })), Zl = Object.keys(xd);
let eh = class extends ln {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), yp(this, "space", i), typeof r == "number")
      for (; ++s < Zl.length; ) {
        const a = Zl[s];
        yp(this, Zl[s], (r & xd[a]) === xd[a]);
      }
  }
};
eh.prototype.defined = !0;
function yp(t, e, n) {
  n && (t[e] = n);
}
const yM = {}.hasOwnProperty;
function os(t) {
  const e = {}, n = {};
  let r;
  for (r in t.properties)
    if (yM.call(t.properties, r)) {
      const i = t.properties[r], s = new eh(
        r,
        t.transform(t.attributes || {}, r),
        i,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[Td(r)] = r, n[Td(s.attribute)] = r;
    }
  return new Ra(e, n, t.space);
}
const MT = os({
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), FT = os({
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function BT(t, e) {
  return e in t ? t[e] : e;
}
function UT(t, e) {
  return BT(t, e.toLowerCase());
}
const $T = os({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: UT,
  properties: { xmlns: null, xmlnsXLink: null }
}), HT = os({
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ot,
    ariaAutoComplete: null,
    ariaBusy: ot,
    ariaChecked: ot,
    ariaColCount: ie,
    ariaColIndex: ie,
    ariaColSpan: ie,
    ariaControls: Ke,
    ariaCurrent: null,
    ariaDescribedBy: Ke,
    ariaDetails: null,
    ariaDisabled: ot,
    ariaDropEffect: Ke,
    ariaErrorMessage: null,
    ariaExpanded: ot,
    ariaFlowTo: Ke,
    ariaGrabbed: ot,
    ariaHasPopup: null,
    ariaHidden: ot,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Ke,
    ariaLevel: ie,
    ariaLive: null,
    ariaModal: ot,
    ariaMultiLine: ot,
    ariaMultiSelectable: ot,
    ariaOrientation: null,
    ariaOwns: Ke,
    ariaPlaceholder: null,
    ariaPosInSet: ie,
    ariaPressed: ot,
    ariaReadOnly: ot,
    ariaRelevant: null,
    ariaRequired: ot,
    ariaRoleDescription: Ke,
    ariaRowCount: ie,
    ariaRowIndex: ie,
    ariaRowSpan: ie,
    ariaSelected: ot,
    ariaSetSize: ie,
    ariaSort: null,
    ariaValueMax: ie,
    ariaValueMin: ie,
    ariaValueNow: ie,
    ariaValueText: null,
    role: null
  }
}), TM = os({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: UT,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ni,
    acceptCharset: Ke,
    accessKey: Ke,
    action: null,
    allow: null,
    allowFullScreen: Te,
    allowPaymentRequest: Te,
    allowUserMedia: Te,
    alt: null,
    as: null,
    async: Te,
    autoCapitalize: null,
    autoComplete: Ke,
    autoFocus: Te,
    autoPlay: Te,
    blocking: Ke,
    capture: null,
    charSet: null,
    checked: Te,
    cite: null,
    className: Ke,
    cols: ie,
    colSpan: null,
    content: null,
    contentEditable: ot,
    controls: Te,
    controlsList: Ke,
    coords: ie | Ni,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Te,
    defer: Te,
    dir: null,
    dirName: null,
    disabled: Te,
    download: NT,
    draggable: ot,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Te,
    formTarget: null,
    headers: Ke,
    height: ie,
    hidden: Te,
    high: ie,
    href: null,
    hrefLang: null,
    htmlFor: Ke,
    httpEquiv: Ke,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Te,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Te,
    itemId: null,
    itemProp: Ke,
    itemRef: Ke,
    itemScope: Te,
    itemType: Ke,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Te,
    low: ie,
    manifest: null,
    max: null,
    maxLength: ie,
    media: null,
    method: null,
    min: null,
    minLength: ie,
    multiple: Te,
    muted: Te,
    name: null,
    nonce: null,
    noModule: Te,
    noValidate: Te,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Te,
    optimum: ie,
    pattern: null,
    ping: Ke,
    placeholder: null,
    playsInline: Te,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Te,
    referrerPolicy: null,
    rel: Ke,
    required: Te,
    reversed: Te,
    rows: ie,
    rowSpan: ie,
    sandbox: Ke,
    scope: null,
    scoped: Te,
    seamless: Te,
    selected: Te,
    shadowRootClonable: Te,
    shadowRootDelegatesFocus: Te,
    shadowRootMode: null,
    shape: null,
    size: ie,
    sizes: null,
    slot: null,
    span: ie,
    spellCheck: ot,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ie,
    step: null,
    style: null,
    tabIndex: ie,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Te,
    useMap: null,
    value: ot,
    width: ie,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Ke,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ie,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ie,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Te,
    // Lists. Use CSS to reduce space between items instead
    declare: Te,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ie,
    // `<img>` and `<object>`
    leftMargin: ie,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ie,
    // `<body>`
    marginWidth: ie,
    // `<body>`
    noResize: Te,
    // `<frame>`
    noHref: Te,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Te,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Te,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ie,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ot,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ie,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ie,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Te,
    disableRemotePlayback: Te,
    prefix: null,
    property: null,
    results: ie,
    security: null,
    unselectable: null
  }
}), xM = os({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: BT,
  properties: {
    about: jt,
    accentHeight: ie,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ie,
    amplitude: ie,
    arabicForm: null,
    ascent: ie,
    attributeName: null,
    attributeType: null,
    azimuth: ie,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ie,
    by: null,
    calcMode: null,
    capHeight: ie,
    className: Ke,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ie,
    diffuseConstant: ie,
    direction: null,
    display: null,
    dur: null,
    divisor: ie,
    dominantBaseline: null,
    download: Te,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ie,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ie,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ie,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ni,
    g2: Ni,
    glyphName: Ni,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ie,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ie,
    horizOriginX: ie,
    horizOriginY: ie,
    id: null,
    ideographic: ie,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ie,
    k: ie,
    k1: ie,
    k2: ie,
    k3: ie,
    k4: ie,
    kernelMatrix: jt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ie,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ie,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ie,
    overlineThickness: ie,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ie,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Ke,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ie,
    pointsAtY: ie,
    pointsAtZ: ie,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: jt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: jt,
    rev: jt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: jt,
    requiredFeatures: jt,
    requiredFonts: jt,
    requiredFormats: jt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ie,
    specularExponent: ie,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ie,
    strikethroughThickness: ie,
    string: null,
    stroke: null,
    strokeDashArray: jt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ie,
    strokeOpacity: ie,
    strokeWidth: null,
    style: null,
    surfaceScale: ie,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: jt,
    tabIndex: ie,
    tableValues: null,
    target: null,
    targetX: ie,
    targetY: ie,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: jt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ie,
    underlineThickness: ie,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ie,
    values: null,
    vAlphabetic: ie,
    vMathematical: ie,
    vectorEffect: null,
    vHanging: ie,
    vIdeographic: ie,
    version: null,
    vertAdvY: ie,
    vertOriginX: ie,
    vertOriginY: ie,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ie,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), SM = /^data[-\w.:]+$/i, Tp = /-[a-z]/g, AM = /[A-Z]/g;
function vM(t, e) {
  const n = Td(e);
  let r = e, i = ln;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && SM.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(Tp, CM);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!Tp.test(s)) {
        let a = s.replace(AM, IM);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = eh;
  }
  return new i(r, e);
}
function IM(t) {
  return "-" + t.toLowerCase();
}
function CM(t) {
  return t.charAt(1).toUpperCase();
}
const LM = OT([FT, MT, $T, HT, TM], "html"), GT = OT([FT, MT, $T, HT, xM], "svg"), xp = {}.hasOwnProperty;
function th(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let a = r.invalid;
    const o = r.handlers;
    if (i && xp.call(i, t)) {
      const u = String(i[t]);
      a = xp.call(o, u) ? o[u] : r.unknown;
    }
    if (a)
      return a.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const _M = {}, RM = {}.hasOwnProperty, VT = th("type", { handlers: { root: wM, element: MM, text: OM, comment: NM, doctype: PM } });
function kM(t, e) {
  const r = (e || _M).space;
  return VT(t, r === "svg" ? GT : LM);
}
function wM(t, e) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = nh(t.children, n, e), us(t, n), n;
}
function DM(t, e) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = nh(t.children, n, e), us(t, n), n;
}
function PM(t) {
  const e = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return us(t, e), e;
}
function OM(t) {
  const e = {
    nodeName: "#text",
    value: t.value,
    parentNode: null
  };
  return us(t, e), e;
}
function NM(t) {
  const e = {
    nodeName: "#comment",
    data: t.value,
    parentNode: null
  };
  return us(t, e), e;
}
function MM(t, e) {
  const n = e;
  let r = n;
  t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = GT);
  const i = [];
  let s;
  if (t.properties) {
    for (s in t.properties)
      if (s !== "children" && RM.call(t.properties, s)) {
        const u = FM(
          r,
          s,
          t.properties[s]
        );
        u && i.push(u);
      }
  }
  const a = r.space, o = {
    nodeName: t.tagName,
    tagName: t.tagName,
    attrs: i,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: $r[a],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = nh(t.children, o, r), us(t, o), t.tagName === "template" && t.content && (o.content = DM(t.content, r)), o;
}
function FM(t, e, n) {
  const r = vM(t, e);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? TT(n) : xT(n));
  const i = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const s = i.name.indexOf(":");
    s < 0 ? i.prefix = "" : (i.name = i.name.slice(s + 1), i.prefix = r.attribute.slice(0, s)), i.namespace = $r[r.space];
  }
  return i;
}
function nh(t, e, n) {
  let r = -1;
  const i = [];
  if (t)
    for (; ++r < t.length; ) {
      const s = VT(t[r], n);
      s.parentNode = e, i.push(s);
    }
  return i;
}
function us(t, e) {
  const n = t.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, e.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const zT = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], BM = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), Xe = "ï¿½";
var k;
(function(t) {
  t[t.EOF = -1] = "EOF", t[t.NULL = 0] = "NULL", t[t.TABULATION = 9] = "TABULATION", t[t.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", t[t.LINE_FEED = 10] = "LINE_FEED", t[t.FORM_FEED = 12] = "FORM_FEED", t[t.SPACE = 32] = "SPACE", t[t.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", t[t.QUOTATION_MARK = 34] = "QUOTATION_MARK", t[t.AMPERSAND = 38] = "AMPERSAND", t[t.APOSTROPHE = 39] = "APOSTROPHE", t[t.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", t[t.SOLIDUS = 47] = "SOLIDUS", t[t.DIGIT_0 = 48] = "DIGIT_0", t[t.DIGIT_9 = 57] = "DIGIT_9", t[t.SEMICOLON = 59] = "SEMICOLON", t[t.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", t[t.EQUALS_SIGN = 61] = "EQUALS_SIGN", t[t.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", t[t.QUESTION_MARK = 63] = "QUESTION_MARK", t[t.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", t[t.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", t[t.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", t[t.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", t[t.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", t[t.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(k || (k = {}));
const wt = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function qT(t) {
  return t >= 55296 && t <= 57343;
}
function UM(t) {
  return t >= 56320 && t <= 57343;
}
function $M(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
}
function jT(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
}
function KT(t) {
  return t >= 64976 && t <= 65007 || BM.has(t);
}
var K;
(function(t) {
  t.controlCharacterInInputStream = "control-character-in-input-stream", t.noncharacterInInputStream = "noncharacter-in-input-stream", t.surrogateInInputStream = "surrogate-in-input-stream", t.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", t.endTagWithAttributes = "end-tag-with-attributes", t.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", t.unexpectedSolidusInTag = "unexpected-solidus-in-tag", t.unexpectedNullCharacter = "unexpected-null-character", t.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", t.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", t.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", t.missingEndTagName = "missing-end-tag-name", t.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", t.unknownNamedCharacterReference = "unknown-named-character-reference", t.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", t.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", t.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", t.eofBeforeTagName = "eof-before-tag-name", t.eofInTag = "eof-in-tag", t.missingAttributeValue = "missing-attribute-value", t.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", t.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", t.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", t.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", t.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", t.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", t.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", t.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", t.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", t.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", t.cdataInHtmlContent = "cdata-in-html-content", t.incorrectlyOpenedComment = "incorrectly-opened-comment", t.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", t.eofInDoctype = "eof-in-doctype", t.nestedComment = "nested-comment", t.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", t.eofInComment = "eof-in-comment", t.incorrectlyClosedComment = "incorrectly-closed-comment", t.eofInCdata = "eof-in-cdata", t.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", t.nullCharacterReference = "null-character-reference", t.surrogateCharacterReference = "surrogate-character-reference", t.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", t.controlCharacterReference = "control-character-reference", t.noncharacterCharacterReference = "noncharacter-character-reference", t.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", t.missingDoctypeName = "missing-doctype-name", t.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", t.duplicateAttribute = "duplicate-attribute", t.nonConformingDoctype = "non-conforming-doctype", t.missingDoctype = "missing-doctype", t.misplacedDoctype = "misplaced-doctype", t.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", t.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", t.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", t.openElementsLeftAfterEof = "open-elements-left-after-eof", t.abandonedHeadElementChild = "abandoned-head-element-child", t.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", t.nestedNoscriptInHead = "nested-noscript-in-head", t.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(K || (K = {}));
const HM = 65536;
class GM {
  constructor(e) {
    this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = HM, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(e, n) {
    const { line: r, col: i, offset: s } = this, a = i + n, o = s + n;
    return {
      code: e,
      startLine: r,
      endLine: r,
      startCol: a,
      endCol: a,
      startOffset: o,
      endOffset: o
    };
  }
  _err(e) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (UM(n))
        return this.pos++, this._addGap(), $M(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, k.EOF;
    return this._err(K.surrogateInInputStream), e;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(e, n) {
    this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(e, n) {
    if (this.pos + e.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(e, this.pos);
    for (let r = 0; r < e.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== e.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(e) {
    const n = this.pos + e;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, k.EOF;
    const r = this.html.charCodeAt(n);
    return r === k.CARRIAGE_RETURN ? k.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, k.EOF;
    let e = this.html.charCodeAt(this.pos);
    return e === k.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, k.LINE_FEED) : e === k.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, qT(e) && (e = this._processSurrogate(e)), this.handler.onParseError === null || e > 31 && e < 127 || e === k.LINE_FEED || e === k.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    jT(e) ? this._err(K.controlCharacterInInputStream) : KT(e) && this._err(K.noncharacterInInputStream);
  }
  retreat(e) {
    for (this.pos -= e; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var Re;
(function(t) {
  t[t.CHARACTER = 0] = "CHARACTER", t[t.NULL_CHARACTER = 1] = "NULL_CHARACTER", t[t.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", t[t.START_TAG = 3] = "START_TAG", t[t.END_TAG = 4] = "END_TAG", t[t.COMMENT = 5] = "COMMENT", t[t.DOCTYPE = 6] = "DOCTYPE", t[t.EOF = 7] = "EOF", t[t.HIBERNATION = 8] = "HIBERNATION";
})(Re || (Re = {}));
function WT(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
}
const VM = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ 'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((t) => t.charCodeAt(0))
), zM = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function qM(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = zM.get(t)) !== null && e !== void 0 ? e : t;
}
var gt;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(gt || (gt = {}));
const jM = 32;
var Sr;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Sr || (Sr = {}));
function Sd(t) {
  return t >= gt.ZERO && t <= gt.NINE;
}
function KM(t) {
  return t >= gt.UPPER_A && t <= gt.UPPER_F || t >= gt.LOWER_A && t <= gt.LOWER_F;
}
function WM(t) {
  return t >= gt.UPPER_A && t <= gt.UPPER_Z || t >= gt.LOWER_A && t <= gt.LOWER_Z || Sd(t);
}
function YM(t) {
  return t === gt.EQUALS || WM(t);
}
var pt;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(pt || (pt = {}));
var tr;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(tr || (tr = {}));
class XM {
  constructor(e, n, r) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = r, this.state = pt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = tr.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = pt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case pt.EntityStart:
        return e.charCodeAt(n) === gt.NUM ? (this.state = pt.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = pt.NamedEntity, this.stateNamedEntity(e, n));
      case pt.NumericStart:
        return this.stateNumericStart(e, n);
      case pt.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case pt.NumericHex:
        return this.stateNumericHex(e, n);
      case pt.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | jM) === gt.LOWER_X ? (this.state = pt.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = pt.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + Number.parseInt(e.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (Sd(i) || KM(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (Sd(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === gt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === tr.Strict)
      return 0;
    return this.emitCodePoint(qM(this.result), this.consumed), this.errors && (e !== gt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Sr.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const a = e.charCodeAt(n);
      if (this.treeIndex = QM(r, i, this.treeIndex + Math.max(1, s), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === tr.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        YM(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Sr.VALUE_LENGTH) >> 14, s !== 0) {
        if (a === gt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== tr.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this, i = (r[n] & Sr.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[e] & ~Sr.VALUE_LENGTH : i[e + 1], r), n === 3 && this.emitCodePoint(i[e + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case pt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== tr.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case pt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case pt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case pt.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case pt.EntityStart:
        return 0;
    }
  }
}
function QM(t, e, n, r) {
  const i = (e & Sr.BRANCH_LENGTH) >> 7, s = e & Sr.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const u = r - s;
    return u < 0 || u >= i ? -1 : t[n + u] - 1;
  }
  let a = n, o = a + i - 1;
  for (; a <= o; ) {
    const u = a + o >>> 1, l = t[u];
    if (l < r)
      a = u + 1;
    else if (l > r)
      o = u - 1;
    else
      return t[u + i];
  }
  return -1;
}
var Z;
(function(t) {
  t.HTML = "http://www.w3.org/1999/xhtml", t.MATHML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLINK = "http://www.w3.org/1999/xlink", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/";
})(Z || (Z = {}));
var jr;
(function(t) {
  t.TYPE = "type", t.ACTION = "action", t.ENCODING = "encoding", t.PROMPT = "prompt", t.NAME = "name", t.COLOR = "color", t.FACE = "face", t.SIZE = "size";
})(jr || (jr = {}));
var tn;
(function(t) {
  t.NO_QUIRKS = "no-quirks", t.QUIRKS = "quirks", t.LIMITED_QUIRKS = "limited-quirks";
})(tn || (tn = {}));
var j;
(function(t) {
  t.A = "a", t.ADDRESS = "address", t.ANNOTATION_XML = "annotation-xml", t.APPLET = "applet", t.AREA = "area", t.ARTICLE = "article", t.ASIDE = "aside", t.B = "b", t.BASE = "base", t.BASEFONT = "basefont", t.BGSOUND = "bgsound", t.BIG = "big", t.BLOCKQUOTE = "blockquote", t.BODY = "body", t.BR = "br", t.BUTTON = "button", t.CAPTION = "caption", t.CENTER = "center", t.CODE = "code", t.COL = "col", t.COLGROUP = "colgroup", t.DD = "dd", t.DESC = "desc", t.DETAILS = "details", t.DIALOG = "dialog", t.DIR = "dir", t.DIV = "div", t.DL = "dl", t.DT = "dt", t.EM = "em", t.EMBED = "embed", t.FIELDSET = "fieldset", t.FIGCAPTION = "figcaption", t.FIGURE = "figure", t.FONT = "font", t.FOOTER = "footer", t.FOREIGN_OBJECT = "foreignObject", t.FORM = "form", t.FRAME = "frame", t.FRAMESET = "frameset", t.H1 = "h1", t.H2 = "h2", t.H3 = "h3", t.H4 = "h4", t.H5 = "h5", t.H6 = "h6", t.HEAD = "head", t.HEADER = "header", t.HGROUP = "hgroup", t.HR = "hr", t.HTML = "html", t.I = "i", t.IMG = "img", t.IMAGE = "image", t.INPUT = "input", t.IFRAME = "iframe", t.KEYGEN = "keygen", t.LABEL = "label", t.LI = "li", t.LINK = "link", t.LISTING = "listing", t.MAIN = "main", t.MALIGNMARK = "malignmark", t.MARQUEE = "marquee", t.MATH = "math", t.MENU = "menu", t.META = "meta", t.MGLYPH = "mglyph", t.MI = "mi", t.MO = "mo", t.MN = "mn", t.MS = "ms", t.MTEXT = "mtext", t.NAV = "nav", t.NOBR = "nobr", t.NOFRAMES = "noframes", t.NOEMBED = "noembed", t.NOSCRIPT = "noscript", t.OBJECT = "object", t.OL = "ol", t.OPTGROUP = "optgroup", t.OPTION = "option", t.P = "p", t.PARAM = "param", t.PLAINTEXT = "plaintext", t.PRE = "pre", t.RB = "rb", t.RP = "rp", t.RT = "rt", t.RTC = "rtc", t.RUBY = "ruby", t.S = "s", t.SCRIPT = "script", t.SEARCH = "search", t.SECTION = "section", t.SELECT = "select", t.SOURCE = "source", t.SMALL = "small", t.SPAN = "span", t.STRIKE = "strike", t.STRONG = "strong", t.STYLE = "style", t.SUB = "sub", t.SUMMARY = "summary", t.SUP = "sup", t.TABLE = "table", t.TBODY = "tbody", t.TEMPLATE = "template", t.TEXTAREA = "textarea", t.TFOOT = "tfoot", t.TD = "td", t.TH = "th", t.THEAD = "thead", t.TITLE = "title", t.TR = "tr", t.TRACK = "track", t.TT = "tt", t.U = "u", t.UL = "ul", t.SVG = "svg", t.VAR = "var", t.WBR = "wbr", t.XMP = "xmp";
})(j || (j = {}));
var b;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.A = 1] = "A", t[t.ADDRESS = 2] = "ADDRESS", t[t.ANNOTATION_XML = 3] = "ANNOTATION_XML", t[t.APPLET = 4] = "APPLET", t[t.AREA = 5] = "AREA", t[t.ARTICLE = 6] = "ARTICLE", t[t.ASIDE = 7] = "ASIDE", t[t.B = 8] = "B", t[t.BASE = 9] = "BASE", t[t.BASEFONT = 10] = "BASEFONT", t[t.BGSOUND = 11] = "BGSOUND", t[t.BIG = 12] = "BIG", t[t.BLOCKQUOTE = 13] = "BLOCKQUOTE", t[t.BODY = 14] = "BODY", t[t.BR = 15] = "BR", t[t.BUTTON = 16] = "BUTTON", t[t.CAPTION = 17] = "CAPTION", t[t.CENTER = 18] = "CENTER", t[t.CODE = 19] = "CODE", t[t.COL = 20] = "COL", t[t.COLGROUP = 21] = "COLGROUP", t[t.DD = 22] = "DD", t[t.DESC = 23] = "DESC", t[t.DETAILS = 24] = "DETAILS", t[t.DIALOG = 25] = "DIALOG", t[t.DIR = 26] = "DIR", t[t.DIV = 27] = "DIV", t[t.DL = 28] = "DL", t[t.DT = 29] = "DT", t[t.EM = 30] = "EM", t[t.EMBED = 31] = "EMBED", t[t.FIELDSET = 32] = "FIELDSET", t[t.FIGCAPTION = 33] = "FIGCAPTION", t[t.FIGURE = 34] = "FIGURE", t[t.FONT = 35] = "FONT", t[t.FOOTER = 36] = "FOOTER", t[t.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", t[t.FORM = 38] = "FORM", t[t.FRAME = 39] = "FRAME", t[t.FRAMESET = 40] = "FRAMESET", t[t.H1 = 41] = "H1", t[t.H2 = 42] = "H2", t[t.H3 = 43] = "H3", t[t.H4 = 44] = "H4", t[t.H5 = 45] = "H5", t[t.H6 = 46] = "H6", t[t.HEAD = 47] = "HEAD", t[t.HEADER = 48] = "HEADER", t[t.HGROUP = 49] = "HGROUP", t[t.HR = 50] = "HR", t[t.HTML = 51] = "HTML", t[t.I = 52] = "I", t[t.IMG = 53] = "IMG", t[t.IMAGE = 54] = "IMAGE", t[t.INPUT = 55] = "INPUT", t[t.IFRAME = 56] = "IFRAME", t[t.KEYGEN = 57] = "KEYGEN", t[t.LABEL = 58] = "LABEL", t[t.LI = 59] = "LI", t[t.LINK = 60] = "LINK", t[t.LISTING = 61] = "LISTING", t[t.MAIN = 62] = "MAIN", t[t.MALIGNMARK = 63] = "MALIGNMARK", t[t.MARQUEE = 64] = "MARQUEE", t[t.MATH = 65] = "MATH", t[t.MENU = 66] = "MENU", t[t.META = 67] = "META", t[t.MGLYPH = 68] = "MGLYPH", t[t.MI = 69] = "MI", t[t.MO = 70] = "MO", t[t.MN = 71] = "MN", t[t.MS = 72] = "MS", t[t.MTEXT = 73] = "MTEXT", t[t.NAV = 74] = "NAV", t[t.NOBR = 75] = "NOBR", t[t.NOFRAMES = 76] = "NOFRAMES", t[t.NOEMBED = 77] = "NOEMBED", t[t.NOSCRIPT = 78] = "NOSCRIPT", t[t.OBJECT = 79] = "OBJECT", t[t.OL = 80] = "OL", t[t.OPTGROUP = 81] = "OPTGROUP", t[t.OPTION = 82] = "OPTION", t[t.P = 83] = "P", t[t.PARAM = 84] = "PARAM", t[t.PLAINTEXT = 85] = "PLAINTEXT", t[t.PRE = 86] = "PRE", t[t.RB = 87] = "RB", t[t.RP = 88] = "RP", t[t.RT = 89] = "RT", t[t.RTC = 90] = "RTC", t[t.RUBY = 91] = "RUBY", t[t.S = 92] = "S", t[t.SCRIPT = 93] = "SCRIPT", t[t.SEARCH = 94] = "SEARCH", t[t.SECTION = 95] = "SECTION", t[t.SELECT = 96] = "SELECT", t[t.SOURCE = 97] = "SOURCE", t[t.SMALL = 98] = "SMALL", t[t.SPAN = 99] = "SPAN", t[t.STRIKE = 100] = "STRIKE", t[t.STRONG = 101] = "STRONG", t[t.STYLE = 102] = "STYLE", t[t.SUB = 103] = "SUB", t[t.SUMMARY = 104] = "SUMMARY", t[t.SUP = 105] = "SUP", t[t.TABLE = 106] = "TABLE", t[t.TBODY = 107] = "TBODY", t[t.TEMPLATE = 108] = "TEMPLATE", t[t.TEXTAREA = 109] = "TEXTAREA", t[t.TFOOT = 110] = "TFOOT", t[t.TD = 111] = "TD", t[t.TH = 112] = "TH", t[t.THEAD = 113] = "THEAD", t[t.TITLE = 114] = "TITLE", t[t.TR = 115] = "TR", t[t.TRACK = 116] = "TRACK", t[t.TT = 117] = "TT", t[t.U = 118] = "U", t[t.UL = 119] = "UL", t[t.SVG = 120] = "SVG", t[t.VAR = 121] = "VAR", t[t.WBR = 122] = "WBR", t[t.XMP = 123] = "XMP";
})(b || (b = {}));
const ZM = /* @__PURE__ */ new Map([
  [j.A, b.A],
  [j.ADDRESS, b.ADDRESS],
  [j.ANNOTATION_XML, b.ANNOTATION_XML],
  [j.APPLET, b.APPLET],
  [j.AREA, b.AREA],
  [j.ARTICLE, b.ARTICLE],
  [j.ASIDE, b.ASIDE],
  [j.B, b.B],
  [j.BASE, b.BASE],
  [j.BASEFONT, b.BASEFONT],
  [j.BGSOUND, b.BGSOUND],
  [j.BIG, b.BIG],
  [j.BLOCKQUOTE, b.BLOCKQUOTE],
  [j.BODY, b.BODY],
  [j.BR, b.BR],
  [j.BUTTON, b.BUTTON],
  [j.CAPTION, b.CAPTION],
  [j.CENTER, b.CENTER],
  [j.CODE, b.CODE],
  [j.COL, b.COL],
  [j.COLGROUP, b.COLGROUP],
  [j.DD, b.DD],
  [j.DESC, b.DESC],
  [j.DETAILS, b.DETAILS],
  [j.DIALOG, b.DIALOG],
  [j.DIR, b.DIR],
  [j.DIV, b.DIV],
  [j.DL, b.DL],
  [j.DT, b.DT],
  [j.EM, b.EM],
  [j.EMBED, b.EMBED],
  [j.FIELDSET, b.FIELDSET],
  [j.FIGCAPTION, b.FIGCAPTION],
  [j.FIGURE, b.FIGURE],
  [j.FONT, b.FONT],
  [j.FOOTER, b.FOOTER],
  [j.FOREIGN_OBJECT, b.FOREIGN_OBJECT],
  [j.FORM, b.FORM],
  [j.FRAME, b.FRAME],
  [j.FRAMESET, b.FRAMESET],
  [j.H1, b.H1],
  [j.H2, b.H2],
  [j.H3, b.H3],
  [j.H4, b.H4],
  [j.H5, b.H5],
  [j.H6, b.H6],
  [j.HEAD, b.HEAD],
  [j.HEADER, b.HEADER],
  [j.HGROUP, b.HGROUP],
  [j.HR, b.HR],
  [j.HTML, b.HTML],
  [j.I, b.I],
  [j.IMG, b.IMG],
  [j.IMAGE, b.IMAGE],
  [j.INPUT, b.INPUT],
  [j.IFRAME, b.IFRAME],
  [j.KEYGEN, b.KEYGEN],
  [j.LABEL, b.LABEL],
  [j.LI, b.LI],
  [j.LINK, b.LINK],
  [j.LISTING, b.LISTING],
  [j.MAIN, b.MAIN],
  [j.MALIGNMARK, b.MALIGNMARK],
  [j.MARQUEE, b.MARQUEE],
  [j.MATH, b.MATH],
  [j.MENU, b.MENU],
  [j.META, b.META],
  [j.MGLYPH, b.MGLYPH],
  [j.MI, b.MI],
  [j.MO, b.MO],
  [j.MN, b.MN],
  [j.MS, b.MS],
  [j.MTEXT, b.MTEXT],
  [j.NAV, b.NAV],
  [j.NOBR, b.NOBR],
  [j.NOFRAMES, b.NOFRAMES],
  [j.NOEMBED, b.NOEMBED],
  [j.NOSCRIPT, b.NOSCRIPT],
  [j.OBJECT, b.OBJECT],
  [j.OL, b.OL],
  [j.OPTGROUP, b.OPTGROUP],
  [j.OPTION, b.OPTION],
  [j.P, b.P],
  [j.PARAM, b.PARAM],
  [j.PLAINTEXT, b.PLAINTEXT],
  [j.PRE, b.PRE],
  [j.RB, b.RB],
  [j.RP, b.RP],
  [j.RT, b.RT],
  [j.RTC, b.RTC],
  [j.RUBY, b.RUBY],
  [j.S, b.S],
  [j.SCRIPT, b.SCRIPT],
  [j.SEARCH, b.SEARCH],
  [j.SECTION, b.SECTION],
  [j.SELECT, b.SELECT],
  [j.SOURCE, b.SOURCE],
  [j.SMALL, b.SMALL],
  [j.SPAN, b.SPAN],
  [j.STRIKE, b.STRIKE],
  [j.STRONG, b.STRONG],
  [j.STYLE, b.STYLE],
  [j.SUB, b.SUB],
  [j.SUMMARY, b.SUMMARY],
  [j.SUP, b.SUP],
  [j.TABLE, b.TABLE],
  [j.TBODY, b.TBODY],
  [j.TEMPLATE, b.TEMPLATE],
  [j.TEXTAREA, b.TEXTAREA],
  [j.TFOOT, b.TFOOT],
  [j.TD, b.TD],
  [j.TH, b.TH],
  [j.THEAD, b.THEAD],
  [j.TITLE, b.TITLE],
  [j.TR, b.TR],
  [j.TRACK, b.TRACK],
  [j.TT, b.TT],
  [j.U, b.U],
  [j.UL, b.UL],
  [j.SVG, b.SVG],
  [j.VAR, b.VAR],
  [j.WBR, b.WBR],
  [j.XMP, b.XMP]
]);
function ls(t) {
  var e;
  return (e = ZM.get(t)) !== null && e !== void 0 ? e : b.UNKNOWN;
}
const ee = b, JM = {
  [Z.HTML]: /* @__PURE__ */ new Set([
    ee.ADDRESS,
    ee.APPLET,
    ee.AREA,
    ee.ARTICLE,
    ee.ASIDE,
    ee.BASE,
    ee.BASEFONT,
    ee.BGSOUND,
    ee.BLOCKQUOTE,
    ee.BODY,
    ee.BR,
    ee.BUTTON,
    ee.CAPTION,
    ee.CENTER,
    ee.COL,
    ee.COLGROUP,
    ee.DD,
    ee.DETAILS,
    ee.DIR,
    ee.DIV,
    ee.DL,
    ee.DT,
    ee.EMBED,
    ee.FIELDSET,
    ee.FIGCAPTION,
    ee.FIGURE,
    ee.FOOTER,
    ee.FORM,
    ee.FRAME,
    ee.FRAMESET,
    ee.H1,
    ee.H2,
    ee.H3,
    ee.H4,
    ee.H5,
    ee.H6,
    ee.HEAD,
    ee.HEADER,
    ee.HGROUP,
    ee.HR,
    ee.HTML,
    ee.IFRAME,
    ee.IMG,
    ee.INPUT,
    ee.LI,
    ee.LINK,
    ee.LISTING,
    ee.MAIN,
    ee.MARQUEE,
    ee.MENU,
    ee.META,
    ee.NAV,
    ee.NOEMBED,
    ee.NOFRAMES,
    ee.NOSCRIPT,
    ee.OBJECT,
    ee.OL,
    ee.P,
    ee.PARAM,
    ee.PLAINTEXT,
    ee.PRE,
    ee.SCRIPT,
    ee.SECTION,
    ee.SELECT,
    ee.SOURCE,
    ee.STYLE,
    ee.SUMMARY,
    ee.TABLE,
    ee.TBODY,
    ee.TD,
    ee.TEMPLATE,
    ee.TEXTAREA,
    ee.TFOOT,
    ee.TH,
    ee.THEAD,
    ee.TITLE,
    ee.TR,
    ee.TRACK,
    ee.UL,
    ee.WBR,
    ee.XMP
  ]),
  [Z.MATHML]: /* @__PURE__ */ new Set([ee.MI, ee.MO, ee.MN, ee.MS, ee.MTEXT, ee.ANNOTATION_XML]),
  [Z.SVG]: /* @__PURE__ */ new Set([ee.TITLE, ee.FOREIGN_OBJECT, ee.DESC]),
  [Z.XLINK]: /* @__PURE__ */ new Set(),
  [Z.XML]: /* @__PURE__ */ new Set(),
  [Z.XMLNS]: /* @__PURE__ */ new Set()
}, Ad = /* @__PURE__ */ new Set([ee.H1, ee.H2, ee.H3, ee.H4, ee.H5, ee.H6]);
j.STYLE, j.SCRIPT, j.XMP, j.IFRAME, j.NOEMBED, j.NOFRAMES, j.PLAINTEXT;
var P;
(function(t) {
  t[t.DATA = 0] = "DATA", t[t.RCDATA = 1] = "RCDATA", t[t.RAWTEXT = 2] = "RAWTEXT", t[t.SCRIPT_DATA = 3] = "SCRIPT_DATA", t[t.PLAINTEXT = 4] = "PLAINTEXT", t[t.TAG_OPEN = 5] = "TAG_OPEN", t[t.END_TAG_OPEN = 6] = "END_TAG_OPEN", t[t.TAG_NAME = 7] = "TAG_NAME", t[t.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", t[t.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", t[t.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", t[t.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", t[t.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", t[t.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", t[t.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", t[t.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", t[t.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", t[t.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", t[t.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", t[t.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", t[t.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", t[t.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", t[t.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", t[t.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", t[t.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", t[t.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", t[t.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", t[t.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", t[t.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", t[t.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", t[t.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", t[t.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", t[t.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", t[t.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", t[t.COMMENT_START = 42] = "COMMENT_START", t[t.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", t[t.COMMENT = 44] = "COMMENT", t[t.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", t[t.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", t[t.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", t[t.COMMENT_END = 50] = "COMMENT_END", t[t.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", t[t.DOCTYPE = 52] = "DOCTYPE", t[t.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", t[t.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", t[t.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", t[t.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", t[t.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", t[t.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", t[t.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", t[t.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", t[t.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", t[t.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", t[t.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", t[t.CDATA_SECTION = 68] = "CDATA_SECTION", t[t.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", t[t.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", t[t.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", t[t.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(P || (P = {}));
const it = {
  DATA: P.DATA,
  RCDATA: P.RCDATA,
  RAWTEXT: P.RAWTEXT,
  SCRIPT_DATA: P.SCRIPT_DATA,
  PLAINTEXT: P.PLAINTEXT,
  CDATA_SECTION: P.CDATA_SECTION
};
function e5(t) {
  return t >= k.DIGIT_0 && t <= k.DIGIT_9;
}
function Ps(t) {
  return t >= k.LATIN_CAPITAL_A && t <= k.LATIN_CAPITAL_Z;
}
function t5(t) {
  return t >= k.LATIN_SMALL_A && t <= k.LATIN_SMALL_Z;
}
function br(t) {
  return t5(t) || Ps(t);
}
function Sp(t) {
  return br(t) || e5(t);
}
function To(t) {
  return t + 32;
}
function YT(t) {
  return t === k.SPACE || t === k.LINE_FEED || t === k.TABULATION || t === k.FORM_FEED;
}
function Ap(t) {
  return YT(t) || t === k.SOLIDUS || t === k.GREATER_THAN_SIGN;
}
function n5(t) {
  return t === k.NULL ? K.nullCharacterReference : t > 1114111 ? K.characterReferenceOutsideUnicodeRange : qT(t) ? K.surrogateCharacterReference : KT(t) ? K.noncharacterCharacterReference : jT(t) || t === k.CARRIAGE_RETURN ? K.controlCharacterReference : null;
}
class r5 {
  constructor(e, n) {
    this.options = e, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = P.DATA, this.returnState = P.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new GM(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new XM(VM, (r, i) => {
      this.preprocessor.pos = this.entityStartPos + i - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(K.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(K.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const i = n5(r);
        i && this._err(i, 1);
      }
    } : void 0);
  }
  //Errors
  _err(e, n = 0) {
    var r, i;
    (i = (r = this.handler).onParseError) === null || i === void 0 || i.call(r, this.preprocessor.getError(e, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(e) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - e,
      startOffset: this.preprocessor.offset - e,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const e = this._consume();
        this._ensureHibernation() || this._callState(e);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(e) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || e == null || e());
  }
  write(e, n, r) {
    this.active = !0, this.preprocessor.write(e, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(e) {
    this.consumedAfterSnapshot += e;
    for (let n = 0; n < e; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(e, n) {
    return this.preprocessor.startsWith(e, n) ? (this._advanceBy(e.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Re.START_TAG,
      tagName: "",
      tagID: b.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Re.END_TAG,
      tagName: "",
      tagID: b.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(e) {
    this.currentToken = {
      type: Re.COMMENT,
      data: "",
      location: this.getCurrentLocation(e)
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: Re.DOCTYPE,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var e, n;
    const r = this.currentToken;
    if (WT(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const i = (e = (n = r.location).attrs) !== null && e !== void 0 ? e : n.attrs = /* @__PURE__ */ Object.create(null);
        i[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(K.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(e) {
    this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const e = this.currentToken;
    this.prepareToken(e), e.tagID = ls(e.tagName), e.type === Re.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(K.endTagWithAttributes), e.selfClosing && this._err(K.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(e) {
    this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(e) {
    this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(e) {
    if (this.currentCharacterToken) {
      switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) {
        case Re.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case Re.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case Re.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const e = this.getCurrentLocation(0);
    e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: Re.EOF, location: e }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === e) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    const n = YT(e) ? Re.WHITESPACE_CHARACTER : e === k.NULL ? Re.NULL_CHARACTER : Re.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(e));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(Re.CHARACTER, e);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = P.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? tr.Attribute : tr.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === P.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === P.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === P.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(e) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(e) {
    switch (this.state) {
      case P.DATA: {
        this._stateData(e);
        break;
      }
      case P.RCDATA: {
        this._stateRcdata(e);
        break;
      }
      case P.RAWTEXT: {
        this._stateRawtext(e);
        break;
      }
      case P.SCRIPT_DATA: {
        this._stateScriptData(e);
        break;
      }
      case P.PLAINTEXT: {
        this._statePlaintext(e);
        break;
      }
      case P.TAG_OPEN: {
        this._stateTagOpen(e);
        break;
      }
      case P.END_TAG_OPEN: {
        this._stateEndTagOpen(e);
        break;
      }
      case P.TAG_NAME: {
        this._stateTagName(e);
        break;
      }
      case P.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(e);
        break;
      }
      case P.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(e);
        break;
      }
      case P.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(e);
        break;
      }
      case P.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(e);
        break;
      }
      case P.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(e);
        break;
      }
      case P.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(e);
        break;
      }
      case P.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(e);
        break;
      }
      case P.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(e);
        break;
      }
      case P.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(e);
        break;
      }
      case P.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(e);
        break;
      }
      case P.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(e);
        break;
      }
      case P.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(e);
        break;
      }
      case P.ATTRIBUTE_NAME: {
        this._stateAttributeName(e);
        break;
      }
      case P.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(e);
        break;
      }
      case P.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(e);
        break;
      }
      case P.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(e);
        break;
      }
      case P.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(e);
        break;
      }
      case P.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(e);
        break;
      }
      case P.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(e);
        break;
      }
      case P.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(e);
        break;
      }
      case P.BOGUS_COMMENT: {
        this._stateBogusComment(e);
        break;
      }
      case P.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(e);
        break;
      }
      case P.COMMENT_START: {
        this._stateCommentStart(e);
        break;
      }
      case P.COMMENT_START_DASH: {
        this._stateCommentStartDash(e);
        break;
      }
      case P.COMMENT: {
        this._stateComment(e);
        break;
      }
      case P.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(e);
        break;
      }
      case P.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(e);
        break;
      }
      case P.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(e);
        break;
      }
      case P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(e);
        break;
      }
      case P.COMMENT_END_DASH: {
        this._stateCommentEndDash(e);
        break;
      }
      case P.COMMENT_END: {
        this._stateCommentEnd(e);
        break;
      }
      case P.COMMENT_END_BANG: {
        this._stateCommentEndBang(e);
        break;
      }
      case P.DOCTYPE: {
        this._stateDoctype(e);
        break;
      }
      case P.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(e);
        break;
      }
      case P.DOCTYPE_NAME: {
        this._stateDoctypeName(e);
        break;
      }
      case P.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(e);
        break;
      }
      case P.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(e);
        break;
      }
      case P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(e);
        break;
      }
      case P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(e);
        break;
      }
      case P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(e);
        break;
      }
      case P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(e);
        break;
      }
      case P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
        break;
      }
      case P.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(e);
        break;
      }
      case P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(e);
        break;
      }
      case P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(e);
        break;
      }
      case P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(e);
        break;
      }
      case P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(e);
        break;
      }
      case P.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(e);
        break;
      }
      case P.CDATA_SECTION: {
        this._stateCdataSection(e);
        break;
      }
      case P.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(e);
        break;
      }
      case P.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(e);
        break;
      }
      case P.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case P.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(e);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(e) {
    switch (e) {
      case k.LESS_THAN_SIGN: {
        this.state = P.TAG_OPEN;
        break;
      }
      case k.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitCodePoint(e);
        break;
      }
      case k.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(e) {
    switch (e) {
      case k.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(e) {
    switch (e) {
      case k.LESS_THAN_SIGN: {
        this.state = P.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(e) {
    switch (e) {
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(e) {
    switch (e) {
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(e) {
    if (br(e))
      this._createStartTagToken(), this.state = P.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case k.EXCLAMATION_MARK: {
          this.state = P.MARKUP_DECLARATION_OPEN;
          break;
        }
        case k.SOLIDUS: {
          this.state = P.END_TAG_OPEN;
          break;
        }
        case k.QUESTION_MARK: {
          this._err(K.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = P.BOGUS_COMMENT, this._stateBogusComment(e);
          break;
        }
        case k.EOF: {
          this._err(K.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(K.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = P.DATA, this._stateData(e);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(e) {
    if (br(e))
      this._createEndTagToken(), this.state = P.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case k.GREATER_THAN_SIGN: {
          this._err(K.missingEndTagName), this.state = P.DATA;
          break;
        }
        case k.EOF: {
          this._err(K.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(K.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = P.BOGUS_COMMENT, this._stateBogusComment(e);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case k.SOLIDUS: {
        this.state = P.SELF_CLOSING_START_TAG;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.tagName += Xe;
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Ps(e) ? To(e) : e);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(e) {
    e === k.SOLIDUS ? this.state = P.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = P.RCDATA, this._stateRcdata(e));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(e) {
    br(e) ? (this.state = P.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = P.RCDATA, this._stateRcdata(e));
  }
  handleSpecialEndTag(e) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = P.BEFORE_ATTRIBUTE_NAME, !1;
      case k.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = P.SELF_CLOSING_START_TAG, !1;
      case k.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = P.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = P.RCDATA, this._stateRcdata(e));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(e) {
    e === k.SOLIDUS ? this.state = P.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = P.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(e) {
    br(e) ? (this.state = P.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = P.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = P.RAWTEXT, this._stateRawtext(e));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(e) {
    switch (e) {
      case k.SOLIDUS: {
        this.state = P.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case k.EXCLAMATION_MARK: {
        this.state = P.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = P.SCRIPT_DATA, this._stateScriptData(e);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(e) {
    br(e) ? (this.state = P.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = P.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = P.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(e) {
    e === k.HYPHEN_MINUS ? (this.state = P.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = P.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(e) {
    e === k.HYPHEN_MINUS ? (this.state = P.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = P.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.state = P.SCRIPT_DATA_ESCAPED, this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = P.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.state = P.SCRIPT_DATA_ESCAPED, this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = P.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(e) {
    e === k.SOLIDUS ? this.state = P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : br(e) ? (this._emitChars("<"), this.state = P.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = P.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(e) {
    br(e) ? (this.state = P.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = P.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = P.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(e) {
    if (this.preprocessor.startsWith(wt.SCRIPT, !1) && Ap(this.preprocessor.peek(wt.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < wt.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = P.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case k.LESS_THAN_SIGN: {
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Xe);
        break;
      }
      case k.EOF: {
        this._err(K.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(e) {
    e === k.SOLIDUS ? (this.state = P.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(e) {
    if (this.preprocessor.startsWith(wt.SCRIPT, !1) && Ap(this.preprocessor.peek(wt.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < wt.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = P.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = P.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.SOLIDUS:
      case k.GREATER_THAN_SIGN:
      case k.EOF: {
        this.state = P.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case k.EQUALS_SIGN: {
        this._err(K.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = P.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = P.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
      case k.SOLIDUS:
      case k.GREATER_THAN_SIGN:
      case k.EOF: {
        this._leaveAttrName(), this.state = P.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case k.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = P.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case k.QUOTATION_MARK:
      case k.APOSTROPHE:
      case k.LESS_THAN_SIGN: {
        this._err(K.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e);
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.currentAttr.name += Xe;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Ps(e) ? To(e) : e);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.SOLIDUS: {
        this.state = P.SELF_CLOSING_START_TAG;
        break;
      }
      case k.EQUALS_SIGN: {
        this.state = P.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = P.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.QUOTATION_MARK: {
        this.state = P.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        this.state = P.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.missingAttributeValue), this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = P.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(e) {
    switch (e) {
      case k.QUOTATION_MARK: {
        this.state = P.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case k.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.currentAttr.value += Xe;
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(e) {
    switch (e) {
      case k.APOSTROPHE: {
        this.state = P.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case k.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.currentAttr.value += Xe;
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this._leaveAttrValue(), this.state = P.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case k.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), this.currentAttr.value += Xe;
        break;
      }
      case k.QUOTATION_MARK:
      case k.APOSTROPHE:
      case k.LESS_THAN_SIGN:
      case k.EQUALS_SIGN:
      case k.GRAVE_ACCENT: {
        this._err(K.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e);
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this._leaveAttrValue(), this.state = P.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case k.SOLIDUS: {
        this._leaveAttrValue(), this.state = P.SELF_CLOSING_START_TAG;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingWhitespaceBetweenAttributes), this.state = P.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(e) {
    switch (e) {
      case k.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = P.DATA, this.emitCurrentTagToken();
        break;
      }
      case k.EOF: {
        this._err(K.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.unexpectedSolidusInTag), this.state = P.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(e) {
    const n = this.currentToken;
    switch (e) {
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentComment(n);
        break;
      }
      case k.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.data += Xe;
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(e) {
    this._consumeSequenceIfMatch(wt.DASH_DASH, !0) ? (this._createCommentToken(wt.DASH_DASH.length + 1), this.state = P.COMMENT_START) : this._consumeSequenceIfMatch(wt.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(wt.DOCTYPE.length + 1), this.state = P.DOCTYPE) : this._consumeSequenceIfMatch(wt.CDATA_START, !0) ? this.inForeignNode ? this.state = P.CDATA_SECTION : (this._err(K.cdataInHtmlContent), this._createCommentToken(wt.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = P.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(K.incorrectlyOpenedComment), this._createCommentToken(2), this.state = P.BOGUS_COMMENT, this._stateBogusComment(e));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(e) {
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.COMMENT_START_DASH;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptClosingOfEmptyComment), this.state = P.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(e) {
    const n = this.currentToken;
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.COMMENT_END;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptClosingOfEmptyComment), this.state = P.DATA, this.emitCurrentComment(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(e) {
    const n = this.currentToken;
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.COMMENT_END_DASH;
        break;
      }
      case k.LESS_THAN_SIGN: {
        n.data += "<", this.state = P.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.data += Xe;
        break;
      }
      case k.EOF: {
        this._err(K.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(e) {
    const n = this.currentToken;
    switch (e) {
      case k.EXCLAMATION_MARK: {
        n.data += "!", this.state = P.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case k.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(e) {
    e === k.HYPHEN_MINUS ? this.state = P.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = P.COMMENT, this._stateComment(e));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(e) {
    e === k.HYPHEN_MINUS ? this.state = P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = P.COMMENT_END_DASH, this._stateCommentEndDash(e));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(e) {
    e !== k.GREATER_THAN_SIGN && e !== k.EOF && this._err(K.nestedComment), this.state = P.COMMENT_END, this._stateCommentEnd(e);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(e) {
    const n = this.currentToken;
    switch (e) {
      case k.HYPHEN_MINUS: {
        this.state = P.COMMENT_END;
        break;
      }
      case k.EOF: {
        this._err(K.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(e) {
    const n = this.currentToken;
    switch (e) {
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentComment(n);
        break;
      }
      case k.EXCLAMATION_MARK: {
        this.state = P.COMMENT_END_BANG;
        break;
      }
      case k.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case k.EOF: {
        this._err(K.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(e) {
    const n = this.currentToken;
    switch (e) {
      case k.HYPHEN_MINUS: {
        n.data += "--!", this.state = P.COMMENT_END_DASH;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.incorrectlyClosedComment), this.state = P.DATA, this.emitCurrentComment(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = P.COMMENT, this._stateComment(e);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(e) {
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.BEFORE_DOCTYPE_NAME;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingWhitespaceBeforeDoctypeName), this.state = P.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(e) {
    if (Ps(e))
      this._createDoctypeToken(String.fromCharCode(To(e))), this.state = P.DOCTYPE_NAME;
    else
      switch (e) {
        case k.SPACE:
        case k.LINE_FEED:
        case k.TABULATION:
        case k.FORM_FEED:
          break;
        case k.NULL: {
          this._err(K.unexpectedNullCharacter), this._createDoctypeToken(Xe), this.state = P.DOCTYPE_NAME;
          break;
        }
        case k.GREATER_THAN_SIGN: {
          this._err(K.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = P.DATA;
          break;
        }
        case k.EOF: {
          this._err(K.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(e)), this.state = P.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.AFTER_DOCTYPE_NAME;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.name += Xe;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Ps(e) ? To(e) : e);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(wt.PUBLIC, !1) ? this.state = P.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(wt.SYSTEM, !1) ? this.state = P.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(K.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case k.QUOTATION_MARK: {
        this._err(K.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        this._err(K.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.QUOTATION_MARK: {
        n.publicId = "", this.state = P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        n.publicId = "", this.state = P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case k.QUOTATION_MARK: {
        this.state = P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.publicId += Xe;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case k.APOSTROPHE: {
        this.state = P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.publicId += Xe;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.QUOTATION_MARK: {
        this._err(K.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        this._err(K.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.QUOTATION_MARK: {
        n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED: {
        this.state = P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case k.QUOTATION_MARK: {
        this._err(K.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        this._err(K.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.QUOTATION_MARK: {
        n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case k.APOSTROPHE: {
        n.systemId = "", this.state = P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case k.QUOTATION_MARK: {
        this.state = P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.systemId += Xe;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case k.APOSTROPHE: {
        this.state = P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter), n.systemId += Xe;
        break;
      }
      case k.GREATER_THAN_SIGN: {
        this._err(K.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case k.SPACE:
      case k.LINE_FEED:
      case k.TABULATION:
      case k.FORM_FEED:
        break;
      case k.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.EOF: {
        this._err(K.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(K.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = P.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(e) {
    const n = this.currentToken;
    switch (e) {
      case k.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = P.DATA;
        break;
      }
      case k.NULL: {
        this._err(K.unexpectedNullCharacter);
        break;
      }
      case k.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(e) {
    switch (e) {
      case k.RIGHT_SQUARE_BRACKET: {
        this.state = P.CDATA_SECTION_BRACKET;
        break;
      }
      case k.EOF: {
        this._err(K.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(e) {
    e === k.RIGHT_SQUARE_BRACKET ? this.state = P.CDATA_SECTION_END : (this._emitChars("]"), this.state = P.CDATA_SECTION, this._stateCdataSection(e));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(e) {
    switch (e) {
      case k.GREATER_THAN_SIGN: {
        this.state = P.DATA;
        break;
      }
      case k.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = P.CDATA_SECTION, this._stateCdataSection(e);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (e < 0)
      if (this.preprocessor.lastChunkWritten)
        e = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    e === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(k.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Sp(this.preprocessor.peek(1)) ? P.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(e) {
    Sp(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === k.SEMICOLON && this._err(K.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e));
  }
}
const XT = /* @__PURE__ */ new Set([b.DD, b.DT, b.LI, b.OPTGROUP, b.OPTION, b.P, b.RB, b.RP, b.RT, b.RTC]), vp = /* @__PURE__ */ new Set([
  ...XT,
  b.CAPTION,
  b.COLGROUP,
  b.TBODY,
  b.TD,
  b.TFOOT,
  b.TH,
  b.THEAD,
  b.TR
]), xu = /* @__PURE__ */ new Set([
  b.APPLET,
  b.CAPTION,
  b.HTML,
  b.MARQUEE,
  b.OBJECT,
  b.TABLE,
  b.TD,
  b.TEMPLATE,
  b.TH
]), i5 = /* @__PURE__ */ new Set([...xu, b.OL, b.UL]), s5 = /* @__PURE__ */ new Set([...xu, b.BUTTON]), Ip = /* @__PURE__ */ new Set([b.ANNOTATION_XML, b.MI, b.MN, b.MO, b.MS, b.MTEXT]), Cp = /* @__PURE__ */ new Set([b.DESC, b.FOREIGN_OBJECT, b.TITLE]), a5 = /* @__PURE__ */ new Set([b.TR, b.TEMPLATE, b.HTML]), o5 = /* @__PURE__ */ new Set([b.TBODY, b.TFOOT, b.THEAD, b.TEMPLATE, b.HTML]), u5 = /* @__PURE__ */ new Set([b.TABLE, b.TEMPLATE, b.HTML]), l5 = /* @__PURE__ */ new Set([b.TD, b.TH]);
class c5 {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(e, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = b.UNKNOWN, this.current = e;
  }
  //Index of element
  _indexOf(e) {
    return this.items.lastIndexOf(e, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === b.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Z.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(e, n) {
    this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, n, !0);
  }
  pop() {
    const e = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0);
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(e, n, r) {
    const i = this._indexOf(e) + 1;
    this.items.splice(i, 0, n), this.tagIDs.splice(i, 0, r), this.stackTop++, i === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop);
  }
  popUntilTagNamePopped(e) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(e, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== Z.HTML);
    this.shortenToLength(Math.max(n, 0));
  }
  shortenToLength(e) {
    for (; this.stackTop >= e; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < e);
    }
  }
  popUntilElementPopped(e) {
    const n = this._indexOf(e);
    this.shortenToLength(Math.max(n, 0));
  }
  popUntilPopped(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(Math.max(r, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(Ad, Z.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(l5, Z.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(e, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (e.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(u5, Z.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(o5, Z.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(a5, Z.HTML);
  }
  remove(e) {
    const n = this._indexOf(e);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === b.BODY ? this.items[1] : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    const n = this._indexOf(e) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === b.HTML;
  }
  //Element in scope
  hasInDynamicScope(e, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case Z.HTML: {
          if (i === e)
            return !0;
          if (n.has(i))
            return !1;
          break;
        }
        case Z.SVG: {
          if (Cp.has(i))
            return !1;
          break;
        }
        case Z.MATHML: {
          if (Ip.has(i))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(e) {
    return this.hasInDynamicScope(e, xu);
  }
  hasInListItemScope(e) {
    return this.hasInDynamicScope(e, i5);
  }
  hasInButtonScope(e) {
    return this.hasInDynamicScope(e, s5);
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.tagIDs[e];
      switch (this.treeAdapter.getNamespaceURI(this.items[e])) {
        case Z.HTML: {
          if (Ad.has(n))
            return !0;
          if (xu.has(n))
            return !1;
          break;
        }
        case Z.SVG: {
          if (Cp.has(n))
            return !1;
          break;
        }
        case Z.MATHML: {
          if (Ip.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Z.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case b.TABLE:
          case b.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--)
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === Z.HTML)
        switch (this.tagIDs[e]) {
          case b.TBODY:
          case b.THEAD:
          case b.TFOOT:
            return !0;
          case b.TABLE:
          case b.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Z.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case b.OPTION:
          case b.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && XT.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && vp.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== e && vp.has(this.currentTagId); )
      this.pop();
  }
}
const Jl = 3;
var In;
(function(t) {
  t[t.Marker = 0] = "Marker", t[t.Element = 1] = "Element";
})(In || (In = {}));
const Lp = { type: In.Marker };
class d5 {
  constructor(e) {
    this.treeAdapter = e, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e, n) {
    const r = [], i = n.length, s = this.treeAdapter.getTagName(e), a = this.treeAdapter.getNamespaceURI(e);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === In.Marker)
        break;
      const { element: l } = u;
      if (this.treeAdapter.getTagName(l) === s && this.treeAdapter.getNamespaceURI(l) === a) {
        const c = this.treeAdapter.getAttrList(l);
        c.length === i && r.push({ idx: o, attrs: c });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(e) {
    if (this.entries.length < Jl)
      return;
    const n = this.treeAdapter.getAttrList(e), r = this._getNoahArkConditionCandidates(e, n);
    if (r.length < Jl)
      return;
    const i = new Map(n.map((a) => [a.name, a.value]));
    let s = 0;
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      o.attrs.every((u) => i.get(u.name) === u.value) && (s += 1, s >= Jl && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Lp);
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.unshift({
      type: In.Element,
      element: e,
      token: n
    });
  }
  insertElementAfterBookmark(e, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: In.Element,
      element: e,
      token: n
    });
  }
  removeEntry(e) {
    const n = this.entries.indexOf(e);
    n !== -1 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const e = this.entries.indexOf(Lp);
    e === -1 ? this.entries.length = 0 : this.entries.splice(0, e + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    const n = this.entries.find((r) => r.type === In.Marker || this.treeAdapter.getTagName(r.element) === e);
    return n && n.type === In.Element ? n : null;
  }
  getElementEntry(e) {
    return this.entries.find((n) => n.type === In.Element && n.element === e);
  }
}
const Er = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: tn.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(t, e, n) {
    return {
      nodeName: t,
      tagName: t,
      attrs: n,
      namespaceURI: e,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(t) {
    return {
      nodeName: "#comment",
      data: t,
      parentNode: null
    };
  },
  createTextNode(t) {
    return {
      nodeName: "#text",
      value: t,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(t, e) {
    t.childNodes.push(e), e.parentNode = t;
  },
  insertBefore(t, e, n) {
    const r = t.childNodes.indexOf(n);
    t.childNodes.splice(r, 0, e), e.parentNode = t;
  },
  setTemplateContent(t, e) {
    t.content = e;
  },
  getTemplateContent(t) {
    return t.content;
  },
  setDocumentType(t, e, n, r) {
    const i = t.childNodes.find((s) => s.nodeName === "#documentType");
    if (i)
      i.name = e, i.publicId = n, i.systemId = r;
    else {
      const s = {
        nodeName: "#documentType",
        name: e,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Er.appendChild(t, s);
    }
  },
  setDocumentMode(t, e) {
    t.mode = e;
  },
  getDocumentMode(t) {
    return t.mode;
  },
  detachNode(t) {
    if (t.parentNode) {
      const e = t.parentNode.childNodes.indexOf(t);
      t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
    }
  },
  insertText(t, e) {
    if (t.childNodes.length > 0) {
      const n = t.childNodes[t.childNodes.length - 1];
      if (Er.isTextNode(n)) {
        n.value += e;
        return;
      }
    }
    Er.appendChild(t, Er.createTextNode(e));
  },
  insertTextBefore(t, e, n) {
    const r = t.childNodes[t.childNodes.indexOf(n) - 1];
    r && Er.isTextNode(r) ? r.value += e : Er.insertBefore(t, Er.createTextNode(e), n);
  },
  adoptAttributes(t, e) {
    const n = new Set(t.attrs.map((r) => r.name));
    for (let r = 0; r < e.length; r++)
      n.has(e[r].name) || t.attrs.push(e[r]);
  },
  //Tree traversing
  getFirstChild(t) {
    return t.childNodes[0];
  },
  getChildNodes(t) {
    return t.childNodes;
  },
  getParentNode(t) {
    return t.parentNode;
  },
  getAttrList(t) {
    return t.attrs;
  },
  //Node data
  getTagName(t) {
    return t.tagName;
  },
  getNamespaceURI(t) {
    return t.namespaceURI;
  },
  getTextNodeContent(t) {
    return t.value;
  },
  getCommentNodeContent(t) {
    return t.data;
  },
  getDocumentTypeNodeName(t) {
    return t.name;
  },
  getDocumentTypeNodePublicId(t) {
    return t.publicId;
  },
  getDocumentTypeNodeSystemId(t) {
    return t.systemId;
  },
  //Node types
  isTextNode(t) {
    return t.nodeName === "#text";
  },
  isCommentNode(t) {
    return t.nodeName === "#comment";
  },
  isDocumentTypeNode(t) {
    return t.nodeName === "#documentType";
  },
  isElementNode(t) {
    return Object.prototype.hasOwnProperty.call(t, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = e;
  },
  getNodeSourceCodeLocation(t) {
    return t.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = { ...t.sourceCodeLocation, ...e };
  }
}, QT = "html", f5 = "about:legacy-compat", h5 = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", ZT = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], m5 = [
  ...ZT,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], p5 = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), JT = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], g5 = [
  ...JT,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function _p(t, e) {
  return e.some((n) => t.startsWith(n));
}
function b5(t) {
  return t.name === QT && t.publicId === null && (t.systemId === null || t.systemId === f5);
}
function E5(t) {
  if (t.name !== QT)
    return tn.QUIRKS;
  const { systemId: e } = t;
  if (e && e.toLowerCase() === h5)
    return tn.QUIRKS;
  let { publicId: n } = t;
  if (n !== null) {
    if (n = n.toLowerCase(), p5.has(n))
      return tn.QUIRKS;
    let r = e === null ? m5 : ZT;
    if (_p(n, r))
      return tn.QUIRKS;
    if (r = e === null ? JT : g5, _p(n, r))
      return tn.LIMITED_QUIRKS;
  }
  return tn.NO_QUIRKS;
}
const Rp = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, y5 = "definitionurl", T5 = "definitionURL", x5 = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), S5 = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Z.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Z.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: Z.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: Z.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: Z.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: Z.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: Z.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: Z.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: Z.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: Z.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Z.XMLNS }]
]), A5 = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), v5 = /* @__PURE__ */ new Set([
  b.B,
  b.BIG,
  b.BLOCKQUOTE,
  b.BODY,
  b.BR,
  b.CENTER,
  b.CODE,
  b.DD,
  b.DIV,
  b.DL,
  b.DT,
  b.EM,
  b.EMBED,
  b.H1,
  b.H2,
  b.H3,
  b.H4,
  b.H5,
  b.H6,
  b.HEAD,
  b.HR,
  b.I,
  b.IMG,
  b.LI,
  b.LISTING,
  b.MENU,
  b.META,
  b.NOBR,
  b.OL,
  b.P,
  b.PRE,
  b.RUBY,
  b.S,
  b.SMALL,
  b.SPAN,
  b.STRONG,
  b.STRIKE,
  b.SUB,
  b.SUP,
  b.TABLE,
  b.TT,
  b.U,
  b.UL,
  b.VAR
]);
function I5(t) {
  const e = t.tagID;
  return e === b.FONT && t.attrs.some(({ name: r }) => r === jr.COLOR || r === jr.SIZE || r === jr.FACE) || v5.has(e);
}
function ex(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === y5) {
      t.attrs[e].name = T5;
      break;
    }
}
function tx(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = x5.get(t.attrs[e].name);
    n != null && (t.attrs[e].name = n);
  }
}
function rh(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = S5.get(t.attrs[e].name);
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
}
function C5(t) {
  const e = A5.get(t.tagName);
  e != null && (t.tagName = e, t.tagID = ls(t.tagName));
}
function L5(t, e) {
  return e === Z.MATHML && (t === b.MI || t === b.MO || t === b.MN || t === b.MS || t === b.MTEXT);
}
function _5(t, e, n) {
  if (e === Z.MATHML && t === b.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === jr.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === Rp.TEXT_HTML || i === Rp.APPLICATION_XML;
      }
  }
  return e === Z.SVG && (t === b.FOREIGN_OBJECT || t === b.DESC || t === b.TITLE);
}
function R5(t, e, n, r) {
  return (!r || r === Z.HTML) && _5(t, e, n) || (!r || r === Z.MATHML) && L5(t, e);
}
const k5 = "hidden", w5 = 8, D5 = 3;
var M;
(function(t) {
  t[t.INITIAL = 0] = "INITIAL", t[t.BEFORE_HTML = 1] = "BEFORE_HTML", t[t.BEFORE_HEAD = 2] = "BEFORE_HEAD", t[t.IN_HEAD = 3] = "IN_HEAD", t[t.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", t[t.AFTER_HEAD = 5] = "AFTER_HEAD", t[t.IN_BODY = 6] = "IN_BODY", t[t.TEXT = 7] = "TEXT", t[t.IN_TABLE = 8] = "IN_TABLE", t[t.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", t[t.IN_CAPTION = 10] = "IN_CAPTION", t[t.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", t[t.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", t[t.IN_ROW = 13] = "IN_ROW", t[t.IN_CELL = 14] = "IN_CELL", t[t.IN_SELECT = 15] = "IN_SELECT", t[t.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", t[t.IN_TEMPLATE = 17] = "IN_TEMPLATE", t[t.AFTER_BODY = 18] = "AFTER_BODY", t[t.IN_FRAMESET = 19] = "IN_FRAMESET", t[t.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", t[t.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", t[t.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(M || (M = {}));
const P5 = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, nx = /* @__PURE__ */ new Set([b.TABLE, b.TBODY, b.TFOOT, b.THEAD, b.TR]), kp = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Er,
  onParseError: null
};
class wp {
  constructor(e, n, r = null, i = null) {
    this.fragmentContext = r, this.scriptHandler = i, this.currentToken = null, this.stopped = !1, this.insertionMode = M.INITIAL, this.originalInsertionMode = M.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...kp,
      ...e
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new r5(this.options, this), this.activeFormattingElements = new d5(this.treeAdapter), this.fragmentContextID = r ? ls(this.treeAdapter.getTagName(r)) : b.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new c5(this.document, this.treeAdapter, this);
  }
  // API
  static parse(e, n) {
    const r = new this(n);
    return r.tokenizer.write(e, !0), r.document;
  }
  static getFragmentParser(e, n) {
    const r = {
      ...kp,
      ...n
    };
    e ?? (e = r.treeAdapter.createElement(j.TEMPLATE, Z.HTML, []));
    const i = r.treeAdapter.createElement("documentmock", Z.HTML, []), s = new this(r, i, e);
    return s.fragmentContextID === b.TEMPLATE && s.tmplInsertionModeStack.unshift(M.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s;
  }
  getFragment() {
    const e = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(e, n), n;
  }
  //Errors
  /** @internal */
  _err(e, n, r) {
    var i;
    if (!this.onParseError)
      return;
    const s = (i = e.location) !== null && i !== void 0 ? i : P5, a = {
      code: n,
      startLine: s.startLine,
      startCol: s.startCol,
      startOffset: s.startOffset,
      endLine: r ? s.startLine : s.endLine,
      endCol: r ? s.startCol : s.endCol,
      endOffset: r ? s.startOffset : s.endOffset
    };
    this.onParseError(a);
  }
  //Stack events
  /** @internal */
  onItemPush(e, n, r) {
    var i, s;
    (s = (i = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(i, e), r && this.openElements.stackTop > 0 && this._setContextModes(e, n);
  }
  /** @internal */
  onItemPop(e, n) {
    var r, i;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, e, this.openElements.current), n) {
      let s, a;
      this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext, a = this.fragmentContextID) : { current: s, currentTagId: a } = this.openElements, this._setContextModes(s, a);
    }
  }
  _setContextModes(e, n) {
    const r = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === Z.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && e !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, e);
  }
  /** @protected */
  _switchToTextParsing(e, n) {
    this._insertElement(e, Z.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = M.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = M.TEXT, this.originalInsertionMode = M.IN_BODY, this.tokenizer.state = it.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    for (; e; ) {
      if (this.treeAdapter.getTagName(e) === j.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Z.HTML))
      switch (this.fragmentContextID) {
        case b.TITLE:
        case b.TEXTAREA: {
          this.tokenizer.state = it.RCDATA;
          break;
        }
        case b.STYLE:
        case b.XMP:
        case b.IFRAME:
        case b.NOEMBED:
        case b.NOFRAMES:
        case b.NOSCRIPT: {
          this.tokenizer.state = it.RAWTEXT;
          break;
        }
        case b.SCRIPT: {
          this.tokenizer.state = it.SCRIPT_DATA;
          break;
        }
        case b.PLAINTEXT: {
          this.tokenizer.state = it.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", i = e.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, i), e.location) {
      const a = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      a && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
    }
  }
  /** @protected */
  _attachElementToTree(e, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(e, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r ?? this.document, e);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location);
  }
  /** @protected */
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location), this.openElements.push(r, e.tagID);
  }
  /** @protected */
  _insertFakeElement(e, n) {
    const r = this.treeAdapter.createElement(e, Z.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, Z.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(j.HTML, Z.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, b.HTML);
  }
  /** @protected */
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, e.location);
  }
  /** @protected */
  _insertCharacters(e) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, e.chars, r) : this.treeAdapter.insertText(n, e.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, e.chars)), !e.location)
      return;
    const i = this.treeAdapter.getChildNodes(n), s = r ? i.lastIndexOf(r) : i.length, a = i[s - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(a)) {
      const { endLine: u, endCol: l, endOffset: c } = e.location;
      this.treeAdapter.updateNodeSourceCodeLocation(a, { endLine: u, endCol: l, endOffset: c });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
  }
  /** @protected */
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const r = n.location, i = this.treeAdapter.getTagName(e), s = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === Re.END_TAG && i === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(e, s);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(e) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, e.tagID === b.SVG && this.treeAdapter.getTagName(n) === j.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === Z.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (e.tagID === b.MGLYPH || e.tagID === b.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, Z.HTML)
    );
  }
  /** @protected */
  _processToken(e) {
    switch (e.type) {
      case Re.CHARACTER: {
        this.onCharacter(e);
        break;
      }
      case Re.NULL_CHARACTER: {
        this.onNullCharacter(e);
        break;
      }
      case Re.COMMENT: {
        this.onComment(e);
        break;
      }
      case Re.DOCTYPE: {
        this.onDoctype(e);
        break;
      }
      case Re.START_TAG: {
        this._processStartTag(e);
        break;
      }
      case Re.END_TAG: {
        this.onEndTag(e);
        break;
      }
      case Re.EOF: {
        this.onEof(e);
        break;
      }
      case Re.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(e);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(e, n, r) {
    const i = this.treeAdapter.getNamespaceURI(n), s = this.treeAdapter.getAttrList(n);
    return R5(e, i, s, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.entries.length;
    if (e) {
      const n = this.activeFormattingElements.entries.findIndex((i) => i.type === In.Marker || this.openElements.contains(i.element)), r = n === -1 ? e - 1 : n - 1;
      for (let i = r; i >= 0; i--) {
        const s = this.activeFormattingElements.entries[i];
        this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)), s.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = M.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(b.P), this.openElements.popUntilTagNamePopped(b.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop; e >= 0; e--)
      switch (e === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
        case b.TR: {
          this.insertionMode = M.IN_ROW;
          return;
        }
        case b.TBODY:
        case b.THEAD:
        case b.TFOOT: {
          this.insertionMode = M.IN_TABLE_BODY;
          return;
        }
        case b.CAPTION: {
          this.insertionMode = M.IN_CAPTION;
          return;
        }
        case b.COLGROUP: {
          this.insertionMode = M.IN_COLUMN_GROUP;
          return;
        }
        case b.TABLE: {
          this.insertionMode = M.IN_TABLE;
          return;
        }
        case b.BODY: {
          this.insertionMode = M.IN_BODY;
          return;
        }
        case b.FRAMESET: {
          this.insertionMode = M.IN_FRAMESET;
          return;
        }
        case b.SELECT: {
          this._resetInsertionModeForSelect(e);
          return;
        }
        case b.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case b.HTML: {
          this.insertionMode = this.headElement ? M.AFTER_HEAD : M.BEFORE_HEAD;
          return;
        }
        case b.TD:
        case b.TH: {
          if (e > 0) {
            this.insertionMode = M.IN_CELL;
            return;
          }
          break;
        }
        case b.HEAD: {
          if (e > 0) {
            this.insertionMode = M.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = M.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === b.TEMPLATE)
          break;
        if (r === b.TABLE) {
          this.insertionMode = M.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = M.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(e) {
    return nx.has(e);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let e = this.openElements.stackTop; e >= 0; e--) {
      const n = this.openElements.items[e];
      switch (this.openElements.tagIDs[e]) {
        case b.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === Z.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case b.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[e - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(e, n) {
    const r = this.treeAdapter.getNamespaceURI(e);
    return JM[r].has(n);
  }
  /** @internal */
  onCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      lB(this, e);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL: {
        vs(this, e);
        break;
      }
      case M.BEFORE_HTML: {
        $s(this, e);
        break;
      }
      case M.BEFORE_HEAD: {
        Hs(this, e);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, e);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        Vs(this, e);
        break;
      }
      case M.AFTER_HEAD: {
        zs(this, e);
        break;
      }
      case M.IN_BODY:
      case M.IN_CAPTION:
      case M.IN_CELL:
      case M.IN_TEMPLATE: {
        ix(this, e);
        break;
      }
      case M.TEXT:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE: {
        this._insertCharacters(e);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        ec(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        cx(this, e);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        Su(this, e);
        break;
      }
      case M.AFTER_BODY: {
        Au(this, e);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        qo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      uB(this, e);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL: {
        vs(this, e);
        break;
      }
      case M.BEFORE_HTML: {
        $s(this, e);
        break;
      }
      case M.BEFORE_HEAD: {
        Hs(this, e);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, e);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        Vs(this, e);
        break;
      }
      case M.AFTER_HEAD: {
        zs(this, e);
        break;
      }
      case M.TEXT: {
        this._insertCharacters(e);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        ec(this, e);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        Su(this, e);
        break;
      }
      case M.AFTER_BODY: {
        Au(this, e);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        qo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onComment(e) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      vd(this, e);
      return;
    }
    switch (this.insertionMode) {
      case M.INITIAL:
      case M.BEFORE_HTML:
      case M.BEFORE_HEAD:
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD:
      case M.IN_BODY:
      case M.IN_TABLE:
      case M.IN_CAPTION:
      case M.IN_COLUMN_GROUP:
      case M.IN_TABLE_BODY:
      case M.IN_ROW:
      case M.IN_CELL:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE:
      case M.IN_TEMPLATE:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET: {
        vd(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Is(this, e);
        break;
      }
      case M.AFTER_BODY: {
        $5(this, e);
        break;
      }
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        H5(this, e);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(e) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case M.INITIAL: {
        G5(this, e);
        break;
      }
      case M.BEFORE_HEAD:
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD: {
        this._err(e, K.misplacedDoctype);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Is(this, e);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, K.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(e) {
    this.shouldProcessStartTagTokenInForeignContent(e) ? cB(this, e) : this._startTagOutsideForeignContent(e);
  }
  /** @protected */
  _startTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        vs(this, e);
        break;
      }
      case M.BEFORE_HTML: {
        V5(this, e);
        break;
      }
      case M.BEFORE_HEAD: {
        q5(this, e);
        break;
      }
      case M.IN_HEAD: {
        En(this, e);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        W5(this, e);
        break;
      }
      case M.AFTER_HEAD: {
        X5(this, e);
        break;
      }
      case M.IN_BODY: {
        vt(this, e);
        break;
      }
      case M.IN_TABLE: {
        Qi(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Is(this, e);
        break;
      }
      case M.IN_CAPTION: {
        jF(this, e);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        ah(this, e);
        break;
      }
      case M.IN_TABLE_BODY: {
        Zu(this, e);
        break;
      }
      case M.IN_ROW: {
        Ju(this, e);
        break;
      }
      case M.IN_CELL: {
        YF(this, e);
        break;
      }
      case M.IN_SELECT: {
        hx(this, e);
        break;
      }
      case M.IN_SELECT_IN_TABLE: {
        QF(this, e);
        break;
      }
      case M.IN_TEMPLATE: {
        JF(this, e);
        break;
      }
      case M.AFTER_BODY: {
        tB(this, e);
        break;
      }
      case M.IN_FRAMESET: {
        nB(this, e);
        break;
      }
      case M.AFTER_FRAMESET: {
        iB(this, e);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        aB(this, e);
        break;
      }
      case M.AFTER_AFTER_FRAMESET: {
        oB(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? dB(this, e) : this._endTagOutsideForeignContent(e);
  }
  /** @protected */
  _endTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        vs(this, e);
        break;
      }
      case M.BEFORE_HTML: {
        z5(this, e);
        break;
      }
      case M.BEFORE_HEAD: {
        j5(this, e);
        break;
      }
      case M.IN_HEAD: {
        K5(this, e);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        Y5(this, e);
        break;
      }
      case M.AFTER_HEAD: {
        Q5(this, e);
        break;
      }
      case M.IN_BODY: {
        Qu(this, e);
        break;
      }
      case M.TEXT: {
        MF(this, e);
        break;
      }
      case M.IN_TABLE: {
        fa(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Is(this, e);
        break;
      }
      case M.IN_CAPTION: {
        KF(this, e);
        break;
      }
      case M.IN_COLUMN_GROUP: {
        WF(this, e);
        break;
      }
      case M.IN_TABLE_BODY: {
        Id(this, e);
        break;
      }
      case M.IN_ROW: {
        fx(this, e);
        break;
      }
      case M.IN_CELL: {
        XF(this, e);
        break;
      }
      case M.IN_SELECT: {
        mx(this, e);
        break;
      }
      case M.IN_SELECT_IN_TABLE: {
        ZF(this, e);
        break;
      }
      case M.IN_TEMPLATE: {
        eB(this, e);
        break;
      }
      case M.AFTER_BODY: {
        gx(this, e);
        break;
      }
      case M.IN_FRAMESET: {
        rB(this, e);
        break;
      }
      case M.AFTER_FRAMESET: {
        sB(this, e);
        break;
      }
      case M.AFTER_AFTER_BODY: {
        qo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEof(e) {
    switch (this.insertionMode) {
      case M.INITIAL: {
        vs(this, e);
        break;
      }
      case M.BEFORE_HTML: {
        $s(this, e);
        break;
      }
      case M.BEFORE_HEAD: {
        Hs(this, e);
        break;
      }
      case M.IN_HEAD: {
        Gs(this, e);
        break;
      }
      case M.IN_HEAD_NO_SCRIPT: {
        Vs(this, e);
        break;
      }
      case M.AFTER_HEAD: {
        zs(this, e);
        break;
      }
      case M.IN_BODY:
      case M.IN_TABLE:
      case M.IN_CAPTION:
      case M.IN_COLUMN_GROUP:
      case M.IN_TABLE_BODY:
      case M.IN_ROW:
      case M.IN_CELL:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE: {
        ux(this, e);
        break;
      }
      case M.TEXT: {
        FF(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        Is(this, e);
        break;
      }
      case M.IN_TEMPLATE: {
        px(this, e);
        break;
      }
      case M.AFTER_BODY:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET:
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        sh(this, e);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(e) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === k.LINE_FEED)) {
      if (e.chars.length === 1)
        return;
      e.chars = e.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(e);
      return;
    }
    switch (this.insertionMode) {
      case M.IN_HEAD:
      case M.IN_HEAD_NO_SCRIPT:
      case M.AFTER_HEAD:
      case M.TEXT:
      case M.IN_COLUMN_GROUP:
      case M.IN_SELECT:
      case M.IN_SELECT_IN_TABLE:
      case M.IN_FRAMESET:
      case M.AFTER_FRAMESET: {
        this._insertCharacters(e);
        break;
      }
      case M.IN_BODY:
      case M.IN_CAPTION:
      case M.IN_CELL:
      case M.IN_TEMPLATE:
      case M.AFTER_BODY:
      case M.AFTER_AFTER_BODY:
      case M.AFTER_AFTER_FRAMESET: {
        rx(this, e);
        break;
      }
      case M.IN_TABLE:
      case M.IN_TABLE_BODY:
      case M.IN_ROW: {
        ec(this, e);
        break;
      }
      case M.IN_TABLE_TEXT: {
        lx(this, e);
        break;
      }
    }
  }
}
function O5(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagID) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : ox(t, e), n;
}
function N5(t, e) {
  let n = null, r = t.openElements.stackTop;
  for (; r >= 0; r--) {
    const i = t.openElements.items[r];
    if (i === e.element)
      break;
    t._isSpecialElement(i, t.openElements.tagIDs[r]) && (n = i);
  }
  return n || (t.openElements.shortenToLength(Math.max(r, 0)), t.activeFormattingElements.removeEntry(e)), n;
}
function M5(t, e, n) {
  let r = e, i = t.openElements.getCommonAncestor(e);
  for (let s = 0, a = i; a !== n; s++, a = i) {
    i = t.openElements.getCommonAncestor(a);
    const o = t.activeFormattingElements.getElementEntry(a), u = o && s >= D5;
    !o || u ? (u && t.activeFormattingElements.removeEntry(o), t.openElements.remove(a)) : (a = F5(t, o), r === e && (t.activeFormattingElements.bookmark = o), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(a, r), r = a);
  }
  return r;
}
function F5(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function B5(t, e, n) {
  const r = t.treeAdapter.getTagName(e), i = ls(r);
  if (t._isElementCausesFosterParenting(i))
    t._fosterParentElement(n);
  else {
    const s = t.treeAdapter.getNamespaceURI(e);
    i === b.TEMPLATE && s === Z.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function U5(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), { token: i } = n, s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
  t._adoptNodes(e, s), t.treeAdapter.appendChild(e, s), t.activeFormattingElements.insertElementAfterBookmark(s, i), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, s, i.tagID);
}
function ih(t, e) {
  for (let n = 0; n < w5; n++) {
    const r = O5(t, e);
    if (!r)
      break;
    const i = N5(t, r);
    if (!i)
      break;
    t.activeFormattingElements.bookmark = r;
    const s = M5(t, i, r.element), a = t.openElements.getCommonAncestor(r.element);
    t.treeAdapter.detachNode(s), a && B5(t, a, s), U5(t, i, r);
  }
}
function vd(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContentOrNode);
}
function $5(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function H5(t, e) {
  t._appendCommentNode(e, t.document);
}
function sh(t, e) {
  if (t.stopped = !0, e.location) {
    const n = t.fragmentContext ? 0 : 2;
    for (let r = t.openElements.stackTop; r >= n; r--)
      t._setEndLocation(t.openElements.items[r], e);
    if (!t.fragmentContext && t.openElements.stackTop >= 0) {
      const r = t.openElements.items[0], i = t.treeAdapter.getNodeSourceCodeLocation(r);
      if (i && !i.endTag && (t._setEndLocation(r, e), t.openElements.stackTop >= 1)) {
        const s = t.openElements.items[1], a = t.treeAdapter.getNodeSourceCodeLocation(s);
        a && !a.endTag && t._setEndLocation(s, e);
      }
    }
  }
}
function G5(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? tn.QUIRKS : E5(e);
  b5(e) || t._err(e, K.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = M.BEFORE_HTML;
}
function vs(t, e) {
  t._err(e, K.missingDoctype, !0), t.treeAdapter.setDocumentMode(t.document, tn.QUIRKS), t.insertionMode = M.BEFORE_HTML, t._processToken(e);
}
function V5(t, e) {
  e.tagID === b.HTML ? (t._insertElement(e, Z.HTML), t.insertionMode = M.BEFORE_HEAD) : $s(t, e);
}
function z5(t, e) {
  const n = e.tagID;
  (n === b.HTML || n === b.HEAD || n === b.BODY || n === b.BR) && $s(t, e);
}
function $s(t, e) {
  t._insertFakeRootElement(), t.insertionMode = M.BEFORE_HEAD, t._processToken(e);
}
function q5(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.HEAD: {
      t._insertElement(e, Z.HTML), t.headElement = t.openElements.current, t.insertionMode = M.IN_HEAD;
      break;
    }
    default:
      Hs(t, e);
  }
}
function j5(t, e) {
  const n = e.tagID;
  n === b.HEAD || n === b.BODY || n === b.HTML || n === b.BR ? Hs(t, e) : t._err(e, K.endTagWithoutMatchingOpenElement);
}
function Hs(t, e) {
  t._insertFakeElement(j.HEAD, b.HEAD), t.headElement = t.openElements.current, t.insertionMode = M.IN_HEAD, t._processToken(e);
}
function En(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.BASE:
    case b.BASEFONT:
    case b.BGSOUND:
    case b.LINK:
    case b.META: {
      t._appendElement(e, Z.HTML), e.ackSelfClosing = !0;
      break;
    }
    case b.TITLE: {
      t._switchToTextParsing(e, it.RCDATA);
      break;
    }
    case b.NOSCRIPT: {
      t.options.scriptingEnabled ? t._switchToTextParsing(e, it.RAWTEXT) : (t._insertElement(e, Z.HTML), t.insertionMode = M.IN_HEAD_NO_SCRIPT);
      break;
    }
    case b.NOFRAMES:
    case b.STYLE: {
      t._switchToTextParsing(e, it.RAWTEXT);
      break;
    }
    case b.SCRIPT: {
      t._switchToTextParsing(e, it.SCRIPT_DATA);
      break;
    }
    case b.TEMPLATE: {
      t._insertTemplate(e), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = M.IN_TEMPLATE, t.tmplInsertionModeStack.unshift(M.IN_TEMPLATE);
      break;
    }
    case b.HEAD: {
      t._err(e, K.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Gs(t, e);
  }
}
function K5(t, e) {
  switch (e.tagID) {
    case b.HEAD: {
      t.openElements.pop(), t.insertionMode = M.AFTER_HEAD;
      break;
    }
    case b.BODY:
    case b.BR:
    case b.HTML: {
      Gs(t, e);
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
    default:
      t._err(e, K.endTagWithoutMatchingOpenElement);
  }
}
function ii(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagId !== b.TEMPLATE && t._err(e, K.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(b.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode()) : t._err(e, K.endTagWithoutMatchingOpenElement);
}
function Gs(t, e) {
  t.openElements.pop(), t.insertionMode = M.AFTER_HEAD, t._processToken(e);
}
function W5(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.BASEFONT:
    case b.BGSOUND:
    case b.HEAD:
    case b.LINK:
    case b.META:
    case b.NOFRAMES:
    case b.STYLE: {
      En(t, e);
      break;
    }
    case b.NOSCRIPT: {
      t._err(e, K.nestedNoscriptInHead);
      break;
    }
    default:
      Vs(t, e);
  }
}
function Y5(t, e) {
  switch (e.tagID) {
    case b.NOSCRIPT: {
      t.openElements.pop(), t.insertionMode = M.IN_HEAD;
      break;
    }
    case b.BR: {
      Vs(t, e);
      break;
    }
    default:
      t._err(e, K.endTagWithoutMatchingOpenElement);
  }
}
function Vs(t, e) {
  const n = e.type === Re.EOF ? K.openElementsLeftAfterEof : K.disallowedContentInNoscriptInHead;
  t._err(e, n), t.openElements.pop(), t.insertionMode = M.IN_HEAD, t._processToken(e);
}
function X5(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.BODY: {
      t._insertElement(e, Z.HTML), t.framesetOk = !1, t.insertionMode = M.IN_BODY;
      break;
    }
    case b.FRAMESET: {
      t._insertElement(e, Z.HTML), t.insertionMode = M.IN_FRAMESET;
      break;
    }
    case b.BASE:
    case b.BASEFONT:
    case b.BGSOUND:
    case b.LINK:
    case b.META:
    case b.NOFRAMES:
    case b.SCRIPT:
    case b.STYLE:
    case b.TEMPLATE:
    case b.TITLE: {
      t._err(e, K.abandonedHeadElementChild), t.openElements.push(t.headElement, b.HEAD), En(t, e), t.openElements.remove(t.headElement);
      break;
    }
    case b.HEAD: {
      t._err(e, K.misplacedStartTagForHeadElement);
      break;
    }
    default:
      zs(t, e);
  }
}
function Q5(t, e) {
  switch (e.tagID) {
    case b.BODY:
    case b.HTML:
    case b.BR: {
      zs(t, e);
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
    default:
      t._err(e, K.endTagWithoutMatchingOpenElement);
  }
}
function zs(t, e) {
  t._insertFakeElement(j.BODY, b.BODY), t.insertionMode = M.IN_BODY, Xu(t, e);
}
function Xu(t, e) {
  switch (e.type) {
    case Re.CHARACTER: {
      ix(t, e);
      break;
    }
    case Re.WHITESPACE_CHARACTER: {
      rx(t, e);
      break;
    }
    case Re.COMMENT: {
      vd(t, e);
      break;
    }
    case Re.START_TAG: {
      vt(t, e);
      break;
    }
    case Re.END_TAG: {
      Qu(t, e);
      break;
    }
    case Re.EOF: {
      ux(t, e);
      break;
    }
  }
}
function rx(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function ix(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function Z5(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function J5(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function eF(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_FRAMESET);
}
function tF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML);
}
function nF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t.openElements.currentTagId !== void 0 && Ad.has(t.openElements.currentTagId) && t.openElements.pop(), t._insertElement(e, Z.HTML);
}
function rF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function iF(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML), n || (t.formElement = t.openElements.current));
}
function sF(t, e) {
  t.framesetOk = !1;
  const n = e.tagID;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.tagIDs[r];
    if (n === b.LI && i === b.LI || (n === b.DD || n === b.DT) && (i === b.DD || i === b.DT)) {
      t.openElements.generateImpliedEndTagsWithExclusion(i), t.openElements.popUntilTagNamePopped(i);
      break;
    }
    if (i !== b.ADDRESS && i !== b.DIV && i !== b.P && t._isSpecialElement(t.openElements.items[r], i))
      break;
  }
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML);
}
function aF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML), t.tokenizer.state = it.PLAINTEXT;
}
function oF(t, e) {
  t.openElements.hasInScope(b.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(b.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML), t.framesetOk = !1;
}
function uF(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(j.A);
  n && (ih(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function lF(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function cF(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(b.NOBR) && (ih(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, Z.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function dF(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function fF(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== tn.QUIRKS && t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._insertElement(e, Z.HTML), t.framesetOk = !1, t.insertionMode = M.IN_TABLE;
}
function sx(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Z.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function ax(t) {
  const e = WT(t, jr.TYPE);
  return e != null && e.toLowerCase() === k5;
}
function hF(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, Z.HTML), ax(e) || (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function mF(t, e) {
  t._appendElement(e, Z.HTML), e.ackSelfClosing = !0;
}
function pF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._appendElement(e, Z.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function gF(t, e) {
  e.tagName = j.IMG, e.tagID = b.IMG, sx(t, e);
}
function bF(t, e) {
  t._insertElement(e, Z.HTML), t.skipNextNewLine = !0, t.tokenizer.state = it.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = M.TEXT;
}
function EF(t, e) {
  t.openElements.hasInButtonScope(b.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, it.RAWTEXT);
}
function yF(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, it.RAWTEXT);
}
function Dp(t, e) {
  t._switchToTextParsing(e, it.RAWTEXT);
}
function TF(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML), t.framesetOk = !1, t.insertionMode = t.insertionMode === M.IN_TABLE || t.insertionMode === M.IN_CAPTION || t.insertionMode === M.IN_TABLE_BODY || t.insertionMode === M.IN_ROW || t.insertionMode === M.IN_CELL ? M.IN_SELECT_IN_TABLE : M.IN_SELECT;
}
function xF(t, e) {
  t.openElements.currentTagId === b.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML);
}
function SF(t, e) {
  t.openElements.hasInScope(b.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, Z.HTML);
}
function AF(t, e) {
  t.openElements.hasInScope(b.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(b.RTC), t._insertElement(e, Z.HTML);
}
function vF(t, e) {
  t._reconstructActiveFormattingElements(), ex(e), rh(e), e.selfClosing ? t._appendElement(e, Z.MATHML) : t._insertElement(e, Z.MATHML), e.ackSelfClosing = !0;
}
function IF(t, e) {
  t._reconstructActiveFormattingElements(), tx(e), rh(e), e.selfClosing ? t._appendElement(e, Z.SVG) : t._insertElement(e, Z.SVG), e.ackSelfClosing = !0;
}
function Pp(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, Z.HTML);
}
function vt(t, e) {
  switch (e.tagID) {
    case b.I:
    case b.S:
    case b.B:
    case b.U:
    case b.EM:
    case b.TT:
    case b.BIG:
    case b.CODE:
    case b.FONT:
    case b.SMALL:
    case b.STRIKE:
    case b.STRONG: {
      lF(t, e);
      break;
    }
    case b.A: {
      uF(t, e);
      break;
    }
    case b.H1:
    case b.H2:
    case b.H3:
    case b.H4:
    case b.H5:
    case b.H6: {
      nF(t, e);
      break;
    }
    case b.P:
    case b.DL:
    case b.OL:
    case b.UL:
    case b.DIV:
    case b.DIR:
    case b.NAV:
    case b.MAIN:
    case b.MENU:
    case b.ASIDE:
    case b.CENTER:
    case b.FIGURE:
    case b.FOOTER:
    case b.HEADER:
    case b.HGROUP:
    case b.DIALOG:
    case b.DETAILS:
    case b.ADDRESS:
    case b.ARTICLE:
    case b.SEARCH:
    case b.SECTION:
    case b.SUMMARY:
    case b.FIELDSET:
    case b.BLOCKQUOTE:
    case b.FIGCAPTION: {
      tF(t, e);
      break;
    }
    case b.LI:
    case b.DD:
    case b.DT: {
      sF(t, e);
      break;
    }
    case b.BR:
    case b.IMG:
    case b.WBR:
    case b.AREA:
    case b.EMBED:
    case b.KEYGEN: {
      sx(t, e);
      break;
    }
    case b.HR: {
      pF(t, e);
      break;
    }
    case b.RB:
    case b.RTC: {
      SF(t, e);
      break;
    }
    case b.RT:
    case b.RP: {
      AF(t, e);
      break;
    }
    case b.PRE:
    case b.LISTING: {
      rF(t, e);
      break;
    }
    case b.XMP: {
      EF(t, e);
      break;
    }
    case b.SVG: {
      IF(t, e);
      break;
    }
    case b.HTML: {
      Z5(t, e);
      break;
    }
    case b.BASE:
    case b.LINK:
    case b.META:
    case b.STYLE:
    case b.TITLE:
    case b.SCRIPT:
    case b.BGSOUND:
    case b.BASEFONT:
    case b.TEMPLATE: {
      En(t, e);
      break;
    }
    case b.BODY: {
      J5(t, e);
      break;
    }
    case b.FORM: {
      iF(t, e);
      break;
    }
    case b.NOBR: {
      cF(t, e);
      break;
    }
    case b.MATH: {
      vF(t, e);
      break;
    }
    case b.TABLE: {
      fF(t, e);
      break;
    }
    case b.INPUT: {
      hF(t, e);
      break;
    }
    case b.PARAM:
    case b.TRACK:
    case b.SOURCE: {
      mF(t, e);
      break;
    }
    case b.IMAGE: {
      gF(t, e);
      break;
    }
    case b.BUTTON: {
      oF(t, e);
      break;
    }
    case b.APPLET:
    case b.OBJECT:
    case b.MARQUEE: {
      dF(t, e);
      break;
    }
    case b.IFRAME: {
      yF(t, e);
      break;
    }
    case b.SELECT: {
      TF(t, e);
      break;
    }
    case b.OPTION:
    case b.OPTGROUP: {
      xF(t, e);
      break;
    }
    case b.NOEMBED:
    case b.NOFRAMES: {
      Dp(t, e);
      break;
    }
    case b.FRAMESET: {
      eF(t, e);
      break;
    }
    case b.TEXTAREA: {
      bF(t, e);
      break;
    }
    case b.NOSCRIPT: {
      t.options.scriptingEnabled ? Dp(t, e) : Pp(t, e);
      break;
    }
    case b.PLAINTEXT: {
      aF(t, e);
      break;
    }
    case b.COL:
    case b.TH:
    case b.TD:
    case b.TR:
    case b.HEAD:
    case b.FRAME:
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD:
    case b.CAPTION:
    case b.COLGROUP:
      break;
    default:
      Pp(t, e);
  }
}
function CF(t, e) {
  if (t.openElements.hasInScope(b.BODY) && (t.insertionMode = M.AFTER_BODY, t.options.sourceCodeLocationInfo)) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    n && t._setEndLocation(n, e);
  }
}
function LF(t, e) {
  t.openElements.hasInScope(b.BODY) && (t.insertionMode = M.AFTER_BODY, gx(t, e));
}
function _F(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function RF(t) {
  const e = t.openElements.tmplCount > 0, { formElement: n } = t;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(b.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(b.FORM) : n && t.openElements.remove(n));
}
function kF(t) {
  t.openElements.hasInButtonScope(b.P) || t._insertFakeElement(j.P, b.P), t._closePElement();
}
function wF(t) {
  t.openElements.hasInListItemScope(b.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(b.LI), t.openElements.popUntilTagNamePopped(b.LI));
}
function DF(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function PF(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function OF(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function NF(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(j.BR, b.BR), t.openElements.pop(), t.framesetOk = !1;
}
function ox(t, e) {
  const n = e.tagName, r = e.tagID;
  for (let i = t.openElements.stackTop; i > 0; i--) {
    const s = t.openElements.items[i], a = t.openElements.tagIDs[i];
    if (r === a && (r !== b.UNKNOWN || t.treeAdapter.getTagName(s) === n)) {
      t.openElements.generateImpliedEndTagsWithExclusion(r), t.openElements.stackTop >= i && t.openElements.shortenToLength(i);
      break;
    }
    if (t._isSpecialElement(s, a))
      break;
  }
}
function Qu(t, e) {
  switch (e.tagID) {
    case b.A:
    case b.B:
    case b.I:
    case b.S:
    case b.U:
    case b.EM:
    case b.TT:
    case b.BIG:
    case b.CODE:
    case b.FONT:
    case b.NOBR:
    case b.SMALL:
    case b.STRIKE:
    case b.STRONG: {
      ih(t, e);
      break;
    }
    case b.P: {
      kF(t);
      break;
    }
    case b.DL:
    case b.UL:
    case b.OL:
    case b.DIR:
    case b.DIV:
    case b.NAV:
    case b.PRE:
    case b.MAIN:
    case b.MENU:
    case b.ASIDE:
    case b.BUTTON:
    case b.CENTER:
    case b.FIGURE:
    case b.FOOTER:
    case b.HEADER:
    case b.HGROUP:
    case b.DIALOG:
    case b.ADDRESS:
    case b.ARTICLE:
    case b.DETAILS:
    case b.SEARCH:
    case b.SECTION:
    case b.SUMMARY:
    case b.LISTING:
    case b.FIELDSET:
    case b.BLOCKQUOTE:
    case b.FIGCAPTION: {
      _F(t, e);
      break;
    }
    case b.LI: {
      wF(t);
      break;
    }
    case b.DD:
    case b.DT: {
      DF(t, e);
      break;
    }
    case b.H1:
    case b.H2:
    case b.H3:
    case b.H4:
    case b.H5:
    case b.H6: {
      PF(t);
      break;
    }
    case b.BR: {
      NF(t);
      break;
    }
    case b.BODY: {
      CF(t, e);
      break;
    }
    case b.HTML: {
      LF(t, e);
      break;
    }
    case b.FORM: {
      RF(t);
      break;
    }
    case b.APPLET:
    case b.OBJECT:
    case b.MARQUEE: {
      OF(t, e);
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
    default:
      ox(t, e);
  }
}
function ux(t, e) {
  t.tmplInsertionModeStack.length > 0 ? px(t, e) : sh(t, e);
}
function MF(t, e) {
  var n;
  e.tagID === b.SCRIPT && ((n = t.scriptHandler) === null || n === void 0 || n.call(t, t.openElements.current)), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function FF(t, e) {
  t._err(e, K.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t.onEof(e);
}
function ec(t, e) {
  if (t.openElements.currentTagId !== void 0 && nx.has(t.openElements.currentTagId))
    switch (t.pendingCharacterTokens.length = 0, t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = M.IN_TABLE_TEXT, e.type) {
      case Re.CHARACTER: {
        cx(t, e);
        break;
      }
      case Re.WHITESPACE_CHARACTER: {
        lx(t, e);
        break;
      }
    }
  else
    ka(t, e);
}
function BF(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_CAPTION;
}
function UF(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_COLUMN_GROUP;
}
function $F(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(j.COLGROUP, b.COLGROUP), t.insertionMode = M.IN_COLUMN_GROUP, ah(t, e);
}
function HF(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_TABLE_BODY;
}
function GF(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(j.TBODY, b.TBODY), t.insertionMode = M.IN_TABLE_BODY, Zu(t, e);
}
function VF(t, e) {
  t.openElements.hasInTableScope(b.TABLE) && (t.openElements.popUntilTagNamePopped(b.TABLE), t._resetInsertionMode(), t._processStartTag(e));
}
function zF(t, e) {
  ax(e) ? t._appendElement(e, Z.HTML) : ka(t, e), e.ackSelfClosing = !0;
}
function qF(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, Z.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function Qi(t, e) {
  switch (e.tagID) {
    case b.TD:
    case b.TH:
    case b.TR: {
      GF(t, e);
      break;
    }
    case b.STYLE:
    case b.SCRIPT:
    case b.TEMPLATE: {
      En(t, e);
      break;
    }
    case b.COL: {
      $F(t, e);
      break;
    }
    case b.FORM: {
      qF(t, e);
      break;
    }
    case b.TABLE: {
      VF(t, e);
      break;
    }
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD: {
      HF(t, e);
      break;
    }
    case b.INPUT: {
      zF(t, e);
      break;
    }
    case b.CAPTION: {
      BF(t, e);
      break;
    }
    case b.COLGROUP: {
      UF(t, e);
      break;
    }
    default:
      ka(t, e);
  }
}
function fa(t, e) {
  switch (e.tagID) {
    case b.TABLE: {
      t.openElements.hasInTableScope(b.TABLE) && (t.openElements.popUntilTagNamePopped(b.TABLE), t._resetInsertionMode());
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
    case b.BODY:
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.HTML:
    case b.TBODY:
    case b.TD:
    case b.TFOOT:
    case b.TH:
    case b.THEAD:
    case b.TR:
      break;
    default:
      ka(t, e);
  }
}
function ka(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, Xu(t, e), t.fosterParentingEnabled = n;
}
function lx(t, e) {
  t.pendingCharacterTokens.push(e);
}
function cx(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function Is(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      ka(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
const dx = /* @__PURE__ */ new Set([b.CAPTION, b.COL, b.COLGROUP, b.TBODY, b.TD, b.TFOOT, b.TH, b.THEAD, b.TR]);
function jF(t, e) {
  const n = e.tagID;
  dx.has(n) ? t.openElements.hasInTableScope(b.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(b.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = M.IN_TABLE, Qi(t, e)) : vt(t, e);
}
function KF(t, e) {
  const n = e.tagID;
  switch (n) {
    case b.CAPTION:
    case b.TABLE: {
      t.openElements.hasInTableScope(b.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(b.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = M.IN_TABLE, n === b.TABLE && fa(t, e));
      break;
    }
    case b.BODY:
    case b.COL:
    case b.COLGROUP:
    case b.HTML:
    case b.TBODY:
    case b.TD:
    case b.TFOOT:
    case b.TH:
    case b.THEAD:
    case b.TR:
      break;
    default:
      Qu(t, e);
  }
}
function ah(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.COL: {
      t._appendElement(e, Z.HTML), e.ackSelfClosing = !0;
      break;
    }
    case b.TEMPLATE: {
      En(t, e);
      break;
    }
    default:
      Su(t, e);
  }
}
function WF(t, e) {
  switch (e.tagID) {
    case b.COLGROUP: {
      t.openElements.currentTagId === b.COLGROUP && (t.openElements.pop(), t.insertionMode = M.IN_TABLE);
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
    case b.COL:
      break;
    default:
      Su(t, e);
  }
}
function Su(t, e) {
  t.openElements.currentTagId === b.COLGROUP && (t.openElements.pop(), t.insertionMode = M.IN_TABLE, t._processToken(e));
}
function Zu(t, e) {
  switch (e.tagID) {
    case b.TR: {
      t.openElements.clearBackToTableBodyContext(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_ROW;
      break;
    }
    case b.TH:
    case b.TD: {
      t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(j.TR, b.TR), t.insertionMode = M.IN_ROW, Ju(t, e);
      break;
    }
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE, Qi(t, e));
      break;
    }
    default:
      Qi(t, e);
  }
}
function Id(t, e) {
  const n = e.tagID;
  switch (e.tagID) {
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD: {
      t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE);
      break;
    }
    case b.TABLE: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE, fa(t, e));
      break;
    }
    case b.BODY:
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.HTML:
    case b.TD:
    case b.TH:
    case b.TR:
      break;
    default:
      fa(t, e);
  }
}
function Ju(t, e) {
  switch (e.tagID) {
    case b.TH:
    case b.TD: {
      t.openElements.clearBackToTableRowContext(), t._insertElement(e, Z.HTML), t.insertionMode = M.IN_CELL, t.activeFormattingElements.insertMarker();
      break;
    }
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD:
    case b.TR: {
      t.openElements.hasInTableScope(b.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE_BODY, Zu(t, e));
      break;
    }
    default:
      Qi(t, e);
  }
}
function fx(t, e) {
  switch (e.tagID) {
    case b.TR: {
      t.openElements.hasInTableScope(b.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE_BODY);
      break;
    }
    case b.TABLE: {
      t.openElements.hasInTableScope(b.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE_BODY, Id(t, e));
      break;
    }
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD: {
      (t.openElements.hasInTableScope(e.tagID) || t.openElements.hasInTableScope(b.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = M.IN_TABLE_BODY, Id(t, e));
      break;
    }
    case b.BODY:
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.HTML:
    case b.TD:
    case b.TH:
      break;
    default:
      fa(t, e);
  }
}
function YF(t, e) {
  const n = e.tagID;
  dx.has(n) ? (t.openElements.hasInTableScope(b.TD) || t.openElements.hasInTableScope(b.TH)) && (t._closeTableCell(), Ju(t, e)) : vt(t, e);
}
function XF(t, e) {
  const n = e.tagID;
  switch (n) {
    case b.TD:
    case b.TH: {
      t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = M.IN_ROW);
      break;
    }
    case b.TABLE:
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD:
    case b.TR: {
      t.openElements.hasInTableScope(n) && (t._closeTableCell(), fx(t, e));
      break;
    }
    case b.BODY:
    case b.CAPTION:
    case b.COL:
    case b.COLGROUP:
    case b.HTML:
      break;
    default:
      Qu(t, e);
  }
}
function hx(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.OPTION: {
      t.openElements.currentTagId === b.OPTION && t.openElements.pop(), t._insertElement(e, Z.HTML);
      break;
    }
    case b.OPTGROUP: {
      t.openElements.currentTagId === b.OPTION && t.openElements.pop(), t.openElements.currentTagId === b.OPTGROUP && t.openElements.pop(), t._insertElement(e, Z.HTML);
      break;
    }
    case b.HR: {
      t.openElements.currentTagId === b.OPTION && t.openElements.pop(), t.openElements.currentTagId === b.OPTGROUP && t.openElements.pop(), t._appendElement(e, Z.HTML), e.ackSelfClosing = !0;
      break;
    }
    case b.INPUT:
    case b.KEYGEN:
    case b.TEXTAREA:
    case b.SELECT: {
      t.openElements.hasInSelectScope(b.SELECT) && (t.openElements.popUntilTagNamePopped(b.SELECT), t._resetInsertionMode(), e.tagID !== b.SELECT && t._processStartTag(e));
      break;
    }
    case b.SCRIPT:
    case b.TEMPLATE: {
      En(t, e);
      break;
    }
  }
}
function mx(t, e) {
  switch (e.tagID) {
    case b.OPTGROUP: {
      t.openElements.stackTop > 0 && t.openElements.currentTagId === b.OPTION && t.openElements.tagIDs[t.openElements.stackTop - 1] === b.OPTGROUP && t.openElements.pop(), t.openElements.currentTagId === b.OPTGROUP && t.openElements.pop();
      break;
    }
    case b.OPTION: {
      t.openElements.currentTagId === b.OPTION && t.openElements.pop();
      break;
    }
    case b.SELECT: {
      t.openElements.hasInSelectScope(b.SELECT) && (t.openElements.popUntilTagNamePopped(b.SELECT), t._resetInsertionMode());
      break;
    }
    case b.TEMPLATE: {
      ii(t, e);
      break;
    }
  }
}
function QF(t, e) {
  const n = e.tagID;
  n === b.CAPTION || n === b.TABLE || n === b.TBODY || n === b.TFOOT || n === b.THEAD || n === b.TR || n === b.TD || n === b.TH ? (t.openElements.popUntilTagNamePopped(b.SELECT), t._resetInsertionMode(), t._processStartTag(e)) : hx(t, e);
}
function ZF(t, e) {
  const n = e.tagID;
  n === b.CAPTION || n === b.TABLE || n === b.TBODY || n === b.TFOOT || n === b.THEAD || n === b.TR || n === b.TD || n === b.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(b.SELECT), t._resetInsertionMode(), t.onEndTag(e)) : mx(t, e);
}
function JF(t, e) {
  switch (e.tagID) {
    case b.BASE:
    case b.BASEFONT:
    case b.BGSOUND:
    case b.LINK:
    case b.META:
    case b.NOFRAMES:
    case b.SCRIPT:
    case b.STYLE:
    case b.TEMPLATE:
    case b.TITLE: {
      En(t, e);
      break;
    }
    case b.CAPTION:
    case b.COLGROUP:
    case b.TBODY:
    case b.TFOOT:
    case b.THEAD: {
      t.tmplInsertionModeStack[0] = M.IN_TABLE, t.insertionMode = M.IN_TABLE, Qi(t, e);
      break;
    }
    case b.COL: {
      t.tmplInsertionModeStack[0] = M.IN_COLUMN_GROUP, t.insertionMode = M.IN_COLUMN_GROUP, ah(t, e);
      break;
    }
    case b.TR: {
      t.tmplInsertionModeStack[0] = M.IN_TABLE_BODY, t.insertionMode = M.IN_TABLE_BODY, Zu(t, e);
      break;
    }
    case b.TD:
    case b.TH: {
      t.tmplInsertionModeStack[0] = M.IN_ROW, t.insertionMode = M.IN_ROW, Ju(t, e);
      break;
    }
    default:
      t.tmplInsertionModeStack[0] = M.IN_BODY, t.insertionMode = M.IN_BODY, vt(t, e);
  }
}
function eB(t, e) {
  e.tagID === b.TEMPLATE && ii(t, e);
}
function px(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(b.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode(), t.onEof(e)) : sh(t, e);
}
function tB(t, e) {
  e.tagID === b.HTML ? vt(t, e) : Au(t, e);
}
function gx(t, e) {
  var n;
  if (e.tagID === b.HTML) {
    if (t.fragmentContext || (t.insertionMode = M.AFTER_AFTER_BODY), t.options.sourceCodeLocationInfo && t.openElements.tagIDs[0] === b.HTML) {
      t._setEndLocation(t.openElements.items[0], e);
      const r = t.openElements.items[1];
      r && !(!((n = t.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && t._setEndLocation(r, e);
    }
  } else
    Au(t, e);
}
function Au(t, e) {
  t.insertionMode = M.IN_BODY, Xu(t, e);
}
function nB(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.FRAMESET: {
      t._insertElement(e, Z.HTML);
      break;
    }
    case b.FRAME: {
      t._appendElement(e, Z.HTML), e.ackSelfClosing = !0;
      break;
    }
    case b.NOFRAMES: {
      En(t, e);
      break;
    }
  }
}
function rB(t, e) {
  e.tagID === b.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagId !== b.FRAMESET && (t.insertionMode = M.AFTER_FRAMESET));
}
function iB(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.NOFRAMES: {
      En(t, e);
      break;
    }
  }
}
function sB(t, e) {
  e.tagID === b.HTML && (t.insertionMode = M.AFTER_AFTER_FRAMESET);
}
function aB(t, e) {
  e.tagID === b.HTML ? vt(t, e) : qo(t, e);
}
function qo(t, e) {
  t.insertionMode = M.IN_BODY, Xu(t, e);
}
function oB(t, e) {
  switch (e.tagID) {
    case b.HTML: {
      vt(t, e);
      break;
    }
    case b.NOFRAMES: {
      En(t, e);
      break;
    }
  }
}
function uB(t, e) {
  e.chars = Xe, t._insertCharacters(e);
}
function lB(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function bx(t) {
  for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== Z.HTML && t.openElements.currentTagId !== void 0 && !t._isIntegrationPoint(t.openElements.currentTagId, t.openElements.current); )
    t.openElements.pop();
}
function cB(t, e) {
  if (I5(e))
    bx(t), t._startTagOutsideForeignContent(e);
  else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === Z.MATHML ? ex(e) : r === Z.SVG && (C5(e), tx(e)), rh(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function dB(t, e) {
  if (e.tagID === b.P || e.tagID === b.BR) {
    bx(t), t._endTagOutsideForeignContent(e);
    return;
  }
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === Z.HTML) {
      t._endTagOutsideForeignContent(e);
      break;
    }
    const i = t.treeAdapter.getTagName(r);
    if (i.toLowerCase() === e.tagName) {
      e.tagName = i, t.openElements.shortenToLength(n);
      break;
    }
  }
}
j.AREA, j.BASE, j.BASEFONT, j.BGSOUND, j.BR, j.COL, j.EMBED, j.FRAME, j.HR, j.IMG, j.INPUT, j.KEYGEN, j.LINK, j.META, j.PARAM, j.SOURCE, j.TRACK, j.WBR;
const Ex = yx("end"), si = yx("start");
function yx(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
const Tx = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return pB;
    if (typeof t == "function")
      return el(t);
    if (typeof t == "object")
      return Array.isArray(t) ? fB(t) : hB(t);
    if (typeof t == "string")
      return mB(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function fB(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Tx(t[n]);
  return el(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function hB(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return el(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function mB(t) {
  return el(e);
  function e(n) {
    return n && n.type === t;
  }
}
function el(t) {
  return e;
  function e(n, r, i) {
    return !!(gB(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function pB() {
  return !0;
}
function gB(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const xx = [], bB = !0, vu = !1, EB = "skip";
function Sx(t, e, n, r) {
  let i;
  typeof e == "function" && typeof n != "function" ? (r = n, n = e) : i = e;
  const s = Tx(i), a = r ? -1 : 1;
  o(t, void 0, [])();
  function o(u, l, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      u && typeof u == "object" ? u : {}
    );
    if (typeof d.type == "string") {
      const h = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (u.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let h = xx, m, p, g;
      if ((!e || s(u, l, c[c.length - 1] || void 0)) && (h = yB(n(u, c)), h[0] === vu))
        return h;
      if ("children" in u && u.children) {
        const E = (
          /** @type {UnistParent} */
          u
        );
        if (E.children && h[0] !== EB)
          for (p = (r ? E.children.length : -1) + a, g = c.concat(E); p > -1 && p < E.children.length; ) {
            const y = E.children[p];
            if (m = o(y, p, g)(), m[0] === vu)
              return m;
            p = typeof m[1] == "number" ? m[1] : p + a;
          }
      }
      return h;
    }
  }
}
function yB(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [bB, t] : t == null ? xx : [t];
}
function tl(t, e, n, r) {
  let i, s, a;
  typeof e == "function" && typeof n != "function" ? (s = void 0, a = e, i = n) : (s = e, a = n, i = r), Sx(t, s, o, i);
  function o(u, l) {
    const c = l[l.length - 1], d = c ? c.children.indexOf(u) : void 0;
    return a(u, d, c);
  }
}
const TB = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, xB = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Op = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function Ax(t, e) {
  const n = wB(t), r = th("type", {
    handlers: { root: SB, element: AB, text: vB, comment: Ix, doctype: IB, raw: LB },
    unknown: _B
  }), i = {
    parser: n ? new wp(Op) : wp.getFragmentParser(void 0, Op),
    handle(o) {
      r(o, i);
    },
    stitches: !1,
    options: e || {}
  };
  r(t, i), cs(i, si());
  const s = n ? i.parser.document : i.parser.getFragment(), a = pM(s, {
    // To do: support `space`?
    file: i.options.file
  });
  return i.stitches && tl(a, "comment", function(o, u, l) {
    const c = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (c.value.stitch && l && u !== void 0) {
      const d = l.children;
      return d[u] = c.value.stitch, u;
    }
  }), a.type === "root" && a.children.length === 1 && a.children[0].type === t.type ? a.children[0] : a;
}
function vx(t, e) {
  let n = -1;
  if (t)
    for (; ++n < t.length; )
      e.handle(t[n]);
}
function SB(t, e) {
  vx(t.children, e);
}
function AB(t, e) {
  RB(t, e), vx(t.children, e), kB(t, e);
}
function vB(t, e) {
  e.parser.tokenizer.state > 4 && (e.parser.tokenizer.state = 0);
  const n = {
    type: Re.CHARACTER,
    chars: t.value,
    location: wa(t)
  };
  cs(e, si(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function IB(t, e) {
  const n = {
    type: Re.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: wa(t)
  };
  cs(e, si(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function CB(t, e) {
  e.stitches = !0;
  const n = DB(t);
  if ("children" in t && "children" in n) {
    const r = (
      /** @type {Root} */
      Ax({ type: "root", children: t.children }, e.options)
    );
    n.children = r.children;
  }
  Ix({ type: "comment", value: { stitch: n } }, e);
}
function Ix(t, e) {
  const n = t.value, r = {
    type: Re.COMMENT,
    data: n,
    location: wa(t)
  };
  cs(e, si(t)), e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken);
}
function LB(t, e) {
  if (e.parser.tokenizer.preprocessor.html = "", e.parser.tokenizer.preprocessor.pos = -1, e.parser.tokenizer.preprocessor.lastGapPos = -2, e.parser.tokenizer.preprocessor.gapStack = [], e.parser.tokenizer.preprocessor.skipNextNewLine = !1, e.parser.tokenizer.preprocessor.lastChunkWritten = !1, e.parser.tokenizer.preprocessor.endOfChunkHit = !1, e.parser.tokenizer.preprocessor.isEol = !1, Cx(e, si(t)), e.parser.tokenizer.write(
    e.options.tagfilter ? t.value.replace(TB, "&lt;$1$2") : t.value,
    !1
  ), e.parser.tokenizer._runParsingLoop(), e.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  e.parser.tokenizer.state === 78) {
    e.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = e.parser.tokenizer._consume();
    e.parser.tokenizer._callState(n);
  }
}
function _B(t, e) {
  const n = (
    /** @type {Nodes} */
    t
  );
  if (e.options.passThrough && e.options.passThrough.includes(n.type))
    CB(n, e);
  else {
    let r = "";
    throw xB.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function cs(t, e) {
  Cx(t, e);
  const n = t.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = t.parser.tokenizer.preprocessor.line, n.location.endCol = t.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = t.parser.tokenizer.preprocessor.offset + 1, t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken)), t.parser.tokenizer.paused = !1, t.parser.tokenizer.inLoop = !1, t.parser.tokenizer.active = !1, t.parser.tokenizer.returnState = it.DATA, t.parser.tokenizer.charRefCode = -1, t.parser.tokenizer.consumedAfterSnapshot = -1, t.parser.tokenizer.currentLocation = null, t.parser.tokenizer.currentCharacterToken = null, t.parser.tokenizer.currentToken = null, t.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function Cx(t, e) {
  if (e && e.offset !== void 0) {
    const n = {
      startLine: e.line,
      startCol: e.column,
      startOffset: e.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    t.parser.tokenizer.preprocessor.lineStartPos = -e.column + 1, t.parser.tokenizer.preprocessor.droppedBufferSize = e.offset, t.parser.tokenizer.preprocessor.line = e.line, t.parser.tokenizer.currentLocation = n;
  }
}
function RB(t, e) {
  const n = t.tagName.toLowerCase();
  if (e.parser.tokenizer.state === it.PLAINTEXT) return;
  cs(e, si(t));
  const r = e.parser.openElements.current;
  let i = "namespaceURI" in r ? r.namespaceURI : $r.html;
  i === $r.html && n === "svg" && (i = $r.svg);
  const s = kM(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...t, children: [] },
    { space: i === $r.svg ? "svg" : "html" }
  ), a = {
    type: Re.START_TAG,
    tagName: n,
    tagID: ls(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in s ? s.attrs : [],
    location: wa(t)
  };
  e.parser.currentToken = a, e.parser._processToken(e.parser.currentToken), e.parser.tokenizer.lastStartTagName = n;
}
function kB(t, e) {
  const n = t.tagName.toLowerCase();
  if (!e.parser.tokenizer.inForeignNode && zT.includes(n) || e.parser.tokenizer.state === it.PLAINTEXT) return;
  cs(e, Ex(t));
  const r = {
    type: Re.END_TAG,
    tagName: n,
    tagID: ls(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: wa(t)
  };
  e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken), // Current element is closed.
  n === e.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (e.parser.tokenizer.state === it.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  e.parser.tokenizer.state === it.RAWTEXT || // `<script>`
  e.parser.tokenizer.state === it.SCRIPT_DATA) && (e.parser.tokenizer.state = it.DATA);
}
function wB(t) {
  const e = t.type === "root" ? t.children[0] : t;
  return !!(e && (e.type === "doctype" || e.type === "element" && e.tagName.toLowerCase() === "html"));
}
function wa(t) {
  const e = si(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = Ex(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: e.line,
    startCol: e.column,
    startOffset: e.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function DB(t) {
  return "children" in t ? Xi({ ...t, children: [] }) : Xi(t);
}
function PB(t) {
  return function(e, n) {
    return (
      /** @type {Root} */
      Ax(e, { ...t, file: n })
    );
  };
}
class Da {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
}
Da.prototype.normal = {};
Da.prototype.property = {};
Da.prototype.space = void 0;
function Lx(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Da(n, r, e);
}
function Cd(t) {
  return t.toLowerCase();
}
class Ut {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
}
Ut.prototype.attribute = "";
Ut.prototype.booleanish = !1;
Ut.prototype.boolean = !1;
Ut.prototype.commaOrSpaceSeparated = !1;
Ut.prototype.commaSeparated = !1;
Ut.prototype.defined = !1;
Ut.prototype.mustUseProperty = !1;
Ut.prototype.number = !1;
Ut.prototype.overloadedBoolean = !1;
Ut.prototype.property = "";
Ut.prototype.spaceSeparated = !1;
Ut.prototype.space = void 0;
let OB = 0;
const Ie = ai(), ut = ai(), Ld = ai(), se = ai(), We = ai(), Mi = ai(), Kt = ai();
function ai() {
  return 2 ** ++OB;
}
const _d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Ie,
  booleanish: ut,
  commaOrSpaceSeparated: Kt,
  commaSeparated: Mi,
  number: se,
  overloadedBoolean: Ld,
  spaceSeparated: We
}, Symbol.toStringTag, { value: "Module" })), tc = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(_d)
);
class oh extends Ut {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), Np(this, "space", i), typeof r == "number")
      for (; ++s < tc.length; ) {
        const a = tc[s];
        Np(this, tc[s], (r & _d[a]) === _d[a]);
      }
  }
}
oh.prototype.defined = !0;
function Np(t, e, n) {
  n && (t[e] = n);
}
function ds(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new oh(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[Cd(r)] = r, n[Cd(s.attribute)] = r;
  }
  return new Da(e, n, t.space);
}
const _x = ds({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ut,
    ariaAutoComplete: null,
    ariaBusy: ut,
    ariaChecked: ut,
    ariaColCount: se,
    ariaColIndex: se,
    ariaColSpan: se,
    ariaControls: We,
    ariaCurrent: null,
    ariaDescribedBy: We,
    ariaDetails: null,
    ariaDisabled: ut,
    ariaDropEffect: We,
    ariaErrorMessage: null,
    ariaExpanded: ut,
    ariaFlowTo: We,
    ariaGrabbed: ut,
    ariaHasPopup: null,
    ariaHidden: ut,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: We,
    ariaLevel: se,
    ariaLive: null,
    ariaModal: ut,
    ariaMultiLine: ut,
    ariaMultiSelectable: ut,
    ariaOrientation: null,
    ariaOwns: We,
    ariaPlaceholder: null,
    ariaPosInSet: se,
    ariaPressed: ut,
    ariaReadOnly: ut,
    ariaRelevant: null,
    ariaRequired: ut,
    ariaRoleDescription: We,
    ariaRowCount: se,
    ariaRowIndex: se,
    ariaRowSpan: se,
    ariaSelected: ut,
    ariaSetSize: se,
    ariaSort: null,
    ariaValueMax: se,
    ariaValueMin: se,
    ariaValueNow: se,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function Rx(t, e) {
  return e in t ? t[e] : e;
}
function kx(t, e) {
  return Rx(t, e.toLowerCase());
}
const NB = ds({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Mi,
    acceptCharset: We,
    accessKey: We,
    action: null,
    allow: null,
    allowFullScreen: Ie,
    allowPaymentRequest: Ie,
    allowUserMedia: Ie,
    alt: null,
    as: null,
    async: Ie,
    autoCapitalize: null,
    autoComplete: We,
    autoFocus: Ie,
    autoPlay: Ie,
    blocking: We,
    capture: null,
    charSet: null,
    checked: Ie,
    cite: null,
    className: We,
    cols: se,
    colSpan: null,
    content: null,
    contentEditable: ut,
    controls: Ie,
    controlsList: We,
    coords: se | Mi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Ie,
    defer: Ie,
    dir: null,
    dirName: null,
    disabled: Ie,
    download: Ld,
    draggable: ut,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Ie,
    formTarget: null,
    headers: We,
    height: se,
    hidden: Ld,
    high: se,
    href: null,
    hrefLang: null,
    htmlFor: We,
    httpEquiv: We,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Ie,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Ie,
    itemId: null,
    itemProp: We,
    itemRef: We,
    itemScope: Ie,
    itemType: We,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Ie,
    low: se,
    manifest: null,
    max: null,
    maxLength: se,
    media: null,
    method: null,
    min: null,
    minLength: se,
    multiple: Ie,
    muted: Ie,
    name: null,
    nonce: null,
    noModule: Ie,
    noValidate: Ie,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Ie,
    optimum: se,
    pattern: null,
    ping: We,
    placeholder: null,
    playsInline: Ie,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Ie,
    referrerPolicy: null,
    rel: We,
    required: Ie,
    reversed: Ie,
    rows: se,
    rowSpan: se,
    sandbox: We,
    scope: null,
    scoped: Ie,
    seamless: Ie,
    selected: Ie,
    shadowRootClonable: Ie,
    shadowRootDelegatesFocus: Ie,
    shadowRootMode: null,
    shape: null,
    size: se,
    sizes: null,
    slot: null,
    span: se,
    spellCheck: ut,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: se,
    step: null,
    style: null,
    tabIndex: se,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Ie,
    useMap: null,
    value: ut,
    width: se,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: We,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: se,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: se,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Ie,
    // Lists. Use CSS to reduce space between items instead
    declare: Ie,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: se,
    // `<img>` and `<object>`
    leftMargin: se,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: se,
    // `<body>`
    marginWidth: se,
    // `<body>`
    noResize: Ie,
    // `<frame>`
    noHref: Ie,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Ie,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Ie,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: se,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ut,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: se,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: se,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Ie,
    disableRemotePlayback: Ie,
    prefix: null,
    property: null,
    results: se,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: kx
}), MB = ds({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Kt,
    accentHeight: se,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: se,
    amplitude: se,
    arabicForm: null,
    ascent: se,
    attributeName: null,
    attributeType: null,
    azimuth: se,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: se,
    by: null,
    calcMode: null,
    capHeight: se,
    className: We,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: se,
    diffuseConstant: se,
    direction: null,
    display: null,
    dur: null,
    divisor: se,
    dominantBaseline: null,
    download: Ie,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: se,
    enableBackground: null,
    end: null,
    event: null,
    exponent: se,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: se,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Mi,
    g2: Mi,
    glyphName: Mi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: se,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: se,
    horizOriginX: se,
    horizOriginY: se,
    id: null,
    ideographic: se,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: se,
    k: se,
    k1: se,
    k2: se,
    k3: se,
    k4: se,
    kernelMatrix: Kt,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: se,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: se,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: se,
    overlineThickness: se,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: se,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: We,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: se,
    pointsAtY: se,
    pointsAtZ: se,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Kt,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Kt,
    rev: Kt,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Kt,
    requiredFeatures: Kt,
    requiredFonts: Kt,
    requiredFormats: Kt,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: se,
    specularExponent: se,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: se,
    strikethroughThickness: se,
    string: null,
    stroke: null,
    strokeDashArray: Kt,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: se,
    strokeOpacity: se,
    strokeWidth: null,
    style: null,
    surfaceScale: se,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Kt,
    tabIndex: se,
    tableValues: null,
    target: null,
    targetX: se,
    targetY: se,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Kt,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: se,
    underlineThickness: se,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: se,
    values: null,
    vAlphabetic: se,
    vMathematical: se,
    vectorEffect: null,
    vHanging: se,
    vIdeographic: se,
    version: null,
    vertAdvY: se,
    vertOriginX: se,
    vertOriginY: se,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: se,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Rx
}), wx = ds({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), Dx = ds({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: kx
}), Px = ds({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), FB = /[A-Z]/g, Mp = /-[a-z]/g, BB = /^data[-\w.:]+$/i;
function UB(t, e) {
  const n = Cd(e);
  let r = e, i = Ut;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && BB.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(Mp, HB);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!Mp.test(s)) {
        let a = s.replace(FB, $B);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = oh;
  }
  return new i(r, e);
}
function $B(t) {
  return "-" + t.toLowerCase();
}
function HB(t) {
  return t.charAt(1).toUpperCase();
}
const GB = Lx([_x, NB, wx, Dx, Px], "html"), Ox = Lx([_x, MB, wx, Dx, Px], "svg"), VB = /["&'<>`]/g, zB = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, qB = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), jB = /[|\\{}()[\]^$+*?.]/g, Fp = /* @__PURE__ */ new WeakMap();
function KB(t, e) {
  if (t = t.replace(
    e.subset ? WB(e.subset) : VB,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(zB, n).replace(qB, r);
  function n(i, s, a) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(s + 2),
      e
    );
  }
  function r(i, s, a) {
    return e.format(
      i.charCodeAt(0),
      a.charCodeAt(s + 1),
      e
    );
  }
}
function WB(t) {
  let e = Fp.get(t);
  return e || (e = YB(t), Fp.set(t, e)), e;
}
function YB(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(jB, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const XB = /[\dA-Fa-f]/;
function QB(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !XB.test(String.fromCharCode(e)) ? r : r + ";";
}
const ZB = /\d/;
function JB(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !ZB.test(String.fromCharCode(e)) ? r : r + ";";
}
const e9 = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], nc = {
  nbsp: "Â ",
  iexcl: "Â¡",
  cent: "Â¢",
  pound: "Â£",
  curren: "Â¤",
  yen: "Â¥",
  brvbar: "Â¦",
  sect: "Â§",
  uml: "Â¨",
  copy: "Â©",
  ordf: "Âª",
  laquo: "Â«",
  not: "Â¬",
  shy: "Â­",
  reg: "Â®",
  macr: "Â¯",
  deg: "Â°",
  plusmn: "Â±",
  sup2: "Â²",
  sup3: "Â³",
  acute: "Â´",
  micro: "Âµ",
  para: "Â¶",
  middot: "Â·",
  cedil: "Â¸",
  sup1: "Â¹",
  ordm: "Âº",
  raquo: "Â»",
  frac14: "Â¼",
  frac12: "Â½",
  frac34: "Â¾",
  iquest: "Â¿",
  Agrave: "Ã€",
  Aacute: "Ã",
  Acirc: "Ã‚",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Aring: "Ã…",
  AElig: "Ã†",
  Ccedil: "Ã‡",
  Egrave: "Ãˆ",
  Eacute: "Ã‰",
  Ecirc: "ÃŠ",
  Euml: "Ã‹",
  Igrave: "ÃŒ",
  Iacute: "Ã",
  Icirc: "Ã",
  Iuml: "Ã",
  ETH: "Ã",
  Ntilde: "Ã‘",
  Ograve: "Ã’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Otilde: "Ã•",
  Ouml: "Ã–",
  times: "Ã—",
  Oslash: "Ã˜",
  Ugrave: "Ã™",
  Uacute: "Ãš",
  Ucirc: "Ã›",
  Uuml: "Ãœ",
  Yacute: "Ã",
  THORN: "Ã",
  szlig: "ÃŸ",
  agrave: "Ã ",
  aacute: "Ã¡",
  acirc: "Ã¢",
  atilde: "Ã£",
  auml: "Ã¤",
  aring: "Ã¥",
  aelig: "Ã¦",
  ccedil: "Ã§",
  egrave: "Ã¨",
  eacute: "Ã©",
  ecirc: "Ãª",
  euml: "Ã«",
  igrave: "Ã¬",
  iacute: "Ã­",
  icirc: "Ã®",
  iuml: "Ã¯",
  eth: "Ã°",
  ntilde: "Ã±",
  ograve: "Ã²",
  oacute: "Ã³",
  ocirc: "Ã´",
  otilde: "Ãµ",
  ouml: "Ã¶",
  divide: "Ã·",
  oslash: "Ã¸",
  ugrave: "Ã¹",
  uacute: "Ãº",
  ucirc: "Ã»",
  uuml: "Ã¼",
  yacute: "Ã½",
  thorn: "Ã¾",
  yuml: "Ã¿",
  fnof: "Æ’",
  Alpha: "Î‘",
  Beta: "Î’",
  Gamma: "Î“",
  Delta: "Î”",
  Epsilon: "Î•",
  Zeta: "Î–",
  Eta: "Î—",
  Theta: "Î˜",
  Iota: "Î™",
  Kappa: "Îš",
  Lambda: "Î›",
  Mu: "Îœ",
  Nu: "Î",
  Xi: "Î",
  Omicron: "ÎŸ",
  Pi: "Î ",
  Rho: "Î¡",
  Sigma: "Î£",
  Tau: "Î¤",
  Upsilon: "Î¥",
  Phi: "Î¦",
  Chi: "Î§",
  Psi: "Î¨",
  Omega: "Î©",
  alpha: "Î±",
  beta: "Î²",
  gamma: "Î³",
  delta: "Î´",
  epsilon: "Îµ",
  zeta: "Î¶",
  eta: "Î·",
  theta: "Î¸",
  iota: "Î¹",
  kappa: "Îº",
  lambda: "Î»",
  mu: "Î¼",
  nu: "Î½",
  xi: "Î¾",
  omicron: "Î¿",
  pi: "Ï€",
  rho: "Ï",
  sigmaf: "Ï‚",
  sigma: "Ïƒ",
  tau: "Ï„",
  upsilon: "Ï…",
  phi: "Ï†",
  chi: "Ï‡",
  psi: "Ïˆ",
  omega: "Ï‰",
  thetasym: "Ï‘",
  upsih: "Ï’",
  piv: "Ï–",
  bull: "â€¢",
  hellip: "â€¦",
  prime: "â€²",
  Prime: "â€³",
  oline: "â€¾",
  frasl: "â„",
  weierp: "â„˜",
  image: "â„‘",
  real: "â„œ",
  trade: "â„¢",
  alefsym: "â„µ",
  larr: "â†",
  uarr: "â†‘",
  rarr: "â†’",
  darr: "â†“",
  harr: "â†”",
  crarr: "â†µ",
  lArr: "â‡",
  uArr: "â‡‘",
  rArr: "â‡’",
  dArr: "â‡“",
  hArr: "â‡”",
  forall: "âˆ€",
  part: "âˆ‚",
  exist: "âˆƒ",
  empty: "âˆ…",
  nabla: "âˆ‡",
  isin: "âˆˆ",
  notin: "âˆ‰",
  ni: "âˆ‹",
  prod: "âˆ",
  sum: "âˆ‘",
  minus: "âˆ’",
  lowast: "âˆ—",
  radic: "âˆš",
  prop: "âˆ",
  infin: "âˆ",
  ang: "âˆ ",
  and: "âˆ§",
  or: "âˆ¨",
  cap: "âˆ©",
  cup: "âˆª",
  int: "âˆ«",
  there4: "âˆ´",
  sim: "âˆ¼",
  cong: "â‰…",
  asymp: "â‰ˆ",
  ne: "â‰ ",
  equiv: "â‰¡",
  le: "â‰¤",
  ge: "â‰¥",
  sub: "âŠ‚",
  sup: "âŠƒ",
  nsub: "âŠ„",
  sube: "âŠ†",
  supe: "âŠ‡",
  oplus: "âŠ•",
  otimes: "âŠ—",
  perp: "âŠ¥",
  sdot: "â‹…",
  lceil: "âŒˆ",
  rceil: "âŒ‰",
  lfloor: "âŒŠ",
  rfloor: "âŒ‹",
  lang: "âŒ©",
  rang: "âŒª",
  loz: "â—Š",
  spades: "â™ ",
  clubs: "â™£",
  hearts: "â™¥",
  diams: "â™¦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Å’",
  oelig: "Å“",
  Scaron: "Å ",
  scaron: "Å¡",
  Yuml: "Å¸",
  circ: "Ë†",
  tilde: "Ëœ",
  ensp: "â€‚",
  emsp: "â€ƒ",
  thinsp: "â€‰",
  zwnj: "â€Œ",
  zwj: "â€",
  lrm: "â€",
  rlm: "â€",
  ndash: "â€“",
  mdash: "â€”",
  lsquo: "â€˜",
  rsquo: "â€™",
  sbquo: "â€š",
  ldquo: "â€œ",
  rdquo: "â€",
  bdquo: "â€",
  dagger: "â€ ",
  Dagger: "â€¡",
  permil: "â€°",
  lsaquo: "â€¹",
  rsaquo: "â€º",
  euro: "â‚¬"
}, t9 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], Nx = {}.hasOwnProperty, Rd = {};
let xo;
for (xo in nc)
  Nx.call(nc, xo) && (Rd[nc[xo]] = xo);
const n9 = /[^\dA-Za-z]/;
function r9(t, e, n, r) {
  const i = String.fromCharCode(t);
  if (Nx.call(Rd, i)) {
    const s = Rd[i], a = "&" + s;
    return n && e9.includes(s) && !t9.includes(s) && (!r || e && e !== 61 && n9.test(String.fromCharCode(e))) ? a : a + ";";
  }
  return "";
}
function i9(t, e, n) {
  let r = QB(t, e, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = r9(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const s = JB(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function Fi(t, e) {
  return KB(t, Object.assign({ format: i9 }, e));
}
const s9 = /^>|^->|<!--|-->|--!>|<!-$/g, a9 = [">"], o9 = ["<", ">"];
function u9(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Fi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: a9
    })
  ) + ">" : "<!--" + t.value.replace(s9, i) + "-->";
  function i(s) {
    return Fi(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: o9
      })
    );
  }
}
function l9(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
function Iu(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(e);
  for (; i !== -1; )
    r++, i = n.indexOf(e, i + e.length);
  return r;
}
const c9 = /[ \t\n\f\r]/g;
function uh(t) {
  return typeof t == "object" ? t.type === "text" ? Bp(t.value) : !1 : Bp(t);
}
function Bp(t) {
  return t.replace(c9, "") === "";
}
const ht = Fx(1), Mx = Fx(-1), d9 = [];
function Fx(t) {
  return e;
  function e(n, r, i) {
    const s = n ? n.children : d9;
    let a = (r || 0) + t, o = s[a];
    if (!i)
      for (; o && uh(o); )
        a += t, o = s[a];
    return o;
  }
}
const f9 = {}.hasOwnProperty;
function Bx(t) {
  return e;
  function e(n, r, i) {
    return f9.call(t, n.tagName) && t[n.tagName](n, r, i);
  }
}
const lh = Bx({
  body: m9,
  caption: rc,
  colgroup: rc,
  dd: E9,
  dt: b9,
  head: rc,
  html: h9,
  li: g9,
  optgroup: y9,
  option: T9,
  p: p9,
  rp: Up,
  rt: Up,
  tbody: S9,
  td: $p,
  tfoot: A9,
  th: $p,
  thead: x9,
  tr: v9
});
function rc(t, e, n) {
  const r = ht(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && uh(r.value.charAt(0)));
}
function h9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type !== "comment";
}
function m9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type !== "comment";
}
function p9(t, e, n) {
  const r = ht(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function g9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function b9(t, e, n) {
  const r = ht(n, e);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function E9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function Up(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function y9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function T9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function x9(t, e, n) {
  const r = ht(n, e);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function S9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function A9(t, e, n) {
  return !ht(n, e);
}
function v9(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function $p(t, e, n) {
  const r = ht(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const I9 = Bx({
  body: _9,
  colgroup: R9,
  head: L9,
  html: C9,
  tbody: k9
});
function C9(t) {
  const e = ht(t, -1);
  return !e || e.type !== "comment";
}
function L9(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (e.has(r.tagName)) return !1;
      e.add(r.tagName);
    }
  const n = t.children[0];
  return !n || n.type === "element";
}
function _9(t) {
  const e = ht(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && uh(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function R9(t, e, n) {
  const r = Mx(n, e), i = ht(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && lh(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function k9(t, e, n) {
  const r = Mx(n, e), i = ht(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && lh(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const So = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function w9(t, e, n, r) {
  const i = r.schema, s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let a = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const o = [];
  let u;
  i.space === "html" && t.tagName === "svg" && (r.schema = Ox);
  const l = D9(r, t.properties), c = r.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = i, c && (a = !1), (l || !s || !I9(t, e, n)) && (o.push("<", t.tagName, l ? " " + l : ""), a && (i.space === "svg" || r.settings.closeSelfClosing) && (u = l.charAt(l.length - 1), (!r.settings.tightSelfClosing || u === "/" || u && u !== '"' && u !== "'") && o.push(" "), o.push("/")), o.push(">")), o.push(c), !a && (!s || !lh(t, e, n)) && o.push("</" + t.tagName + ">"), o.join("");
}
function D9(t, e) {
  const n = [];
  let r = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== null && e[i] !== void 0) {
        const s = P9(t, i, e[i]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function P9(t, e, n) {
  const r = UB(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let a = t.quote, o;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const u = Fi(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: So.name[i][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? TT : xT)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? u : (t.settings.preferUnquoted && (o = Fi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: So.unquoted[i][s]
    })
  )), o !== n && (t.settings.quoteSmart && Iu(n, a) > Iu(n, t.alternative) && (a = t.alternative), o = a + Fi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (a === "'" ? So.single : So.double)[i][s],
      attribute: !0
    })
  ) + a), u + (o && "=" + o));
}
const O9 = ["<", "&"];
function Ux(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Fi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: O9
    })
  );
}
function N9(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : Ux(t, e, n, r);
}
function M9(t, e, n, r) {
  return r.all(t);
}
const F9 = th("type", {
  invalid: B9,
  unknown: U9,
  handlers: { comment: u9, doctype: l9, element: w9, raw: N9, root: M9, text: Ux }
});
function B9(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function U9(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const $9 = {}, H9 = {}, G9 = [];
function V9(t, e) {
  const n = e || $9, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: z9,
    all: q9,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || zT,
      characterReferences: n.characterReferences || H9,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Ox : GB,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function z9(t, e, n) {
  return F9(t, e, n, this);
}
function q9(t) {
  const e = [], n = t && t.children || G9;
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
function j9(t) {
  const e = this, n = { ...e.data("settings"), ...t };
  e.compiler = r;
  function r(i) {
    return V9(i, n);
  }
}
const K9 = $x(new RegExp("\\p{P}|\\p{S}", "u")), W9 = $x(/\s/);
function $x(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Y9(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const Hx = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return J9;
    if (typeof t == "function")
      return nl(t);
    if (typeof t == "object")
      return Array.isArray(t) ? X9(t) : Q9(t);
    if (typeof t == "string")
      return Z9(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function X9(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Hx(t[n]);
  return nl(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function Q9(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return nl(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function Z9(t) {
  return nl(e);
  function e(n) {
    return n && n.type === t;
  }
}
function nl(t) {
  return e;
  function e(n, r, i) {
    return !!(eU(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function J9() {
  return !0;
}
function eU(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
function tU(t, e, n) {
  const i = Hx((n || {}).ignore || []), s = nU(e);
  let a = -1;
  for (; ++a < s.length; )
    Sx(t, "text", o);
  function o(l, c) {
    let d = -1, f;
    for (; ++d < c.length; ) {
      const h = c[d], m = f ? f.children : void 0;
      if (i(
        h,
        m ? m.indexOf(h) : void 0,
        f
      ))
        return;
      f = h;
    }
    if (f)
      return u(l, c);
  }
  function u(l, c) {
    const d = c[c.length - 1], f = s[a][0], h = s[a][1];
    let m = 0;
    const g = d.children.indexOf(l);
    let E = !1, y = [];
    f.lastIndex = 0;
    let T = f.exec(l.value);
    for (; T; ) {
      const S = T.index, v = {
        index: T.index,
        input: T.input,
        stack: [...c, l]
      };
      let I = h(...T, v);
      if (typeof I == "string" && (I = I.length > 0 ? { type: "text", value: I } : void 0), I === !1 ? f.lastIndex = S + 1 : (m !== S && y.push({
        type: "text",
        value: l.value.slice(m, S)
      }), Array.isArray(I) ? y.push(...I) : I && y.push(I), m = S + T[0].length, E = !0), !f.global)
        break;
      T = f.exec(l.value);
    }
    return E ? (m < l.value.length && y.push({ type: "text", value: l.value.slice(m) }), d.children.splice(g, 1, ...y)) : y = [l], g + y.length;
  }
}
function nU(t) {
  const e = [];
  if (!Array.isArray(t))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !t[0] || Array.isArray(t[0]) ? t : [t];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    e.push([rU(i[0]), iU(i[1])]);
  }
  return e;
}
function rU(t) {
  return typeof t == "string" ? new RegExp(Y9(t), "g") : t;
}
function iU(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}
const ic = "phrasing", sc = ["autolink", "link", "image", "label"];
function sU() {
  return {
    transforms: [fU],
    enter: {
      literalAutolink: oU,
      literalAutolinkEmail: ac,
      literalAutolinkHttp: ac,
      literalAutolinkWww: ac
    },
    exit: {
      literalAutolink: dU,
      literalAutolinkEmail: cU,
      literalAutolinkHttp: uU,
      literalAutolinkWww: lU
    }
  };
}
function aU() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: ic,
        notInConstruct: sc
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: ic,
        notInConstruct: sc
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: ic,
        notInConstruct: sc
      }
    ]
  };
}
function oU(t) {
  this.enter({ type: "link", title: null, url: "", children: [] }, t);
}
function ac(t) {
  this.config.enter.autolinkProtocol.call(this, t);
}
function uU(t) {
  this.config.exit.autolinkProtocol.call(this, t);
}
function lU(t) {
  this.config.exit.data.call(this, t);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(t);
}
function cU(t) {
  this.config.exit.autolinkEmail.call(this, t);
}
function dU(t) {
  this.exit(t);
}
function fU(t) {
  tU(
    t,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, hU],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), mU]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function hU(t, e, n, r, i) {
  let s = "";
  if (!Gx(i) || (/^w/i.test(e) && (n = e + n, e = "", s = "http://"), !pU(n)))
    return !1;
  const a = gU(n + r);
  if (!a[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: s + e + a[0],
    children: [{ type: "text", value: e + a[0] }]
  };
  return a[1] ? [o, { type: "text", value: a[1] }] : o;
}
function mU(t, e, n, r) {
  return (
    // Not an expected previous character.
    !Gx(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + n,
      children: [{ type: "text", value: e + "@" + n }]
    }
  );
}
function pU(t) {
  const e = t.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function gU(t) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(t);
  if (!e)
    return [t, void 0];
  t = t.slice(0, e.index);
  let n = e[0], r = n.indexOf(")");
  const i = Iu(t, "(");
  let s = Iu(t, ")");
  for (; r !== -1 && i > s; )
    t += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), s++;
  return [t, n];
}
function Gx(t, e) {
  const n = t.input.charCodeAt(t.index - 1);
  return (t.index === 0 || W9(n) || K9(n)) && // If itâ€™s an email, the previous character should not be a slash.
  (!e || n !== 47);
}
function Vx(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
zx.peek = IU;
function bU() {
  this.buffer();
}
function EU(t) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, t);
}
function yU() {
  this.buffer();
}
function TU(t) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    t
  );
}
function xU(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Vx(
    this.sliceSerialize(t)
  ).toLowerCase(), n.label = e;
}
function SU(t) {
  this.exit(t);
}
function AU(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Vx(
    this.sliceSerialize(t)
  ).toLowerCase(), n.label = e;
}
function vU(t) {
  this.exit(t);
}
function IU() {
  return "[";
}
function zx(t, e, n, r) {
  const i = n.createTracker(r);
  let s = i.move("[^");
  const a = n.enter("footnoteReference"), o = n.enter("reference");
  return s += i.move(
    n.safe(n.associationId(t), { after: "]", before: s })
  ), o(), a(), s += i.move("]"), s;
}
function CU() {
  return {
    enter: {
      gfmFootnoteCallString: bU,
      gfmFootnoteCall: EU,
      gfmFootnoteDefinitionLabelString: yU,
      gfmFootnoteDefinition: TU
    },
    exit: {
      gfmFootnoteCallString: xU,
      gfmFootnoteCall: SU,
      gfmFootnoteDefinitionLabelString: AU,
      gfmFootnoteDefinition: vU
    }
  };
}
function LU(t) {
  let e = !1;
  return t && t.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: zx },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, s, a) {
    const o = s.createTracker(a);
    let u = o.move("[^");
    const l = s.enter("footnoteDefinition"), c = s.enter("label");
    return u += o.move(
      s.safe(s.associationId(r), { before: u, after: "]" })
    ), c(), u += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), u += o.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, o.current()),
        e ? qx : _U
      )
    )), l(), u;
  }
}
function _U(t, e, n) {
  return e === 0 ? t : qx(t, e, n);
}
function qx(t, e, n) {
  return (n ? "" : "    ") + t;
}
const RU = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
jx.peek = OU;
function kU() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: DU },
    exit: { strikethrough: PU }
  };
}
function wU() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: RU
      }
    ],
    handlers: { delete: jx }
  };
}
function DU(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function PU(t) {
  this.exit(t);
}
function jx(t, e, n, r) {
  const i = n.createTracker(r), s = n.enter("strikethrough");
  let a = i.move("~~");
  return a += n.containerPhrasing(t, {
    ...i.current(),
    before: a,
    after: "~"
  }), a += i.move("~~"), s(), a;
}
function OU() {
  return "~";
}
function NU(t) {
  return t.length;
}
function MU(t, e) {
  const n = e || {}, r = (n.align || []).concat(), i = n.stringLength || NU, s = [], a = [], o = [], u = [];
  let l = 0, c = -1;
  for (; ++c < t.length; ) {
    const p = [], g = [];
    let E = -1;
    for (t[c].length > l && (l = t[c].length); ++E < t[c].length; ) {
      const y = FU(t[c][E]);
      if (n.alignDelimiters !== !1) {
        const T = i(y);
        g[E] = T, (u[E] === void 0 || T > u[E]) && (u[E] = T);
      }
      p.push(y);
    }
    a[c] = p, o[c] = g;
  }
  let d = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++d < l; )
      s[d] = Hp(r[d]);
  else {
    const p = Hp(r);
    for (; ++d < l; )
      s[d] = p;
  }
  d = -1;
  const f = [], h = [];
  for (; ++d < l; ) {
    const p = s[d];
    let g = "", E = "";
    p === 99 ? (g = ":", E = ":") : p === 108 ? g = ":" : p === 114 && (E = ":");
    let y = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      u[d] - g.length - E.length
    );
    const T = g + "-".repeat(y) + E;
    n.alignDelimiters !== !1 && (y = g.length + y + E.length, y > u[d] && (u[d] = y), h[d] = y), f[d] = T;
  }
  a.splice(1, 0, f), o.splice(1, 0, h), c = -1;
  const m = [];
  for (; ++c < a.length; ) {
    const p = a[c], g = o[c];
    d = -1;
    const E = [];
    for (; ++d < l; ) {
      const y = p[d] || "";
      let T = "", S = "";
      if (n.alignDelimiters !== !1) {
        const v = u[d] - (g[d] || 0), I = s[d];
        I === 114 ? T = " ".repeat(v) : I === 99 ? v % 2 ? (T = " ".repeat(v / 2 + 0.5), S = " ".repeat(v / 2 - 0.5)) : (T = " ".repeat(v / 2), S = T) : S = " ".repeat(v);
      }
      n.delimiterStart !== !1 && !d && E.push("|"), n.padding !== !1 && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && y === "") && (n.delimiterStart !== !1 || d) && E.push(" "), n.alignDelimiters !== !1 && E.push(T), E.push(y), n.alignDelimiters !== !1 && E.push(S), n.padding !== !1 && E.push(" "), (n.delimiterEnd !== !1 || d !== l - 1) && E.push("|");
    }
    m.push(
      n.delimiterEnd === !1 ? E.join("").replace(/ +$/, "") : E.join("")
    );
  }
  return m.join(`
`);
}
function FU(t) {
  return t == null ? "" : String(t);
}
function Hp(t) {
  const e = typeof t == "string" ? t.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function BU(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const a = n.indentLines(
    n.containerFlow(t, s.current()),
    UU
  );
  return i(), a;
}
function UU(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function $U(t, e) {
  return Gp(t, e.inConstruct, !0) && !Gp(t, e.notInConstruct, !1);
}
function Gp(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function Vp(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && $U(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Kx(t, e) {
  const n = String(t);
  let r = n.indexOf(e), i = r, s = 0, a = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > a && (a = s) : s = 1, i = r + e.length, r = n.indexOf(e, i);
  return a;
}
function HU(t, e) {
  return !!(e.options.fences === !1 && t.value && // If thereâ€™s no infoâ€¦
  !t.lang && // And thereâ€™s a non-whitespace characterâ€¦
  /[^ \r\n]/.test(t.value) && // And the value doesnâ€™t start or end in a blankâ€¦
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function GU(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function VU(t, e, n, r) {
  const i = GU(n), s = t.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (HU(t, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(s, zU);
    return d(), f;
  }
  const o = n.createTracker(r), u = i.repeat(Math.max(Kx(s, i) + 1, 3)), l = n.enter("codeFenced");
  let c = o.move(u);
  if (t.lang) {
    const d = n.enter(`codeFencedLang${a}`);
    c += o.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (t.lang && t.meta) {
    const d = n.enter(`codeFencedMeta${a}`);
    c += o.move(" "), c += o.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), s && (c += o.move(s + `
`)), c += o.move(u), l(), c;
}
function zU(t, e, n) {
  return (n ? "" : "    ") + t;
}
function ch(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function qU(t, e, n, r) {
  const i = ch(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("[");
  return l += u.move(
    n.safe(n.associationId(t), {
      before: l,
      after: "]",
      ...u.current()
    })
  ), l += u.move("]: "), o(), // If thereâ€™s no url, orâ€¦
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : `
`,
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), a(), l;
}
function jU(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function ha(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function KU(t) {
  return t !== null && (t < 0 || t === 32);
}
const WU = Wx(new RegExp("\\p{P}|\\p{S}", "u")), YU = Wx(/\s/);
function Wx(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function zp(t) {
  if (t === null || KU(t) || YU(t))
    return 1;
  if (WU(t))
    return 2;
}
function Cu(t, e, n) {
  const r = zp(t), i = zp(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Yx.peek = XU;
function Yx(t, e, n, r) {
  const i = jU(n), s = n.enter("emphasis"), a = n.createTracker(r), o = a.move(i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Cu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = ha(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Cu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + ha(d));
  const h = a.move(i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function XU(t, e, n) {
  return n.options.emphasis || "*";
}
const QU = {};
function Xx(t, e) {
  const n = QU, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return Qx(t, r, i);
}
function Qx(t, e, n) {
  if (ZU(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return qp(t.children, e, n);
  }
  return Array.isArray(t) ? qp(t, e, n) : "";
}
function qp(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = Qx(t[i], e, n);
  return r.join("");
}
function ZU(t) {
  return !!(t && typeof t == "object");
}
function JU(t, e) {
  let n = !1;
  return tl(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, vu;
  }), !!((!t.depth || t.depth < 3) && Xx(t) && (e.options.setext || n));
}
function e7(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (JU(t, n)) {
    const c = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), o = n.enter("headingAtx"), u = n.enter("phrasing");
  s.move(a + " ");
  let l = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(l) && (l = ha(l.charCodeAt(0)) + l.slice(1)), l = l ? a + " " + l : a, n.options.closeAtx && (l += " " + a), u(), o(), l;
}
Zx.peek = t7;
function Zx(t) {
  return t.value || "";
}
function t7() {
  return "<";
}
Jx.peek = n7;
function Jx(t, e, n, r) {
  const i = ch(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("![");
  return l += u.move(
    n.safe(t.alt, { before: l, after: "]", ...u.current() })
  ), l += u.move("]("), o(), // If thereâ€™s no url but there is a titleâ€¦
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), l += u.move(")"), a(), l;
}
function n7() {
  return "!";
}
eS.peek = r7;
function eS(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const l = n.safe(t.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function r7() {
  return "!";
}
tS.peek = i7;
function tS(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const a = n.unsafe[s], o = n.compilePattern(a);
    let u;
    if (a.atBreak)
      for (; u = o.exec(r); ) {
        let l = u.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(u.index + 1);
      }
  }
  return i + r + i;
}
function i7() {
  return "`";
}
function nS(t, e) {
  const n = Xx(t);
  return !!(!e.options.resourceLink && // If thereâ€™s a urlâ€¦
  t.url && // And thereâ€™s a no titleâ€¦
  !t.title && // And the content of `node` is a single text nodeâ€¦
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the contentâ€¦
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocolâ€¦
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
  // references donâ€™t work), space, or angle bracketsâ€¦
  !/[\0- <>\u007F]/.test(t.url));
}
rS.peek = s7;
function rS(t, e, n, r) {
  const i = ch(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let o, u;
  if (nS(t, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = a.move("<");
    return d += a.move(
      n.containerPhrasing(t, {
        before: d,
        after: ">",
        ...a.current()
      })
    ), d += a.move(">"), o(), n.stack = c, d;
  }
  o = n.enter("link"), u = n.enter("label");
  let l = a.move("[");
  return l += a.move(
    n.containerPhrasing(t, {
      before: l,
      after: "](",
      ...a.current()
    })
  ), l += a.move("]("), u(), // If thereâ€™s no url but there is a titleâ€¦
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (u = n.enter("destinationLiteral"), l += a.move("<"), l += a.move(
    n.safe(t.url, { before: l, after: ">", ...a.current() })
  ), l += a.move(">")) : (u = n.enter("destinationRaw"), l += a.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...a.current()
    })
  )), u(), t.title && (u = n.enter(`title${s}`), l += a.move(" " + i), l += a.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...a.current()
    })
  ), l += a.move(i), u()), l += a.move(")"), o(), l;
}
function s7(t, e, n) {
  return nS(t, n) ? "<" : "[";
}
iS.peek = a7;
function iS(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const l = n.containerPhrasing(t, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function a7() {
  return "[";
}
function dh(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function o7(t) {
  const e = dh(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function u7(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function sS(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function l7(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let a = t.ordered ? u7(n) : dh(n);
  const o = t.ordered ? a === "." ? ")" : "." : o7(n);
  let u = e && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const c = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), sS(n) === a && c
    ) {
      let d = -1;
      for (; ++d < t.children.length; ) {
        const f = t.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (a = o), n.bulletCurrent = a;
  const l = n.containerFlow(t, r);
  return n.bulletLastUsed = a, n.bulletCurrent = s, i(), l;
}
function c7(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function d7(t, e, n, r) {
  const i = c7(n);
  let s = n.bulletCurrent || dh(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let a = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (a = Math.ceil(a / 4) * 4);
  const o = n.createTracker(r);
  o.move(s + " ".repeat(a - s.length)), o.shift(a);
  const u = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(t, o.current()),
    c
  );
  return u(), l;
  function c(d, f, h) {
    return f ? (h ? "" : " ".repeat(a)) + d : (h ? s : s + " ".repeat(a - s.length)) + d;
  }
}
function f7(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), a = n.containerPhrasing(t, r);
  return s(), i(), a;
}
const aS = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return g7;
    if (typeof t == "function")
      return rl(t);
    if (typeof t == "object")
      return Array.isArray(t) ? h7(t) : m7(t);
    if (typeof t == "string")
      return p7(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function h7(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = aS(t[n]);
  return rl(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function m7(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return rl(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function p7(t) {
  return rl(e);
  function e(n) {
    return n && n.type === t;
  }
}
function rl(t) {
  return e;
  function e(n, r, i) {
    return !!(b7(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function g7() {
  return !0;
}
function b7(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const E7 = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  aS([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function y7(t, e, n, r) {
  return (t.children.some(function(a) {
    return E7(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function T7(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
oS.peek = x7;
function oS(t, e, n, r) {
  const i = T7(n), s = n.enter("strong"), a = n.createTracker(r), o = a.move(i + i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Cu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = ha(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Cu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + ha(d));
  const h = a.move(i + i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function x7(t, e, n) {
  return n.options.strong || "*";
}
function S7(t, e, n, r) {
  return n.safe(t.value, r);
}
function A7(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function v7(t, e, n) {
  const r = (sS(n) + (n.options.ruleSpaces ? " " : "")).repeat(A7(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const I7 = {
  blockquote: BU,
  break: Vp,
  code: VU,
  definition: qU,
  emphasis: Yx,
  hardBreak: Vp,
  heading: e7,
  html: Zx,
  image: Jx,
  imageReference: eS,
  inlineCode: tS,
  link: rS,
  linkReference: iS,
  list: l7,
  listItem: d7,
  paragraph: f7,
  root: y7,
  strong: oS,
  text: S7,
  thematicBreak: v7
}, jp = document.createElement("i");
function fh(t) {
  const e = "&" + t + ";";
  jp.innerHTML = e;
  const n = jp.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n
  );
}
function C7() {
  return {
    enter: {
      table: L7,
      tableData: Kp,
      tableHeader: Kp,
      tableRow: R7
    },
    exit: {
      codeText: k7,
      table: _7,
      tableData: oc,
      tableHeader: oc,
      tableRow: oc
    }
  };
}
function L7(t) {
  const e = t._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    t
  ), this.data.inTable = !0;
}
function _7(t) {
  this.exit(t), this.data.inTable = void 0;
}
function R7(t) {
  this.enter({ type: "tableRow", children: [] }, t);
}
function oc(t) {
  this.exit(t);
}
function Kp(t) {
  this.enter({ type: "tableCell", children: [] }, t);
}
function k7(t) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, w7));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = e, this.exit(t);
}
function w7(t, e) {
  return e === "|" ? e : t;
}
function D7(t) {
  const e = t || {}, n = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: a,
      tableCell: u,
      tableRow: o
    }
  };
  function a(h, m, p, g) {
    return l(c(h, p, g), h.align);
  }
  function o(h, m, p, g) {
    const E = d(h, p, g), y = l([E]);
    return y.slice(0, y.indexOf(`
`));
  }
  function u(h, m, p, g) {
    const E = p.enter("tableCell"), y = p.enter("phrasing"), T = p.containerPhrasing(h, {
      ...g,
      before: s,
      after: s
    });
    return y(), E(), T;
  }
  function l(h, m) {
    return MU(h, {
      align: m,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function c(h, m, p) {
    const g = h.children;
    let E = -1;
    const y = [], T = m.enter("table");
    for (; ++E < g.length; )
      y[E] = d(g[E], m, p);
    return T(), y;
  }
  function d(h, m, p) {
    const g = h.children;
    let E = -1;
    const y = [], T = m.enter("tableRow");
    for (; ++E < g.length; )
      y[E] = u(g[E], h, m, p);
    return T(), y;
  }
  function f(h, m, p) {
    let g = I7.inlineCode(h, m, p);
    return p.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function P7(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const a = n.indentLines(
    n.containerFlow(t, s.current()),
    O7
  );
  return i(), a;
}
function O7(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function N7(t, e) {
  return Wp(t, e.inConstruct, !0) && !Wp(t, e.notInConstruct, !1);
}
function Wp(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function Yp(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && N7(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function M7(t, e) {
  return !!(e.options.fences === !1 && t.value && // If thereâ€™s no infoâ€¦
  !t.lang && // And thereâ€™s a non-whitespace characterâ€¦
  /[^ \r\n]/.test(t.value) && // And the value doesnâ€™t start or end in a blankâ€¦
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function F7(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function B7(t, e, n, r) {
  const i = F7(n), s = t.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (M7(t, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(s, U7);
    return d(), f;
  }
  const o = n.createTracker(r), u = i.repeat(Math.max(Kx(s, i) + 1, 3)), l = n.enter("codeFenced");
  let c = o.move(u);
  if (t.lang) {
    const d = n.enter(`codeFencedLang${a}`);
    c += o.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (t.lang && t.meta) {
    const d = n.enter(`codeFencedMeta${a}`);
    c += o.move(" "), c += o.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), s && (c += o.move(s + `
`)), c += o.move(u), l(), c;
}
function U7(t, e, n) {
  return (n ? "" : "    ") + t;
}
function hh(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function $7(t, e, n, r) {
  const i = hh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("[");
  return l += u.move(
    n.safe(n.associationId(t), {
      before: l,
      after: "]",
      ...u.current()
    })
  ), l += u.move("]: "), o(), // If thereâ€™s no url, orâ€¦
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : `
`,
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), a(), l;
}
function H7(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function ma(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function G7(t) {
  return t !== null && (t < 0 || t === 32);
}
const V7 = uS(new RegExp("\\p{P}|\\p{S}", "u")), z7 = uS(/\s/);
function uS(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Xp(t) {
  if (t === null || G7(t) || z7(t))
    return 1;
  if (V7(t))
    return 2;
}
function Lu(t, e, n) {
  const r = Xp(t), i = Xp(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
lS.peek = q7;
function lS(t, e, n, r) {
  const i = H7(n), s = n.enter("emphasis"), a = n.createTracker(r), o = a.move(i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Lu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = ma(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Lu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + ma(d));
  const h = a.move(i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function q7(t, e, n) {
  return n.options.emphasis || "*";
}
const j7 = {};
function cS(t, e) {
  const n = j7, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return dS(t, r, i);
}
function dS(t, e, n) {
  if (K7(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return Qp(t.children, e, n);
  }
  return Array.isArray(t) ? Qp(t, e, n) : "";
}
function Qp(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = dS(t[i], e, n);
  return r.join("");
}
function K7(t) {
  return !!(t && typeof t == "object");
}
function W7(t, e) {
  let n = !1;
  return tl(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, vu;
  }), !!((!t.depth || t.depth < 3) && cS(t) && (e.options.setext || n));
}
function Y7(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (W7(t, n)) {
    const c = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), o = n.enter("headingAtx"), u = n.enter("phrasing");
  s.move(a + " ");
  let l = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(l) && (l = ma(l.charCodeAt(0)) + l.slice(1)), l = l ? a + " " + l : a, n.options.closeAtx && (l += " " + a), u(), o(), l;
}
fS.peek = X7;
function fS(t) {
  return t.value || "";
}
function X7() {
  return "<";
}
hS.peek = Q7;
function hS(t, e, n, r) {
  const i = hh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("![");
  return l += u.move(
    n.safe(t.alt, { before: l, after: "]", ...u.current() })
  ), l += u.move("]("), o(), // If thereâ€™s no url but there is a titleâ€¦
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), l += u.move(")"), a(), l;
}
function Q7() {
  return "!";
}
mS.peek = Z7;
function mS(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const l = n.safe(t.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function Z7() {
  return "!";
}
pS.peek = J7;
function pS(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const a = n.unsafe[s], o = n.compilePattern(a);
    let u;
    if (a.atBreak)
      for (; u = o.exec(r); ) {
        let l = u.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(u.index + 1);
      }
  }
  return i + r + i;
}
function J7() {
  return "`";
}
function gS(t, e) {
  const n = cS(t);
  return !!(!e.options.resourceLink && // If thereâ€™s a urlâ€¦
  t.url && // And thereâ€™s a no titleâ€¦
  !t.title && // And the content of `node` is a single text nodeâ€¦
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the contentâ€¦
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocolâ€¦
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
  // references donâ€™t work), space, or angle bracketsâ€¦
  !/[\0- <>\u007F]/.test(t.url));
}
bS.peek = e$;
function bS(t, e, n, r) {
  const i = hh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let o, u;
  if (gS(t, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = a.move("<");
    return d += a.move(
      n.containerPhrasing(t, {
        before: d,
        after: ">",
        ...a.current()
      })
    ), d += a.move(">"), o(), n.stack = c, d;
  }
  o = n.enter("link"), u = n.enter("label");
  let l = a.move("[");
  return l += a.move(
    n.containerPhrasing(t, {
      before: l,
      after: "](",
      ...a.current()
    })
  ), l += a.move("]("), u(), // If thereâ€™s no url but there is a titleâ€¦
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (u = n.enter("destinationLiteral"), l += a.move("<"), l += a.move(
    n.safe(t.url, { before: l, after: ">", ...a.current() })
  ), l += a.move(">")) : (u = n.enter("destinationRaw"), l += a.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...a.current()
    })
  )), u(), t.title && (u = n.enter(`title${s}`), l += a.move(" " + i), l += a.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...a.current()
    })
  ), l += a.move(i), u()), l += a.move(")"), o(), l;
}
function e$(t, e, n) {
  return gS(t, n) ? "<" : "[";
}
ES.peek = t$;
function ES(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const l = n.containerPhrasing(t, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function t$() {
  return "[";
}
function mh(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function n$(t) {
  const e = mh(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function r$(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function yS(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function i$(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let a = t.ordered ? r$(n) : mh(n);
  const o = t.ordered ? a === "." ? ")" : "." : n$(n);
  let u = e && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const c = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), yS(n) === a && c
    ) {
      let d = -1;
      for (; ++d < t.children.length; ) {
        const f = t.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (a = o), n.bulletCurrent = a;
  const l = n.containerFlow(t, r);
  return n.bulletLastUsed = a, n.bulletCurrent = s, i(), l;
}
function s$(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function a$(t, e, n, r) {
  const i = s$(n);
  let s = n.bulletCurrent || mh(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let a = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (a = Math.ceil(a / 4) * 4);
  const o = n.createTracker(r);
  o.move(s + " ".repeat(a - s.length)), o.shift(a);
  const u = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(t, o.current()),
    c
  );
  return u(), l;
  function c(d, f, h) {
    return f ? (h ? "" : " ".repeat(a)) + d : (h ? s : s + " ".repeat(a - s.length)) + d;
  }
}
function o$(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), a = n.containerPhrasing(t, r);
  return s(), i(), a;
}
const TS = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return d$;
    if (typeof t == "function")
      return il(t);
    if (typeof t == "object")
      return Array.isArray(t) ? u$(t) : l$(t);
    if (typeof t == "string")
      return c$(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function u$(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = TS(t[n]);
  return il(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function l$(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return il(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function c$(t) {
  return il(e);
  function e(n) {
    return n && n.type === t;
  }
}
function il(t) {
  return e;
  function e(n, r, i) {
    return !!(f$(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function d$() {
  return !0;
}
function f$(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const h$ = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  TS([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function m$(t, e, n, r) {
  return (t.children.some(function(a) {
    return h$(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function p$(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
xS.peek = g$;
function xS(t, e, n, r) {
  const i = p$(n), s = n.enter("strong"), a = n.createTracker(r), o = a.move(i + i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Lu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = ma(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Lu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + ma(d));
  const h = a.move(i + i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function g$(t, e, n) {
  return n.options.strong || "*";
}
function b$(t, e, n, r) {
  return n.safe(t.value, r);
}
function E$(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function y$(t, e, n) {
  const r = (yS(n) + (n.options.ruleSpaces ? " " : "")).repeat(E$(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const T$ = {
  blockquote: P7,
  break: Yp,
  code: B7,
  definition: $7,
  emphasis: lS,
  hardBreak: Yp,
  heading: Y7,
  html: fS,
  image: hS,
  imageReference: mS,
  inlineCode: pS,
  link: bS,
  linkReference: ES,
  list: i$,
  listItem: a$,
  paragraph: o$,
  root: m$,
  strong: xS,
  text: b$,
  thematicBreak: y$
};
function x$() {
  return {
    exit: {
      taskListCheckValueChecked: Zp,
      taskListCheckValueUnchecked: Zp,
      paragraph: A$
    }
  };
}
function S$() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: v$ }
  };
}
function Zp(t) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = t.type === "taskListCheckValueChecked";
}
function A$(t) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, a;
      for (; ++s < i.length; ) {
        const o = i[s];
        if (o.type === "paragraph") {
          a = o;
          break;
        }
      }
      a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(t);
}
function v$(t, e, n, r) {
  const i = t.children[0], s = typeof t.checked == "boolean" && i && i.type === "paragraph", a = "[" + (t.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  s && o.move(a);
  let u = T$.listItem(t, e, n, {
    ...r,
    ...o.current()
  });
  return s && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), u;
  function l(c) {
    return c + a;
  }
}
function I$() {
  return [
    sU(),
    CU(),
    kU(),
    C7(),
    x$()
  ];
}
function C$(t) {
  return {
    extensions: [
      aU(),
      LU(t),
      wU(),
      D7(t),
      S$()
    ]
  };
}
function L$(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
const Jp = {}.hasOwnProperty;
function _$(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    R$(e, t[n]);
  return e;
}
function R$(t, e) {
  let n;
  for (n in e) {
    const i = (Jp.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let a;
    if (s)
      for (a in s) {
        Jp.call(i, a) || (i[a] = []);
        const o = s[a];
        k$(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function k$(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  L$(t, 0, 0, r);
}
const pa = sl(/[A-Za-z]/), ph = sl(/[\dA-Za-z]/);
function w$(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
function Zi(t) {
  return t !== null && (t < 0 || t === 32);
}
const SS = sl(new RegExp("\\p{P}|\\p{S}", "u")), ga = sl(/\s/);
function sl(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
const D$ = {
  tokenize: B$,
  partial: !0
}, AS = {
  tokenize: U$,
  partial: !0
}, vS = {
  tokenize: $$,
  partial: !0
}, IS = {
  tokenize: H$,
  partial: !0
}, P$ = {
  tokenize: G$,
  partial: !0
}, CS = {
  name: "wwwAutolink",
  tokenize: M$,
  previous: _S
}, LS = {
  name: "protocolAutolink",
  tokenize: F$,
  previous: RS
}, cr = {
  name: "emailAutolink",
  tokenize: N$,
  previous: kS
}, zn = {};
function O$() {
  return {
    text: zn
  };
}
let Mr = 48;
for (; Mr < 123; )
  zn[Mr] = cr, Mr++, Mr === 58 ? Mr = 65 : Mr === 91 && (Mr = 97);
zn[43] = cr;
zn[45] = cr;
zn[46] = cr;
zn[95] = cr;
zn[72] = [cr, LS];
zn[104] = [cr, LS];
zn[87] = [cr, CS];
zn[119] = [cr, CS];
function N$(t, e, n) {
  const r = this;
  let i, s;
  return a;
  function a(d) {
    return !kd(d) || !kS.call(r, r.previous) || gh(r.events) ? n(d) : (t.enter("literalAutolink"), t.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return kd(d) ? (t.consume(d), o) : d === 64 ? (t.consume(d), u) : n(d);
  }
  function u(d) {
    return d === 46 ? t.check(P$, c, l)(d) : d === 45 || d === 95 || ph(d) ? (s = !0, t.consume(d), u) : c(d);
  }
  function l(d) {
    return t.consume(d), i = !0, u;
  }
  function c(d) {
    return s && i && pa(r.previous) ? (t.exit("literalAutolinkEmail"), t.exit("literalAutolink"), e(d)) : n(d);
  }
}
function M$(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return a !== 87 && a !== 119 || !_S.call(r, r.previous) || gh(r.events) ? n(a) : (t.enter("literalAutolink"), t.enter("literalAutolinkWww"), t.check(D$, t.attempt(AS, t.attempt(vS, s), n), n)(a));
  }
  function s(a) {
    return t.exit("literalAutolinkWww"), t.exit("literalAutolink"), e(a);
  }
}
function F$(t, e, n) {
  const r = this;
  let i = "", s = !1;
  return a;
  function a(d) {
    return (d === 72 || d === 104) && RS.call(r, r.previous) && !gh(r.events) ? (t.enter("literalAutolink"), t.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), t.consume(d), o) : n(d);
  }
  function o(d) {
    if (pa(d) && i.length < 5)
      return i += String.fromCodePoint(d), t.consume(d), o;
    if (d === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return t.consume(d), u;
    }
    return n(d);
  }
  function u(d) {
    return d === 47 ? (t.consume(d), s ? l : (s = !0, u)) : n(d);
  }
  function l(d) {
    return d === null || w$(d) || Zi(d) || ga(d) || SS(d) ? n(d) : t.attempt(AS, t.attempt(vS, c), n)(d);
  }
  function c(d) {
    return t.exit("literalAutolinkHttp"), t.exit("literalAutolink"), e(d);
  }
}
function B$(t, e, n) {
  let r = 0;
  return i;
  function i(a) {
    return (a === 87 || a === 119) && r < 3 ? (r++, t.consume(a), i) : a === 46 && r === 3 ? (t.consume(a), s) : n(a);
  }
  function s(a) {
    return a === null ? n(a) : e(a);
  }
}
function U$(t, e, n) {
  let r, i, s;
  return a;
  function a(l) {
    return l === 46 || l === 95 ? t.check(IS, u, o)(l) : l === null || Zi(l) || ga(l) || l !== 45 && SS(l) ? u(l) : (s = !0, t.consume(l), a);
  }
  function o(l) {
    return l === 95 ? r = !0 : (i = r, r = void 0), t.consume(l), a;
  }
  function u(l) {
    return i || r || !s ? n(l) : e(l);
  }
}
function $$(t, e) {
  let n = 0, r = 0;
  return i;
  function i(a) {
    return a === 40 ? (n++, t.consume(a), i) : a === 41 && r < n ? s(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? t.check(IS, e, s)(a) : a === null || Zi(a) || ga(a) ? e(a) : (t.consume(a), i);
  }
  function s(a) {
    return a === 41 && r++, t.consume(a), i;
  }
}
function H$(t, e, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (t.consume(o), r) : o === 38 ? (t.consume(o), s) : o === 93 ? (t.consume(o), i) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Zi(o) || ga(o) ? e(o) : n(o)
    );
  }
  function i(o) {
    return o === null || o === 40 || o === 91 || Zi(o) || ga(o) ? e(o) : r(o);
  }
  function s(o) {
    return pa(o) ? a(o) : n(o);
  }
  function a(o) {
    return o === 59 ? (t.consume(o), r) : pa(o) ? (t.consume(o), a) : n(o);
  }
}
function G$(t, e, n) {
  return r;
  function r(s) {
    return t.consume(s), i;
  }
  function i(s) {
    return ph(s) ? n(s) : e(s);
  }
}
function _S(t) {
  return t === null || t === 40 || t === 42 || t === 95 || t === 91 || t === 93 || t === 126 || Zi(t);
}
function RS(t) {
  return !pa(t);
}
function kS(t) {
  return !(t === 47 || kd(t));
}
function kd(t) {
  return t === 43 || t === 45 || t === 46 || t === 95 || ph(t);
}
function gh(t) {
  let e = t.length, n = !1;
  for (; e--; ) {
    const r = t[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return t.length > 0 && !n && (t[t.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function V$(t) {
  return t !== null && t < -2;
}
function _u(t) {
  return t !== null && (t < 0 || t === 32);
}
function wd(t) {
  return t === -2 || t === -1 || t === 32;
}
function bh(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return wd(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return wd(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const z$ = {
  partial: !0,
  tokenize: q$
};
function q$(t, e, n) {
  return r;
  function r(s) {
    return wd(s) ? bh(t, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || V$(s) ? e(s) : n(s);
  }
}
function Eh(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const j$ = {
  tokenize: eH,
  partial: !0
};
function K$() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: Q$,
        continuation: {
          tokenize: Z$
        },
        exit: J$
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: X$
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: W$,
        resolveTo: Y$
      }
    }
  };
}
function W$(t, e, n) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a;
  for (; i--; ) {
    const u = r.events[i][1];
    if (u.type === "labelImage") {
      a = u;
      break;
    }
    if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
      break;
  }
  return o;
  function o(u) {
    if (!a || !a._balanced)
      return n(u);
    const l = Eh(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }));
    return l.codePointAt(0) !== 94 || !s.includes(l.slice(1)) ? n(u) : (t.enter("gfmFootnoteCallLabelMarker"), t.consume(u), t.exit("gfmFootnoteCallLabelMarker"), e(u));
  }
}
function Y$(t, e) {
  let n = t.length;
  for (; n--; )
    if (t[n][1].type === "labelImage" && t[n][0] === "enter") {
      t[n][1];
      break;
    }
  t[n + 1][1].type = "data", t[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, t[n + 3][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, t[n + 3][1].end),
    end: Object.assign({}, t[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, t[t.length - 1][1].start)
  }, a = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    t[n + 1],
    t[n + 2],
    ["enter", r, e],
    // The `[`
    t[n + 3],
    t[n + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", a, e],
    ["exit", a, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    t[t.length - 2],
    t[t.length - 1],
    ["exit", r, e]
  ];
  return t.splice(n, t.length - n + 1, ...o), t;
}
function X$(t, e, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, a;
  return o;
  function o(d) {
    return t.enter("gfmFootnoteCall"), t.enter("gfmFootnoteCallLabelMarker"), t.consume(d), t.exit("gfmFootnoteCallLabelMarker"), u;
  }
  function u(d) {
    return d !== 94 ? n(d) : (t.enter("gfmFootnoteCallMarker"), t.consume(d), t.exit("gfmFootnoteCallMarker"), t.enter("gfmFootnoteCallString"), t.enter("chunkString").contentType = "string", l);
  }
  function l(d) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      d === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || _u(d)
    )
      return n(d);
    if (d === 93) {
      t.exit("chunkString");
      const f = t.exit("gfmFootnoteCallString");
      return i.includes(Eh(r.sliceSerialize(f))) ? (t.enter("gfmFootnoteCallLabelMarker"), t.consume(d), t.exit("gfmFootnoteCallLabelMarker"), t.exit("gfmFootnoteCall"), e) : n(d);
    }
    return _u(d) || (a = !0), s++, t.consume(d), d === 92 ? c : l;
  }
  function c(d) {
    return d === 91 || d === 92 || d === 93 ? (t.consume(d), s++, l) : l(d);
  }
}
function Q$(t, e, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, a = 0, o;
  return u;
  function u(m) {
    return t.enter("gfmFootnoteDefinition")._container = !0, t.enter("gfmFootnoteDefinitionLabel"), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionLabelMarker"), l;
  }
  function l(m) {
    return m === 94 ? (t.enter("gfmFootnoteDefinitionMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionMarker"), t.enter("gfmFootnoteDefinitionLabelString"), t.enter("chunkString").contentType = "string", c) : n(m);
  }
  function c(m) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      m === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || _u(m)
    )
      return n(m);
    if (m === 93) {
      t.exit("chunkString");
      const p = t.exit("gfmFootnoteDefinitionLabelString");
      return s = Eh(r.sliceSerialize(p)), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionLabelMarker"), t.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return _u(m) || (o = !0), a++, t.consume(m), m === 92 ? d : c;
  }
  function d(m) {
    return m === 91 || m === 92 || m === 93 ? (t.consume(m), a++, c) : c(m);
  }
  function f(m) {
    return m === 58 ? (t.enter("definitionMarker"), t.consume(m), t.exit("definitionMarker"), i.includes(s) || i.push(s), bh(t, h, "gfmFootnoteDefinitionWhitespace")) : n(m);
  }
  function h(m) {
    return e(m);
  }
}
function Z$(t, e, n) {
  return t.check(z$, e, t.attempt(j$, e, n));
}
function J$(t) {
  t.exit("gfmFootnoteDefinition");
}
function eH(t, e, n) {
  const r = this;
  return bh(t, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? e(s) : n(s);
  }
}
function uc(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
function tH(t) {
  return t !== null && (t < 0 || t === 32);
}
const nH = wS(new RegExp("\\p{P}|\\p{S}", "u")), rH = wS(/\s/);
function wS(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function eg(t) {
  if (t === null || tH(t) || rH(t))
    return 1;
  if (nH(t))
    return 2;
}
function iH(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
function sH(t) {
  let n = (t || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(a, o) {
    let u = -1;
    for (; ++u < a.length; )
      if (a[u][0] === "enter" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._close) {
        let l = u;
        for (; l--; )
          if (a[l][0] === "exit" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._open && // If the sizes are the same:
          a[u][1].end.offset - a[u][1].start.offset === a[l][1].end.offset - a[l][1].start.offset) {
            a[u][1].type = "strikethroughSequence", a[l][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, a[l][1].start),
              end: Object.assign({}, a[u][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, a[l][1].end),
              end: Object.assign({}, a[u][1].start)
            }, f = [["enter", c, o], ["enter", a[l][1], o], ["exit", a[l][1], o], ["enter", d, o]], h = o.parser.constructs.insideSpan.null;
            h && uc(f, f.length, 0, iH(h, a.slice(l + 1, u), o)), uc(f, f.length, 0, [["exit", d, o], ["enter", a[u][1], o], ["exit", a[u][1], o], ["exit", c, o]]), uc(a, l - 1, u - l + 3, f), u = l + f.length - 2;
            break;
          }
      }
    for (u = -1; ++u < a.length; )
      a[u][1].type === "strikethroughSequenceTemporary" && (a[u][1].type = "data");
    return a;
  }
  function s(a, o, u) {
    const l = this.previous, c = this.events;
    let d = 0;
    return f;
    function f(m) {
      return l === 126 && c[c.length - 1][1].type !== "characterEscape" ? u(m) : (a.enter("strikethroughSequenceTemporary"), h(m));
    }
    function h(m) {
      const p = eg(l);
      if (m === 126)
        return d > 1 ? u(m) : (a.consume(m), d++, h);
      if (d < 2 && !n) return u(m);
      const g = a.exit("strikethroughSequenceTemporary"), E = eg(m);
      return g._open = !E || E === 2 && !!p, g._close = !p || p === 2 && !!E, o(m);
    }
  }
}
function Ao(t) {
  return t !== null && t < -2;
}
function tg(t) {
  return t !== null && (t < 0 || t === 32);
}
function Ur(t) {
  return t === -2 || t === -1 || t === 32;
}
function Cs(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Ur(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Ur(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
class aH {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, n, r) {
    oH(this, e, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, a) {
      return s[0] - a[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), e.length = this.map[n][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function oH(t, e, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < t.map.length; ) {
      if (t.map[i][0] === e) {
        t.map[i][1] += n, t.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    t.map.push([e, n, r]);
  }
}
function uH(t, e) {
  let n = !1;
  const r = [];
  for (; e < t.length; ) {
    const i = t[e];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (t[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    e += 1;
  }
  return r;
}
function lH() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: cH,
        resolveAll: dH
      }
    }
  };
}
function cH(t, e, n) {
  const r = this;
  let i = 0, s = 0, a;
  return o;
  function o(A) {
    let L = r.events.length - 1;
    for (; L > -1; ) {
      const z = r.events[L][1].type;
      if (z === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      z === "linePrefix") L--;
      else break;
    }
    const N = L > -1 ? r.events[L][1].type : null, U = N === "tableHead" || N === "tableRow" ? I : u;
    return U === I && r.parser.lazy[r.now().line] ? n(A) : U(A);
  }
  function u(A) {
    return t.enter("tableHead"), t.enter("tableRow"), l(A);
  }
  function l(A) {
    return A === 124 || (a = !0, s += 1), c(A);
  }
  function c(A) {
    return A === null ? n(A) : Ao(A) ? s > 1 ? (s = 0, r.interrupt = !0, t.exit("tableRow"), t.enter("lineEnding"), t.consume(A), t.exit("lineEnding"), h) : n(A) : Ur(A) ? Cs(t, c, "whitespace")(A) : (s += 1, a && (a = !1, i += 1), A === 124 ? (t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), a = !0, c) : (t.enter("data"), d(A)));
  }
  function d(A) {
    return A === null || A === 124 || tg(A) ? (t.exit("data"), c(A)) : (t.consume(A), A === 92 ? f : d);
  }
  function f(A) {
    return A === 92 || A === 124 ? (t.consume(A), d) : d(A);
  }
  function h(A) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(A) : (t.enter("tableDelimiterRow"), a = !1, Ur(A) ? Cs(t, m, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : m(A));
  }
  function m(A) {
    return A === 45 || A === 58 ? g(A) : A === 124 ? (a = !0, t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), p) : v(A);
  }
  function p(A) {
    return Ur(A) ? Cs(t, g, "whitespace")(A) : g(A);
  }
  function g(A) {
    return A === 58 ? (s += 1, a = !0, t.enter("tableDelimiterMarker"), t.consume(A), t.exit("tableDelimiterMarker"), E) : A === 45 ? (s += 1, E(A)) : A === null || Ao(A) ? S(A) : v(A);
  }
  function E(A) {
    return A === 45 ? (t.enter("tableDelimiterFiller"), y(A)) : v(A);
  }
  function y(A) {
    return A === 45 ? (t.consume(A), y) : A === 58 ? (a = !0, t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(A), t.exit("tableDelimiterMarker"), T) : (t.exit("tableDelimiterFiller"), T(A));
  }
  function T(A) {
    return Ur(A) ? Cs(t, S, "whitespace")(A) : S(A);
  }
  function S(A) {
    return A === 124 ? m(A) : A === null || Ao(A) ? !a || i !== s ? v(A) : (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(A)) : v(A);
  }
  function v(A) {
    return n(A);
  }
  function I(A) {
    return t.enter("tableRow"), C(A);
  }
  function C(A) {
    return A === 124 ? (t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), C) : A === null || Ao(A) ? (t.exit("tableRow"), e(A)) : Ur(A) ? Cs(t, C, "whitespace")(A) : (t.enter("data"), D(A));
  }
  function D(A) {
    return A === null || A === 124 || tg(A) ? (t.exit("data"), C(A)) : (t.consume(A), A === 92 ? _ : D);
  }
  function _(A) {
    return A === 92 || A === 124 ? (t.consume(A), D) : D(A);
  }
}
function dH(t, e) {
  let n = -1, r = !0, i = 0, s = [0, 0, 0, 0], a = [0, 0, 0, 0], o = !1, u = 0, l, c, d;
  const f = new aH();
  for (; ++n < t.length; ) {
    const h = t[n], m = h[1];
    h[0] === "enter" ? m.type === "tableHead" ? (o = !1, u !== 0 && (ng(f, e, u, l, c), c = void 0, u = 0), l = {
      type: "table",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, f.add(n, 0, [["enter", l, e]])) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (r = !0, d = void 0, s = [0, 0, 0, 0], a = [0, n + 1, 0, 0], o && (o = !1, c = {
      type: "tableBody",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, f.add(n, 0, [["enter", c, e]])), i = m.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (s[1] !== 0 && (a[0] = a[1], d = vo(f, e, s, i, void 0, d), s = [0, 0, 0, 0]), a[2] = n)) : m.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (a[0] = a[1], d = vo(f, e, s, i, void 0, d)), s = a, a = [s[1], n, 0, 0])) : m.type === "tableHead" ? (o = !0, u = n) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (u = n, s[1] !== 0 ? (a[0] = a[1], d = vo(f, e, s, i, n, d)) : a[1] !== 0 && (d = vo(f, e, a, i, n, d)), i = 0) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") && (a[3] = n);
  }
  for (u !== 0 && ng(f, e, u, l, c), f.consume(e.events), n = -1; ++n < e.events.length; ) {
    const h = e.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = uH(e.events, n));
  }
  return t;
}
function vo(t, e, n, r, i, s) {
  const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (s.end = Object.assign({}, Si(e.events, n[0])), t.add(n[0], 0, [["exit", s, e]]));
  const u = Si(e.events, n[1]);
  if (s = {
    type: a,
    start: Object.assign({}, u),
    // Note: correct end is set later.
    end: Object.assign({}, u)
  }, t.add(n[1], 0, [["enter", s, e]]), n[2] !== 0) {
    const l = Si(e.events, n[2]), c = Si(e.events, n[3]), d = {
      type: o,
      start: Object.assign({}, l),
      end: Object.assign({}, c)
    };
    if (t.add(n[2], 0, [["enter", d, e]]), r !== 2) {
      const f = e.events[n[2]], h = e.events[n[3]];
      if (f[1].end = Object.assign({}, h[1].end), f[1].type = "chunkText", f[1].contentType = "text", n[3] > n[2] + 1) {
        const m = n[2] + 1, p = n[3] - n[2] - 1;
        t.add(m, p, []);
      }
    }
    t.add(n[3] + 1, 0, [["exit", d, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, Si(e.events, i)), t.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function ng(t, e, n, r, i) {
  const s = [], a = Si(e.events, n);
  i && (i.end = Object.assign({}, a), s.push(["exit", i, e])), r.end = Object.assign({}, a), s.push(["exit", r, e]), t.add(n + 1, 0, s);
}
function Si(t, e) {
  const n = t[e], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
function fH(t) {
  return t !== null && t < -2;
}
function hH(t) {
  return t !== null && (t < 0 || t === 32);
}
function Dd(t) {
  return t === -2 || t === -1 || t === 32;
}
function mH(t, e, n, r) {
  const i = Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Dd(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Dd(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const pH = {
  name: "tasklistCheck",
  tokenize: bH
};
function gH() {
  return {
    text: {
      91: pH
    }
  };
}
function bH(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return (
      // Exit if thereâ€™s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(u) : (t.enter("taskListCheck"), t.enter("taskListCheckMarker"), t.consume(u), t.exit("taskListCheckMarker"), s)
    );
  }
  function s(u) {
    return hH(u) ? (t.enter("taskListCheckValueUnchecked"), t.consume(u), t.exit("taskListCheckValueUnchecked"), a) : u === 88 || u === 120 ? (t.enter("taskListCheckValueChecked"), t.consume(u), t.exit("taskListCheckValueChecked"), a) : n(u);
  }
  function a(u) {
    return u === 93 ? (t.enter("taskListCheckMarker"), t.consume(u), t.exit("taskListCheckMarker"), t.exit("taskListCheck"), o) : n(u);
  }
  function o(u) {
    return fH(u) ? e(u) : Dd(u) ? t.check({
      tokenize: EH
    }, e, n)(u) : n(u);
  }
}
function EH(t, e, n) {
  return mH(t, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : e(i);
  }
}
function yH(t) {
  return _$([
    O$(),
    K$(),
    sH(t),
    lH(),
    gH()
  ]);
}
const TH = {};
function xH(t) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), n = t || TH, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(yH(n)), s.push(I$()), a.push(C$(n));
}
const SH = {};
function AH(t, e) {
  const n = SH, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return DS(t, r, i);
}
function DS(t, e, n) {
  if (vH(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return rg(t.children, e, n);
  }
  return Array.isArray(t) ? rg(t, e, n) : "";
}
function rg(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = DS(t[i], e, n);
  return r.join("");
}
function vH(t) {
  return !!(t && typeof t == "object");
}
function Un(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
function nn(t, e) {
  return t.length > 0 ? (Un(t, t.length, 0, e), t) : e;
}
const ig = {}.hasOwnProperty;
function IH(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    CH(e, t[n]);
  return e;
}
function CH(t, e) {
  let n;
  for (n in e) {
    const i = (ig.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let a;
    if (s)
      for (a in s) {
        ig.call(i, a) || (i[a] = []);
        const o = s[a];
        LH(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function LH(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  Un(t, 0, 0, r);
}
function PS(t, e) {
  const n = Number.parseInt(t, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "ï¿½" : String.fromCodePoint(n)
  );
}
function Bi(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const _n = Dr(/[A-Za-z]/), hn = Dr(/[\dA-Za-z]/), _H = Dr(/[#-'*+\--9=?A-Z^-~]/);
function Pd(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const Od = Dr(/\d/), RH = Dr(/[\dA-Fa-f]/), kH = Dr(/[!-/:-@[-`{-~]/);
function ge(t) {
  return t !== null && t < -2;
}
function Mt(t) {
  return t !== null && (t < 0 || t === 32);
}
function Ne(t) {
  return t === -2 || t === -1 || t === 32;
}
const wH = Dr(new RegExp("\\p{P}|\\p{S}", "u")), DH = Dr(/\s/);
function Dr(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Ye(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Ne(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Ne(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const PH = {
  tokenize: OH
};
function OH(t) {
  const e = t.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return e;
  function r(o) {
    if (o === null) {
      t.consume(o);
      return;
    }
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), Ye(t, e, "linePrefix");
  }
  function i(o) {
    return t.enter("paragraph"), s(o);
  }
  function s(o) {
    const u = t.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = u), n = u, a(o);
  }
  function a(o) {
    if (o === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(o);
      return;
    }
    return ge(o) ? (t.consume(o), t.exit("chunkText"), s) : (t.consume(o), a);
  }
}
const NH = {
  tokenize: MH
}, sg = {
  tokenize: FH
};
function MH(t) {
  const e = this, n = [];
  let r = 0, i, s, a;
  return o;
  function o(T) {
    if (r < n.length) {
      const S = n[r];
      return e.containerState = S[1], t.attempt(S[0].continuation, u, l)(T);
    }
    return l(T);
  }
  function u(T) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && y();
      const S = e.events.length;
      let v = S, I;
      for (; v--; )
        if (e.events[v][0] === "exit" && e.events[v][1].type === "chunkFlow") {
          I = e.events[v][1].end;
          break;
        }
      E(r);
      let C = S;
      for (; C < e.events.length; )
        e.events[C][1].end = {
          ...I
        }, C++;
      return Un(e.events, v + 1, 0, e.events.slice(S)), e.events.length = C, l(T);
    }
    return o(T);
  }
  function l(T) {
    if (r === n.length) {
      if (!i)
        return f(T);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(T);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, t.check(sg, c, d)(T);
  }
  function c(T) {
    return i && y(), E(r), f(T);
  }
  function d(T) {
    return e.parser.lazy[e.now().line] = r !== n.length, a = e.now().offset, m(T);
  }
  function f(T) {
    return e.containerState = {}, t.attempt(sg, h, m)(T);
  }
  function h(T) {
    return r++, n.push([e.currentConstruct, e.containerState]), f(T);
  }
  function m(T) {
    if (T === null) {
      i && y(), E(0), t.consume(T);
      return;
    }
    return i = i || e.parser.flow(e.now()), t.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), p(T);
  }
  function p(T) {
    if (T === null) {
      g(t.exit("chunkFlow"), !0), E(0), t.consume(T);
      return;
    }
    return ge(T) ? (t.consume(T), g(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, o) : (t.consume(T), p);
  }
  function g(T, S) {
    const v = e.sliceStream(T);
    if (S && v.push(null), T.previous = s, s && (s.next = T), s = T, i.defineSkip(T.start), i.write(v), e.parser.lazy[T.start.line]) {
      let I = i.events.length;
      for (; I--; )
        if (
          // The token starts before the line endingâ€¦
          i.events[I][1].start.offset < a && // â€¦and either is not ended yetâ€¦
          (!i.events[I][1].end || // â€¦or ends after it.
          i.events[I][1].end.offset > a)
        )
          return;
      const C = e.events.length;
      let D = C, _, A;
      for (; D--; )
        if (e.events[D][0] === "exit" && e.events[D][1].type === "chunkFlow") {
          if (_) {
            A = e.events[D][1].end;
            break;
          }
          _ = !0;
        }
      for (E(r), I = C; I < e.events.length; )
        e.events[I][1].end = {
          ...A
        }, I++;
      Un(e.events, D + 1, 0, e.events.slice(C)), e.events.length = I;
    }
  }
  function E(T) {
    let S = n.length;
    for (; S-- > T; ) {
      const v = n[S];
      e.containerState = v[1], v[0].exit.call(e, t);
    }
    n.length = T;
  }
  function y() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function FH(t, e, n) {
  return Ye(t, t.attempt(this.parser.constructs.document, e, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function ag(t) {
  if (t === null || Mt(t) || DH(t))
    return 1;
  if (wH(t))
    return 2;
}
function yh(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
const Nd = {
  name: "attention",
  resolveAll: BH,
  tokenize: UH
};
function BH(t, e) {
  let n = -1, r, i, s, a, o, u, l, c;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
            continue;
          u = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...t[r][1].end
          }, f = {
            ...t[n][1].start
          };
          og(d, -u), og(f, u), a = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...t[r][1].end
            }
          }, o = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...t[n][1].start
            },
            end: f
          }, s = {
            type: u > 1 ? "strongText" : "emphasisText",
            start: {
              ...t[r][1].end
            },
            end: {
              ...t[n][1].start
            }
          }, i = {
            type: u > 1 ? "strong" : "emphasis",
            start: {
              ...a.start
            },
            end: {
              ...o.end
            }
          }, t[r][1].end = {
            ...a.start
          }, t[n][1].start = {
            ...o.end
          }, l = [], t[r][1].end.offset - t[r][1].start.offset && (l = nn(l, [["enter", t[r][1], e], ["exit", t[r][1], e]])), l = nn(l, [["enter", i, e], ["enter", a, e], ["exit", a, e], ["enter", s, e]]), l = nn(l, yh(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e)), l = nn(l, [["exit", s, e], ["enter", o, e], ["exit", o, e], ["exit", i, e]]), t[n][1].end.offset - t[n][1].start.offset ? (c = 2, l = nn(l, [["enter", t[n][1], e], ["exit", t[n][1], e]])) : c = 0, Un(t, r - 1, n - r + 3, l), n = r + l.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < t.length; )
    t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function UH(t, e) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = ag(r);
  let s;
  return a;
  function a(u) {
    return s = u, t.enter("attentionSequence"), o(u);
  }
  function o(u) {
    if (u === s)
      return t.consume(u), o;
    const l = t.exit("attentionSequence"), c = ag(u), d = !c || c === 2 && i || n.includes(u), f = !i || i === 2 && c || n.includes(r);
    return l._open = !!(s === 42 ? d : d && (i || !f)), l._close = !!(s === 42 ? f : f && (c || !d)), e(u);
  }
}
function og(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
const $H = {
  name: "autolink",
  tokenize: HH
};
function HH(t, e, n) {
  let r = 0;
  return i;
  function i(h) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), s;
  }
  function s(h) {
    return _n(h) ? (t.consume(h), a) : h === 64 ? n(h) : l(h);
  }
  function a(h) {
    return h === 43 || h === 45 || h === 46 || hn(h) ? (r = 1, o(h)) : l(h);
  }
  function o(h) {
    return h === 58 ? (t.consume(h), r = 0, u) : (h === 43 || h === 45 || h === 46 || hn(h)) && r++ < 32 ? (t.consume(h), o) : (r = 0, l(h));
  }
  function u(h) {
    return h === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.exit("autolink"), e) : h === null || h === 32 || h === 60 || Pd(h) ? n(h) : (t.consume(h), u);
  }
  function l(h) {
    return h === 64 ? (t.consume(h), c) : _H(h) ? (t.consume(h), l) : n(h);
  }
  function c(h) {
    return hn(h) ? d(h) : n(h);
  }
  function d(h) {
    return h === 46 ? (t.consume(h), r = 0, c) : h === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.exit("autolink"), e) : f(h);
  }
  function f(h) {
    if ((h === 45 || hn(h)) && r++ < 63) {
      const m = h === 45 ? f : d;
      return t.consume(h), m;
    }
    return n(h);
  }
}
const al = {
  partial: !0,
  tokenize: GH
};
function GH(t, e, n) {
  return r;
  function r(s) {
    return Ne(s) ? Ye(t, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || ge(s) ? e(s) : n(s);
  }
}
const OS = {
  continuation: {
    tokenize: zH
  },
  exit: qH,
  name: "blockQuote",
  tokenize: VH
};
function VH(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    if (a === 62) {
      const o = r.containerState;
      return o.open || (t.enter("blockQuote", {
        _container: !0
      }), o.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(a), t.exit("blockQuoteMarker"), s;
    }
    return n(a);
  }
  function s(a) {
    return Ne(a) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(a), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(a));
  }
}
function zH(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return Ne(a) ? Ye(t, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : s(a);
  }
  function s(a) {
    return t.attempt(OS, e, n)(a);
  }
}
function qH(t) {
  t.exit("blockQuote");
}
const NS = {
  name: "characterEscape",
  tokenize: jH
};
function jH(t, e, n) {
  return r;
  function r(s) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(s), t.exit("escapeMarker"), i;
  }
  function i(s) {
    return kH(s) ? (t.enter("characterEscapeValue"), t.consume(s), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(s);
  }
}
const MS = {
  name: "characterReference",
  tokenize: KH
};
function KH(t, e, n) {
  const r = this;
  let i = 0, s, a;
  return o;
  function o(d) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), u;
  }
  function u(d) {
    return d === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(d), t.exit("characterReferenceMarkerNumeric"), l) : (t.enter("characterReferenceValue"), s = 31, a = hn, c(d));
  }
  function l(d) {
    return d === 88 || d === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(d), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), s = 6, a = RH, c) : (t.enter("characterReferenceValue"), s = 7, a = Od, c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const f = t.exit("characterReferenceValue");
      return a === hn && !fh(r.sliceSerialize(f)) ? n(d) : (t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), t.exit("characterReference"), e);
    }
    return a(d) && i++ < s ? (t.consume(d), c) : n(d);
  }
}
const ug = {
  partial: !0,
  tokenize: YH
}, lg = {
  concrete: !0,
  name: "codeFenced",
  tokenize: WH
};
function WH(t, e, n) {
  const r = this, i = {
    partial: !0,
    tokenize: v
  };
  let s = 0, a = 0, o;
  return u;
  function u(I) {
    return l(I);
  }
  function l(I) {
    const C = r.events[r.events.length - 1];
    return s = C && C[1].type === "linePrefix" ? C[2].sliceSerialize(C[1], !0).length : 0, o = I, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), c(I);
  }
  function c(I) {
    return I === o ? (a++, t.consume(I), c) : a < 3 ? n(I) : (t.exit("codeFencedFenceSequence"), Ne(I) ? Ye(t, d, "whitespace")(I) : d(I));
  }
  function d(I) {
    return I === null || ge(I) ? (t.exit("codeFencedFence"), r.interrupt ? e(I) : t.check(ug, p, S)(I)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), f(I));
  }
  function f(I) {
    return I === null || ge(I) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), d(I)) : Ne(I) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), Ye(t, h, "whitespace")(I)) : I === 96 && I === o ? n(I) : (t.consume(I), f);
  }
  function h(I) {
    return I === null || ge(I) ? d(I) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), m(I));
  }
  function m(I) {
    return I === null || ge(I) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), d(I)) : I === 96 && I === o ? n(I) : (t.consume(I), m);
  }
  function p(I) {
    return t.attempt(i, S, g)(I);
  }
  function g(I) {
    return t.enter("lineEnding"), t.consume(I), t.exit("lineEnding"), E;
  }
  function E(I) {
    return s > 0 && Ne(I) ? Ye(t, y, "linePrefix", s + 1)(I) : y(I);
  }
  function y(I) {
    return I === null || ge(I) ? t.check(ug, p, S)(I) : (t.enter("codeFlowValue"), T(I));
  }
  function T(I) {
    return I === null || ge(I) ? (t.exit("codeFlowValue"), y(I)) : (t.consume(I), T);
  }
  function S(I) {
    return t.exit("codeFenced"), e(I);
  }
  function v(I, C, D) {
    let _ = 0;
    return A;
    function A(O) {
      return I.enter("lineEnding"), I.consume(O), I.exit("lineEnding"), L;
    }
    function L(O) {
      return I.enter("codeFencedFence"), Ne(O) ? Ye(I, N, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : N(O);
    }
    function N(O) {
      return O === o ? (I.enter("codeFencedFenceSequence"), U(O)) : D(O);
    }
    function U(O) {
      return O === o ? (_++, I.consume(O), U) : _ >= a ? (I.exit("codeFencedFenceSequence"), Ne(O) ? Ye(I, z, "whitespace")(O) : z(O)) : D(O);
    }
    function z(O) {
      return O === null || ge(O) ? (I.exit("codeFencedFence"), C(O)) : D(O);
    }
  }
}
function YH(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return a === null ? n(a) : (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), s);
  }
  function s(a) {
    return r.parser.lazy[r.now().line] ? n(a) : e(a);
  }
}
const lc = {
  name: "codeIndented",
  tokenize: QH
}, XH = {
  partial: !0,
  tokenize: ZH
};
function QH(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return t.enter("codeIndented"), Ye(t, s, "linePrefix", 5)(l);
  }
  function s(l) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(l) : n(l);
  }
  function a(l) {
    return l === null ? u(l) : ge(l) ? t.attempt(XH, a, u)(l) : (t.enter("codeFlowValue"), o(l));
  }
  function o(l) {
    return l === null || ge(l) ? (t.exit("codeFlowValue"), a(l)) : (t.consume(l), o);
  }
  function u(l) {
    return t.exit("codeIndented"), e(l);
  }
}
function ZH(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return r.parser.lazy[r.now().line] ? n(a) : ge(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), i) : Ye(t, s, "linePrefix", 5)(a);
  }
  function s(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : ge(a) ? i(a) : n(a);
  }
}
const JH = {
  name: "codeText",
  previous: tG,
  resolve: eG,
  tokenize: nG
};
function eG(t) {
  let e = t.length - 4, n = 3, r, i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2;
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData", r !== i + 2 && (t[i][1].end = t[r - 1][1].end, t.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return t;
}
function tG(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function nG(t, e, n) {
  let r = 0, i, s;
  return a;
  function a(d) {
    return t.enter("codeText"), t.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (t.consume(d), r++, o) : (t.exit("codeTextSequence"), u(d));
  }
  function u(d) {
    return d === null ? n(d) : d === 32 ? (t.enter("space"), t.consume(d), t.exit("space"), u) : d === 96 ? (s = t.enter("codeTextSequence"), i = 0, c(d)) : ge(d) ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), u) : (t.enter("codeTextData"), l(d));
  }
  function l(d) {
    return d === null || d === 32 || d === 96 || ge(d) ? (t.exit("codeTextData"), u(d)) : (t.consume(d), l);
  }
  function c(d) {
    return d === 96 ? (t.consume(d), i++, c) : i === r ? (t.exit("codeTextSequence"), t.exit("codeText"), e(d)) : (s.type = "codeTextData", l(d));
  }
}
class rG {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Ls(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), Ls(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), Ls(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const n = this.left.splice(e, Number.POSITIVE_INFINITY);
        Ls(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        Ls(this.left, n.reverse());
      }
  }
}
function Ls(t, e) {
  let n = 0;
  if (e.length < 1e4)
    t.push(...e);
  else
    for (; n < e.length; )
      t.push(...e.slice(n, n + 1e4)), n += 1e4;
}
function FS(t) {
  const e = {};
  let n = -1, r, i, s, a, o, u, l;
  const c = new rG(t);
  for (; ++n < c.length; ) {
    for (; n in e; )
      n = e[n];
    if (r = c.get(n), n && r[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, s = 0, s < u.length && u[s][1].type === "lineEndingBlank" && (s += 2), s < u.length && u[s][1].type === "content"))
      for (; ++s < u.length && u[s][1].type !== "content"; )
        u[s][1].type === "chunkText" && (u[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, iG(c, n)), n = e[n], l = !0);
    else if (r[1]._container) {
      for (s = n, i = void 0; s--; )
        if (a = c.get(s), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank")
          a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = s);
        else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...c.get(i)[1].start
      }, o = c.slice(i, n), o.unshift(r), c.splice(i, n - i + 1, o));
    }
  }
  return Un(t, 0, Number.POSITIVE_INFINITY, c.slice(0)), !l;
}
function iG(t, e) {
  const n = t.get(e)[1], r = t.get(e)[2];
  let i = e - 1;
  const s = [];
  let a = n._tokenizer;
  a || (a = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0));
  const o = a.events, u = [], l = {};
  let c, d, f = -1, h = n, m = 0, p = 0;
  const g = [p];
  for (; h; ) {
    for (; t.get(++i)[1] !== h; )
      ;
    s.push(i), h._tokenizer || (c = r.sliceStream(h), h.next || c.push(null), d && a.defineSkip(h.start), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = h, h = h.next;
  }
  for (h = n; ++f < o.length; )
    // Find a void token that includes a break.
    o[f][0] === "exit" && o[f - 1][0] === "enter" && o[f][1].type === o[f - 1][1].type && o[f][1].start.line !== o[f][1].end.line && (p = f + 1, g.push(p), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (a.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const E = o.slice(g[f], g[f + 1]), y = s.pop();
    u.push([y, y + E.length - 1]), t.splice(y, 2, E);
  }
  for (u.reverse(), f = -1; ++f < u.length; )
    l[m + u[f][0]] = m + u[f][1], m += u[f][1] - u[f][0] - 1;
  return l;
}
const sG = {
  resolve: oG,
  tokenize: uG
}, aG = {
  partial: !0,
  tokenize: lG
};
function oG(t) {
  return FS(t), t;
}
function uG(t, e) {
  let n;
  return r;
  function r(o) {
    return t.enter("content"), n = t.enter("chunkContent", {
      contentType: "content"
    }), i(o);
  }
  function i(o) {
    return o === null ? s(o) : ge(o) ? t.check(aG, a, s)(o) : (t.consume(o), i);
  }
  function s(o) {
    return t.exit("chunkContent"), t.exit("content"), e(o);
  }
  function a(o) {
    return t.consume(o), t.exit("chunkContent"), n.next = t.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function lG(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), Ye(t, s, "linePrefix");
  }
  function s(a) {
    if (a === null || ge(a))
      return n(a);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : t.interrupt(r.parser.constructs.flow, n, e)(a);
  }
}
function BS(t, e, n, r, i, s, a, o, u) {
  const l = u || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(E) {
    return E === 60 ? (t.enter(r), t.enter(i), t.enter(s), t.consume(E), t.exit(s), f) : E === null || E === 32 || E === 41 || Pd(E) ? n(E) : (t.enter(r), t.enter(a), t.enter(o), t.enter("chunkString", {
      contentType: "string"
    }), p(E));
  }
  function f(E) {
    return E === 62 ? (t.enter(s), t.consume(E), t.exit(s), t.exit(i), t.exit(r), e) : (t.enter(o), t.enter("chunkString", {
      contentType: "string"
    }), h(E));
  }
  function h(E) {
    return E === 62 ? (t.exit("chunkString"), t.exit(o), f(E)) : E === null || E === 60 || ge(E) ? n(E) : (t.consume(E), E === 92 ? m : h);
  }
  function m(E) {
    return E === 60 || E === 62 || E === 92 ? (t.consume(E), h) : h(E);
  }
  function p(E) {
    return !c && (E === null || E === 41 || Mt(E)) ? (t.exit("chunkString"), t.exit(o), t.exit(a), t.exit(r), e(E)) : c < l && E === 40 ? (t.consume(E), c++, p) : E === 41 ? (t.consume(E), c--, p) : E === null || E === 32 || E === 40 || Pd(E) ? n(E) : (t.consume(E), E === 92 ? g : p);
  }
  function g(E) {
    return E === 40 || E === 41 || E === 92 ? (t.consume(E), p) : p(E);
  }
}
function US(t, e, n, r, i, s) {
  const a = this;
  let o = 0, u;
  return l;
  function l(h) {
    return t.enter(r), t.enter(i), t.consume(h), t.exit(i), t.enter(s), c;
  }
  function c(h) {
    return o > 999 || h === null || h === 91 || h === 93 && !u || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !o && "_hiddenFootnoteSupport" in a.parser.constructs ? n(h) : h === 93 ? (t.exit(s), t.enter(i), t.consume(h), t.exit(i), t.exit(r), e) : ge(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), c) : (t.enter("chunkString", {
      contentType: "string"
    }), d(h));
  }
  function d(h) {
    return h === null || h === 91 || h === 93 || ge(h) || o++ > 999 ? (t.exit("chunkString"), c(h)) : (t.consume(h), u || (u = !Ne(h)), h === 92 ? f : d);
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), o++, d) : d(h);
  }
}
function $S(t, e, n, r, i, s) {
  let a;
  return o;
  function o(f) {
    return f === 34 || f === 39 || f === 40 ? (t.enter(r), t.enter(i), t.consume(f), t.exit(i), a = f === 40 ? 41 : f, u) : n(f);
  }
  function u(f) {
    return f === a ? (t.enter(i), t.consume(f), t.exit(i), t.exit(r), e) : (t.enter(s), l(f));
  }
  function l(f) {
    return f === a ? (t.exit(s), u(a)) : f === null ? n(f) : ge(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), Ye(t, l, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), c(f));
  }
  function c(f) {
    return f === a || f === null || ge(f) ? (t.exit("chunkString"), l(f)) : (t.consume(f), f === 92 ? d : c);
  }
  function d(f) {
    return f === a || f === 92 ? (t.consume(f), c) : c(f);
  }
}
function qs(t, e) {
  let n;
  return r;
  function r(i) {
    return ge(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), n = !0, r) : Ne(i) ? Ye(t, r, n ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const cG = {
  name: "definition",
  tokenize: fG
}, dG = {
  partial: !0,
  tokenize: hG
};
function fG(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(h) {
    return t.enter("definition"), a(h);
  }
  function a(h) {
    return US.call(
      r,
      t,
      o,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function o(h) {
    return i = Bi(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (t.enter("definitionMarker"), t.consume(h), t.exit("definitionMarker"), u) : n(h);
  }
  function u(h) {
    return Mt(h) ? qs(t, l)(h) : l(h);
  }
  function l(h) {
    return BS(
      t,
      c,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function c(h) {
    return t.attempt(dG, d, d)(h);
  }
  function d(h) {
    return Ne(h) ? Ye(t, f, "whitespace")(h) : f(h);
  }
  function f(h) {
    return h === null || ge(h) ? (t.exit("definition"), r.parser.defined.push(i), e(h)) : n(h);
  }
}
function hG(t, e, n) {
  return r;
  function r(o) {
    return Mt(o) ? qs(t, i)(o) : n(o);
  }
  function i(o) {
    return $S(t, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function s(o) {
    return Ne(o) ? Ye(t, a, "whitespace")(o) : a(o);
  }
  function a(o) {
    return o === null || ge(o) ? e(o) : n(o);
  }
}
const mG = {
  name: "hardBreakEscape",
  tokenize: pG
};
function pG(t, e, n) {
  return r;
  function r(s) {
    return t.enter("hardBreakEscape"), t.consume(s), i;
  }
  function i(s) {
    return ge(s) ? (t.exit("hardBreakEscape"), e(s)) : n(s);
  }
}
const gG = {
  name: "headingAtx",
  resolve: bG,
  tokenize: EG
};
function bG(t, e) {
  let n = t.length - 2, r = 3, i, s;
  return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[n][1].end
  }, s = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[n][1].end,
    contentType: "text"
  }, Un(t, r, n - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), t;
}
function EG(t, e, n) {
  let r = 0;
  return i;
  function i(c) {
    return t.enter("atxHeading"), s(c);
  }
  function s(c) {
    return t.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && r++ < 6 ? (t.consume(c), a) : c === null || Mt(c) ? (t.exit("atxHeadingSequence"), o(c)) : n(c);
  }
  function o(c) {
    return c === 35 ? (t.enter("atxHeadingSequence"), u(c)) : c === null || ge(c) ? (t.exit("atxHeading"), e(c)) : Ne(c) ? Ye(t, o, "whitespace")(c) : (t.enter("atxHeadingText"), l(c));
  }
  function u(c) {
    return c === 35 ? (t.consume(c), u) : (t.exit("atxHeadingSequence"), o(c));
  }
  function l(c) {
    return c === null || c === 35 || Mt(c) ? (t.exit("atxHeadingText"), o(c)) : (t.consume(c), l);
  }
}
const yG = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], cg = ["pre", "script", "style", "textarea"], TG = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: AG,
  tokenize: vG
}, xG = {
  partial: !0,
  tokenize: CG
}, SG = {
  partial: !0,
  tokenize: IG
};
function AG(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t;
}
function vG(t, e, n) {
  const r = this;
  let i, s, a, o, u;
  return l;
  function l(R) {
    return c(R);
  }
  function c(R) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(R), d;
  }
  function d(R) {
    return R === 33 ? (t.consume(R), f) : R === 47 ? (t.consume(R), s = !0, p) : R === 63 ? (t.consume(R), i = 3, r.interrupt ? e : w) : _n(R) ? (t.consume(R), a = String.fromCharCode(R), g) : n(R);
  }
  function f(R) {
    return R === 45 ? (t.consume(R), i = 2, h) : R === 91 ? (t.consume(R), i = 5, o = 0, m) : _n(R) ? (t.consume(R), i = 4, r.interrupt ? e : w) : n(R);
  }
  function h(R) {
    return R === 45 ? (t.consume(R), r.interrupt ? e : w) : n(R);
  }
  function m(R) {
    const te = "CDATA[";
    return R === te.charCodeAt(o++) ? (t.consume(R), o === te.length ? r.interrupt ? e : N : m) : n(R);
  }
  function p(R) {
    return _n(R) ? (t.consume(R), a = String.fromCharCode(R), g) : n(R);
  }
  function g(R) {
    if (R === null || R === 47 || R === 62 || Mt(R)) {
      const te = R === 47, he = a.toLowerCase();
      return !te && !s && cg.includes(he) ? (i = 1, r.interrupt ? e(R) : N(R)) : yG.includes(a.toLowerCase()) ? (i = 6, te ? (t.consume(R), E) : r.interrupt ? e(R) : N(R)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(R) : s ? y(R) : T(R));
    }
    return R === 45 || hn(R) ? (t.consume(R), a += String.fromCharCode(R), g) : n(R);
  }
  function E(R) {
    return R === 62 ? (t.consume(R), r.interrupt ? e : N) : n(R);
  }
  function y(R) {
    return Ne(R) ? (t.consume(R), y) : A(R);
  }
  function T(R) {
    return R === 47 ? (t.consume(R), A) : R === 58 || R === 95 || _n(R) ? (t.consume(R), S) : Ne(R) ? (t.consume(R), T) : A(R);
  }
  function S(R) {
    return R === 45 || R === 46 || R === 58 || R === 95 || hn(R) ? (t.consume(R), S) : v(R);
  }
  function v(R) {
    return R === 61 ? (t.consume(R), I) : Ne(R) ? (t.consume(R), v) : T(R);
  }
  function I(R) {
    return R === null || R === 60 || R === 61 || R === 62 || R === 96 ? n(R) : R === 34 || R === 39 ? (t.consume(R), u = R, C) : Ne(R) ? (t.consume(R), I) : D(R);
  }
  function C(R) {
    return R === u ? (t.consume(R), u = null, _) : R === null || ge(R) ? n(R) : (t.consume(R), C);
  }
  function D(R) {
    return R === null || R === 34 || R === 39 || R === 47 || R === 60 || R === 61 || R === 62 || R === 96 || Mt(R) ? v(R) : (t.consume(R), D);
  }
  function _(R) {
    return R === 47 || R === 62 || Ne(R) ? T(R) : n(R);
  }
  function A(R) {
    return R === 62 ? (t.consume(R), L) : n(R);
  }
  function L(R) {
    return R === null || ge(R) ? N(R) : Ne(R) ? (t.consume(R), L) : n(R);
  }
  function N(R) {
    return R === 45 && i === 2 ? (t.consume(R), F) : R === 60 && i === 1 ? (t.consume(R), B) : R === 62 && i === 4 ? (t.consume(R), Q) : R === 63 && i === 3 ? (t.consume(R), w) : R === 93 && i === 5 ? (t.consume(R), X) : ge(R) && (i === 6 || i === 7) ? (t.exit("htmlFlowData"), t.check(xG, J, U)(R)) : R === null || ge(R) ? (t.exit("htmlFlowData"), U(R)) : (t.consume(R), N);
  }
  function U(R) {
    return t.check(SG, z, J)(R);
  }
  function z(R) {
    return t.enter("lineEnding"), t.consume(R), t.exit("lineEnding"), O;
  }
  function O(R) {
    return R === null || ge(R) ? U(R) : (t.enter("htmlFlowData"), N(R));
  }
  function F(R) {
    return R === 45 ? (t.consume(R), w) : N(R);
  }
  function B(R) {
    return R === 47 ? (t.consume(R), a = "", H) : N(R);
  }
  function H(R) {
    if (R === 62) {
      const te = a.toLowerCase();
      return cg.includes(te) ? (t.consume(R), Q) : N(R);
    }
    return _n(R) && a.length < 8 ? (t.consume(R), a += String.fromCharCode(R), H) : N(R);
  }
  function X(R) {
    return R === 93 ? (t.consume(R), w) : N(R);
  }
  function w(R) {
    return R === 62 ? (t.consume(R), Q) : R === 45 && i === 2 ? (t.consume(R), w) : N(R);
  }
  function Q(R) {
    return R === null || ge(R) ? (t.exit("htmlFlowData"), J(R)) : (t.consume(R), Q);
  }
  function J(R) {
    return t.exit("htmlFlow"), e(R);
  }
}
function IG(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return ge(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), s) : n(a);
  }
  function s(a) {
    return r.parser.lazy[r.now().line] ? n(a) : e(a);
  }
}
function CG(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), t.attempt(al, e, n);
  }
}
const LG = {
  name: "htmlText",
  tokenize: _G
};
function _G(t, e, n) {
  const r = this;
  let i, s, a;
  return o;
  function o(w) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(w), u;
  }
  function u(w) {
    return w === 33 ? (t.consume(w), l) : w === 47 ? (t.consume(w), v) : w === 63 ? (t.consume(w), T) : _n(w) ? (t.consume(w), D) : n(w);
  }
  function l(w) {
    return w === 45 ? (t.consume(w), c) : w === 91 ? (t.consume(w), s = 0, m) : _n(w) ? (t.consume(w), y) : n(w);
  }
  function c(w) {
    return w === 45 ? (t.consume(w), h) : n(w);
  }
  function d(w) {
    return w === null ? n(w) : w === 45 ? (t.consume(w), f) : ge(w) ? (a = d, B(w)) : (t.consume(w), d);
  }
  function f(w) {
    return w === 45 ? (t.consume(w), h) : d(w);
  }
  function h(w) {
    return w === 62 ? F(w) : w === 45 ? f(w) : d(w);
  }
  function m(w) {
    const Q = "CDATA[";
    return w === Q.charCodeAt(s++) ? (t.consume(w), s === Q.length ? p : m) : n(w);
  }
  function p(w) {
    return w === null ? n(w) : w === 93 ? (t.consume(w), g) : ge(w) ? (a = p, B(w)) : (t.consume(w), p);
  }
  function g(w) {
    return w === 93 ? (t.consume(w), E) : p(w);
  }
  function E(w) {
    return w === 62 ? F(w) : w === 93 ? (t.consume(w), E) : p(w);
  }
  function y(w) {
    return w === null || w === 62 ? F(w) : ge(w) ? (a = y, B(w)) : (t.consume(w), y);
  }
  function T(w) {
    return w === null ? n(w) : w === 63 ? (t.consume(w), S) : ge(w) ? (a = T, B(w)) : (t.consume(w), T);
  }
  function S(w) {
    return w === 62 ? F(w) : T(w);
  }
  function v(w) {
    return _n(w) ? (t.consume(w), I) : n(w);
  }
  function I(w) {
    return w === 45 || hn(w) ? (t.consume(w), I) : C(w);
  }
  function C(w) {
    return ge(w) ? (a = C, B(w)) : Ne(w) ? (t.consume(w), C) : F(w);
  }
  function D(w) {
    return w === 45 || hn(w) ? (t.consume(w), D) : w === 47 || w === 62 || Mt(w) ? _(w) : n(w);
  }
  function _(w) {
    return w === 47 ? (t.consume(w), F) : w === 58 || w === 95 || _n(w) ? (t.consume(w), A) : ge(w) ? (a = _, B(w)) : Ne(w) ? (t.consume(w), _) : F(w);
  }
  function A(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || hn(w) ? (t.consume(w), A) : L(w);
  }
  function L(w) {
    return w === 61 ? (t.consume(w), N) : ge(w) ? (a = L, B(w)) : Ne(w) ? (t.consume(w), L) : _(w);
  }
  function N(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 34 || w === 39 ? (t.consume(w), i = w, U) : ge(w) ? (a = N, B(w)) : Ne(w) ? (t.consume(w), N) : (t.consume(w), z);
  }
  function U(w) {
    return w === i ? (t.consume(w), i = void 0, O) : w === null ? n(w) : ge(w) ? (a = U, B(w)) : (t.consume(w), U);
  }
  function z(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 96 ? n(w) : w === 47 || w === 62 || Mt(w) ? _(w) : (t.consume(w), z);
  }
  function O(w) {
    return w === 47 || w === 62 || Mt(w) ? _(w) : n(w);
  }
  function F(w) {
    return w === 62 ? (t.consume(w), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(w);
  }
  function B(w) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(w), t.exit("lineEnding"), H;
  }
  function H(w) {
    return Ne(w) ? Ye(t, X, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(w) : X(w);
  }
  function X(w) {
    return t.enter("htmlTextData"), a(w);
  }
}
const Th = {
  name: "labelEnd",
  resolveAll: DG,
  resolveTo: PG,
  tokenize: OG
}, RG = {
  tokenize: NG
}, kG = {
  tokenize: MG
}, wG = {
  tokenize: FG
};
function DG(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.length; ) {
    const r = t[e][1];
    if (n.push(t[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return t.length !== n.length && Un(t, 0, t.length, n), t;
}
function PG(t, e) {
  let n = t.length, r = 0, i, s, a, o;
  for (; n--; )
    if (i = t[n][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = n);
  const u = {
    type: t[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...t[s][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  }, l = {
    type: "label",
    start: {
      ...t[s][1].start
    },
    end: {
      ...t[a][1].end
    }
  }, c = {
    type: "labelText",
    start: {
      ...t[s + r + 2][1].end
    },
    end: {
      ...t[a - 2][1].start
    }
  };
  return o = [["enter", u, e], ["enter", l, e]], o = nn(o, t.slice(s + 1, s + r + 3)), o = nn(o, [["enter", c, e]]), o = nn(o, yh(e.parser.constructs.insideSpan.null, t.slice(s + r + 4, a - 3), e)), o = nn(o, [["exit", c, e], t[a - 2], t[a - 1], ["exit", l, e]]), o = nn(o, t.slice(a + 1)), o = nn(o, [["exit", u, e]]), Un(t, s, t.length, o), t;
}
function OG(t, e, n) {
  const r = this;
  let i = r.events.length, s, a;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return o;
  function o(f) {
    return s ? s._inactive ? d(f) : (a = r.parser.defined.includes(Bi(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(f), t.exit("labelMarker"), t.exit("labelEnd"), u) : n(f);
  }
  function u(f) {
    return f === 40 ? t.attempt(RG, c, a ? c : d)(f) : f === 91 ? t.attempt(kG, c, a ? l : d)(f) : a ? c(f) : d(f);
  }
  function l(f) {
    return t.attempt(wG, c, d)(f);
  }
  function c(f) {
    return e(f);
  }
  function d(f) {
    return s._balanced = !0, n(f);
  }
}
function NG(t, e, n) {
  return r;
  function r(d) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), i;
  }
  function i(d) {
    return Mt(d) ? qs(t, s)(d) : s(d);
  }
  function s(d) {
    return d === 41 ? c(d) : BS(t, a, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function a(d) {
    return Mt(d) ? qs(t, u)(d) : c(d);
  }
  function o(d) {
    return n(d);
  }
  function u(d) {
    return d === 34 || d === 39 || d === 40 ? $S(t, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function l(d) {
    return Mt(d) ? qs(t, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), t.exit("resource"), e) : n(d);
  }
}
function MG(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return US.call(r, t, s, a, "reference", "referenceMarker", "referenceString")(o);
  }
  function s(o) {
    return r.parser.defined.includes(Bi(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(o) : n(o);
  }
  function a(o) {
    return n(o);
  }
}
function FG(t, e, n) {
  return r;
  function r(s) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), t.exit("reference"), e) : n(s);
  }
}
const BG = {
  name: "labelStartImage",
  resolveAll: Th.resolveAll,
  tokenize: UG
};
function UG(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(o), t.exit("labelImageMarker"), s;
  }
  function s(o) {
    return o === 91 ? (t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelImage"), a) : n(o);
  }
  function a(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const $G = {
  name: "labelStartLink",
  resolveAll: Th.resolveAll,
  tokenize: HG
};
function HG(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelLink"), s;
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const cc = {
  name: "lineEnding",
  tokenize: GG
};
function GG(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), Ye(t, e, "linePrefix");
  }
}
const jo = {
  name: "thematicBreak",
  tokenize: VG
};
function VG(t, e, n) {
  let r = 0, i;
  return s;
  function s(l) {
    return t.enter("thematicBreak"), a(l);
  }
  function a(l) {
    return i = l, o(l);
  }
  function o(l) {
    return l === i ? (t.enter("thematicBreakSequence"), u(l)) : r >= 3 && (l === null || ge(l)) ? (t.exit("thematicBreak"), e(l)) : n(l);
  }
  function u(l) {
    return l === i ? (t.consume(l), r++, u) : (t.exit("thematicBreakSequence"), Ne(l) ? Ye(t, o, "whitespace")(l) : o(l));
  }
}
const Dt = {
  continuation: {
    tokenize: KG
  },
  exit: YG,
  name: "list",
  tokenize: jG
}, zG = {
  partial: !0,
  tokenize: XG
}, qG = {
  partial: !0,
  tokenize: WG
};
function jG(t, e, n) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return o;
  function o(h) {
    const m = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : Od(h)) {
      if (r.containerState.type || (r.containerState.type = m, t.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return t.enter("listItemPrefix"), h === 42 || h === 45 ? t.check(jo, n, l)(h) : l(h);
      if (!r.interrupt || h === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), u(h);
    }
    return n(h);
  }
  function u(h) {
    return Od(h) && ++a < 10 ? (t.consume(h), u) : (!r.interrupt || a < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (t.exit("listItemValue"), l(h)) : n(h);
  }
  function l(h) {
    return t.enter("listItemMarker"), t.consume(h), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, t.check(
      al,
      // Canâ€™t be empty when interrupting.
      r.interrupt ? n : c,
      t.attempt(zG, f, d)
    );
  }
  function c(h) {
    return r.containerState.initialBlankLine = !0, s++, f(h);
  }
  function d(h) {
    return Ne(h) ? (t.enter("listItemPrefixWhitespace"), t.consume(h), t.exit("listItemPrefixWhitespace"), f) : n(h);
  }
  function f(h) {
    return r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(h);
  }
}
function KG(t, e, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(al, i, s);
  function i(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ye(t, e, "listItemIndent", r.containerState.size + 1)(o);
  }
  function s(o) {
    return r.containerState.furtherBlankLines || !Ne(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(qG, e, a)(o));
  }
  function a(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ye(t, t.attempt(Dt, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function WG(t, e, n) {
  const r = this;
  return Ye(t, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? e(s) : n(s);
  }
}
function YG(t) {
  t.exit(this.containerState.type);
}
function XG(t, e, n) {
  const r = this;
  return Ye(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return !Ne(s) && a && a[1].type === "listItemPrefixWhitespace" ? e(s) : n(s);
  }
}
const dg = {
  name: "setextUnderline",
  resolveTo: QG,
  tokenize: ZG
};
function QG(t, e) {
  let n = t.length, r, i, s;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else
      t[n][1].type === "content" && t.splice(n, 1), !s && t[n][1].type === "definition" && (s = n);
  const a = {
    type: "setextHeading",
    start: {
      ...t[r][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  };
  return t[i][1].type = "setextHeadingText", s ? (t.splice(i, 0, ["enter", a, e]), t.splice(s + 1, 0, ["exit", t[r][1], e]), t[r][1].end = {
    ...t[s][1].end
  }) : t[r][1] = a, t.push(["exit", a, e]), t;
}
function ZG(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(l) {
    let c = r.events.length, d;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        d = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (t.enter("setextHeadingLine"), i = l, a(l)) : n(l);
  }
  function a(l) {
    return t.enter("setextHeadingLineSequence"), o(l);
  }
  function o(l) {
    return l === i ? (t.consume(l), o) : (t.exit("setextHeadingLineSequence"), Ne(l) ? Ye(t, u, "lineSuffix")(l) : u(l));
  }
  function u(l) {
    return l === null || ge(l) ? (t.exit("setextHeadingLine"), e(l)) : n(l);
  }
}
const JG = {
  tokenize: eV
};
function eV(t) {
  const e = this, n = t.attempt(
    // Try to parse a blank line.
    al,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(this.parser.constructs.flowInitial, i, Ye(t, t.attempt(this.parser.constructs.flow, i, t.attempt(sG, i)), "linePrefix"))
  );
  return n;
  function r(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(s), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n;
  }
  function i(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), e.currentConstruct = void 0, n;
  }
}
const tV = {
  resolveAll: GS()
}, nV = HS("string"), rV = HS("text");
function HS(t) {
  return {
    resolveAll: GS(t === "text" ? iV : void 0),
    tokenize: e
  };
  function e(n) {
    const r = this, i = this.parser.constructs[t], s = n.attempt(i, a, o);
    return a;
    function a(c) {
      return l(c) ? s(c) : o(c);
    }
    function o(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), u;
    }
    function u(c) {
      return l(c) ? (n.exit("data"), s(c)) : (n.consume(c), u);
    }
    function l(c) {
      if (c === null)
        return !0;
      const d = i[c];
      let f = -1;
      if (d)
        for (; ++f < d.length; ) {
          const h = d[f];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function GS(t) {
  return e;
  function e(n, r) {
    let i = -1, s;
    for (; ++i <= n.length; )
      s === void 0 ? n[i] && n[i][1].type === "data" && (s = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end, n.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return t ? t(n, r) : n;
  }
}
function iV(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1], i = e.sliceStream(r);
      let s = i.length, a = -1, o = 0, u;
      for (; s--; ) {
        const l = i[s];
        if (typeof l == "string") {
          for (a = l.length; l.charCodeAt(a - 1) === 32; )
            o++, a--;
          if (a) break;
          a = -1;
        } else if (l === -2)
          u = !0, o++;
        else if (l !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && n === t.length && (o = 0), o) {
        const l = {
          type: n === t.length || u || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? a : r.start._bufferIndex + a,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...l.start
        }, r.start.offset === r.end.offset ? Object.assign(r, l) : (t.splice(n, 0, ["enter", l, e], ["exit", l, e]), n += 2);
      }
      n++;
    }
  return t;
}
const sV = {
  42: Dt,
  43: Dt,
  45: Dt,
  48: Dt,
  49: Dt,
  50: Dt,
  51: Dt,
  52: Dt,
  53: Dt,
  54: Dt,
  55: Dt,
  56: Dt,
  57: Dt,
  62: OS
}, aV = {
  91: cG
}, oV = {
  [-2]: lc,
  [-1]: lc,
  32: lc
}, uV = {
  35: gG,
  42: jo,
  45: [dg, jo],
  60: TG,
  61: dg,
  95: jo,
  96: lg,
  126: lg
}, lV = {
  38: MS,
  92: NS
}, cV = {
  [-5]: cc,
  [-4]: cc,
  [-3]: cc,
  33: BG,
  38: MS,
  42: Nd,
  60: [$H, LG],
  91: $G,
  92: [mG, NS],
  93: Th,
  95: Nd,
  96: JH
}, dV = {
  null: [Nd, tV]
}, fV = {
  null: [42, 95]
}, hV = {
  null: []
}, mV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: fV,
  contentInitial: aV,
  disable: hV,
  document: sV,
  flow: uV,
  flowInitial: oV,
  insideSpan: dV,
  string: lV,
  text: cV
}, Symbol.toStringTag, { value: "Module" }));
function pV(t, e, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, s = [];
  let a = [], o = [];
  const u = {
    attempt: C(v),
    check: C(I),
    consume: y,
    enter: T,
    exit: S,
    interrupt: C(I, {
      interrupt: !0
    })
  }, l = {
    code: null,
    containerState: {},
    defineSkip: p,
    events: [],
    now: m,
    parser: t,
    previous: null,
    sliceSerialize: f,
    sliceStream: h,
    write: d
  };
  let c = e.tokenize.call(l, u);
  return e.resolveAll && s.push(e), l;
  function d(L) {
    return a = nn(a, L), g(), a[a.length - 1] !== null ? [] : (D(e, 0), l.events = yh(s, l.events, l), l.events);
  }
  function f(L, N) {
    return bV(h(L), N);
  }
  function h(L) {
    return gV(a, L);
  }
  function m() {
    const {
      _bufferIndex: L,
      _index: N,
      line: U,
      column: z,
      offset: O
    } = r;
    return {
      _bufferIndex: L,
      _index: N,
      line: U,
      column: z,
      offset: O
    };
  }
  function p(L) {
    i[L.line] = L.column, A();
  }
  function g() {
    let L;
    for (; r._index < a.length; ) {
      const N = a[r._index];
      if (typeof N == "string")
        for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < N.length; )
          E(N.charCodeAt(r._bufferIndex));
      else
        E(N);
    }
  }
  function E(L) {
    c = c(L);
  }
  function y(L) {
    ge(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, A()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    a[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = L;
  }
  function T(L, N) {
    const U = N || {};
    return U.type = L, U.start = m(), l.events.push(["enter", U, l]), o.push(U), U;
  }
  function S(L) {
    const N = o.pop();
    return N.end = m(), l.events.push(["exit", N, l]), N;
  }
  function v(L, N) {
    D(L, N.from);
  }
  function I(L, N) {
    N.restore();
  }
  function C(L, N) {
    return U;
    function U(z, O, F) {
      let B, H, X, w;
      return Array.isArray(z) ? (
        /* c8 ignore next 1 */
        J(z)
      ) : "tokenize" in z ? (
        // Looks like a construct.
        J([
          /** @type {Construct} */
          z
        ])
      ) : Q(z);
      function Q(ae) {
        return me;
        function me(ke) {
          const Pe = ke !== null && ae[ke], Oe = ke !== null && ae.null, bt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Pe) ? Pe : Pe ? [Pe] : [],
            ...Array.isArray(Oe) ? Oe : Oe ? [Oe] : []
          ];
          return J(bt)(ke);
        }
      }
      function J(ae) {
        return B = ae, H = 0, ae.length === 0 ? F : R(ae[H]);
      }
      function R(ae) {
        return me;
        function me(ke) {
          return w = _(), X = ae, ae.partial || (l.currentConstruct = ae), ae.name && l.parser.constructs.disable.null.includes(ae.name) ? he() : ae.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            N ? Object.assign(Object.create(l), N) : l,
            u,
            te,
            he
          )(ke);
        }
      }
      function te(ae) {
        return L(X, w), O;
      }
      function he(ae) {
        return w.restore(), ++H < B.length ? R(B[H]) : F;
      }
    }
  }
  function D(L, N) {
    L.resolveAll && !s.includes(L) && s.push(L), L.resolve && Un(l.events, N, l.events.length - N, L.resolve(l.events.slice(N), l)), L.resolveTo && (l.events = L.resolveTo(l.events, l));
  }
  function _() {
    const L = m(), N = l.previous, U = l.currentConstruct, z = l.events.length, O = Array.from(o);
    return {
      from: z,
      restore: F
    };
    function F() {
      r = L, l.previous = N, l.currentConstruct = U, l.events.length = z, o = O, A();
    }
  }
  function A() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function gV(t, e) {
  const n = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let a;
  if (n === i)
    a = [t[n].slice(r, s)];
  else {
    if (a = t.slice(n, i), r > -1) {
      const o = a[0];
      typeof o == "string" ? a[0] = o.slice(r) : a.shift();
    }
    s > 0 && a.push(t[i].slice(0, s));
  }
  return a;
}
function bV(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const s = t[n];
    let a;
    if (typeof s == "string")
      a = s;
    else switch (s) {
      case -5: {
        a = "\r";
        break;
      }
      case -4: {
        a = `
`;
        break;
      }
      case -3: {
        a = `\r
`;
        break;
      }
      case -2: {
        a = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        a = " ";
        break;
      }
      default:
        a = String.fromCharCode(s);
    }
    i = s === -2, r.push(a);
  }
  return r.join("");
}
function EV(t) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      IH([mV, ...(t || {}).extensions || []])
    ),
    content: i(PH),
    defined: [],
    document: i(NH),
    flow: i(JG),
    lazy: {},
    string: i(nV),
    text: i(rV)
  };
  return r;
  function i(s) {
    return a;
    function a(o) {
      return pV(r, s, o);
    }
  }
}
function yV(t) {
  for (; !FS(t); )
    ;
  return t;
}
const fg = /[\0\t\n\r]/g;
function TV() {
  let t = 1, e = "", n = !0, r;
  return i;
  function i(s, a, o) {
    const u = [];
    let l, c, d, f, h;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(a || void 0).decode(s)), d = 0, e = "", n && (s.charCodeAt(0) === 65279 && d++, n = void 0); d < s.length; ) {
      if (fg.lastIndex = d, l = fg.exec(s), f = l && l.index !== void 0 ? l.index : s.length, h = s.charCodeAt(f), !l) {
        e = s.slice(d);
        break;
      }
      if (h === 10 && d === f && r)
        u.push(-3), r = void 0;
      else
        switch (r && (u.push(-5), r = void 0), d < f && (u.push(s.slice(d, f)), t += f - d), h) {
          case 0: {
            u.push(65533), t++;
            break;
          }
          case 9: {
            for (c = Math.ceil(t / 4) * 4, u.push(-2); t++ < c; ) u.push(-1);
            break;
          }
          case 10: {
            u.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      d = f + 1;
    }
    return o && (r && u.push(-5), e && u.push(e), u.push(null)), u;
  }
}
const xV = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function SV(t) {
  return t.replace(xV, AV);
}
function AV(t, e, n) {
  if (e)
    return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), s = i === 120 || i === 88;
    return PS(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return fh(n) || t;
}
function Ko(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? hg(t.position) : "start" in t || "end" in t ? hg(t) : "line" in t || "column" in t ? Md(t) : "";
}
function Md(t) {
  return mg(t && t.line) + ":" + mg(t && t.column);
}
function hg(t) {
  return Md(t && t.start) + "-" + Md(t && t.end);
}
function mg(t) {
  return t && typeof t == "number" ? t : 1;
}
const VS = {}.hasOwnProperty;
function vV(t, e, n) {
  return typeof e != "string" && (n = e, e = void 0), IV(n)(yV(EV(n).document().write(TV()(t, e, !0))));
}
function IV(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(It),
      autolinkProtocol: _,
      autolinkEmail: _,
      atxHeading: s(hs),
      blockQuote: s(Oe),
      characterEscape: _,
      characterReference: _,
      codeFenced: s(bt),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: s(bt, a),
      codeText: s(qn, a),
      codeTextData: _,
      data: _,
      codeFlowValue: _,
      definition: s(Ht),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: s(dr),
      hardBreakEscape: s(we),
      hardBreakTrailing: s(we),
      htmlFlow: s(nt, a),
      htmlFlowData: _,
      htmlText: s(nt, a),
      htmlTextData: _,
      image: s(St),
      label: a,
      link: s(It),
      listItem: s(fr),
      listItemValue: f,
      listOrdered: s(Rt, d),
      listUnordered: s(Rt),
      paragraph: s(jn),
      reference: R,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: s(hs),
      strong: s(Oa),
      thematicBreak: s(Na)
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: v,
      autolink: u(),
      autolinkEmail: Pe,
      autolinkProtocol: ke,
      blockQuote: u(),
      characterEscapeValue: A,
      characterReferenceMarkerHexadecimal: he,
      characterReferenceMarkerNumeric: he,
      characterReferenceValue: ae,
      characterReference: me,
      codeFenced: u(g),
      codeFencedFence: p,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: m,
      codeFlowValue: A,
      codeIndented: u(E),
      codeText: u(O),
      codeTextData: A,
      data: A,
      definition: u(),
      definitionDestinationString: S,
      definitionLabelString: y,
      definitionTitleString: T,
      emphasis: u(),
      hardBreakEscape: u(N),
      hardBreakTrailing: u(N),
      htmlFlow: u(U),
      htmlFlowData: A,
      htmlText: u(z),
      htmlTextData: A,
      image: u(B),
      label: X,
      labelText: H,
      lineEnding: L,
      link: u(F),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: te,
      resourceDestinationString: w,
      resourceTitleString: Q,
      resource: J,
      setextHeading: u(D),
      setextHeadingLineSequence: C,
      setextHeadingText: I,
      strong: u(),
      thematicBreak: u()
    }
  };
  zS(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(W) {
    let oe = {
      type: "root",
      children: []
    };
    const Ee = {
      stack: [oe],
      tokenStack: [],
      config: e,
      enter: o,
      exit: l,
      buffer: a,
      resume: c,
      data: n
    }, Le = [];
    let Me = -1;
    for (; ++Me < W.length; )
      if (W[Me][1].type === "listOrdered" || W[Me][1].type === "listUnordered")
        if (W[Me][0] === "enter")
          Le.push(Me);
        else {
          const Et = Le.pop();
          Me = i(W, Et, Me);
        }
    for (Me = -1; ++Me < W.length; ) {
      const Et = e[W[Me][0]];
      VS.call(Et, W[Me][1].type) && Et[W[Me][1].type].call(Object.assign({
        sliceSerialize: W[Me][2].sliceSerialize
      }, Ee), W[Me][1]);
    }
    if (Ee.tokenStack.length > 0) {
      const Et = Ee.tokenStack[Ee.tokenStack.length - 1];
      (Et[1] || pg).call(Ee, void 0, Et[0]);
    }
    for (oe.position = {
      start: pr(W.length > 0 ? W[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: pr(W.length > 0 ? W[W.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Me = -1; ++Me < e.transforms.length; )
      oe = e.transforms[Me](oe) || oe;
    return oe;
  }
  function i(W, oe, Ee) {
    let Le = oe - 1, Me = -1, Et = !1, Pr, Kn, ms, ps;
    for (; ++Le <= Ee; ) {
      const Gt = W[Le];
      switch (Gt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Gt[0] === "enter" ? Me++ : Me--, ps = void 0;
          break;
        }
        case "lineEndingBlank": {
          Gt[0] === "enter" && (Pr && !ps && !Me && !ms && (ms = Le), ps = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          ps = void 0;
      }
      if (!Me && Gt[0] === "enter" && Gt[1].type === "listItemPrefix" || Me === -1 && Gt[0] === "exit" && (Gt[1].type === "listUnordered" || Gt[1].type === "listOrdered")) {
        if (Pr) {
          let ui = Le;
          for (Kn = void 0; ui--; ) {
            const Wn = W[ui];
            if (Wn[1].type === "lineEnding" || Wn[1].type === "lineEndingBlank") {
              if (Wn[0] === "exit") continue;
              Kn && (W[Kn][1].type = "lineEndingBlank", Et = !0), Wn[1].type = "lineEnding", Kn = ui;
            } else if (!(Wn[1].type === "linePrefix" || Wn[1].type === "blockQuotePrefix" || Wn[1].type === "blockQuotePrefixWhitespace" || Wn[1].type === "blockQuoteMarker" || Wn[1].type === "listItemIndent")) break;
          }
          ms && (!Kn || ms < Kn) && (Pr._spread = !0), Pr.end = Object.assign({}, Kn ? W[Kn][1].start : Gt[1].end), W.splice(Kn || Le, 0, ["exit", Pr, Gt[2]]), Le++, Ee++;
        }
        if (Gt[1].type === "listItemPrefix") {
          const ui = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Gt[1].start),
            // @ts-expect-error: weâ€™ll add `end` in a second.
            end: void 0
          };
          Pr = ui, W.splice(Le, 0, ["enter", ui, Gt[2]]), Le++, Ee++, ms = void 0, ps = !0;
        }
      }
    }
    return W[oe][1]._spread = Et, Ee;
  }
  function s(W, oe) {
    return Ee;
    function Ee(Le) {
      o.call(this, W(Le), Le), oe && oe.call(this, Le);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(W, oe, Ee) {
    this.stack[this.stack.length - 1].children.push(W), this.stack.push(W), this.tokenStack.push([oe, Ee || void 0]), W.position = {
      start: pr(oe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function u(W) {
    return oe;
    function oe(Ee) {
      W && W.call(this, Ee), l.call(this, Ee);
    }
  }
  function l(W, oe) {
    const Ee = this.stack.pop(), Le = this.tokenStack.pop();
    if (Le)
      Le[0].type !== W.type && (oe ? oe.call(this, W, Le[0]) : (Le[1] || pg).call(this, W, Le[0]));
    else throw new Error("Cannot close `" + W.type + "` (" + Ko({
      start: W.start,
      end: W.end
    }) + "): itâ€™s not open");
    Ee.position.end = pr(W.end);
  }
  function c() {
    return AH(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(W) {
    if (this.data.expectingFirstListItemValue) {
      const oe = this.stack[this.stack.length - 2];
      oe.start = Number.parseInt(this.sliceSerialize(W), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.lang = W;
  }
  function m() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.meta = W;
  }
  function p() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = W.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function E() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = W.replace(/(\r?\n|\r)$/g, "");
  }
  function y(W) {
    const oe = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = oe, Ee.identifier = Bi(this.sliceSerialize(W)).toLowerCase();
  }
  function T() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.title = W;
  }
  function S() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.url = W;
  }
  function v(W) {
    const oe = this.stack[this.stack.length - 1];
    if (!oe.depth) {
      const Ee = this.sliceSerialize(W).length;
      oe.depth = Ee;
    }
  }
  function I() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function C(W) {
    const oe = this.stack[this.stack.length - 1];
    oe.depth = this.sliceSerialize(W).codePointAt(0) === 61 ? 1 : 2;
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function _(W) {
    const Ee = this.stack[this.stack.length - 1].children;
    let Le = Ee[Ee.length - 1];
    (!Le || Le.type !== "text") && (Le = oi(), Le.position = {
      start: pr(W.start),
      // @ts-expect-error: weâ€™ll add `end` later.
      end: void 0
    }, Ee.push(Le)), this.stack.push(Le);
  }
  function A(W) {
    const oe = this.stack.pop();
    oe.value += this.sliceSerialize(W), oe.position.end = pr(W.end);
  }
  function L(W) {
    const oe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ee = oe.children[oe.children.length - 1];
      Ee.position.end = pr(W.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(oe.type) && (_.call(this, W), A.call(this, W));
  }
  function N() {
    this.data.atHardBreak = !0;
  }
  function U() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = W;
  }
  function z() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = W;
  }
  function O() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.value = W;
  }
  function F() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const oe = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = oe, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function B() {
    const W = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const oe = this.data.referenceType || "shortcut";
      W.type += "Reference", W.referenceType = oe, delete W.url, delete W.title;
    } else
      delete W.identifier, delete W.label;
    this.data.referenceType = void 0;
  }
  function H(W) {
    const oe = this.sliceSerialize(W), Ee = this.stack[this.stack.length - 2];
    Ee.label = SV(oe), Ee.identifier = Bi(oe).toLowerCase();
  }
  function X() {
    const W = this.stack[this.stack.length - 1], oe = this.resume(), Ee = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ee.type === "link") {
      const Le = W.children;
      Ee.children = Le;
    } else
      Ee.alt = oe;
  }
  function w() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.url = W;
  }
  function Q() {
    const W = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.title = W;
  }
  function J() {
    this.data.inReference = void 0;
  }
  function R() {
    this.data.referenceType = "collapsed";
  }
  function te(W) {
    const oe = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = oe, Ee.identifier = Bi(this.sliceSerialize(W)).toLowerCase(), this.data.referenceType = "full";
  }
  function he(W) {
    this.data.characterReferenceType = W.type;
  }
  function ae(W) {
    const oe = this.sliceSerialize(W), Ee = this.data.characterReferenceType;
    let Le;
    Ee ? (Le = PS(oe, Ee === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Le = fh(oe);
    const Me = this.stack[this.stack.length - 1];
    Me.value += Le;
  }
  function me(W) {
    const oe = this.stack.pop();
    oe.position.end = pr(W.end);
  }
  function ke(W) {
    A.call(this, W);
    const oe = this.stack[this.stack.length - 1];
    oe.url = this.sliceSerialize(W);
  }
  function Pe(W) {
    A.call(this, W);
    const oe = this.stack[this.stack.length - 1];
    oe.url = "mailto:" + this.sliceSerialize(W);
  }
  function Oe() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function bt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function qn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ht() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function dr() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function hs() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function we() {
    return {
      type: "break"
    };
  }
  function nt() {
    return {
      type: "html",
      value: ""
    };
  }
  function St() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function It() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Rt(W) {
    return {
      type: "list",
      ordered: W.type === "listOrdered",
      start: null,
      spread: W._spread,
      children: []
    };
  }
  function fr(W) {
    return {
      type: "listItem",
      spread: W._spread,
      checked: null,
      children: []
    };
  }
  function jn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Oa() {
    return {
      type: "strong",
      children: []
    };
  }
  function oi() {
    return {
      type: "text",
      value: ""
    };
  }
  function Na() {
    return {
      type: "thematicBreak"
    };
  }
}
function pr(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function zS(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? zS(t, r) : CV(t, r);
  }
}
function CV(t, e) {
  let n;
  for (n in e)
    if (VS.call(e, n))
      switch (n) {
        case "canContainEols": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "transforms": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[n];
          r && Object.assign(t[n], r);
          break;
        }
      }
}
function pg(t, e) {
  throw t ? new Error("Cannot close `" + t.type + "` (" + Ko({
    start: t.start,
    end: t.end
  }) + "): a different token (`" + e.type + "`, " + Ko({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Ko({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function LV(t) {
  const e = this;
  e.parser = n;
  function n(r) {
    return vV(r, {
      ...e.data("settings"),
      ...t,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
function _V(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function RV(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function kV(t, e) {
  const n = e.value ? e.value + `
` : "", r = {};
  e.lang && (r.className = ["language-" + e.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (i.data = { meta: e.meta }), t.patch(e, i), i = t.applyData(e, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, t.patch(e, i), i;
}
function wV(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function DV(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const gg = PV(/[\dA-Za-z]/);
function PV(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function fs(t) {
  const e = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < t.length; ) {
    const s = t.charCodeAt(n);
    let a = "";
    if (s === 37 && gg(t.charCodeAt(n + 1)) && gg(t.charCodeAt(n + 2)))
      i = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (a = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const o = t.charCodeAt(n + 1);
      s < 56320 && o > 56319 && o < 57344 ? (a = String.fromCharCode(s, o), i = 1) : a = "ï¿½";
    } else
      a = String.fromCharCode(s);
    a && (e.push(t.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0);
  }
  return e.join("") + t.slice(r);
}
function OV(t, e) {
  const n = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", r = String(e.identifier).toUpperCase(), i = fs(r.toLowerCase()), s = t.footnoteOrder.indexOf(r);
  let a, o = t.footnoteCounts.get(r);
  o === void 0 ? (o = 0, t.footnoteOrder.push(r), a = t.footnoteOrder.length) : a = s + 1, o += 1, t.footnoteCounts.set(r, o);
  const u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  t.patch(e, u);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return t.patch(e, l), t.applyData(e, l);
}
function NV(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function MV(t, e) {
  if (t.options.allowDangerousHtml) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
}
function qS(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return [{ type: "text", value: "![" + e.alt + r }];
  const i = t.all(e), s = i[0];
  s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += r : i.push({ type: "text", value: r }), i;
}
function FV(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return qS(t, e);
  const i = { src: fs(r.url || ""), alt: e.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = { type: "element", tagName: "img", properties: i, children: [] };
  return t.patch(e, s), t.applyData(e, s);
}
function BV(t, e) {
  const n = { src: fs(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function UV(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function $V(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return qS(t, e);
  const i = { href: fs(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: i,
    children: t.all(e)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function HV(t, e) {
  const n = { href: fs(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function GV(t, e, n) {
  const r = t.all(e), i = n ? VV(n) : jS(e), s = {}, a = [];
  if (typeof e.checked == "boolean") {
    const c = r[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const c = r[o];
    (i || o !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const u = r[r.length - 1];
  u && (i || u.type !== "element" || u.tagName !== "p") && a.push({ type: "text", value: `
` });
  const l = { type: "element", tagName: "li", properties: s, children: a };
  return t.patch(e, l), t.applyData(e, l);
}
function VV(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = jS(n[r]);
  }
  return e;
}
function jS(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function zV(t, e) {
  const n = {}, r = t.all(e);
  let i = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++i < r.length; ) {
    const a = r[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function qV(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function jV(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function KV(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const KS = YS("end"), WS = YS("start");
function YS(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function WV(t) {
  const e = WS(t), n = KS(t);
  if (e && n)
    return { start: e, end: n };
}
function YV(t, e) {
  const n = t.all(e), r = n.shift(), i = [];
  if (r) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], a), i.push(a);
  }
  if (n.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, o = WS(e.children[1]), u = KS(e.children[e.children.length - 1]);
    o && u && (a.position = { start: o, end: u }), i.push(a);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(i, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function XV(t, e, n) {
  const r = n ? n.children : void 0, s = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, o = a ? a.length : e.children.length;
  let u = -1;
  const l = [];
  for (; ++u < o; ) {
    const d = e.children[u], f = {}, h = a ? a[u] : void 0;
    h && (f.align = h);
    let m = { type: "element", tagName: s, properties: f, children: [] };
    d && (m.children = t.all(d), t.patch(d, m), m = t.applyData(d, m)), l.push(m);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(l, !0)
  };
  return t.patch(e, c), t.applyData(e, c);
}
function QV(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const bg = 9, Eg = 32;
function ZV(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), i = 0;
  const s = [];
  for (; r; )
    s.push(
      yg(e.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(e);
  return s.push(yg(e.slice(i), i > 0, !1)), s.join("");
}
function yg(t, e, n) {
  let r = 0, i = t.length;
  if (e) {
    let s = t.codePointAt(r);
    for (; s === bg || s === Eg; )
      r++, s = t.codePointAt(r);
  }
  if (n) {
    let s = t.codePointAt(i - 1);
    for (; s === bg || s === Eg; )
      i--, s = t.codePointAt(i - 1);
  }
  return i > r ? t.slice(r, i) : "";
}
function JV(t, e) {
  const n = { type: "text", value: ZV(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function ez(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const tz = {
  blockquote: _V,
  break: RV,
  code: kV,
  delete: wV,
  emphasis: DV,
  footnoteReference: OV,
  heading: NV,
  html: MV,
  imageReference: FV,
  image: BV,
  inlineCode: UV,
  linkReference: $V,
  link: HV,
  listItem: GV,
  list: zV,
  paragraph: qV,
  // @ts-expect-error: root is different, but hard to type.
  root: jV,
  strong: KV,
  table: YV,
  tableCell: QV,
  tableRow: XV,
  text: JV,
  thematicBreak: ez,
  toml: Io,
  yaml: Io,
  definition: Io,
  footnoteDefinition: Io
};
function Io() {
}
function nz(t, e) {
  const n = [{ type: "text", value: "â†©" }];
  return e > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(e) }]
  }), n;
}
function rz(t, e) {
  return "Back to reference " + (t + 1) + (e > 1 ? "-" + e : "");
}
function iz(t) {
  const e = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", n = t.options.footnoteBackContent || nz, r = t.options.footnoteBackLabel || rz, i = t.options.footnoteLabel || "Footnotes", s = t.options.footnoteLabelTagName || "h2", a = t.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let u = -1;
  for (; ++u < t.footnoteOrder.length; ) {
    const l = t.footnoteById.get(
      t.footnoteOrder[u]
    );
    if (!l)
      continue;
    const c = t.all(l), d = String(l.identifier).toUpperCase(), f = fs(d.toLowerCase());
    let h = 0;
    const m = [], p = t.footnoteCounts.get(d);
    for (; p !== void 0 && ++h <= p; ) {
      m.length > 0 && m.push({ type: "text", value: " " });
      let y = typeof n == "string" ? n : n(u, h);
      typeof y == "string" && (y = { type: "text", value: y }), m.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + e + "fnref-" + f + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(u, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(y) ? y : [y]
      });
    }
    const g = c[c.length - 1];
    if (g && g.type === "element" && g.tagName === "p") {
      const y = g.children[g.children.length - 1];
      y && y.type === "text" ? y.value += " " : g.children.push({ type: "text", value: " " }), g.children.push(...m);
    } else
      c.push(...m);
    const E = {
      type: "element",
      tagName: "li",
      properties: { id: e + "fn-" + f },
      children: t.wrap(c, !0)
    };
    t.patch(l, E), o.push(E);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...Xi(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Fd = {}.hasOwnProperty, sz = {};
function az(t, e) {
  const n = e || sz, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = { ...tz, ...n.handlers }, o = {
    all: l,
    applyData: uz,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: a,
    one: u,
    options: n,
    patch: oz,
    wrap: cz
  };
  return tl(t, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? r : i, f = String(c.identifier).toUpperCase();
      d.has(f) || d.set(f, c);
    }
  }), o;
  function u(c, d) {
    const f = c.type, h = o.handlers[f];
    if (Fd.call(o.handlers, f) && h)
      return h(o, c, d);
    if (o.options.passThrough && o.options.passThrough.includes(f)) {
      if ("children" in c) {
        const { children: p, ...g } = c, E = Xi(g);
        return E.children = o.all(c), E;
      }
      return Xi(c);
    }
    return (o.options.unknownHandler || lz)(o, c, d);
  }
  function l(c) {
    const d = [];
    if ("children" in c) {
      const f = c.children;
      let h = -1;
      for (; ++h < f.length; ) {
        const m = o.one(f[h], c);
        if (m) {
          if (h && f[h - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = Tg(m.value)), !Array.isArray(m) && m.type === "element")) {
            const p = m.children[0];
            p && p.type === "text" && (p.value = Tg(p.value));
          }
          Array.isArray(m) ? d.push(...m) : d.push(m);
        }
      }
    }
    return d;
  }
}
function oz(t, e) {
  t.position && (e.position = WV(t));
}
function uz(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, i = t.data.hChildren, s = t.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const a = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: a };
      }
    n.type === "element" && s && Object.assign(n.properties, Xi(s)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function lz(t, e) {
  const n = e.data || {}, r = "value" in e && !(Fd.call(n, "hProperties") || Fd.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function cz(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Tg(t) {
  let e = 0, n = t.charCodeAt(e);
  for (; n === 9 || n === 32; )
    e++, n = t.charCodeAt(e);
  return t.slice(e);
}
function xg(t, e) {
  const n = az(t, e), r = n.one(t, void 0), i = iz(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && s.children.push({ type: "text", value: `
` }, i), s;
}
function dz(t, e) {
  return t && "run" in t ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      xg(n, { file: r, ...e })
    );
    await t.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      xg(n, { file: r, ...t || e })
    );
  };
}
function Sg(t) {
  if (t)
    throw t;
}
var Wo = Object.prototype.hasOwnProperty, XS = Object.prototype.toString, Ag = Object.defineProperty, vg = Object.getOwnPropertyDescriptor, Ig = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : XS.call(e) === "[object Array]";
}, Cg = function(e) {
  if (!e || XS.call(e) !== "[object Object]")
    return !1;
  var n = Wo.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Wo.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !r)
    return !1;
  var i;
  for (i in e)
    ;
  return typeof i > "u" || Wo.call(e, i);
}, Lg = function(e, n) {
  Ag && n.name === "__proto__" ? Ag(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, _g = function(e, n) {
  if (n === "__proto__")
    if (Wo.call(e, n)) {
      if (vg)
        return vg(e, n).value;
    } else return;
  return e[n];
}, fz = function t() {
  var e, n, r, i, s, a, o = arguments[0], u = 1, l = arguments.length, c = !1;
  for (typeof o == "boolean" && (c = o, o = arguments[1] || {}, u = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); u < l; ++u)
    if (e = arguments[u], e != null)
      for (n in e)
        r = _g(o, n), i = _g(e, n), o !== i && (c && i && (Cg(i) || (s = Ig(i))) ? (s ? (s = !1, a = r && Ig(r) ? r : []) : a = r && Cg(r) ? r : {}, Lg(o, { name: n, newValue: t(c, a, i) })) : typeof i < "u" && Lg(o, { name: n, newValue: i }));
  return o;
};
const dc = /* @__PURE__ */ $g(fz);
function Bd(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function hz() {
  const t = [], e = { run: n, use: r };
  return e;
  function n(...i) {
    let s = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    o(null, ...i);
    function o(u, ...l) {
      const c = t[++s];
      let d = -1;
      if (u) {
        a(u);
        return;
      }
      for (; ++d < i.length; )
        (l[d] === null || l[d] === void 0) && (l[d] = i[d]);
      i = l, c ? mz(c, o)(...l) : a(null, ...l);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return t.push(i), e;
  }
}
function mz(t, e) {
  let n;
  return r;
  function r(...a) {
    const o = t.length > a.length;
    let u;
    o && a.push(i);
    try {
      u = t.apply(this, a);
    } catch (l) {
      const c = (
        /** @type {Error} */
        l
      );
      if (o && n)
        throw c;
      return i(c);
    }
    o || (u && u.then && typeof u.then == "function" ? u.then(s, i) : u instanceof Error ? i(u) : s(u));
  }
  function i(a, ...o) {
    n || (n = !0, e(a, ...o));
  }
  function s(a) {
    i(null, a);
  }
}
function pz(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? Rg(t.position) : "start" in t || "end" in t ? Rg(t) : "line" in t || "column" in t ? Ud(t) : "";
}
function Ud(t) {
  return kg(t && t.line) + ":" + kg(t && t.column);
}
function Rg(t) {
  return Ud(t && t.start) + "-" + Ud(t && t.end);
}
function kg(t) {
  return t && typeof t == "number" ? t : 1;
}
class $t extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", s = {}, a = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof e == "string" ? i = e : !s.cause && e && (a = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? s.ruleId = r : (s.source = r.slice(0, u), s.ruleId = r.slice(u + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const u = s.ancestors[s.ancestors.length - 1];
      u && (s.place = u.position);
    }
    const o = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = o ? o.line : void 0, this.name = pz(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = a && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
$t.prototype.file = "";
$t.prototype.name = "";
$t.prototype.reason = "";
$t.prototype.message = "";
$t.prototype.stack = "";
$t.prototype.column = void 0;
$t.prototype.line = void 0;
$t.prototype.ancestors = void 0;
$t.prototype.cause = void 0;
$t.prototype.fatal = void 0;
$t.prototype.place = void 0;
$t.prototype.ruleId = void 0;
$t.prototype.source = void 0;
const An = { basename: gz, dirname: bz, extname: Ez, join: yz, sep: "/" };
function gz(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  Pa(t);
  let n = 0, r = -1, i = t.length, s;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; i--; )
      if (t.codePointAt(i) === 47) {
        if (s) {
          n = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let a = -1, o = e.length - 1;
  for (; i--; )
    if (t.codePointAt(i) === 47) {
      if (s) {
        n = i + 1;
        break;
      }
    } else
      a < 0 && (s = !0, a = i + 1), o > -1 && (t.codePointAt(i) === e.codePointAt(o--) ? o < 0 && (r = i) : (o = -1, r = a));
  return n === r ? r = a : r < 0 && (r = t.length), t.slice(n, r);
}
function bz(t) {
  if (Pa(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.codePointAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? t.codePointAt(0) === 47 ? "/" : "." : e === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, e);
}
function Ez(t) {
  Pa(t);
  let e = t.length, n = -1, r = 0, i = -1, s = 0, a;
  for (; e--; ) {
    const o = t.codePointAt(e);
    if (o === 47) {
      if (a) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (a = !0, n = e + 1), o === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === n - 1 && i === r + 1 ? "" : t.slice(i, n);
}
function yz(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    Pa(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : Tz(n);
}
function Tz(t) {
  Pa(t);
  const e = t.codePointAt(0) === 47;
  let n = xz(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.codePointAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function xz(t, e) {
  let n = "", r = 0, i = -1, s = 0, a = -1, o, u;
  for (; ++a <= t.length; ) {
    if (a < t.length)
      o = t.codePointAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(i === a - 1 || s === 1)) if (i !== a - 1 && s === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (u = n.lastIndexOf("/"), u !== n.length - 1) {
              u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), i = a, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = a, s = 0;
            continue;
          }
        }
        e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + t.slice(i + 1, a) : n = t.slice(i + 1, a), r = a - i - 1;
      i = a, s = 0;
    } else o === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Pa(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const Sz = { cwd: Az };
function Az() {
  return "/";
}
function $d(t) {
  return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && // @ts-expect-error: indexing is fine.
  t.auth === void 0);
}
function vz(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!$d(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return Iz(t);
}
function Iz(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.codePointAt(n) === 37 && e.codePointAt(n + 1) === 50) {
      const r = e.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const fc = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Cz {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? $d(e) ? n = { path: e } : typeof e == "string" || Lz(e) ? n = { value: e } : n = e : n = {}, this.cwd = "cwd" in n ? "" : Sz.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < fc.length; ) {
      const s = fc[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let i;
    for (i in n)
      fc.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? An.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    mc(e, "basename"), hc(e, "basename"), this.path = An.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? An.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    wg(this.basename, "dirname"), this.path = An.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? An.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (hc(e, "extname"), wg(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = An.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    $d(e) && (e = vz(e)), mc(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? An.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    mc(e, "stem"), hc(e, "stem"), this.path = An.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const i = this.message(e, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const i = this.message(e, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const i = new $t(
      // @ts-expect-error: the overloads are fine.
      e,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function hc(t, e) {
  if (t && t.includes(An.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + An.sep + "`"
    );
}
function mc(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function wg(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function Lz(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const _z = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(t) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[t], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), Rz = {}.hasOwnProperty;
class xh extends _z {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = hz();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new xh()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      e.use(...r);
    }
    return e.data(dc(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, n) {
    return typeof e == "string" ? arguments.length === 2 ? (bc("data", this.frozen), this.namespace[e] = n, this) : Rz.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (bc("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const n = Co(e), r = this.parser || this.Parser;
    return pc("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, n) {
    const r = this;
    return this.freeze(), pc("process", this.parser || this.Parser), gc("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(s, a) {
      const o = Co(e), u = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(u, o, function(c, d, f) {
        if (c || !d || !f)
          return l(c);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), m = r.stringify(h, f);
        Dz(m) ? f.value = m : f.result = m, l(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function l(c, d) {
        c || !d ? a(c) : s ? s(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let n = !1, r;
    return this.freeze(), pc("processSync", this.parser || this.Parser), gc("processSync", this.compiler || this.Compiler), this.process(e, i), Pg("processSync", "process", n), r;
    function i(s, a) {
      n = !0, Sg(s), r = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, n, r) {
    Dg(e), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s);
    function s(a, o) {
      const u = Co(n);
      i.run(e, u, l);
      function l(c, d, f) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || e
        );
        c ? o(c) : a ? a(h) : r(void 0, h, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, n) {
    let r = !1, i;
    return this.run(e, n, s), Pg("runSync", "run", r), i;
    function s(a, o) {
      Sg(a), i = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, n) {
    this.freeze();
    const r = Co(n), i = this.compiler || this.Compiler;
    return gc("stringify", i), Dg(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...n) {
    const r = this.attachers, i = this.namespace;
    if (bc("use", this.frozen), e != null) if (typeof e == "function")
      u(e, n);
    else if (typeof e == "object")
      Array.isArray(e) ? o(e) : a(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(l) {
      if (typeof l == "function")
        u(l, []);
      else if (typeof l == "object")
        if (Array.isArray(l)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            l
          );
          u(c, d);
        } else
          a(l);
      else
        throw new TypeError("Expected usable value, not `" + l + "`");
    }
    function a(l) {
      if (!("plugins" in l) && !("settings" in l))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(l.plugins), l.settings && (i.settings = dc(!0, i.settings, l.settings));
    }
    function o(l) {
      let c = -1;
      if (l != null) if (Array.isArray(l))
        for (; ++c < l.length; ) {
          const d = l[c];
          s(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + l + "`");
    }
    function u(l, c) {
      let d = -1, f = -1;
      for (; ++d < r.length; )
        if (r[d][0] === l) {
          f = d;
          break;
        }
      if (f === -1)
        r.push([l, ...c]);
      else if (c.length > 0) {
        let [h, ...m] = c;
        const p = r[f][1];
        Bd(p) && Bd(h) && (h = dc(!0, p, h)), r[f] = [l, h, ...m];
      }
    }
  }
}
const kz = new xh().freeze();
function pc(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `parser`");
}
function gc(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `compiler`");
}
function bc(t, e) {
  if (e)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Dg(t) {
  if (!Bd(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function Pg(t, e, n) {
  if (!n)
    throw new Error(
      "`" + t + "` finished async. Use `" + e + "` instead"
    );
}
function Co(t) {
  return wz(t) ? t : new Cz(t);
}
function wz(t) {
  return !!(t && typeof t == "object" && "message" in t && "messages" in t);
}
function Dz(t) {
  return typeof t == "string" || Pz(t);
}
function Pz(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
var QS = { exports: {} }, _s = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Og;
function Oz() {
  if (Og)
    return _s;
  Og = 1;
  var t = $, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, u, l) {
    var c, d = {}, f = null, h = null;
    l !== void 0 && (f = "" + l), u.key !== void 0 && (f = "" + u.key), u.ref !== void 0 && (h = u.ref);
    for (c in u)
      r.call(u, c) && !s.hasOwnProperty(c) && (d[c] = u[c]);
    if (o && o.defaultProps)
      for (c in u = o.defaultProps, u)
        d[c] === void 0 && (d[c] = u[c]);
    return { $$typeof: e, type: o, key: f, ref: h, props: d, _owner: i.current };
  }
  return _s.Fragment = n, _s.jsx = a, _s.jsxs = a, _s;
}
QS.exports = Oz();
var Nz = QS.exports;
async function Mz(t) {
  const e = await kz().use(LV).use(xH).use(dz, { allowDangerousHtml: !0 }).use(PB).use(j9).processSync(t);
  return String(e);
}
function Fz(t) {
  const [e, n] = $.useState("");
  return $.useEffect(() => {
    (async () => {
      const r = await Mz(t);
      n(r);
    })();
  }, [t]), { html: e, jsx: /* @__PURE__ */ Nz.jsx("div", { dangerouslySetInnerHTML: { __html: e } }) };
}
const Bz = ({
  body: t,
  stringLength: e,
  type: n = "content"
}) => {
  const { state: r } = $n(gn), { activeLanguages: i, searchActiveMatch: s, searchString: a } = r;
  let o = String(t.value);
  n == "snippet" && (o = M8({
    searchString: a,
    content: o,
    stringLength: e
  }));
  let u;
  const l = Fz(o);
  if (t.format === "text/plain") {
    const p = /\n/g;
    u = o == null ? void 0 : o.replace(p, "<br />");
  }
  if (t.format === "text/markdown" && (u = l == null ? void 0 : l.html), t.format === "text/html" && (u = o), String(a) && u) {
    let p = 1;
    const g = new RegExp(`(${a})`, "gi");
    u = u == null ? void 0 : u.replace(g, (E) => {
      const y = `${t.id}/${p}`, T = s === y;
      return p += 1, `<span class="clover-scroll-highlight${T ? " active" : ""}" data-index="${y}">${E}</span>`;
    });
  }
  const c = [t.id, n].join("-"), d = Y6(String(t.language)) === "RTL", f = d ? "rtl" : "ltr", h = d ? "1.3em" : "1em", m = String(t.language);
  return lt(() => {
    if (s) {
      const p = document.querySelector(
        `[data-index="${s}"]`
      );
      p && p.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "center"
      });
    }
  }, [s]), u ? /* @__PURE__ */ $.createElement(
    N8,
    {
      dangerouslySetInnerHTML: { __html: u },
      "data-active-language": !(i != null && i.length) || (i == null ? void 0 : i.includes(m)),
      "data-body-id": c,
      "data-testid": "scroll-item-body",
      id: c,
      dir: f,
      css: { fontSize: h },
      lang: m
    }
  ) : null;
}, Uz = ({
  hasItemBreak: t,
  isLastItem: e,
  item: n,
  itemCount: r,
  itemNumber: i
}) => {
  var C;
  const { state: s } = $.useContext(gn), { activeLanguages: a, annotations: o, vault: u, options: l } = s, d = (l.figure || {}).width || ((C = Cn.options.figure) == null ? void 0 : C.width) || "38.2%", f = u == null ? void 0 : u.get(n), h = (o == null ? void 0 : o.filter((D) => {
    var _, A;
    return ((A = (_ = D.target) == null ? void 0 : _.source) == null ? void 0 : A.id) === n.id;
  })) || [], m = (D) => {
    const { language: _ } = D;
    if (_)
      return Array.isArray(_) ? _[0] : String(_);
  }, p = h.reduce(
    (D, _) => {
      var A;
      return (A = _ == null ? void 0 : _.body) == null || A.forEach((L) => {
        const N = L;
        if (!N) return;
        const U = m(N), z = U || "__undefined__";
        D[z] || (D[z] = {
          label: U,
          bodies: []
        }), D[z].bodies.push(N);
      }), D;
    },
    {}
  ), g = Object.keys(p), S = (!!(a != null && a.length) ? g.filter((D) => {
    const _ = p[D].label;
    return _ ? a == null ? void 0 : a.includes(_) : !1;
  }) : g).map((D) => {
    const _ = p[D];
    if (!_) return null;
    const A = _.label || "Unspecified", L = _.label ? _.label : void 0;
    return /* @__PURE__ */ $.createElement(
      FP,
      {
        key: D,
        "data-language": A,
        lang: L
      },
      _.bodies.map((N, U) => /* @__PURE__ */ $.createElement(
        Bz,
        {
          body: N,
          key: `${N.id || D}-${U}`
        }
      ))
    );
  }).filter(
    (D) => !!D
  ), v = S.length || 1, I = {
    current: i,
    total: r
  };
  return /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    NP,
    {
      "data-page-break": t,
      "data-page-number": i,
      "data-last-item": e
    },
    /* @__PURE__ */ $.createElement(
      tT,
      {
        css: {
          width: d
        },
        "data-width": d
      },
      f && /* @__PURE__ */ $.createElement(O8, { canvas: f, canvasInfo: I })
    ),
    /* @__PURE__ */ $.createElement(MP, null, /* @__PURE__ */ $.createElement(
      "div",
      {
        style: { "--num-items": v },
        "data-columns": v,
        "data-testid": "scroll-item-language-columns"
      },
      S.length ? S : /* @__PURE__ */ $.createElement("p", null, "[Blank]")
    ))
  ), t && /* @__PURE__ */ $.createElement(BP, { "aria-label": "Page Break" }));
}, $z = $.memo(Uz), Hz = ({
  children: t,
  rootMargin: e = "100px",
  attributes: n = {},
  isVisibleCallback: r = () => {
  }
}) => {
  const i = Ji(null), [s, a] = sn(!1);
  return lt(() => {
    const o = i.current;
    if (!o) return;
    const u = new IntersectionObserver(
      ([l]) => {
        l.isIntersecting && (r(!0), a(!0), u.disconnect());
      },
      { rootMargin: e }
    );
    return u.observe(o), () => u.disconnect();
  }, [i]), /* @__PURE__ */ $.createElement("div", { ref: i, ...n }, s ? t : null);
}, Gz = ({ items: t }) => /* @__PURE__ */ $.createElement(UP, null, t.map((e, n) => {
  const r = n + 1, i = r === t.length;
  return /* @__PURE__ */ $.createElement(Hz, { key: n }, /* @__PURE__ */ $.createElement(
    $z,
    {
      item: e,
      hasItemBreak: r < t.length,
      isLastItem: i,
      key: e.id,
      itemCount: t.length,
      itemNumber: r
    }
  ));
})), Vz = (t, e, n) => {
  const [r, i] = sn([]);
  return lt(() => {
    if (!e) return;
    const s = [];
    t == null || t.forEach((u) => {
      var c;
      const l = e.get(u);
      (c = l == null ? void 0 : l.annotations) == null || c.forEach(
        (d) => {
          var h;
          const f = e.get(d);
          (h = f == null ? void 0 : f.items) == null || h.forEach(
            (m) => {
              var g;
              const p = e.get(m);
              p && s.push({
                ...p,
                body: (g = p == null ? void 0 : p.body) == null ? void 0 : g.map((E) => e.get(E))
              });
            }
          );
        }
      );
    });
    const a = s.reduce(
      (u, l) => (u.some((c) => c.id === l.id) || u.push(l), u),
      []
    ), o = J6(
      a,
      n
    );
    i(o);
  }, [t, e, n]), r;
}, zz = ({ iiifContent: t }) => {
  var c;
  const [e, n] = sn(), [r, i] = sn(!1), { state: s, dispatch: a } = $n(gn), { options: o, vault: u } = s, l = Vz(
    e == null ? void 0 : e.items,
    u,
    (c = o == null ? void 0 : o.annotations) == null ? void 0 : c.motivations
  );
  return lt(() => {
    u && u.load(t).then((d) => d && n(d)).catch(
      (d) => console.error(`Manifest ${t} failed to load: ${d}`)
    );
  }, [t]), lt(() => {
    var h;
    const d = Gy(l), f = d.length ? ((h = o == null ? void 0 : o.language) == null ? void 0 : h.defaultLanguages) || d : [];
    i(!!d.length), a({
      type: "updateAnnotations",
      payload: l
    }), a({
      type: "updateActiveLanguages",
      payload: f
    });
  }, [l]), e ? /* @__PURE__ */ $.createElement(Lk, null, e && /* @__PURE__ */ $.createElement($.Fragment, null, /* @__PURE__ */ $.createElement(
    OP,
    {
      label: e == null ? void 0 : e.label,
      hasDefinedLanguages: r
    }
  ), /* @__PURE__ */ $.createElement(Gz, { items: e.items }))) : null;
}, wq = ({
  iiifContent: t,
  options: e
}) => /* @__PURE__ */ $.createElement(o2, { options: e }, /* @__PURE__ */ $.createElement(zz, { iiifContent: t }));
export {
  wq as default
};
