"use client";
import * as M from "./react-shim.mjs";
import v, { useReducer as OA, useEffect as Se, Component as NA, createElement as qt, createContext as du, useState as Be, useRef as ms, useCallback as yt, useContext as z1, cloneElement as Af, Fragment as q1, useMemo as fu, useLayoutEffect as W1, forwardRef as ci, Children as Ys, isValidElement as hu } from "./react-shim.mjs";
import { Vault as K1 } from "@iiif/helpers/vault";
import { decodeContentState as MA, getVisibleCanvasesFromCanvasId as FA, encodeContentState as BA, getManifestSequence as $A } from "@iiif/helpers";
import { jsx as ee, jsxs as es, Fragment as If } from "react/jsx-runtime";
import * as Yu from "./react-dom-shim.mjs";
import UA from "./react-dom-shim.mjs";
import { initReactI18next as HA, useTranslation as VA } from "react-i18next";
import GA from "i18next-browser-languagedetector";
import Gs from "i18next";
import { getThumbnail as zA } from "@iiif/helpers/thumbnail";
import zs from "openseadragon";
import { convertPresentation2 as qA } from "@iiif/parser/presentation-2";
const WA = (t) => {
  const e = t.toString().split(":"), n = Math.ceil(parseInt(e[0])), r = Math.ceil(parseInt(e[1])), i = KA(Math.ceil(parseInt(e[2])), 2);
  let a = `${n !== 0 && r < 10 ? (r + "").padStart(2, "0") : r}:${i}`;
  return n !== 0 && (a = `${n}:${a}`), a;
}, j1 = (t) => {
  const e = new Date(t * 1e3).toISOString().substr(11, 8);
  return WA(e);
}, Y1 = (t, e) => {
  if (typeof t != "object" || t === null)
    return e;
  for (const n in e)
    typeof e[n] == "object" && e[n] !== null && !Array.isArray(e[n]) ? (t[n] || (t[n] = {}), t[n] = Y1(t[n], e[n])) : t[n] = e[n];
  return t;
}, X1 = (t) => t.split("").reduce(function(e, n) {
  return e = (e << 5) - e + n.charCodeAt(0), e & e;
}, 0), Q1 = (t, e) => Object.hasOwn(t, e) ? t[e].toString() : void 0, KA = (t, e) => String(t).padStart(e, "0");
let Qa;
const jA = new Uint8Array(16);
function YA() {
  if (!Qa && (Qa = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Qa))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Qa(jA);
}
const Ct = [];
for (let t = 0; t < 256; ++t)
  Ct.push((t + 256).toString(16).slice(1));
function XA(t, e = 0) {
  return Ct[t[e + 0]] + Ct[t[e + 1]] + Ct[t[e + 2]] + Ct[t[e + 3]] + "-" + Ct[t[e + 4]] + Ct[t[e + 5]] + "-" + Ct[t[e + 6]] + Ct[t[e + 7]] + "-" + Ct[t[e + 8]] + Ct[t[e + 9]] + "-" + Ct[t[e + 10]] + Ct[t[e + 11]] + Ct[t[e + 12]] + Ct[t[e + 13]] + Ct[t[e + 14]] + Ct[t[e + 15]];
}
const QA = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), x0 = {
  randomUUID: QA
};
function ts(t, e, n) {
  if (x0.randomUUID && !t)
    return x0.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || YA)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, XA(r);
}
const Z1 = {
  behavior: "smooth",
  block: "center"
}, In = {
  annotationOverlays: {
    backgroundColor: "#6666ff",
    borderColor: "#000099",
    borderType: "solid",
    borderWidth: "1px",
    opacity: "0.5",
    renderOverlays: !0,
    zoomLevel: 2
  },
  annotations: {
    motivations: void 0
  },
  background: "transparent",
  canvasBackgroundColor: "#6662",
  canvasHeight: "500px",
  contentSearch: {
    searchResultsLimit: 20,
    overlays: {
      backgroundColor: "#ff6666",
      borderColor: "#990000",
      borderType: "solid",
      borderWidth: "1px",
      opacity: "0.5",
      renderOverlays: !0,
      zoomLevel: 4
    }
  },
  crossOrigin: "anonymous",
  ignoreCaptionLabels: [],
  informationPanel: {
    vtt: {
      autoScroll: {
        enabled: !0,
        settings: Z1
      }
    },
    open: !0,
    renderAbout: !0,
    renderSupplementing: !0,
    renderToggle: !0,
    renderAnnotation: !0,
    renderContentSearch: !0
  },
  openSeadragon: {},
  requestHeaders: { "Content-Type": "application/json" },
  showDownload: !0,
  showIIIFBadge: !0,
  showTitle: !0,
  withCredentials: !1
}, Cf = (t = In) => Qc(t);
function Qc(t) {
  return Array.isArray(t) ? t.map((e) => Qc(e)) : t && typeof t == "object" ? Object.entries(t).reduce(
    (e, [n, r]) => (e[n] = Qc(r), e),
    {}
  ) : t;
}
function J1(t) {
  const n = (() => {
    var a, o;
    return ((o = (a = In == null ? void 0 : In.informationPanel) == null ? void 0 : a.vtt) == null ? void 0 : o.autoScroll) || {
      enabled: !0,
      settings: Z1
    };
  })();
  if (t == null)
    return {
      enabled: n.enabled,
      settings: { ...n.settings }
    };
  if (typeof t == "boolean")
    return {
      enabled: t,
      settings: { ...n.settings }
    };
  if ("enabled" in t) {
    const s = t;
    return {
      enabled: s.enabled,
      settings: { ...s.settings }
    };
  }
  const i = {
    enabled: !0,
    settings: { ...t }
  };
  return ZA(i.settings), i;
}
function ZA({ behavior: t, block: e }) {
  const n = ["auto", "instant", "smooth"], r = ["center", "end", "nearest", "start"];
  if (!n.includes(t))
    throw TypeError(`'${t}' not in ${n.join(" | ")}`);
  if (!r.includes(e))
    throw TypeError(`'${e}' not in ${r.join(" | ")}`);
}
var V1, G1;
const JA = J1(
  (G1 = (V1 = In == null ? void 0 : In.informationPanel) == null ? void 0 : V1.vtt) == null ? void 0 : G1.autoScroll
), eb = () => {
  var t;
  return {
    activeCanvas: "",
    activeManifest: "",
    activePlayer: null,
    activeSelector: void 0,
    OSDImageLoaded: !1,
    collection: {},
    configOptions: Cf(),
    customDisplays: [],
    plugins: [],
    isAutoScrollEnabled: JA.enabled,
    isAutoScrolling: !1,
    // Respect explicit false; default to true only when undefined
    isInformationOpen: ((t = In == null ? void 0 : In.informationPanel) == null ? void 0 : t.open) ?? !0,
    isLoaded: !1,
    isPaged: !1,
    isUserScrolling: void 0,
    sequence: [[], []],
    vault: new K1(),
    viewingDirection: "left-to-right",
    openSeadragonViewer: null,
    viewerId: ts(),
    visibleCanvases: [],
    visibleAnnotations: []
  };
}, Lf = eb(), tb = v.createContext(Lf), nb = v.createContext(Lf);
function eI(t, e) {
  switch (e.type) {
    case "updateActiveCanvas":
      return e.canvasId || (e.canvasId = ""), {
        ...t,
        activeCanvas: e.canvasId
      };
    case "updateActiveManifest":
      return {
        ...t,
        activeManifest: e.manifestId
      };
    case "updateActivePlayer":
      return {
        ...t,
        activePlayer: e.player
      };
    case "updateOSDImageLoaded":
      return {
        ...t,
        OSDImageLoaded: e.OSDImageLoaded
      };
    case "updateAutoScrollAnnotationEnabled":
      return {
        ...t,
        isAutoScrollEnabled: e.isAutoScrollEnabled
      };
    case "updateAutoScrolling":
      return {
        ...t,
        isAutoScrolling: e.isAutoScrolling
      };
    case "updateCollection":
      return {
        ...t,
        collection: e.collection
      };
    case "updateConfigOptions": {
      const n = Y1(
        Cf(t.configOptions),
        e.configOptions
      );
      return {
        ...t,
        configOptions: n
      };
    }
    case "updateContentStateAnnotation":
      return {
        ...t,
        contentStateAnnotation: e.contentStateAnnotation
      };
    case "updateInformationOpen":
      return {
        ...t,
        isInformationOpen: e.isInformationOpen
      };
    case "updateInformationPanelResource":
      return {
        ...t,
        informationPanelResource: e.informationPanelResource
      };
    case "updateIsLoaded":
      return {
        ...t,
        isLoaded: e.isLoaded
      };
    case "updateManifestSequence":
      return {
        ...t,
        sequence: e.sequence
      };
    case "updateUserScrolling":
      return {
        ...t,
        isUserScrolling: e.isUserScrolling
      };
    case "updateOpenSeadragonViewer":
      return {
        ...t,
        openSeadragonViewer: e.openSeadragonViewer
      };
    case "updateViewerId":
      return {
        ...t,
        viewerId: e.viewerId
      };
    case "updateActiveSelector":
      return {
        ...t,
        activeSelector: e.selector
      };
    case "updateVisibleCanvases":
      return {
        ...t,
        visibleCanvases: e.visibleCanvases
      };
    case "updateViewingDirection":
      return {
        ...t,
        viewingDirection: e.viewingDirection
      };
    case "updateIsPaged":
      return {
        ...t,
        isPaged: e.isPaged
      };
    default:
      throw new Error(`Unhandled action type: ${e.type}`);
  }
}
const tI = ({
  initialState: t,
  children: e
}) => {
  const [n, r] = OA(
    eI,
    t,
    (s) => s ? {
      ...s,
      configOptions: Cf(
        s.configOptions ?? In
      ),
      viewerId: s.viewerId ?? ts()
    } : eb()
  ), { openSeadragonViewer: i } = n;
  return Se(() => {
    if (i)
      return i.addHandler("update-viewport", () => {
        const s = i.viewport, a = s.getBounds(), o = s.viewportToImageRectangle(a), l = `xywh=${[
          Math.round(o.x),
          Math.round(o.y),
          Math.round(o.width),
          Math.round(o.height)
        ].join(",")}`;
        r({
          type: "updateActiveSelector",
          // @ts-ignore
          selector: {
            type: "FragmentSelector",
            value: l
          }
        });
      }), () => {
        i.removeAllHandlers("update-viewport");
      };
  }, [i]), /* @__PURE__ */ v.createElement(tb.Provider, { value: n }, /* @__PURE__ */ v.createElement(
    nb.Provider,
    {
      value: r
    },
    e
  ));
};
function st() {
  const t = v.useContext(tb);
  if (t === void 0)
    throw new Error("useViewerState must be used within a ViewerProvider");
  return t;
}
function jt() {
  const t = v.useContext(nb);
  if (t === void 0)
    throw new Error("useViewerDispatch must be used within a ViewerProvider");
  return t;
}
function Oe(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (t == null || t(i), n === !1 || !i.defaultPrevented)
      return e == null ? void 0 : e(i);
  };
}
function jn(t, e = []) {
  let n = [];
  function r(s, a) {
    const o = M.createContext(a), u = n.length;
    n = [...n, a];
    const l = (d) => {
      var b;
      const { scope: f, children: h, ...m } = d, p = ((b = f == null ? void 0 : f[t]) == null ? void 0 : b[u]) || o, g = M.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ ee(p.Provider, { value: g, children: h });
    };
    l.displayName = s + "Provider";
    function c(d, f) {
      var p;
      const h = ((p = f == null ? void 0 : f[t]) == null ? void 0 : p[u]) || o, m = M.useContext(h);
      if (m) return m;
      if (a !== void 0) return a;
      throw new Error(`\`${d}\` must be used within \`${s}\``);
    }
    return [l, c];
  }
  const i = () => {
    const s = n.map((a) => M.createContext(a));
    return function(o) {
      const u = (o == null ? void 0 : o[t]) || s;
      return M.useMemo(
        () => ({ [`__scope${t}`]: { ...o, [t]: u } }),
        [o, u]
      );
    };
  };
  return i.scopeName = t, [r, nI(i, ...e)];
}
function nI(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const a = r.reduce((o, { useScope: u, scopeName: l }) => {
        const d = u(s)[`__scope${l}`];
        return { ...o, ...d };
      }, {});
      return M.useMemo(() => ({ [`__scope${e.scopeName}`]: a }), [a]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var wt = globalThis != null && globalThis.document ? M.useLayoutEffect : () => {
}, rI = M[" useInsertionEffect ".trim().toString()] || wt;
function kr({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  },
  caller: r
}) {
  const [i, s, a] = iI({
    defaultProp: e,
    onChange: n
  }), o = t !== void 0, u = o ? t : i;
  {
    const c = M.useRef(t !== void 0);
    M.useEffect(() => {
      const d = c.current;
      d !== o && console.warn(
        `${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${o ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), c.current = o;
    }, [o, r]);
  }
  const l = M.useCallback(
    (c) => {
      var d;
      if (o) {
        const f = sI(c) ? c(t) : c;
        f !== t && ((d = a.current) == null || d.call(a, f));
      } else
        s(c);
    },
    [o, t, s, a]
  );
  return [u, l];
}
function iI({
  defaultProp: t,
  onChange: e
}) {
  const [n, r] = M.useState(t), i = M.useRef(n), s = M.useRef(e);
  return rI(() => {
    s.current = e;
  }, [e]), M.useEffect(() => {
    var a;
    i.current !== n && ((a = s.current) == null || a.call(s, n), i.current = n);
  }, [n, i]), [n, r, s];
}
function sI(t) {
  return typeof t == "function";
}
function v0(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function rb(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((i) => {
      const s = v0(i, e);
      return !n && typeof s == "function" && (n = !0), s;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : v0(t[i], null);
        }
      };
  };
}
function Je(...t) {
  return M.useCallback(rb(...t), t);
}
// @__NO_SIDE_EFFECTS__
function ua(t) {
  const e = /* @__PURE__ */ aI(t), n = M.forwardRef((r, i) => {
    const { children: s, ...a } = r, o = M.Children.toArray(s), u = o.find(uI);
    if (u) {
      const l = u.props.children, c = o.map((d) => d === u ? M.Children.count(l) > 1 ? M.Children.only(null) : M.isValidElement(l) ? l.props.children : null : d);
      return /* @__PURE__ */ ee(e, { ...a, ref: i, children: M.isValidElement(l) ? M.cloneElement(l, void 0, c) : null });
    }
    return /* @__PURE__ */ ee(e, { ...a, ref: i, children: s });
  });
  return n.displayName = `${t}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function aI(t) {
  const e = M.forwardRef((n, r) => {
    const { children: i, ...s } = n;
    if (M.isValidElement(i)) {
      const a = cI(i), o = lI(s, i.props);
      return i.type !== M.Fragment && (o.ref = r ? rb(r, a) : a), M.cloneElement(i, o);
    }
    return M.Children.count(i) > 1 ? M.Children.only(null) : null;
  });
  return e.displayName = `${t}.SlotClone`, e;
}
var oI = Symbol("radix.slottable");
function uI(t) {
  return M.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === oI;
}
function lI(t, e) {
  const n = { ...e };
  for (const r in e) {
    const i = t[r], s = e[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...o) => {
      const u = s(...o);
      return i(...o), u;
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...s } : r === "className" && (n[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function cI(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var dI = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], $e = dI.reduce((t, e) => {
  const n = /* @__PURE__ */ ua(`Primitive.${e}`), r = M.forwardRef((i, s) => {
    const { asChild: a, ...o } = i, u = a ? n : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ ee(u, { ...o, ref: s });
  });
  return r.displayName = `Primitive.${e}`, { ...t, [e]: r };
}, {});
function fI(t, e) {
  t && Yu.flushSync(() => t.dispatchEvent(e));
}
function hI(t, e) {
  return M.useReducer((n, r) => e[n][r] ?? n, t);
}
var Da = (t) => {
  const { present: e, children: n } = t, r = mI(e), i = typeof n == "function" ? n({ present: r.isPresent }) : M.Children.only(n), s = Je(r.ref, pI(i));
  return typeof n == "function" || r.isPresent ? M.cloneElement(i, { ref: s }) : null;
};
Da.displayName = "Presence";
function mI(t) {
  const [e, n] = M.useState(), r = M.useRef(null), i = M.useRef(t), s = M.useRef("none"), a = t ? "mounted" : "unmounted", [o, u] = hI(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return M.useEffect(() => {
    const l = Za(r.current);
    s.current = o === "mounted" ? l : "none";
  }, [o]), wt(() => {
    const l = r.current, c = i.current;
    if (c !== t) {
      const f = s.current, h = Za(l);
      t ? u("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? u("UNMOUNT") : u(c && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), i.current = t;
    }
  }, [t, u]), wt(() => {
    if (e) {
      let l;
      const c = e.ownerDocument.defaultView ?? window, d = (h) => {
        const p = Za(r.current).includes(CSS.escape(h.animationName));
        if (h.target === e && p && (u("ANIMATION_END"), !i.current)) {
          const g = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", l = c.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = g);
          });
        }
      }, f = (h) => {
        h.target === e && (s.current = Za(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        c.clearTimeout(l), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      u("ANIMATION_END");
  }, [e, u]), {
    isPresent: ["mounted", "unmountSuspended"].includes(o),
    ref: M.useCallback((l) => {
      r.current = l ? getComputedStyle(l) : null, n(l);
    }, [])
  };
}
function Za(t) {
  return (t == null ? void 0 : t.animationName) || "none";
}
function pI(t) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : r.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = (i = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : i.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var gI = M[" useId ".trim().toString()] || (() => {
}), bI = 0;
function di(t) {
  const [e, n] = M.useState(gI());
  return wt(() => {
    n((r) => r ?? String(bI++));
  }, [t]), t || (e ? `radix-${e}` : "");
}
var Xu = "Collapsible", [EI] = jn(Xu), [yI, _f] = EI(Xu), ib = M.forwardRef(
  (t, e) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: i,
      disabled: s,
      onOpenChange: a,
      ...o
    } = t, [u, l] = kr({
      prop: r,
      defaultProp: i ?? !1,
      onChange: a,
      caller: Xu
    });
    return /* @__PURE__ */ ee(
      yI,
      {
        scope: n,
        disabled: s,
        contentId: di(),
        open: u,
        onOpenToggle: M.useCallback(() => l((c) => !c), [l]),
        children: /* @__PURE__ */ ee(
          $e.div,
          {
            "data-state": wf(u),
            "data-disabled": s ? "" : void 0,
            ...o,
            ref: e
          }
        )
      }
    );
  }
);
ib.displayName = Xu;
var sb = "CollapsibleTrigger", TI = M.forwardRef(
  (t, e) => {
    const { __scopeCollapsible: n, ...r } = t, i = _f(sb, n);
    return /* @__PURE__ */ ee(
      $e.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": wf(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...r,
        ref: e,
        onClick: Oe(t.onClick, i.onOpenToggle)
      }
    );
  }
);
TI.displayName = sb;
var Rf = "CollapsibleContent", SI = M.forwardRef(
  (t, e) => {
    const { forceMount: n, ...r } = t, i = _f(Rf, t.__scopeCollapsible);
    return /* @__PURE__ */ ee(Da, { present: n || i.open, children: ({ present: s }) => /* @__PURE__ */ ee(xI, { ...r, ref: e, present: s }) });
  }
);
SI.displayName = Rf;
var xI = M.forwardRef((t, e) => {
  const { __scopeCollapsible: n, present: r, children: i, ...s } = t, a = _f(Rf, n), [o, u] = M.useState(r), l = M.useRef(null), c = Je(e, l), d = M.useRef(0), f = d.current, h = M.useRef(0), m = h.current, p = a.open || o, g = M.useRef(p), b = M.useRef(void 0);
  return M.useEffect(() => {
    const y = requestAnimationFrame(() => g.current = !1);
    return () => cancelAnimationFrame(y);
  }, []), wt(() => {
    const y = l.current;
    if (y) {
      b.current = b.current || {
        transitionDuration: y.style.transitionDuration,
        animationName: y.style.animationName
      }, y.style.transitionDuration = "0s", y.style.animationName = "none";
      const T = y.getBoundingClientRect();
      d.current = T.height, h.current = T.width, g.current || (y.style.transitionDuration = b.current.transitionDuration, y.style.animationName = b.current.animationName), u(r);
    }
  }, [a.open, r]), /* @__PURE__ */ ee(
    $e.div,
    {
      "data-state": wf(a.open),
      "data-disabled": a.disabled ? "" : void 0,
      id: a.contentId,
      hidden: !p,
      ...s,
      ref: c,
      style: {
        "--radix-collapsible-content-height": f ? `${f}px` : void 0,
        "--radix-collapsible-content-width": m ? `${m}px` : void 0,
        ...t.style
      },
      children: p && i
    }
  );
});
function wf(t) {
  return t ? "open" : "closed";
}
var vI = ib;
const AI = async (t, e) => {
  const n = t.get({
    id: e,
    type: "Canvas"
  });
  if (!(n != null && n.annotations) || !n.annotations[0]) return [];
  const i = t.get(n.annotations).filter((a) => a.items ? a : !1), s = [];
  for (const a of i)
    if (a.items.length > 0) {
      const o = a.label || { none: ["Annotations"] };
      s.push({ ...a, label: o });
    } else {
      let o = {};
      try {
        o = await t.load(a.id);
      } catch (u) {
        console.log(u);
      }
      if (o.items && o.items.length > 0) {
        const u = o.label || {
          none: ["Annotations"]
        };
        s.push({ ...o, label: u });
      }
    }
  return s;
}, ab = async (t, e, n) => {
  try {
    if (n == null || n.q == null)
      return {};
    const r = n.q.trim(), i = new URL(e);
    return i.searchParams.set("q", r), await t.load(i.toString());
  } catch (r) {
    return console.warn("Error in getContentSearchResources:", r), {};
  }
}, ob = (t, e, n, r) => {
  var a, o;
  const i = {
    canvas: void 0,
    accompanyingCanvas: void 0,
    annotationPage: void 0,
    annotations: []
  }, s = (u) => {
    if (u) {
      if (!u.body || !u.motivation) {
        console.error(
          "Invalid annotation after Hyperion parsing: missing either 'body' or 'motivation'",
          u
        );
        return;
      }
      let l = u.body;
      Array.isArray(l) && (l = l[0]);
      const c = t.get(l.id);
      if (!c) return;
      switch (n) {
        case "painting":
          return u.target === e.id && u.motivation && u.motivation[0] === "painting" && r.includes(c.type) && (u.body = c), !!u;
        case "supplementing":
          return;
        default:
          throw new Error("Invalid annotation motivation.");
      }
    }
  };
  if (i.canvas = t.get(e), i.canvas && (i.annotationPage = t.get(i.canvas.items[0]), i.accompanyingCanvas = (a = i.canvas) != null && a.accompanyingCanvas ? t.get((o = i.canvas) == null ? void 0 : o.accompanyingCanvas) : void 0), i.annotationPage) {
    const u = t.get(i.annotationPage.items).map((c) => ({
      body: t.get(c.body[0].id),
      motivation: c.motivation,
      type: "Annotation"
    })), l = [];
    u.forEach((c) => {
      c.body.type === "Choice" ? c.body.items.forEach(
        (d) => l.push({
          ...c,
          id: d.id,
          body: t.get(d.id)
        })
      ) : l.push(c);
    }), i.annotations = l.filter(s);
  }
  return i;
}, kf = (t, e = "en") => {
  if (!t) return "";
  if (!t[e]) {
    const n = Object.getOwnPropertyNames(t);
    if (n.length > 0) return t[n[0]];
  }
  return t[e];
}, Dr = (t, e) => {
  const n = ob(
    t,
    { id: e, type: "Canvas" },
    "painting",
    ["Image", "Sound", "Video"]
  );
  if (n.annotations.length !== 0 && n.annotations && n.annotations)
    return n.annotations.map(
      (r) => r == null ? void 0 : r.body
    );
}, II = du(null), Bl = {
  didCatch: !1,
  error: null
};
class Df extends NA {
  constructor(e) {
    super(e), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = Bl;
  }
  static getDerivedStateFromError(e) {
    return {
      didCatch: !0,
      error: e
    };
  }
  resetErrorBoundary() {
    const {
      error: e
    } = this.state;
    if (e !== null) {
      for (var n, r, i = arguments.length, s = new Array(i), a = 0; a < i; a++)
        s[a] = arguments[a];
      (n = (r = this.props).onReset) === null || n === void 0 || n.call(r, {
        args: s,
        reason: "imperative-api"
      }), this.setState(Bl);
    }
  }
  componentDidCatch(e, n) {
    var r, i;
    (r = (i = this.props).onError) === null || r === void 0 || r.call(i, e, n);
  }
  componentDidUpdate(e, n) {
    const {
      didCatch: r
    } = this.state, {
      resetKeys: i
    } = this.props;
    if (r && n.error !== null && CI(e.resetKeys, i)) {
      var s, a;
      (s = (a = this.props).onReset) === null || s === void 0 || s.call(a, {
        next: i,
        prev: e.resetKeys,
        reason: "keys"
      }), this.setState(Bl);
    }
  }
  render() {
    const {
      children: e,
      fallbackRender: n,
      FallbackComponent: r,
      fallback: i
    } = this.props, {
      didCatch: s,
      error: a
    } = this.state;
    let o = e;
    if (s) {
      const u = {
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof n == "function")
        o = n(u);
      else if (r)
        o = qt(r, u);
      else if (i !== void 0)
        o = i;
      else
        throw a;
    }
    return qt(II.Provider, {
      value: {
        didCatch: s,
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, o);
  }
}
function CI() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return t.length !== e.length || t.some((n, r) => !Object.is(n, e[r]));
}
var je = "colors", Nt = "sizes", ge = "space", LI = { gap: ge, gridGap: ge, columnGap: ge, gridColumnGap: ge, rowGap: ge, gridRowGap: ge, inset: ge, insetBlock: ge, insetBlockEnd: ge, insetBlockStart: ge, insetInline: ge, insetInlineEnd: ge, insetInlineStart: ge, margin: ge, marginTop: ge, marginRight: ge, marginBottom: ge, marginLeft: ge, marginBlock: ge, marginBlockEnd: ge, marginBlockStart: ge, marginInline: ge, marginInlineEnd: ge, marginInlineStart: ge, padding: ge, paddingTop: ge, paddingRight: ge, paddingBottom: ge, paddingLeft: ge, paddingBlock: ge, paddingBlockEnd: ge, paddingBlockStart: ge, paddingInline: ge, paddingInlineEnd: ge, paddingInlineStart: ge, top: ge, right: ge, bottom: ge, left: ge, scrollMargin: ge, scrollMarginTop: ge, scrollMarginRight: ge, scrollMarginBottom: ge, scrollMarginLeft: ge, scrollMarginX: ge, scrollMarginY: ge, scrollMarginBlock: ge, scrollMarginBlockEnd: ge, scrollMarginBlockStart: ge, scrollMarginInline: ge, scrollMarginInlineEnd: ge, scrollMarginInlineStart: ge, scrollPadding: ge, scrollPaddingTop: ge, scrollPaddingRight: ge, scrollPaddingBottom: ge, scrollPaddingLeft: ge, scrollPaddingX: ge, scrollPaddingY: ge, scrollPaddingBlock: ge, scrollPaddingBlockEnd: ge, scrollPaddingBlockStart: ge, scrollPaddingInline: ge, scrollPaddingInlineEnd: ge, scrollPaddingInlineStart: ge, fontSize: "fontSizes", background: je, backgroundColor: je, backgroundImage: je, borderImage: je, border: je, borderBlock: je, borderBlockEnd: je, borderBlockStart: je, borderBottom: je, borderBottomColor: je, borderColor: je, borderInline: je, borderInlineEnd: je, borderInlineStart: je, borderLeft: je, borderLeftColor: je, borderRight: je, borderRightColor: je, borderTop: je, borderTopColor: je, caretColor: je, color: je, columnRuleColor: je, fill: je, outline: je, outlineColor: je, stroke: je, textDecorationColor: je, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: Nt, minBlockSize: Nt, maxBlockSize: Nt, inlineSize: Nt, minInlineSize: Nt, maxInlineSize: Nt, width: Nt, minWidth: Nt, maxWidth: Nt, height: Nt, minHeight: Nt, maxHeight: Nt, flexBasis: Nt, gridTemplateColumns: Nt, gridTemplateRows: Nt, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, _I = (t, e) => typeof e == "function" ? { "()": Function.prototype.toString.call(e) } : e, ps = () => {
  const t = /* @__PURE__ */ Object.create(null);
  return (e, n, ...r) => {
    const i = ((s) => JSON.stringify(s, _I))(e);
    return i in t ? t[i] : t[i] = n(e, ...r);
  };
}, Zr = Symbol.for("sxs.internal"), Pf = (t, e) => Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)), A0 = (t) => {
  for (const e in t) return !0;
  return !1;
}, { hasOwnProperty: RI } = Object.prototype, Zc = (t) => t.includes("-") ? t : t.replace(/[A-Z]/g, (e) => "-" + e.toLowerCase()), wI = /\s+(?![^()]*\))/, Ai = (t) => (e) => t(...typeof e == "string" ? String(e).split(wI) : [e]), I0 = { appearance: (t) => ({ WebkitAppearance: t, appearance: t }), backfaceVisibility: (t) => ({ WebkitBackfaceVisibility: t, backfaceVisibility: t }), backdropFilter: (t) => ({ WebkitBackdropFilter: t, backdropFilter: t }), backgroundClip: (t) => ({ WebkitBackgroundClip: t, backgroundClip: t }), boxDecorationBreak: (t) => ({ WebkitBoxDecorationBreak: t, boxDecorationBreak: t }), clipPath: (t) => ({ WebkitClipPath: t, clipPath: t }), content: (t) => ({ content: t.includes('"') || t.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(t) ? t : `"${t}"` }), hyphens: (t) => ({ WebkitHyphens: t, hyphens: t }), maskImage: (t) => ({ WebkitMaskImage: t, maskImage: t }), maskSize: (t) => ({ WebkitMaskSize: t, maskSize: t }), tabSize: (t) => ({ MozTabSize: t, tabSize: t }), textSizeAdjust: (t) => ({ WebkitTextSizeAdjust: t, textSizeAdjust: t }), userSelect: (t) => ({ WebkitUserSelect: t, userSelect: t }), marginBlock: Ai((t, e) => ({ marginBlockStart: t, marginBlockEnd: e || t })), marginInline: Ai((t, e) => ({ marginInlineStart: t, marginInlineEnd: e || t })), maxSize: Ai((t, e) => ({ maxBlockSize: t, maxInlineSize: e || t })), minSize: Ai((t, e) => ({ minBlockSize: t, minInlineSize: e || t })), paddingBlock: Ai((t, e) => ({ paddingBlockStart: t, paddingBlockEnd: e || t })), paddingInline: Ai((t, e) => ({ paddingInlineStart: t, paddingInlineEnd: e || t })) }, $l = /([\d.]+)([^]*)/, kI = (t, e) => t.length ? t.reduce((n, r) => (n.push(...e.map((i) => i.includes("&") ? i.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(i) ? `:is(${r})` : r) : r + " " + i)), n), []) : e, DI = (t, e) => t in PI && typeof e == "string" ? e.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (n, r, i, s) => r + (i === "stretch" ? `-moz-available${s};${Zc(t)}:${r}-webkit-fill-available` : `-moz-fit-content${s};${Zc(t)}:${r}fit-content`) + s) : String(e), PI = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, cr = (t) => t ? t + "-" : "", ub = (t, e, n) => t.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, i, s, a, o) => a == "$" == !!s ? r : (i || a == "--" ? "calc(" : "") + "var(--" + (a === "$" ? cr(e) + (o.includes("$") ? "" : cr(n)) + o.replace(/\$/g, "-") : o) + ")" + (i || a == "--" ? "*" + (i || "") + (s || "1") + ")" : "")), OI = /\s*,\s*(?![^()]*\))/, NI = Object.prototype.toString, Bi = (t, e, n, r, i) => {
  let s, a, o;
  const u = (l, c, d) => {
    let f, h;
    const m = (p) => {
      for (f in p) {
        const y = f.charCodeAt(0) === 64, T = y && Array.isArray(p[f]) ? p[f] : [p[f]];
        for (h of T) {
          const S = /[A-Z]/.test(b = f) ? b : b.replace(/-[^]/g, (C) => C[1].toUpperCase()), I = typeof h == "object" && h && h.toString === NI && (!r.utils[S] || !c.length);
          if (S in r.utils && !I) {
            const C = r.utils[S];
            if (C !== a) {
              a = C, m(C(h)), a = null;
              continue;
            }
          } else if (S in I0) {
            const C = I0[S];
            if (C !== o) {
              o = C, m(C(h)), o = null;
              continue;
            }
          }
          if (y && (g = f.slice(1) in r.media ? "@media " + r.media[f.slice(1)] : f, f = g.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (C, _, R, k, A, L) => {
            const P = $l.test(_), $ = 0.0625 * (P ? -1 : 1), [G, N] = P ? [k, _] : [_, k];
            return "(" + (R[0] === "=" ? "" : R[0] === ">" === P ? "max-" : "min-") + G + ":" + (R[0] !== "=" && R.length === 1 ? N.replace($l, (U, B, V) => Number(B) + $ * (R === ">" ? 1 : -1) + V) : N) + (A ? ") and (" + (A[0] === ">" ? "min-" : "max-") + G + ":" + (A.length === 1 ? L.replace($l, (U, B, V) => Number(B) + $ * (A === ">" ? -1 : 1) + V) : L) : "") + ")";
          })), I) {
            const C = y ? d.concat(f) : [...d], _ = y ? [...c] : kI(c, f.split(OI));
            s !== void 0 && i(C0(...s)), s = void 0, u(h, _, C);
          } else s === void 0 && (s = [[], c, d]), f = y || f.charCodeAt(0) !== 36 ? f : `--${cr(r.prefix)}${f.slice(1).replace(/\$/g, "-")}`, h = I ? h : typeof h == "number" ? h && S in MI ? String(h) + "px" : String(h) : ub(DI(S, h ?? ""), r.prefix, r.themeMap[S]), s[0].push(`${y ? `${f} ` : `${Zc(f)}:`}${h}`);
        }
      }
      var g, b;
    };
    m(l), s !== void 0 && i(C0(...s)), s = void 0;
  };
  u(t, e, n);
}, C0 = (t, e, n) => `${n.map((r) => `${r}{`).join("")}${e.length ? `${e.join(",")}{` : ""}${t.join(";")}${e.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, MI = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, L0 = (t) => String.fromCharCode(t + (t > 25 ? 39 : 97)), Jr = (t) => ((e) => {
  let n, r = "";
  for (n = Math.abs(e); n > 52; n = n / 52 | 0) r = L0(n % 52) + r;
  return L0(n % 52) + r;
})(((e, n) => {
  let r = n.length;
  for (; r; ) e = 33 * e ^ n.charCodeAt(--r);
  return e;
})(5381, JSON.stringify(t)) >>> 0), qs = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], FI = (t) => {
  if (t.href && !t.href.startsWith(location.origin)) return !1;
  try {
    return !!t.cssRules;
  } catch {
    return !1;
  }
}, BI = (t) => {
  let e;
  const n = () => {
    const { cssRules: i } = e.sheet;
    return [].map.call(i, (s, a) => {
      const { cssText: o } = s;
      let u = "";
      if (o.startsWith("--sxs")) return "";
      if (i[a - 1] && (u = i[a - 1].cssText).startsWith("--sxs")) {
        if (!s.cssRules.length) return "";
        for (const l in e.rules) if (e.rules[l].group === s) return `--sxs{--sxs:${[...e.rules[l].cache].join(" ")}}${o}`;
        return s.cssRules.length ? `${u}${o}` : "";
      }
      return o;
    }).join("");
  }, r = () => {
    if (e) {
      const { rules: o, sheet: u } = e;
      if (!u.deleteRule) {
        for (; Object(Object(u.cssRules)[0]).type === 3; ) u.cssRules.splice(0, 1);
        u.cssRules = [];
      }
      for (const l in o) delete o[l];
    }
    const i = Object(t).styleSheets || [];
    for (const o of i) if (FI(o)) {
      for (let u = 0, l = o.cssRules; l[u]; ++u) {
        const c = Object(l[u]);
        if (c.type !== 1) continue;
        const d = Object(l[u + 1]);
        if (d.type !== 4) continue;
        ++u;
        const { cssText: f } = c;
        if (!f.startsWith("--sxs")) continue;
        const h = f.slice(14, -3).trim().split(/\s+/), m = qs[h[0]];
        m && (e || (e = { sheet: o, reset: r, rules: {}, toString: n }), e.rules[m] = { group: d, index: u, cache: new Set(h) });
      }
      if (e) break;
    }
    if (!e) {
      const o = (u, l) => ({ type: l, cssRules: [], insertRule(c, d) {
        this.cssRules.splice(d, 0, o(c, { import: 3, undefined: 1 }[(c.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return u === "@media{}" ? `@media{${[].map.call(this.cssRules, (c) => c.cssText).join("")}}` : u;
      } });
      e = { sheet: t ? (t.head || t).appendChild(document.createElement("style")).sheet : o("", "text/css"), rules: {}, reset: r, toString: n };
    }
    const { sheet: s, rules: a } = e;
    for (let o = qs.length - 1; o >= 0; --o) {
      const u = qs[o];
      if (!a[u]) {
        const l = qs[o + 1], c = a[l] ? a[l].index : s.cssRules.length;
        s.insertRule("@media{}", c), s.insertRule(`--sxs{--sxs:${o}}`, c), a[u] = { group: s.cssRules[c + 1], index: c, cache: /* @__PURE__ */ new Set([o]) };
      }
      $I(a[u]);
    }
  };
  return r(), e;
}, $I = (t) => {
  const e = t.group;
  let n = e.cssRules.length;
  t.apply = (r) => {
    try {
      e.insertRule(r, n), ++n;
    } catch {
    }
  };
}, ws = Symbol(), UI = ps(), _0 = (t, e) => UI(t, () => (...n) => {
  let r = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const i of n) if (i != null) if (i[Zr]) {
    r.type == null && (r.type = i[Zr].type);
    for (const s of i[Zr].composers) r.composers.add(s);
  } else i.constructor !== Object || i.$$typeof ? r.type == null && (r.type = i) : r.composers.add(HI(i, t));
  return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), VI(t, r, e);
}), HI = ({ variants: t, compoundVariants: e, defaultVariants: n, ...r }, i) => {
  const s = `${cr(i.prefix)}c-${Jr(r)}`, a = [], o = [], u = /* @__PURE__ */ Object.create(null), l = [];
  for (const f in n) u[f] = String(n[f]);
  if (typeof t == "object" && t) for (const f in t) {
    c = u, d = f, RI.call(c, d) || (u[f] = "undefined");
    const h = t[f];
    for (const m in h) {
      const p = { [f]: String(m) };
      String(m) === "undefined" && l.push(f);
      const g = h[m], b = [p, g, !A0(g)];
      a.push(b);
    }
  }
  var c, d;
  if (typeof e == "object" && e) for (const f of e) {
    let { css: h, ...m } = f;
    h = typeof h == "object" && h || {};
    for (const g in m) m[g] = String(m[g]);
    const p = [m, h, !A0(h)];
    o.push(p);
  }
  return [s, r, a, o, u, l];
}, VI = (t, e, n) => {
  const [r, i, s, a] = GI(e.composers), o = typeof e.type == "function" || e.type.$$typeof ? ((d) => {
    function f() {
      for (let h = 0; h < f[ws].length; h++) {
        const [m, p] = f[ws][h];
        d.rules[m].apply(p);
      }
      return f[ws] = [], null;
    }
    return f[ws] = [], f.rules = {}, qs.forEach((h) => f.rules[h] = { apply: (m) => f[ws].push([h, m]) }), f;
  })(n) : null, u = (o || n).rules, l = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, c = (d) => {
    d = typeof d == "object" && d || zI;
    const { css: f, ...h } = d, m = {};
    for (const b in s) if (delete h[b], b in d) {
      let y = d[b];
      typeof y == "object" && y ? m[b] = { "@initial": s[b], ...y } : (y = String(y), m[b] = y !== "undefined" || a.has(b) ? y : s[b]);
    } else m[b] = s[b];
    const p = /* @__PURE__ */ new Set([...i]);
    for (const [b, y, T, S] of e.composers) {
      n.rules.styled.cache.has(b) || (n.rules.styled.cache.add(b), Bi(y, [`.${b}`], [], t, (_) => {
        u.styled.apply(_);
      }));
      const I = R0(T, m, t.media), C = R0(S, m, t.media, !0);
      for (const _ of I) if (_ !== void 0) for (const [R, k, A] of _) {
        const L = `${b}-${Jr(k)}-${R}`;
        p.add(L);
        const P = (A ? n.rules.resonevar : n.rules.onevar).cache, $ = A ? u.resonevar : u.onevar;
        P.has(L) || (P.add(L), Bi(k, [`.${L}`], [], t, (G) => {
          $.apply(G);
        }));
      }
      for (const _ of C) if (_ !== void 0) for (const [R, k] of _) {
        const A = `${b}-${Jr(k)}-${R}`;
        p.add(A), n.rules.allvar.cache.has(A) || (n.rules.allvar.cache.add(A), Bi(k, [`.${A}`], [], t, (L) => {
          u.allvar.apply(L);
        }));
      }
    }
    if (typeof f == "object" && f) {
      const b = `${r}-i${Jr(f)}-css`;
      p.add(b), n.rules.inline.cache.has(b) || (n.rules.inline.cache.add(b), Bi(f, [`.${b}`], [], t, (y) => {
        u.inline.apply(y);
      }));
    }
    for (const b of String(d.className || "").trim().split(/\s+/)) b && p.add(b);
    const g = h.className = [...p].join(" ");
    return { type: e.type, className: g, selector: l, props: h, toString: () => g, deferredInjector: o };
  };
  return Pf(c, { className: r, selector: l, [Zr]: e, toString: () => (n.rules.styled.cache.has(r) || c(), r) });
}, GI = (t) => {
  let e = "";
  const n = [], r = {}, i = [];
  for (const [s, , , , a, o] of t) {
    e === "" && (e = s), n.push(s), i.push(...o);
    for (const u in a) {
      const l = a[u];
      (r[u] === void 0 || l !== "undefined" || o.includes(l)) && (r[u] = l);
    }
  }
  return [e, n, r, new Set(i)];
}, R0 = (t, e, n, r) => {
  const i = [];
  e: for (let [s, a, o] of t) {
    if (o) continue;
    let u, l = 0, c = !1;
    for (u in s) {
      const d = s[u];
      let f = e[u];
      if (f !== d) {
        if (typeof f != "object" || !f) continue e;
        {
          let h, m, p = 0;
          for (const g in f) {
            if (d === String(f[g])) {
              if (g !== "@initial") {
                const b = g.slice(1);
                (m = m || []).push(b in n ? n[b] : g.replace(/^@media ?/, "")), c = !0;
              }
              l += p, h = !0;
            }
            ++p;
          }
          if (m && m.length && (a = { ["@media " + m.join(", ")]: a }), !h) continue e;
        }
      }
    }
    (i[l] = i[l] || []).push([r ? "cv" : `${u}-${s[u]}`, a, c]);
  }
  return i;
}, zI = {}, qI = ps(), WI = (t, e) => qI(t, () => (...n) => {
  const r = () => {
    for (let i of n) {
      i = typeof i == "object" && i || {};
      let s = Jr(i);
      if (!e.rules.global.cache.has(s)) {
        if (e.rules.global.cache.add(s), "@import" in i) {
          let a = [].indexOf.call(e.sheet.cssRules, e.rules.themed.group) - 1;
          for (let o of [].concat(i["@import"])) o = o.includes('"') || o.includes("'") ? o : `"${o}"`, e.sheet.insertRule(`@import ${o};`, a++);
          delete i["@import"];
        }
        Bi(i, [], [], t, (a) => {
          e.rules.global.apply(a);
        });
      }
    }
    return "";
  };
  return Pf(r, { toString: r });
}), KI = ps(), jI = (t, e) => KI(t, () => (n) => {
  const r = `${cr(t.prefix)}k-${Jr(n)}`, i = () => {
    if (!e.rules.global.cache.has(r)) {
      e.rules.global.cache.add(r);
      const s = [];
      Bi(n, [], [], t, (o) => s.push(o));
      const a = `@keyframes ${r}{${s.join("")}}`;
      e.rules.global.apply(a);
    }
    return r;
  };
  return Pf(i, { get name() {
    return i();
  }, toString: i });
}), YI = class {
  constructor(t, e, n, r) {
    this.token = t == null ? "" : String(t), this.value = e == null ? "" : String(e), this.scale = n == null ? "" : String(n), this.prefix = r == null ? "" : String(r);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + cr(this.prefix) + cr(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, XI = ps(), QI = (t, e) => XI(t, () => (n, r) => {
  r = typeof n == "object" && n || Object(r);
  const i = `.${n = (n = typeof n == "string" ? n : "") || `${cr(t.prefix)}t-${Jr(r)}`}`, s = {}, a = [];
  for (const u in r) {
    s[u] = {};
    for (const l in r[u]) {
      const c = `--${cr(t.prefix)}${u}-${l}`, d = ub(String(r[u][l]), t.prefix, u);
      s[u][l] = new YI(l, d, u, t.prefix), a.push(`${c}:${d}`);
    }
  }
  const o = () => {
    if (a.length && !e.rules.themed.cache.has(n)) {
      e.rules.themed.cache.add(n);
      const u = `${r === t.theme ? ":root," : ""}.${n}{${a.join(";")}}`;
      e.rules.themed.apply(u);
    }
    return n;
  };
  return { ...s, get className() {
    return o();
  }, selector: i, toString: o };
}), ZI = ps(), w0, JI = ps(), lb = (t) => {
  const e = ((n) => {
    let r = !1;
    const i = ZI(n, (s) => {
      r = !0;
      const a = "prefix" in (s = typeof s == "object" && s || {}) ? String(s.prefix) : "", o = typeof s.media == "object" && s.media || {}, u = typeof s.root == "object" ? s.root || null : globalThis.document || null, l = typeof s.theme == "object" && s.theme || {}, c = { prefix: a, media: o, theme: l, themeMap: typeof s.themeMap == "object" && s.themeMap || { ...LI }, utils: typeof s.utils == "object" && s.utils || {} }, d = BI(u), f = { css: _0(c, d), globalCss: WI(c, d), keyframes: jI(c, d), createTheme: QI(c, d), reset() {
        d.reset(), f.theme.toString();
      }, theme: {}, sheet: d, config: c, prefix: a, getCssText: d.toString, toString: d.toString };
      return String(f.theme = f.createTheme(l)), f;
    });
    return r || i.reset(), i;
  })(t);
  return e.styled = (({ config: n, sheet: r }) => JI(n, () => {
    const i = _0(n, r);
    return (...s) => {
      const a = i(...s), o = a[Zr].type, u = v.forwardRef((l, c) => {
        const d = l && l.as || o, { props: f, deferredInjector: h } = a(l);
        return delete f.as, f.ref = c, h ? v.createElement(v.Fragment, null, v.createElement(d, f), v.createElement(h, null)) : v.createElement(d, f);
      });
      return u.className = a.className, u.displayName = `Styled.${o.displayName || o.name || o}`, u.selector = a.selector, u.toString = () => a.selector, u[Zr] = a[Zr], u;
    };
  }))(e), e;
}, eC = () => w0 || (w0 = lb()), tC = (...t) => eC().createTheme(...t);
const Ul = 209, nC = {
  colors: {
    /*
     * Black and dark grays in a light theme.
     * Must contrast to 4.5 or greater with `secondary`.
     */
    primary: "#1a1d1e",
    primaryMuted: "#26292b",
    primaryAlt: "#151718",
    /*
     * Key brand color(s).
     * Must contrast to 4.5 or greater with `secondary`.
     */
    accent: `hsl(${Ul} 100% 38.2%)`,
    accentMuted: `hsl(${Ul} 80% 61.8%)`,
    accentAlt: `hsl(${Ul} 80% 30%)`,
    /*
     * White and light grays in a light theme.
     * Must contrast to 4.5 or greater with `primary` and  `accent`.
     */
    secondary: "#FFFFFF",
    secondaryMuted: "#e6e8eb",
    secondaryAlt: "#c1c8cd"
  },
  fontSizes: {
    1: "12px",
    2: "13px",
    3: "15px",
    4: "17px",
    5: "19px",
    6: "21px",
    7: "27px",
    8: "35px",
    9: "59px"
  },
  lineHeights: {
    1: "12px",
    2: "13px",
    3: "15px",
    4: "17px",
    5: "19px",
    6: "21px",
    7: "27px",
    8: "35px",
    9: "59px"
  },
  sizes: {
    1: "5px",
    2: "10px",
    3: "15px",
    4: "20px",
    5: "25px",
    6: "35px",
    7: "45px",
    8: "65px",
    9: "80px"
  },
  space: {
    1: "5px",
    2: "10px",
    3: "15px",
    4: "20px",
    5: "25px",
    6: "35px",
    7: "45px",
    8: "65px",
    9: "80px"
  },
  radii: {
    1: "4px",
    2: "6px",
    3: "8px",
    4: "12px",
    round: "50%",
    pill: "9999px"
  },
  transitions: {
    all: "all 200ms cubic-bezier(0.16, 1, 0.3, 1)"
  },
  zIndices: {
    1: "100",
    2: "200",
    3: "300",
    4: "400",
    max: "999"
  }
}, cb = {
  xxs: "(max-width: 349px)",
  xs: "(max-width: 575px)",
  sm: "(max-width: 767px)",
  md: "(max-width: 991px)",
  lg: "(max-width: 90rem)",
  xl: "(min-width: calc(90rem + 1px))"
}, { styled: le, css: VX, keyframes: db, createTheme: GX } = lb({
  theme: nC,
  media: cb
}), rC = le("div", {
  display: "flex",
  flexDirection: "column",
  alignItems: "center"
}), iC = le("p", {
  fontWeight: "bold",
  fontSize: "x-large"
}), sC = le("span", {
  fontSize: "medium"
}), Of = ({ error: t }) => {
  const { message: e } = t;
  return /* @__PURE__ */ v.createElement(rC, { role: "alert" }, /* @__PURE__ */ v.createElement(iC, { "data-testid": "headline" }, "Something went wrong"), e && /* @__PURE__ */ v.createElement(sC, null, `Error message: ${e}`, " "));
}, aC = le("div", {
  position: "relative",
  zIndex: "0"
}), fb = le("div", {
  display: "flex",
  flexDirection: "row",
  flexGrow: "1",
  overflow: "hidden"
}), hb = le("div", {
  display: "flex",
  flexDirection: "column",
  flexGrow: "1",
  flexShrink: "1",
  width: "100%",
  height: "100%",
  "&[data-aside-active='true']": {
    width: "61.8%",
    "@sm": {
      width: "0",
      opacity: "0"
    }
  },
  "&[data-aside-toggle='false']": {
    "@sm": {
      width: "100% !important",
      opacity: "1 !important"
    }
  }
}), oC = le("aside", {
  display: "flex",
  flexGrow: "1",
  flexShrink: "0",
  width: "0",
  maxHeight: "100%",
  "&[data-aside-active='true']": {
    width: "38.2%",
    "@sm": {
      width: "100%"
    }
  },
  "&[data-aside-toggle='false']": {
    "@sm": {
      width: "0 !important"
    }
  }
}), uC = le("div", {
  display: "flex",
  flexDirection: "column",
  fontSmooth: "auto",
  webkitFontSmoothing: "antialiased",
  '&[data-absolute-position="true"]': {
    position: "absolute",
    width: "100%",
    height: "100%",
    zIndex: "0"
  },
  "> div": {
    display: "flex",
    flexDirection: "column",
    flexGrow: "1",
    justifyContent: "flex-start",
    height: "100%",
    maxHeight: "100%",
    "@sm": {
      [`& ${fb}`]: {
        flexGrow: "1"
      },
      [`& ${hb}`]: {
        flexGrow: "0"
      }
    }
  },
  "@sm": {
    padding: "0"
  },
  "&[data-information-panel-open='true']": {
    "@sm": {}
  }
});
function mb(t) {
  const e = t + "CollectionProvider", [n, r] = jn(e), [i, s] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), a = (p) => {
    const { scope: g, children: b } = p, y = v.useRef(null), T = v.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ ee(i, { scope: g, itemMap: T, collectionRef: y, children: b });
  };
  a.displayName = e;
  const o = t + "CollectionSlot", u = /* @__PURE__ */ ua(o), l = v.forwardRef(
    (p, g) => {
      const { scope: b, children: y } = p, T = s(o, b), S = Je(g, T.collectionRef);
      return /* @__PURE__ */ ee(u, { ref: S, children: y });
    }
  );
  l.displayName = o;
  const c = t + "CollectionItemSlot", d = "data-radix-collection-item", f = /* @__PURE__ */ ua(c), h = v.forwardRef(
    (p, g) => {
      const { scope: b, children: y, ...T } = p, S = v.useRef(null), I = Je(g, S), C = s(c, b);
      return v.useEffect(() => (C.itemMap.set(S, { ref: S, ...T }), () => void C.itemMap.delete(S))), /* @__PURE__ */ ee(f, { [d]: "", ref: I, children: y });
    }
  );
  h.displayName = c;
  function m(p) {
    const g = s(t + "CollectionConsumer", p);
    return v.useCallback(() => {
      const y = g.collectionRef.current;
      if (!y) return [];
      const T = Array.from(y.querySelectorAll(`[${d}]`));
      return Array.from(g.itemMap.values()).sort(
        (C, _) => T.indexOf(C.ref.current) - T.indexOf(_.ref.current)
      );
    }, [g.collectionRef, g.itemMap]);
  }
  return [
    { Provider: a, Slot: l, ItemSlot: h },
    m,
    r
  ];
}
function Pr(t) {
  const e = M.useRef(t);
  return M.useEffect(() => {
    e.current = t;
  }), M.useMemo(() => (...n) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...n);
  }, []);
}
var lC = M.createContext(void 0);
function Qu(t) {
  const e = M.useContext(lC);
  return t || e || "ltr";
}
var Hl = "rovingFocusGroup.onEntryFocus", cC = { bubbles: !1, cancelable: !0 }, Pa = "RovingFocusGroup", [Jc, pb, dC] = mb(Pa), [fC, Zu] = jn(
  Pa,
  [dC]
), [hC, mC] = fC(Pa), gb = M.forwardRef(
  (t, e) => /* @__PURE__ */ ee(Jc.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ ee(Jc.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ ee(pC, { ...t, ref: e }) }) })
);
gb.displayName = Pa;
var pC = M.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: s,
    currentTabStopId: a,
    defaultCurrentTabStopId: o,
    onCurrentTabStopIdChange: u,
    onEntryFocus: l,
    preventScrollOnEntryFocus: c = !1,
    ...d
  } = t, f = M.useRef(null), h = Je(e, f), m = Qu(s), [p, g] = kr({
    prop: a,
    defaultProp: o ?? null,
    onChange: u,
    caller: Pa
  }), [b, y] = M.useState(!1), T = Pr(l), S = pb(n), I = M.useRef(!1), [C, _] = M.useState(0);
  return M.useEffect(() => {
    const R = f.current;
    if (R)
      return R.addEventListener(Hl, T), () => R.removeEventListener(Hl, T);
  }, [T]), /* @__PURE__ */ ee(
    hC,
    {
      scope: n,
      orientation: r,
      dir: m,
      loop: i,
      currentTabStopId: p,
      onItemFocus: M.useCallback(
        (R) => g(R),
        [g]
      ),
      onItemShiftTab: M.useCallback(() => y(!0), []),
      onFocusableItemAdd: M.useCallback(
        () => _((R) => R + 1),
        []
      ),
      onFocusableItemRemove: M.useCallback(
        () => _((R) => R - 1),
        []
      ),
      children: /* @__PURE__ */ ee(
        $e.div,
        {
          tabIndex: b || C === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: h,
          style: { outline: "none", ...t.style },
          onMouseDown: Oe(t.onMouseDown, () => {
            I.current = !0;
          }),
          onFocus: Oe(t.onFocus, (R) => {
            const k = !I.current;
            if (R.target === R.currentTarget && k && !b) {
              const A = new CustomEvent(Hl, cC);
              if (R.currentTarget.dispatchEvent(A), !A.defaultPrevented) {
                const L = S().filter((U) => U.focusable), P = L.find((U) => U.active), $ = L.find((U) => U.id === p), N = [P, $, ...L].filter(
                  Boolean
                ).map((U) => U.ref.current);
                yb(N, c);
              }
            }
            I.current = !1;
          }),
          onBlur: Oe(t.onBlur, () => y(!1))
        }
      )
    }
  );
}), bb = "RovingFocusGroupItem", Eb = M.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: s,
      children: a,
      ...o
    } = t, u = di(), l = s || u, c = mC(bb, n), d = c.currentTabStopId === l, f = pb(n), { onFocusableItemAdd: h, onFocusableItemRemove: m, currentTabStopId: p } = c;
    return M.useEffect(() => {
      if (r)
        return h(), () => m();
    }, [r, h, m]), /* @__PURE__ */ ee(
      Jc.ItemSlot,
      {
        scope: n,
        id: l,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ ee(
          $e.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": c.orientation,
            ...o,
            ref: e,
            onMouseDown: Oe(t.onMouseDown, (g) => {
              r ? c.onItemFocus(l) : g.preventDefault();
            }),
            onFocus: Oe(t.onFocus, () => c.onItemFocus(l)),
            onKeyDown: Oe(t.onKeyDown, (g) => {
              if (g.key === "Tab" && g.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (g.target !== g.currentTarget) return;
              const b = EC(g, c.orientation, c.dir);
              if (b !== void 0) {
                if (g.metaKey || g.ctrlKey || g.altKey || g.shiftKey) return;
                g.preventDefault();
                let T = f().filter((S) => S.focusable).map((S) => S.ref.current);
                if (b === "last") T.reverse();
                else if (b === "prev" || b === "next") {
                  b === "prev" && T.reverse();
                  const S = T.indexOf(g.currentTarget);
                  T = c.loop ? yC(T, S + 1) : T.slice(S + 1);
                }
                setTimeout(() => yb(T));
              }
            }),
            children: typeof a == "function" ? a({ isCurrentTabStop: d, hasTabStop: p != null }) : a
          }
        )
      }
    );
  }
);
Eb.displayName = bb;
var gC = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function bC(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function EC(t, e, n) {
  const r = bC(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return gC[r];
}
function yb(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function yC(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var Tb = gb, Sb = Eb, Ju = "Tabs", [TC] = jn(Ju, [
  Zu
]), xb = Zu(), [SC, Nf] = TC(Ju), vb = M.forwardRef(
  (t, e) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: i,
      defaultValue: s,
      orientation: a = "horizontal",
      dir: o,
      activationMode: u = "automatic",
      ...l
    } = t, c = Qu(o), [d, f] = kr({
      prop: r,
      onChange: i,
      defaultProp: s ?? "",
      caller: Ju
    });
    return /* @__PURE__ */ ee(
      SC,
      {
        scope: n,
        baseId: di(),
        value: d,
        onValueChange: f,
        orientation: a,
        dir: c,
        activationMode: u,
        children: /* @__PURE__ */ ee(
          $e.div,
          {
            dir: c,
            "data-orientation": a,
            ...l,
            ref: e
          }
        )
      }
    );
  }
);
vb.displayName = Ju;
var Ab = "TabsList", Ib = M.forwardRef(
  (t, e) => {
    const { __scopeTabs: n, loop: r = !0, ...i } = t, s = Nf(Ab, n), a = xb(n);
    return /* @__PURE__ */ ee(
      Tb,
      {
        asChild: !0,
        ...a,
        orientation: s.orientation,
        dir: s.dir,
        loop: r,
        children: /* @__PURE__ */ ee(
          $e.div,
          {
            role: "tablist",
            "aria-orientation": s.orientation,
            ...i,
            ref: e
          }
        )
      }
    );
  }
);
Ib.displayName = Ab;
var Cb = "TabsTrigger", Lb = M.forwardRef(
  (t, e) => {
    const { __scopeTabs: n, value: r, disabled: i = !1, ...s } = t, a = Nf(Cb, n), o = xb(n), u = wb(a.baseId, r), l = kb(a.baseId, r), c = r === a.value;
    return /* @__PURE__ */ ee(
      Sb,
      {
        asChild: !0,
        ...o,
        focusable: !i,
        active: c,
        children: /* @__PURE__ */ ee(
          $e.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": c,
            "aria-controls": l,
            "data-state": c ? "active" : "inactive",
            "data-disabled": i ? "" : void 0,
            disabled: i,
            id: u,
            ...s,
            ref: e,
            onMouseDown: Oe(t.onMouseDown, (d) => {
              !i && d.button === 0 && d.ctrlKey === !1 ? a.onValueChange(r) : d.preventDefault();
            }),
            onKeyDown: Oe(t.onKeyDown, (d) => {
              [" ", "Enter"].includes(d.key) && a.onValueChange(r);
            }),
            onFocus: Oe(t.onFocus, () => {
              const d = a.activationMode !== "manual";
              !c && !i && d && a.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
Lb.displayName = Cb;
var _b = "TabsContent", Rb = M.forwardRef(
  (t, e) => {
    const { __scopeTabs: n, value: r, forceMount: i, children: s, ...a } = t, o = Nf(_b, n), u = wb(o.baseId, r), l = kb(o.baseId, r), c = r === o.value, d = M.useRef(c);
    return M.useEffect(() => {
      const f = requestAnimationFrame(() => d.current = !1);
      return () => cancelAnimationFrame(f);
    }, []), /* @__PURE__ */ ee(Da, { present: i || c, children: ({ present: f }) => /* @__PURE__ */ ee(
      $e.div,
      {
        "data-state": c ? "active" : "inactive",
        "data-orientation": o.orientation,
        role: "tabpanel",
        "aria-labelledby": u,
        hidden: !f,
        id: l,
        tabIndex: 0,
        ...a,
        ref: e,
        style: {
          ...t.style,
          animationDuration: d.current ? "0s" : void 0
        },
        children: f && s
      }
    ) });
  }
);
Rb.displayName = _b;
function wb(t, e) {
  return `${t}-trigger-${e}`;
}
function kb(t, e) {
  return `${t}-content-${e}`;
}
var xC = vb, vC = Ib, AC = Lb, IC = Rb;
const CC = le(xC, {
  display: "flex",
  flexDirection: "column",
  width: "100%",
  height: "100%",
  flexGrow: "1",
  flexShrink: "0",
  position: "relative",
  zIndex: "1",
  maskImage: "linear-gradient(180deg, rgba(0, 0, 0, 1) calc(100% -  2rem), transparent 100%)",
  "@sm": {
    marginTop: "0.5rem",
    boxShadow: "none"
  }
}), LC = le(vC, {
  display: "flex",
  flexGrow: "0",
  margin: "0 1.618rem",
  borderBottom: "5px solid #6663",
  "@sm": {
    margin: "0 1rem"
  }
}), ks = le(AC, {
  display: "flex",
  position: "relative",
  padding: "0.5rem 1.618rem",
  background: "none",
  backgroundColor: "transparent",
  fontFamily: "inherit",
  border: "none",
  opacity: "0.7",
  fontSize: "1rem",
  lineHeight: "1rem",
  whiteSpace: "nowrap",
  cursor: "pointer",
  fontWeight: 400,
  transition: "$all",
  "&[data-value='manifest-back']": {
    display: "none;",
    "@sm": {
      display: "block"
    }
  },
  "&::after": {
    width: "0",
    height: "4px",
    content: "",
    position: "absolute",
    bottom: "-4px",
    left: "0",
    transition: "$all"
  },
  "&[data-state='active']": {
    opacity: "1",
    fontWeight: 700,
    "&::after": {
      width: "100%",
      backgroundColor: "$accent"
    }
  }
}), Ja = le(IC, {
  display: "flex",
  flexDirection: "column",
  flexGrow: "1",
  flexShrink: "0",
  position: "absolute",
  top: "0",
  left: "0",
  "&[data-state='active']": {
    width: "100%",
    height: "calc(100% - 2rem)",
    padding: "1.618rem 0"
  }
}), _C = ({
  handleScroll: t,
  children: e,
  className: n
}) => /* @__PURE__ */ v.createElement("div", { className: n, onScroll: t }, e), RC = le(_C, {
  position: "relative",
  height: "100%",
  width: "100%",
  overflowY: "scroll"
}), Db = {
  position: "relative",
  display: "flex",
  margin: "0 1.618rem",
  padding: "0.5rem 0",
  fontFamily: "inherit",
  fontSize: "0.8333rem",
  lineHeight: "1.47rem",
  color: "inherit",
  background: "none",
  borderRadius: "3px",
  border: "none"
}, el = le("button", {
  textAlign: "left",
  "&:hover": {
    color: "$accent"
  }
}), Mf = le("div", {
  display: "flex",
  flexDirection: "column",
  width: "100%",
  header: {
    margin: "0 1.618rem 0.5rem ",
    fontWeight: 700,
    fontSize: "0.8333rem",
    em: {
      fontStyle: "normal",
      fontWeight: 400,
      opacity: 0.7
    }
  },
  paddingBottom: "1rem",
  marginBottom: "1rem",
  borderBottom: "1px solid #0001"
}), tl = le("div", {
  gap: "1rem",
  fontSize: "1rem",
  lineHeight: "1.47em",
  margin: "0",
  "&[data-content-search=true]": {
    em: {
      fontWeight: 700,
      display: "inline"
    }
  }
}), wC = le("div", {
  ...Db,
  display: "flex",
  flexDirection: "row",
  gap: "1rem",
  "&[data-format='text/vtt']": {
    marginTop: "-1rem",
    "> span": {
      display: "none"
    }
  },
  "> span": {
    display: "flex",
    width: "2rem",
    height: "2rem",
    backgroundColor: "#0001",
    flexShrink: "0",
    borderRadius: "3px",
    marginTop: "0.25rem"
  },
  [`&[dir=rtl] ${tl}`]: {
    textAlign: "right !important"
  }
}), kC = ({
  value: t,
  handleClick: e
}) => /* @__PURE__ */ v.createElement(el, { onClick: e }, /* @__PURE__ */ v.createElement(tl, { dangerouslySetInnerHTML: { __html: t } })), DC = ({
  caption: t,
  handleClick: e,
  imageUri: n
}) => /* @__PURE__ */ v.createElement(el, { onClick: e }, /* @__PURE__ */ v.createElement("img", { src: n, alt: `A visual annotation for ${t}` }), /* @__PURE__ */ v.createElement("span", null, t)), Pb = -1, nl = 0, Xs = 1, mu = 2, Ff = 3, Bf = 4, $f = 5, Uf = 6, Ob = 7, Nb = 8, k0 = typeof self == "object" ? self : globalThis, PC = (t, e) => {
  const n = (i, s) => (t.set(s, i), i), r = (i) => {
    if (t.has(i))
      return t.get(i);
    const [s, a] = e[i];
    switch (s) {
      case nl:
      case Pb:
        return n(a, i);
      case Xs: {
        const o = n([], i);
        for (const u of a)
          o.push(r(u));
        return o;
      }
      case mu: {
        const o = n({}, i);
        for (const [u, l] of a)
          o[r(u)] = r(l);
        return o;
      }
      case Ff:
        return n(new Date(a), i);
      case Bf: {
        const { source: o, flags: u } = a;
        return n(new RegExp(o, u), i);
      }
      case $f: {
        const o = n(/* @__PURE__ */ new Map(), i);
        for (const [u, l] of a)
          o.set(r(u), r(l));
        return o;
      }
      case Uf: {
        const o = n(/* @__PURE__ */ new Set(), i);
        for (const u of a)
          o.add(r(u));
        return o;
      }
      case Ob: {
        const { name: o, message: u } = a;
        return n(new k0[o](u), i);
      }
      case Nb:
        return n(BigInt(a), i);
      case "BigInt":
        return n(Object(BigInt(a)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(a).buffer, a);
      case "DataView": {
        const { buffer: o } = new Uint8Array(a);
        return n(new DataView(o), a);
      }
    }
    return n(new k0[s](a), i);
  };
  return r;
}, D0 = (t) => PC(/* @__PURE__ */ new Map(), t)(0), Ii = "", { toString: OC } = {}, { keys: NC } = Object, Ds = (t) => {
  const e = typeof t;
  if (e !== "object" || !t)
    return [nl, e];
  const n = OC.call(t).slice(8, -1);
  switch (n) {
    case "Array":
      return [Xs, Ii];
    case "Object":
      return [mu, Ii];
    case "Date":
      return [Ff, Ii];
    case "RegExp":
      return [Bf, Ii];
    case "Map":
      return [$f, Ii];
    case "Set":
      return [Uf, Ii];
    case "DataView":
      return [Xs, n];
  }
  return n.includes("Array") ? [Xs, n] : n.includes("Error") ? [Ob, n] : [mu, n];
}, eo = ([t, e]) => t === nl && (e === "function" || e === "symbol"), MC = (t, e, n, r) => {
  const i = (a, o) => {
    const u = r.push(a) - 1;
    return n.set(o, u), u;
  }, s = (a) => {
    if (n.has(a))
      return n.get(a);
    let [o, u] = Ds(a);
    switch (o) {
      case nl: {
        let c = a;
        switch (u) {
          case "bigint":
            o = Nb, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (t)
              throw new TypeError("unable to serialize " + u);
            c = null;
            break;
          case "undefined":
            return i([Pb], a);
        }
        return i([o, c], a);
      }
      case Xs: {
        if (u) {
          let f = a;
          return u === "DataView" ? f = new Uint8Array(a.buffer) : u === "ArrayBuffer" && (f = new Uint8Array(a)), i([u, [...f]], a);
        }
        const c = [], d = i([o, c], a);
        for (const f of a)
          c.push(s(f));
        return d;
      }
      case mu: {
        if (u)
          switch (u) {
            case "BigInt":
              return i([u, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([u, a.valueOf()], a);
          }
        if (e && "toJSON" in a)
          return s(a.toJSON());
        const c = [], d = i([o, c], a);
        for (const f of NC(a))
          (t || !eo(Ds(a[f]))) && c.push([s(f), s(a[f])]);
        return d;
      }
      case Ff:
        return i([o, a.toISOString()], a);
      case Bf: {
        const { source: c, flags: d } = a;
        return i([o, { source: c, flags: d }], a);
      }
      case $f: {
        const c = [], d = i([o, c], a);
        for (const [f, h] of a)
          (t || !(eo(Ds(f)) || eo(Ds(h)))) && c.push([s(f), s(h)]);
        return d;
      }
      case Uf: {
        const c = [], d = i([o, c], a);
        for (const f of a)
          (t || !eo(Ds(f))) && c.push(s(f));
        return d;
      }
    }
    const { message: l } = a;
    return i([o, { name: u, message: l }], a);
  };
  return s;
}, P0 = (t, { json: e, lossy: n } = {}) => {
  const r = [];
  return MC(!(e || n), !!e, /* @__PURE__ */ new Map(), r)(t), r;
}, ns = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (t, e) => e && ("json" in e || "lossy" in e) ? D0(P0(t, e)) : structuredClone(t)
) : (t, e) => D0(P0(t, e));
let Oa = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
Oa.prototype.normal = {};
Oa.prototype.property = {};
Oa.prototype.space = void 0;
function Mb(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Oa(n, r, e);
}
function la(t) {
  return t.toLowerCase();
}
let Yt = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
};
Yt.prototype.attribute = "";
Yt.prototype.booleanish = !1;
Yt.prototype.boolean = !1;
Yt.prototype.commaOrSpaceSeparated = !1;
Yt.prototype.commaSeparated = !1;
Yt.prototype.defined = !1;
Yt.prototype.mustUseProperty = !1;
Yt.prototype.number = !1;
Yt.prototype.overloadedBoolean = !1;
Yt.prototype.property = "";
Yt.prototype.spaceSeparated = !1;
Yt.prototype.space = void 0;
let FC = 0;
const we = fi(), ft = fi(), ed = fi(), se = fi(), et = fi(), Vi = fi(), en = fi();
function fi() {
  return 2 ** ++FC;
}
const td = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: we,
  booleanish: ft,
  commaOrSpaceSeparated: en,
  commaSeparated: Vi,
  number: se,
  overloadedBoolean: ed,
  spaceSeparated: et
}, Symbol.toStringTag, { value: "Module" })), Vl = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(td)
);
let Hf = class extends Yt {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), O0(this, "space", i), typeof r == "number")
      for (; ++s < Vl.length; ) {
        const a = Vl[s];
        O0(this, Vl[s], (r & td[a]) === td[a]);
      }
  }
};
Hf.prototype.defined = !0;
function O0(t, e, n) {
  n && (t[e] = n);
}
function gs(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new Hf(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[la(r)] = r, n[la(s.attribute)] = r;
  }
  return new Oa(e, n, t.space);
}
const Fb = gs({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ft,
    ariaAutoComplete: null,
    ariaBusy: ft,
    ariaChecked: ft,
    ariaColCount: se,
    ariaColIndex: se,
    ariaColSpan: se,
    ariaControls: et,
    ariaCurrent: null,
    ariaDescribedBy: et,
    ariaDetails: null,
    ariaDisabled: ft,
    ariaDropEffect: et,
    ariaErrorMessage: null,
    ariaExpanded: ft,
    ariaFlowTo: et,
    ariaGrabbed: ft,
    ariaHasPopup: null,
    ariaHidden: ft,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: et,
    ariaLevel: se,
    ariaLive: null,
    ariaModal: ft,
    ariaMultiLine: ft,
    ariaMultiSelectable: ft,
    ariaOrientation: null,
    ariaOwns: et,
    ariaPlaceholder: null,
    ariaPosInSet: se,
    ariaPressed: ft,
    ariaReadOnly: ft,
    ariaRelevant: null,
    ariaRequired: ft,
    ariaRoleDescription: et,
    ariaRowCount: se,
    ariaRowIndex: se,
    ariaRowSpan: se,
    ariaSelected: ft,
    ariaSetSize: se,
    ariaSort: null,
    ariaValueMax: se,
    ariaValueMin: se,
    ariaValueNow: se,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function Bb(t, e) {
  return e in t ? t[e] : e;
}
function $b(t, e) {
  return Bb(t, e.toLowerCase());
}
const BC = gs({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Vi,
    acceptCharset: et,
    accessKey: et,
    action: null,
    allow: null,
    allowFullScreen: we,
    allowPaymentRequest: we,
    allowUserMedia: we,
    alt: null,
    as: null,
    async: we,
    autoCapitalize: null,
    autoComplete: et,
    autoFocus: we,
    autoPlay: we,
    blocking: et,
    capture: null,
    charSet: null,
    checked: we,
    cite: null,
    className: et,
    cols: se,
    colSpan: null,
    content: null,
    contentEditable: ft,
    controls: we,
    controlsList: et,
    coords: se | Vi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: we,
    defer: we,
    dir: null,
    dirName: null,
    disabled: we,
    download: ed,
    draggable: ft,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: we,
    formTarget: null,
    headers: et,
    height: se,
    hidden: ed,
    high: se,
    href: null,
    hrefLang: null,
    htmlFor: et,
    httpEquiv: et,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: we,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: we,
    itemId: null,
    itemProp: et,
    itemRef: et,
    itemScope: we,
    itemType: et,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: we,
    low: se,
    manifest: null,
    max: null,
    maxLength: se,
    media: null,
    method: null,
    min: null,
    minLength: se,
    multiple: we,
    muted: we,
    name: null,
    nonce: null,
    noModule: we,
    noValidate: we,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: we,
    optimum: se,
    pattern: null,
    ping: et,
    placeholder: null,
    playsInline: we,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: we,
    referrerPolicy: null,
    rel: et,
    required: we,
    reversed: we,
    rows: se,
    rowSpan: se,
    sandbox: et,
    scope: null,
    scoped: we,
    seamless: we,
    selected: we,
    shadowRootClonable: we,
    shadowRootDelegatesFocus: we,
    shadowRootMode: null,
    shape: null,
    size: se,
    sizes: null,
    slot: null,
    span: se,
    spellCheck: ft,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: se,
    step: null,
    style: null,
    tabIndex: se,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: we,
    useMap: null,
    value: ft,
    width: se,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: et,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: se,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: se,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: we,
    // Lists. Use CSS to reduce space between items instead
    declare: we,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: se,
    // `<img>` and `<object>`
    leftMargin: se,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: se,
    // `<body>`
    marginWidth: se,
    // `<body>`
    noResize: we,
    // `<frame>`
    noHref: we,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: we,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: we,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: se,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ft,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: se,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: se,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: we,
    disableRemotePlayback: we,
    prefix: null,
    property: null,
    results: se,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: $b
}), $C = gs({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: en,
    accentHeight: se,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: se,
    amplitude: se,
    arabicForm: null,
    ascent: se,
    attributeName: null,
    attributeType: null,
    azimuth: se,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: se,
    by: null,
    calcMode: null,
    capHeight: se,
    className: et,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: se,
    diffuseConstant: se,
    direction: null,
    display: null,
    dur: null,
    divisor: se,
    dominantBaseline: null,
    download: we,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: se,
    enableBackground: null,
    end: null,
    event: null,
    exponent: se,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: se,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Vi,
    g2: Vi,
    glyphName: Vi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: se,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: se,
    horizOriginX: se,
    horizOriginY: se,
    id: null,
    ideographic: se,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: se,
    k: se,
    k1: se,
    k2: se,
    k3: se,
    k4: se,
    kernelMatrix: en,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: se,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: se,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: se,
    overlineThickness: se,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: se,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: et,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: se,
    pointsAtY: se,
    pointsAtZ: se,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: en,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: en,
    rev: en,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: en,
    requiredFeatures: en,
    requiredFonts: en,
    requiredFormats: en,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: se,
    specularExponent: se,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: se,
    strikethroughThickness: se,
    string: null,
    stroke: null,
    strokeDashArray: en,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: se,
    strokeOpacity: se,
    strokeWidth: null,
    style: null,
    surfaceScale: se,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: en,
    tabIndex: se,
    tableValues: null,
    target: null,
    targetX: se,
    targetY: se,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: en,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: se,
    underlineThickness: se,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: se,
    values: null,
    vAlphabetic: se,
    vMathematical: se,
    vectorEffect: null,
    vHanging: se,
    vIdeographic: se,
    version: null,
    vertAdvY: se,
    vertOriginX: se,
    vertOriginY: se,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: se,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Bb
}), Ub = gs({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), Hb = gs({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: $b
}), Vb = gs({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), UC = /[A-Z]/g, N0 = /-[a-z]/g, HC = /^data[-\w.:]+$/i;
function VC(t, e) {
  const n = la(e);
  let r = e, i = Yt;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && HC.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(N0, zC);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!N0.test(s)) {
        let a = s.replace(UC, GC);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = Hf;
  }
  return new i(r, e);
}
function GC(t) {
  return "-" + t.toLowerCase();
}
function zC(t) {
  return t.charAt(1).toUpperCase();
}
const qC = Mb([Fb, BC, Ub, Hb, Vb], "html"), WC = Mb([Fb, $C, Ub, Hb, Vb], "svg");
function M0(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), i = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = n.length, s = !0);
    const a = n.slice(i, r).trim();
    (a || !s) && e.push(a), i = r + 1, r = n.indexOf(",", i);
  }
  return e;
}
function Gb(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const F0 = /[#.]/g;
function KC(t, e) {
  const n = t || "", r = {};
  let i = 0, s, a;
  for (; i < n.length; ) {
    F0.lastIndex = i;
    const o = F0.exec(n), u = n.slice(i, o ? o.index : n.length);
    u && (s ? s === "#" ? r.id = u : Array.isArray(r.className) ? r.className.push(u) : r.className = [u] : a = u, i += u.length), o && (s = o[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: a || e || "div",
    properties: r,
    children: []
  };
}
function B0(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function zb(t) {
  return t.join(" ").trim();
}
function qb(t, e, n) {
  const r = n ? QC(n) : void 0;
  function i(s, a, ...o) {
    let u;
    if (s == null) {
      u = { type: "root", children: [] };
      const l = (
        /** @type {Child} */
        a
      );
      o.unshift(l);
    } else {
      u = KC(s, e);
      const l = u.tagName.toLowerCase(), c = r ? r.get(l) : void 0;
      if (u.tagName = c || l, jC(a))
        o.unshift(a);
      else
        for (const [d, f] of Object.entries(a))
          YC(t, u.properties, d, f);
    }
    for (const l of o)
      nd(u.children, l);
    return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
  }
  return i;
}
function jC(t) {
  if (t === null || typeof t != "object" || Array.isArray(t))
    return !0;
  if (typeof t.type != "string") return !1;
  const e = (
    /** @type {Record<string, unknown>} */
    t
  ), n = Object.keys(t);
  for (const r of n) {
    const i = e[r];
    if (i && typeof i == "object") {
      if (!Array.isArray(i)) return !0;
      const s = (
        /** @type {ReadonlyArray<unknown>} */
        i
      );
      for (const a of s)
        if (typeof a != "number" && typeof a != "string")
          return !0;
    }
  }
  return !!("children" in t && Array.isArray(t.children));
}
function YC(t, e, n, r) {
  const i = VC(t, n);
  let s;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      s = r;
    } else typeof r == "boolean" ? s = r : typeof r == "string" ? i.spaceSeparated ? s = B0(r) : i.commaSeparated ? s = M0(r) : i.commaOrSpaceSeparated ? s = B0(M0(r).join(" ")) : s = $0(i, i.property, r) : Array.isArray(r) ? s = [...r] : s = i.property === "style" ? XC(r) : String(r);
    if (Array.isArray(s)) {
      const a = [];
      for (const o of s)
        a.push(
          /** @type {number | string} */
          $0(i, i.property, o)
        );
      s = a;
    }
    i.property === "className" && Array.isArray(e.className) && (s = e.className.concat(
      /** @type {Array<number | string> | number | string} */
      s
    )), e[i.property] = s;
  }
}
function nd(t, e) {
  if (e != null) if (typeof e == "number" || typeof e == "string")
    t.push({ type: "text", value: String(e) });
  else if (Array.isArray(e))
    for (const n of e)
      nd(t, n);
  else if (typeof e == "object" && "type" in e)
    e.type === "root" ? nd(t, e.children) : t.push(e);
  else
    throw new Error("Expected node, nodes, or string, got `" + e + "`");
}
function $0(t, e, n) {
  if (typeof n == "string") {
    if (t.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((t.boolean || t.overloadedBoolean) && (n === "" || la(n) === la(e)))
      return !0;
  }
  return n;
}
function XC(t) {
  const e = [];
  for (const [n, r] of Object.entries(t))
    e.push([n, r].join(": "));
  return e.join("; ");
}
function QC(t) {
  const e = /* @__PURE__ */ new Map();
  for (const n of t)
    e.set(n.toLowerCase(), n);
  return e;
}
const ZC = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], JC = qb(qC, "div"), eL = qb(WC, "g", ZC);
let Na = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
Na.prototype.normal = {};
Na.prototype.property = {};
Na.prototype.space = void 0;
function Wb(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Na(n, r, e);
}
function rd(t) {
  return t.toLowerCase();
}
let Xt = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
};
Xt.prototype.attribute = "";
Xt.prototype.booleanish = !1;
Xt.prototype.boolean = !1;
Xt.prototype.commaOrSpaceSeparated = !1;
Xt.prototype.commaSeparated = !1;
Xt.prototype.defined = !1;
Xt.prototype.mustUseProperty = !1;
Xt.prototype.number = !1;
Xt.prototype.overloadedBoolean = !1;
Xt.prototype.property = "";
Xt.prototype.spaceSeparated = !1;
Xt.prototype.space = void 0;
let tL = 0;
const ke = hi(), ht = hi(), id = hi(), ae = hi(), tt = hi(), Gi = hi(), tn = hi();
function hi() {
  return 2 ** ++tL;
}
const sd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ke,
  booleanish: ht,
  commaOrSpaceSeparated: tn,
  commaSeparated: Gi,
  number: ae,
  overloadedBoolean: id,
  spaceSeparated: tt
}, Symbol.toStringTag, { value: "Module" })), Gl = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(sd)
);
let Vf = class extends Xt {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), U0(this, "space", i), typeof r == "number")
      for (; ++s < Gl.length; ) {
        const a = Gl[s];
        U0(this, Gl[s], (r & sd[a]) === sd[a]);
      }
  }
};
Vf.prototype.defined = !0;
function U0(t, e, n) {
  n && (t[e] = n);
}
function bs(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new Vf(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[rd(r)] = r, n[rd(s.attribute)] = r;
  }
  return new Na(e, n, t.space);
}
const Kb = bs({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ht,
    ariaAutoComplete: null,
    ariaBusy: ht,
    ariaChecked: ht,
    ariaColCount: ae,
    ariaColIndex: ae,
    ariaColSpan: ae,
    ariaControls: tt,
    ariaCurrent: null,
    ariaDescribedBy: tt,
    ariaDetails: null,
    ariaDisabled: ht,
    ariaDropEffect: tt,
    ariaErrorMessage: null,
    ariaExpanded: ht,
    ariaFlowTo: tt,
    ariaGrabbed: ht,
    ariaHasPopup: null,
    ariaHidden: ht,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: tt,
    ariaLevel: ae,
    ariaLive: null,
    ariaModal: ht,
    ariaMultiLine: ht,
    ariaMultiSelectable: ht,
    ariaOrientation: null,
    ariaOwns: tt,
    ariaPlaceholder: null,
    ariaPosInSet: ae,
    ariaPressed: ht,
    ariaReadOnly: ht,
    ariaRelevant: null,
    ariaRequired: ht,
    ariaRoleDescription: tt,
    ariaRowCount: ae,
    ariaRowIndex: ae,
    ariaRowSpan: ae,
    ariaSelected: ht,
    ariaSetSize: ae,
    ariaSort: null,
    ariaValueMax: ae,
    ariaValueMin: ae,
    ariaValueNow: ae,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function jb(t, e) {
  return e in t ? t[e] : e;
}
function Yb(t, e) {
  return jb(t, e.toLowerCase());
}
const nL = bs({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Gi,
    acceptCharset: tt,
    accessKey: tt,
    action: null,
    allow: null,
    allowFullScreen: ke,
    allowPaymentRequest: ke,
    allowUserMedia: ke,
    alt: null,
    as: null,
    async: ke,
    autoCapitalize: null,
    autoComplete: tt,
    autoFocus: ke,
    autoPlay: ke,
    blocking: tt,
    capture: null,
    charSet: null,
    checked: ke,
    cite: null,
    className: tt,
    cols: ae,
    colSpan: null,
    content: null,
    contentEditable: ht,
    controls: ke,
    controlsList: tt,
    coords: ae | Gi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ke,
    defer: ke,
    dir: null,
    dirName: null,
    disabled: ke,
    download: id,
    draggable: ht,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ke,
    formTarget: null,
    headers: tt,
    height: ae,
    hidden: id,
    high: ae,
    href: null,
    hrefLang: null,
    htmlFor: tt,
    httpEquiv: tt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: ke,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ke,
    itemId: null,
    itemProp: tt,
    itemRef: tt,
    itemScope: ke,
    itemType: tt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ke,
    low: ae,
    manifest: null,
    max: null,
    maxLength: ae,
    media: null,
    method: null,
    min: null,
    minLength: ae,
    multiple: ke,
    muted: ke,
    name: null,
    nonce: null,
    noModule: ke,
    noValidate: ke,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ke,
    optimum: ae,
    pattern: null,
    ping: tt,
    placeholder: null,
    playsInline: ke,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: ke,
    referrerPolicy: null,
    rel: tt,
    required: ke,
    reversed: ke,
    rows: ae,
    rowSpan: ae,
    sandbox: tt,
    scope: null,
    scoped: ke,
    seamless: ke,
    selected: ke,
    shadowRootClonable: ke,
    shadowRootDelegatesFocus: ke,
    shadowRootMode: null,
    shape: null,
    size: ae,
    sizes: null,
    slot: null,
    span: ae,
    spellCheck: ht,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ae,
    step: null,
    style: null,
    tabIndex: ae,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ke,
    useMap: null,
    value: ht,
    width: ae,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: tt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ae,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ae,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ke,
    // Lists. Use CSS to reduce space between items instead
    declare: ke,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ae,
    // `<img>` and `<object>`
    leftMargin: ae,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ae,
    // `<body>`
    marginWidth: ae,
    // `<body>`
    noResize: ke,
    // `<frame>`
    noHref: ke,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ke,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ke,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ae,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ht,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ae,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ae,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ke,
    disableRemotePlayback: ke,
    prefix: null,
    property: null,
    results: ae,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Yb
}), rL = bs({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: tn,
    accentHeight: ae,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ae,
    amplitude: ae,
    arabicForm: null,
    ascent: ae,
    attributeName: null,
    attributeType: null,
    azimuth: ae,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ae,
    by: null,
    calcMode: null,
    capHeight: ae,
    className: tt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ae,
    diffuseConstant: ae,
    direction: null,
    display: null,
    dur: null,
    divisor: ae,
    dominantBaseline: null,
    download: ke,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ae,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ae,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ae,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Gi,
    g2: Gi,
    glyphName: Gi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ae,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ae,
    horizOriginX: ae,
    horizOriginY: ae,
    id: null,
    ideographic: ae,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ae,
    k: ae,
    k1: ae,
    k2: ae,
    k3: ae,
    k4: ae,
    kernelMatrix: tn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ae,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ae,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ae,
    overlineThickness: ae,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ae,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: tt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ae,
    pointsAtY: ae,
    pointsAtZ: ae,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: tn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: tn,
    rev: tn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: tn,
    requiredFeatures: tn,
    requiredFonts: tn,
    requiredFormats: tn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ae,
    specularExponent: ae,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ae,
    strikethroughThickness: ae,
    string: null,
    stroke: null,
    strokeDashArray: tn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ae,
    strokeOpacity: ae,
    strokeWidth: null,
    style: null,
    surfaceScale: ae,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: tn,
    tabIndex: ae,
    tableValues: null,
    target: null,
    targetX: ae,
    targetY: ae,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: tn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ae,
    underlineThickness: ae,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ae,
    values: null,
    vAlphabetic: ae,
    vMathematical: ae,
    vectorEffect: null,
    vHanging: ae,
    vIdeographic: ae,
    version: null,
    vertAdvY: ae,
    vertOriginX: ae,
    vertOriginY: ae,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ae,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: jb
}), Xb = bs({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), Qb = bs({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Yb
}), Zb = bs({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), iL = /[A-Z]/g, H0 = /-[a-z]/g, sL = /^data[-\w.:]+$/i;
function aL(t, e) {
  const n = rd(e);
  let r = e, i = Xt;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && sL.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(H0, uL);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!H0.test(s)) {
        let a = s.replace(iL, oL);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = Vf;
  }
  return new i(r, e);
}
function oL(t) {
  return "-" + t.toLowerCase();
}
function uL(t) {
  return t.charAt(1).toUpperCase();
}
const Jb = Wb([Kb, nL, Xb, Qb, Zb], "html"), eE = Wb([Kb, rL, Xb, Qb, Zb], "svg");
function lL(t) {
  const e = String(t), n = [];
  return { toOffset: i, toPoint: r };
  function r(s) {
    if (typeof s == "number" && s > -1 && s <= e.length) {
      let a = 0;
      for (; ; ) {
        let o = n[a];
        if (o === void 0) {
          const u = V0(e, n[a - 1]);
          o = u === -1 ? e.length + 1 : u + 1, n[a] = o;
        }
        if (o > s)
          return {
            line: a + 1,
            column: s - (a > 0 ? n[a - 1] : 0) + 1,
            offset: s
          };
        a++;
      }
    }
  }
  function i(s) {
    if (s && typeof s.line == "number" && typeof s.column == "number" && !Number.isNaN(s.line) && !Number.isNaN(s.column)) {
      for (; n.length < s.line; ) {
        const o = n[n.length - 1], u = V0(e, o), l = u === -1 ? e.length + 1 : u + 1;
        if (o === l) break;
        n.push(l);
      }
      const a = (s.line > 1 ? n[s.line - 2] : 0) + s.column - 1;
      if (a < n[s.line - 1]) return a;
    }
  }
}
function V0(t, e) {
  const n = t.indexOf("\r", e), r = t.indexOf(`
`, e);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const Qr = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, tE = {}.hasOwnProperty, cL = Object.prototype;
function dL(t, e) {
  const n = e || {};
  return Gf(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? eE : Jb,
      verbose: n.verbose || !1
    },
    t
  );
}
function Gf(t, e) {
  let n;
  switch (e.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        e
      );
      return n = { type: "comment", value: r.data }, Go(t, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        e
      ), i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: nE(t, e.childNodes),
        data: { quirksMode: i }
      }, t.file && t.location) {
        const s = String(t.file), a = lL(s), o = a.toPoint(0), u = a.toPoint(s.length);
        n.position = { start: o, end: u };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        e
      );
      return n = { type: "doctype" }, Go(t, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        e
      );
      return n = { type: "text", value: r.value }, Go(t, r, n), n;
    }
    default:
      return n = fL(
        t,
        /** @type {DefaultTreeAdapterMap['element']} */
        e
      ), n;
  }
}
function nE(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; ) {
    const i = (
      /** @type {RootContent} */
      Gf(t, e[n])
    );
    r.push(i);
  }
  return r;
}
function fL(t, e) {
  const n = t.schema;
  t.schema = e.namespaceURI === Qr.svg ? eE : Jb;
  let r = -1;
  const i = {};
  for (; ++r < e.attrs.length; ) {
    const o = e.attrs[r], u = (o.prefix ? o.prefix + ":" : "") + o.name;
    tE.call(cL, u) || (i[u] = o.value);
  }
  const a = (t.schema.space === "svg" ? eL : JC)(e.tagName, i, nE(t, e.childNodes));
  if (Go(t, e, a), a.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      e
    ), u = o.sourceCodeLocation, l = u && u.startTag && $i(u.startTag), c = u && u.endTag && $i(u.endTag), d = (
      /** @type {Root} */
      Gf(t, o.content)
    );
    l && c && t.file && (d.position = { start: l.end, end: c.start }), a.content = d;
  }
  return t.schema = n, a;
}
function Go(t, e, n) {
  if ("sourceCodeLocation" in e && e.sourceCodeLocation && t.file) {
    const r = hL(t, n, e.sourceCodeLocation);
    r && (t.location = !0, n.position = r);
  }
}
function hL(t, e, n) {
  const r = $i(n);
  if (e.type === "element") {
    const i = e.children[e.children.length - 1];
    if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), t.verbose) {
      const s = {};
      let a;
      if (n.attrs)
        for (a in n.attrs)
          tE.call(n.attrs, a) && (s[aL(t.schema, a).property] = $i(
            n.attrs[a]
          ));
      n.startTag;
      const o = $i(n.startTag), u = n.endTag ? $i(n.endTag) : void 0, l = { opening: o };
      u && (l.closing = u), l.properties = s, e.data = { position: l };
    }
  }
  return r;
}
function $i(t) {
  const e = G0({
    line: t.startLine,
    column: t.startCol,
    offset: t.startOffset
  }), n = G0({
    line: t.endLine,
    column: t.endCol,
    offset: t.endOffset
  });
  return e || n ? { start: e, end: n } : void 0;
}
function G0(t) {
  return t.line && t.column ? t : void 0;
}
let Ma = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(e, n, r) {
    this.property = e, this.normal = n, r && (this.space = r);
  }
};
Ma.prototype.property = {};
Ma.prototype.normal = {};
Ma.prototype.space = null;
function rE(t, e) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < t.length; )
    Object.assign(n, t[i].property), Object.assign(r, t[i].normal);
  return new Ma(n, r, e);
}
function ad(t) {
  return t.toLowerCase();
}
let bn = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(e, n) {
    this.property = e, this.attribute = n;
  }
};
bn.prototype.space = null;
bn.prototype.boolean = !1;
bn.prototype.booleanish = !1;
bn.prototype.overloadedBoolean = !1;
bn.prototype.number = !1;
bn.prototype.commaSeparated = !1;
bn.prototype.spaceSeparated = !1;
bn.prototype.commaOrSpaceSeparated = !1;
bn.prototype.mustUseProperty = !1;
bn.prototype.defined = !1;
let mL = 0;
const _e = mi(), mt = mi(), iE = mi(), oe = mi(), nt = mi(), zi = mi(), nn = mi();
function mi() {
  return 2 ** ++mL;
}
const od = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: _e,
  booleanish: mt,
  commaOrSpaceSeparated: nn,
  commaSeparated: zi,
  number: oe,
  overloadedBoolean: iE,
  spaceSeparated: nt
}, Symbol.toStringTag, { value: "Module" })), zl = Object.keys(od);
let zf = class extends bn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), z0(this, "space", i), typeof r == "number")
      for (; ++s < zl.length; ) {
        const a = zl[s];
        z0(this, zl[s], (r & od[a]) === od[a]);
      }
  }
};
zf.prototype.defined = !0;
function z0(t, e, n) {
  n && (t[e] = n);
}
const pL = {}.hasOwnProperty;
function Es(t) {
  const e = {}, n = {};
  let r;
  for (r in t.properties)
    if (pL.call(t.properties, r)) {
      const i = t.properties[r], s = new zf(
        r,
        t.transform(t.attributes || {}, r),
        i,
        t.space
      );
      t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[ad(r)] = r, n[ad(s.attribute)] = r;
    }
  return new Ma(e, n, t.space);
}
const sE = Es({
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), aE = Es({
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function oE(t, e) {
  return e in t ? t[e] : e;
}
function uE(t, e) {
  return oE(t, e.toLowerCase());
}
const lE = Es({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: uE,
  properties: { xmlns: null, xmlnsXLink: null }
}), cE = Es({
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: mt,
    ariaAutoComplete: null,
    ariaBusy: mt,
    ariaChecked: mt,
    ariaColCount: oe,
    ariaColIndex: oe,
    ariaColSpan: oe,
    ariaControls: nt,
    ariaCurrent: null,
    ariaDescribedBy: nt,
    ariaDetails: null,
    ariaDisabled: mt,
    ariaDropEffect: nt,
    ariaErrorMessage: null,
    ariaExpanded: mt,
    ariaFlowTo: nt,
    ariaGrabbed: mt,
    ariaHasPopup: null,
    ariaHidden: mt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: nt,
    ariaLevel: oe,
    ariaLive: null,
    ariaModal: mt,
    ariaMultiLine: mt,
    ariaMultiSelectable: mt,
    ariaOrientation: null,
    ariaOwns: nt,
    ariaPlaceholder: null,
    ariaPosInSet: oe,
    ariaPressed: mt,
    ariaReadOnly: mt,
    ariaRelevant: null,
    ariaRequired: mt,
    ariaRoleDescription: nt,
    ariaRowCount: oe,
    ariaRowIndex: oe,
    ariaRowSpan: oe,
    ariaSelected: mt,
    ariaSetSize: oe,
    ariaSort: null,
    ariaValueMax: oe,
    ariaValueMin: oe,
    ariaValueNow: oe,
    ariaValueText: null,
    role: null
  }
}), gL = Es({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: uE,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: zi,
    acceptCharset: nt,
    accessKey: nt,
    action: null,
    allow: null,
    allowFullScreen: _e,
    allowPaymentRequest: _e,
    allowUserMedia: _e,
    alt: null,
    as: null,
    async: _e,
    autoCapitalize: null,
    autoComplete: nt,
    autoFocus: _e,
    autoPlay: _e,
    blocking: nt,
    capture: null,
    charSet: null,
    checked: _e,
    cite: null,
    className: nt,
    cols: oe,
    colSpan: null,
    content: null,
    contentEditable: mt,
    controls: _e,
    controlsList: nt,
    coords: oe | zi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: _e,
    defer: _e,
    dir: null,
    dirName: null,
    disabled: _e,
    download: iE,
    draggable: mt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: _e,
    formTarget: null,
    headers: nt,
    height: oe,
    hidden: _e,
    high: oe,
    href: null,
    hrefLang: null,
    htmlFor: nt,
    httpEquiv: nt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: _e,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: _e,
    itemId: null,
    itemProp: nt,
    itemRef: nt,
    itemScope: _e,
    itemType: nt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: _e,
    low: oe,
    manifest: null,
    max: null,
    maxLength: oe,
    media: null,
    method: null,
    min: null,
    minLength: oe,
    multiple: _e,
    muted: _e,
    name: null,
    nonce: null,
    noModule: _e,
    noValidate: _e,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: _e,
    optimum: oe,
    pattern: null,
    ping: nt,
    placeholder: null,
    playsInline: _e,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: _e,
    referrerPolicy: null,
    rel: nt,
    required: _e,
    reversed: _e,
    rows: oe,
    rowSpan: oe,
    sandbox: nt,
    scope: null,
    scoped: _e,
    seamless: _e,
    selected: _e,
    shadowRootClonable: _e,
    shadowRootDelegatesFocus: _e,
    shadowRootMode: null,
    shape: null,
    size: oe,
    sizes: null,
    slot: null,
    span: oe,
    spellCheck: mt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: oe,
    step: null,
    style: null,
    tabIndex: oe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: _e,
    useMap: null,
    value: mt,
    width: oe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: nt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: oe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: oe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: _e,
    // Lists. Use CSS to reduce space between items instead
    declare: _e,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: oe,
    // `<img>` and `<object>`
    leftMargin: oe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: oe,
    // `<body>`
    marginWidth: oe,
    // `<body>`
    noResize: _e,
    // `<frame>`
    noHref: _e,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: _e,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: _e,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: oe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: mt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: oe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: oe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: _e,
    disableRemotePlayback: _e,
    prefix: null,
    property: null,
    results: oe,
    security: null,
    unselectable: null
  }
}), bL = Es({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: oE,
  properties: {
    about: nn,
    accentHeight: oe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: oe,
    amplitude: oe,
    arabicForm: null,
    ascent: oe,
    attributeName: null,
    attributeType: null,
    azimuth: oe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: oe,
    by: null,
    calcMode: null,
    capHeight: oe,
    className: nt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: oe,
    diffuseConstant: oe,
    direction: null,
    display: null,
    dur: null,
    divisor: oe,
    dominantBaseline: null,
    download: _e,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: oe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: oe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: oe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: zi,
    g2: zi,
    glyphName: zi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: oe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: oe,
    horizOriginX: oe,
    horizOriginY: oe,
    id: null,
    ideographic: oe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: oe,
    k: oe,
    k1: oe,
    k2: oe,
    k3: oe,
    k4: oe,
    kernelMatrix: nn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: oe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: oe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: oe,
    overlineThickness: oe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: oe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: nt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: oe,
    pointsAtY: oe,
    pointsAtZ: oe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: nn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: nn,
    rev: nn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: nn,
    requiredFeatures: nn,
    requiredFonts: nn,
    requiredFormats: nn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: oe,
    specularExponent: oe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: oe,
    strikethroughThickness: oe,
    string: null,
    stroke: null,
    strokeDashArray: nn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: oe,
    strokeOpacity: oe,
    strokeWidth: null,
    style: null,
    surfaceScale: oe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: nn,
    tabIndex: oe,
    tableValues: null,
    target: null,
    targetX: oe,
    targetY: oe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: nn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: oe,
    underlineThickness: oe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: oe,
    values: null,
    vAlphabetic: oe,
    vMathematical: oe,
    vectorEffect: null,
    vHanging: oe,
    vIdeographic: oe,
    version: null,
    vertAdvY: oe,
    vertOriginX: oe,
    vertOriginY: oe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: oe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), EL = /^data[-\w.:]+$/i, q0 = /-[a-z]/g, yL = /[A-Z]/g;
function TL(t, e) {
  const n = ad(e);
  let r = e, i = bn;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && EL.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(q0, xL);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!q0.test(s)) {
        let a = s.replace(yL, SL);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = zf;
  }
  return new i(r, e);
}
function SL(t) {
  return "-" + t.toLowerCase();
}
function xL(t) {
  return t.charAt(1).toUpperCase();
}
const vL = rE([aE, sE, lE, cE, gL], "html"), dE = rE([aE, sE, lE, cE, bL], "svg"), W0 = {}.hasOwnProperty;
function qf(t, e) {
  const n = e || {};
  function r(i, ...s) {
    let a = r.invalid;
    const o = r.handlers;
    if (i && W0.call(i, t)) {
      const u = String(i[t]);
      a = W0.call(o, u) ? o[u] : r.unknown;
    }
    if (a)
      return a.call(this, i, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const AL = {}, IL = {}.hasOwnProperty, fE = qf("type", { handlers: { root: LL, element: DL, text: wL, comment: kL, doctype: RL } });
function CL(t, e) {
  const r = (e || AL).space;
  return fE(t, r === "svg" ? dE : vL);
}
function LL(t, e) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (t.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Wf(t.children, n, e), ys(t, n), n;
}
function _L(t, e) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Wf(t.children, n, e), ys(t, n), n;
}
function RL(t) {
  const e = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return ys(t, e), e;
}
function wL(t) {
  const e = {
    nodeName: "#text",
    value: t.value,
    parentNode: null
  };
  return ys(t, e), e;
}
function kL(t) {
  const e = {
    nodeName: "#comment",
    data: t.value,
    parentNode: null
  };
  return ys(t, e), e;
}
function DL(t, e) {
  const n = e;
  let r = n;
  t.type === "element" && t.tagName.toLowerCase() === "svg" && n.space === "html" && (r = dE);
  const i = [];
  let s;
  if (t.properties) {
    for (s in t.properties)
      if (s !== "children" && IL.call(t.properties, s)) {
        const u = PL(
          r,
          s,
          t.properties[s]
        );
        u && i.push(u);
      }
  }
  const a = r.space, o = {
    nodeName: t.tagName,
    tagName: t.tagName,
    attrs: i,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: Qr[a],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Wf(t.children, o, r), ys(t, o), t.tagName === "template" && t.content && (o.content = _L(t.content, r)), o;
}
function PL(t, e, n) {
  const r = TL(t, e);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? Gb(n) : zb(n));
  const i = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const s = i.name.indexOf(":");
    s < 0 ? i.prefix = "" : (i.name = i.name.slice(s + 1), i.prefix = r.attribute.slice(0, s)), i.namespace = Qr[r.space];
  }
  return i;
}
function Wf(t, e, n) {
  let r = -1;
  const i = [];
  if (t)
    for (; ++r < t.length; ) {
      const s = fE(t[r], n);
      s.parentNode = e, i.push(s);
    }
  return i;
}
function ys(t, e) {
  const n = t.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, e.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const hE = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], OL = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), ot = "";
var O;
(function(t) {
  t[t.EOF = -1] = "EOF", t[t.NULL = 0] = "NULL", t[t.TABULATION = 9] = "TABULATION", t[t.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", t[t.LINE_FEED = 10] = "LINE_FEED", t[t.FORM_FEED = 12] = "FORM_FEED", t[t.SPACE = 32] = "SPACE", t[t.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", t[t.QUOTATION_MARK = 34] = "QUOTATION_MARK", t[t.AMPERSAND = 38] = "AMPERSAND", t[t.APOSTROPHE = 39] = "APOSTROPHE", t[t.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", t[t.SOLIDUS = 47] = "SOLIDUS", t[t.DIGIT_0 = 48] = "DIGIT_0", t[t.DIGIT_9 = 57] = "DIGIT_9", t[t.SEMICOLON = 59] = "SEMICOLON", t[t.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", t[t.EQUALS_SIGN = 61] = "EQUALS_SIGN", t[t.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", t[t.QUESTION_MARK = 63] = "QUESTION_MARK", t[t.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", t[t.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", t[t.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", t[t.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", t[t.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", t[t.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(O || (O = {}));
const Ut = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function mE(t) {
  return t >= 55296 && t <= 57343;
}
function NL(t) {
  return t >= 56320 && t <= 57343;
}
function ML(t, e) {
  return (t - 55296) * 1024 + 9216 + e;
}
function pE(t) {
  return t !== 32 && t !== 10 && t !== 13 && t !== 9 && t !== 12 && t >= 1 && t <= 31 || t >= 127 && t <= 159;
}
function gE(t) {
  return t >= 64976 && t <= 65007 || OL.has(t);
}
var j;
(function(t) {
  t.controlCharacterInInputStream = "control-character-in-input-stream", t.noncharacterInInputStream = "noncharacter-in-input-stream", t.surrogateInInputStream = "surrogate-in-input-stream", t.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", t.endTagWithAttributes = "end-tag-with-attributes", t.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", t.unexpectedSolidusInTag = "unexpected-solidus-in-tag", t.unexpectedNullCharacter = "unexpected-null-character", t.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", t.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", t.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", t.missingEndTagName = "missing-end-tag-name", t.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", t.unknownNamedCharacterReference = "unknown-named-character-reference", t.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", t.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", t.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", t.eofBeforeTagName = "eof-before-tag-name", t.eofInTag = "eof-in-tag", t.missingAttributeValue = "missing-attribute-value", t.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", t.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", t.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", t.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", t.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", t.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", t.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", t.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", t.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", t.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", t.cdataInHtmlContent = "cdata-in-html-content", t.incorrectlyOpenedComment = "incorrectly-opened-comment", t.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", t.eofInDoctype = "eof-in-doctype", t.nestedComment = "nested-comment", t.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", t.eofInComment = "eof-in-comment", t.incorrectlyClosedComment = "incorrectly-closed-comment", t.eofInCdata = "eof-in-cdata", t.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", t.nullCharacterReference = "null-character-reference", t.surrogateCharacterReference = "surrogate-character-reference", t.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", t.controlCharacterReference = "control-character-reference", t.noncharacterCharacterReference = "noncharacter-character-reference", t.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", t.missingDoctypeName = "missing-doctype-name", t.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", t.duplicateAttribute = "duplicate-attribute", t.nonConformingDoctype = "non-conforming-doctype", t.missingDoctype = "missing-doctype", t.misplacedDoctype = "misplaced-doctype", t.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", t.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", t.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", t.openElementsLeftAfterEof = "open-elements-left-after-eof", t.abandonedHeadElementChild = "abandoned-head-element-child", t.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", t.nestedNoscriptInHead = "nested-noscript-in-head", t.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(j || (j = {}));
const FL = 65536;
class BL {
  constructor(e) {
    this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = FL, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(e, n) {
    const { line: r, col: i, offset: s } = this, a = i + n, o = s + n;
    return {
      code: e,
      startLine: r,
      endLine: r,
      startCol: a,
      endCol: a,
      startOffset: o,
      endOffset: o
    };
  }
  _err(e) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(e) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (NL(n))
        return this.pos++, this._addGap(), ML(e, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, O.EOF;
    return this._err(j.surrogateInInputStream), e;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(e, n) {
    this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(e) {
    this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(e, n) {
    if (this.pos + e.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(e, this.pos);
    for (let r = 0; r < e.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== e.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(e) {
    const n = this.pos + e;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, O.EOF;
    const r = this.html.charCodeAt(n);
    return r === O.CARRIAGE_RETURN ? O.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, O.EOF;
    let e = this.html.charCodeAt(this.pos);
    return e === O.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, O.LINE_FEED) : e === O.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, mE(e) && (e = this._processSurrogate(e)), this.handler.onParseError === null || e > 31 && e < 127 || e === O.LINE_FEED || e === O.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e);
  }
  _checkForProblematicCharacters(e) {
    pE(e) ? this._err(j.controlCharacterInInputStream) : gE(e) && this._err(j.noncharacterInInputStream);
  }
  retreat(e) {
    for (this.pos -= e; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var Fe;
(function(t) {
  t[t.CHARACTER = 0] = "CHARACTER", t[t.NULL_CHARACTER = 1] = "NULL_CHARACTER", t[t.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", t[t.START_TAG = 3] = "START_TAG", t[t.END_TAG = 4] = "END_TAG", t[t.COMMENT = 5] = "COMMENT", t[t.DOCTYPE = 6] = "DOCTYPE", t[t.EOF = 7] = "EOF", t[t.HIBERNATION = 8] = "HIBERNATION";
})(Fe || (Fe = {}));
function bE(t, e) {
  for (let n = t.attrs.length - 1; n >= 0; n--)
    if (t.attrs[n].name === e)
      return t.attrs[n].value;
  return null;
}
const $L = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((t) => t.charCodeAt(0))
), UL = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function HL(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = UL.get(t)) !== null && e !== void 0 ? e : t;
}
var At;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(At || (At = {}));
const VL = 32;
var Rr;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Rr || (Rr = {}));
function ud(t) {
  return t >= At.ZERO && t <= At.NINE;
}
function GL(t) {
  return t >= At.UPPER_A && t <= At.UPPER_F || t >= At.LOWER_A && t <= At.LOWER_F;
}
function zL(t) {
  return t >= At.UPPER_A && t <= At.UPPER_Z || t >= At.LOWER_A && t <= At.LOWER_Z || ud(t);
}
function qL(t) {
  return t === At.EQUALS || zL(t);
}
var vt;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(vt || (vt = {}));
var lr;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(lr || (lr = {}));
class WL {
  constructor(e, n, r) {
    this.decodeTree = e, this.emitCodePoint = n, this.errors = r, this.state = vt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = lr.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = vt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, n) {
    switch (this.state) {
      case vt.EntityStart:
        return e.charCodeAt(n) === At.NUM ? (this.state = vt.NumericStart, this.consumed += 1, this.stateNumericStart(e, n + 1)) : (this.state = vt.NamedEntity, this.stateNamedEntity(e, n));
      case vt.NumericStart:
        return this.stateNumericStart(e, n);
      case vt.NumericDecimal:
        return this.stateNumericDecimal(e, n);
      case vt.NumericHex:
        return this.stateNumericHex(e, n);
      case vt.NamedEntity:
        return this.stateNamedEntity(e, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, n) {
    return n >= e.length ? -1 : (e.charCodeAt(n) | VL) === At.LOWER_X ? (this.state = vt.NumericHex, this.consumed += 1, this.stateNumericHex(e, n + 1)) : (this.state = vt.NumericDecimal, this.stateNumericDecimal(e, n));
  }
  addToNumericResult(e, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + Number.parseInt(e.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (ud(i) || GL(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(e, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, n) {
    const r = n;
    for (; n < e.length; ) {
      const i = e.charCodeAt(n);
      if (ud(i))
        n += 1;
      else
        return this.addToNumericResult(e, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(e, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === At.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === lr.Strict)
      return 0;
    return this.emitCodePoint(HL(this.result), this.consumed), this.errors && (e !== At.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Rr.VALUE_LENGTH) >> 14;
    for (; n < e.length; n++, this.excess++) {
      const a = e.charCodeAt(n);
      if (this.treeIndex = KL(r, i, this.treeIndex + Math.max(1, s), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === lr.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        qL(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Rr.VALUE_LENGTH) >> 14, s !== 0) {
        if (a === At.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== lr.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: n, decodeTree: r } = this, i = (r[n] & Rr.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[e] & ~Rr.VALUE_LENGTH : i[e + 1], r), n === 3 && this.emitCodePoint(i[e + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case vt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== lr.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case vt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case vt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case vt.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case vt.EntityStart:
        return 0;
    }
  }
}
function KL(t, e, n, r) {
  const i = (e & Rr.BRANCH_LENGTH) >> 7, s = e & Rr.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const u = r - s;
    return u < 0 || u >= i ? -1 : t[n + u] - 1;
  }
  let a = n, o = a + i - 1;
  for (; a <= o; ) {
    const u = a + o >>> 1, l = t[u];
    if (l < r)
      a = u + 1;
    else if (l > r)
      o = u - 1;
    else
      return t[u + i];
  }
  return -1;
}
var ne;
(function(t) {
  t.HTML = "http://www.w3.org/1999/xhtml", t.MATHML = "http://www.w3.org/1998/Math/MathML", t.SVG = "http://www.w3.org/2000/svg", t.XLINK = "http://www.w3.org/1999/xlink", t.XML = "http://www.w3.org/XML/1998/namespace", t.XMLNS = "http://www.w3.org/2000/xmlns/";
})(ne || (ne = {}));
var ei;
(function(t) {
  t.TYPE = "type", t.ACTION = "action", t.ENCODING = "encoding", t.PROMPT = "prompt", t.NAME = "name", t.COLOR = "color", t.FACE = "face", t.SIZE = "size";
})(ei || (ei = {}));
var mn;
(function(t) {
  t.NO_QUIRKS = "no-quirks", t.QUIRKS = "quirks", t.LIMITED_QUIRKS = "limited-quirks";
})(mn || (mn = {}));
var W;
(function(t) {
  t.A = "a", t.ADDRESS = "address", t.ANNOTATION_XML = "annotation-xml", t.APPLET = "applet", t.AREA = "area", t.ARTICLE = "article", t.ASIDE = "aside", t.B = "b", t.BASE = "base", t.BASEFONT = "basefont", t.BGSOUND = "bgsound", t.BIG = "big", t.BLOCKQUOTE = "blockquote", t.BODY = "body", t.BR = "br", t.BUTTON = "button", t.CAPTION = "caption", t.CENTER = "center", t.CODE = "code", t.COL = "col", t.COLGROUP = "colgroup", t.DD = "dd", t.DESC = "desc", t.DETAILS = "details", t.DIALOG = "dialog", t.DIR = "dir", t.DIV = "div", t.DL = "dl", t.DT = "dt", t.EM = "em", t.EMBED = "embed", t.FIELDSET = "fieldset", t.FIGCAPTION = "figcaption", t.FIGURE = "figure", t.FONT = "font", t.FOOTER = "footer", t.FOREIGN_OBJECT = "foreignObject", t.FORM = "form", t.FRAME = "frame", t.FRAMESET = "frameset", t.H1 = "h1", t.H2 = "h2", t.H3 = "h3", t.H4 = "h4", t.H5 = "h5", t.H6 = "h6", t.HEAD = "head", t.HEADER = "header", t.HGROUP = "hgroup", t.HR = "hr", t.HTML = "html", t.I = "i", t.IMG = "img", t.IMAGE = "image", t.INPUT = "input", t.IFRAME = "iframe", t.KEYGEN = "keygen", t.LABEL = "label", t.LI = "li", t.LINK = "link", t.LISTING = "listing", t.MAIN = "main", t.MALIGNMARK = "malignmark", t.MARQUEE = "marquee", t.MATH = "math", t.MENU = "menu", t.META = "meta", t.MGLYPH = "mglyph", t.MI = "mi", t.MO = "mo", t.MN = "mn", t.MS = "ms", t.MTEXT = "mtext", t.NAV = "nav", t.NOBR = "nobr", t.NOFRAMES = "noframes", t.NOEMBED = "noembed", t.NOSCRIPT = "noscript", t.OBJECT = "object", t.OL = "ol", t.OPTGROUP = "optgroup", t.OPTION = "option", t.P = "p", t.PARAM = "param", t.PLAINTEXT = "plaintext", t.PRE = "pre", t.RB = "rb", t.RP = "rp", t.RT = "rt", t.RTC = "rtc", t.RUBY = "ruby", t.S = "s", t.SCRIPT = "script", t.SEARCH = "search", t.SECTION = "section", t.SELECT = "select", t.SOURCE = "source", t.SMALL = "small", t.SPAN = "span", t.STRIKE = "strike", t.STRONG = "strong", t.STYLE = "style", t.SUB = "sub", t.SUMMARY = "summary", t.SUP = "sup", t.TABLE = "table", t.TBODY = "tbody", t.TEMPLATE = "template", t.TEXTAREA = "textarea", t.TFOOT = "tfoot", t.TD = "td", t.TH = "th", t.THEAD = "thead", t.TITLE = "title", t.TR = "tr", t.TRACK = "track", t.TT = "tt", t.U = "u", t.UL = "ul", t.SVG = "svg", t.VAR = "var", t.WBR = "wbr", t.XMP = "xmp";
})(W || (W = {}));
var E;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.A = 1] = "A", t[t.ADDRESS = 2] = "ADDRESS", t[t.ANNOTATION_XML = 3] = "ANNOTATION_XML", t[t.APPLET = 4] = "APPLET", t[t.AREA = 5] = "AREA", t[t.ARTICLE = 6] = "ARTICLE", t[t.ASIDE = 7] = "ASIDE", t[t.B = 8] = "B", t[t.BASE = 9] = "BASE", t[t.BASEFONT = 10] = "BASEFONT", t[t.BGSOUND = 11] = "BGSOUND", t[t.BIG = 12] = "BIG", t[t.BLOCKQUOTE = 13] = "BLOCKQUOTE", t[t.BODY = 14] = "BODY", t[t.BR = 15] = "BR", t[t.BUTTON = 16] = "BUTTON", t[t.CAPTION = 17] = "CAPTION", t[t.CENTER = 18] = "CENTER", t[t.CODE = 19] = "CODE", t[t.COL = 20] = "COL", t[t.COLGROUP = 21] = "COLGROUP", t[t.DD = 22] = "DD", t[t.DESC = 23] = "DESC", t[t.DETAILS = 24] = "DETAILS", t[t.DIALOG = 25] = "DIALOG", t[t.DIR = 26] = "DIR", t[t.DIV = 27] = "DIV", t[t.DL = 28] = "DL", t[t.DT = 29] = "DT", t[t.EM = 30] = "EM", t[t.EMBED = 31] = "EMBED", t[t.FIELDSET = 32] = "FIELDSET", t[t.FIGCAPTION = 33] = "FIGCAPTION", t[t.FIGURE = 34] = "FIGURE", t[t.FONT = 35] = "FONT", t[t.FOOTER = 36] = "FOOTER", t[t.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", t[t.FORM = 38] = "FORM", t[t.FRAME = 39] = "FRAME", t[t.FRAMESET = 40] = "FRAMESET", t[t.H1 = 41] = "H1", t[t.H2 = 42] = "H2", t[t.H3 = 43] = "H3", t[t.H4 = 44] = "H4", t[t.H5 = 45] = "H5", t[t.H6 = 46] = "H6", t[t.HEAD = 47] = "HEAD", t[t.HEADER = 48] = "HEADER", t[t.HGROUP = 49] = "HGROUP", t[t.HR = 50] = "HR", t[t.HTML = 51] = "HTML", t[t.I = 52] = "I", t[t.IMG = 53] = "IMG", t[t.IMAGE = 54] = "IMAGE", t[t.INPUT = 55] = "INPUT", t[t.IFRAME = 56] = "IFRAME", t[t.KEYGEN = 57] = "KEYGEN", t[t.LABEL = 58] = "LABEL", t[t.LI = 59] = "LI", t[t.LINK = 60] = "LINK", t[t.LISTING = 61] = "LISTING", t[t.MAIN = 62] = "MAIN", t[t.MALIGNMARK = 63] = "MALIGNMARK", t[t.MARQUEE = 64] = "MARQUEE", t[t.MATH = 65] = "MATH", t[t.MENU = 66] = "MENU", t[t.META = 67] = "META", t[t.MGLYPH = 68] = "MGLYPH", t[t.MI = 69] = "MI", t[t.MO = 70] = "MO", t[t.MN = 71] = "MN", t[t.MS = 72] = "MS", t[t.MTEXT = 73] = "MTEXT", t[t.NAV = 74] = "NAV", t[t.NOBR = 75] = "NOBR", t[t.NOFRAMES = 76] = "NOFRAMES", t[t.NOEMBED = 77] = "NOEMBED", t[t.NOSCRIPT = 78] = "NOSCRIPT", t[t.OBJECT = 79] = "OBJECT", t[t.OL = 80] = "OL", t[t.OPTGROUP = 81] = "OPTGROUP", t[t.OPTION = 82] = "OPTION", t[t.P = 83] = "P", t[t.PARAM = 84] = "PARAM", t[t.PLAINTEXT = 85] = "PLAINTEXT", t[t.PRE = 86] = "PRE", t[t.RB = 87] = "RB", t[t.RP = 88] = "RP", t[t.RT = 89] = "RT", t[t.RTC = 90] = "RTC", t[t.RUBY = 91] = "RUBY", t[t.S = 92] = "S", t[t.SCRIPT = 93] = "SCRIPT", t[t.SEARCH = 94] = "SEARCH", t[t.SECTION = 95] = "SECTION", t[t.SELECT = 96] = "SELECT", t[t.SOURCE = 97] = "SOURCE", t[t.SMALL = 98] = "SMALL", t[t.SPAN = 99] = "SPAN", t[t.STRIKE = 100] = "STRIKE", t[t.STRONG = 101] = "STRONG", t[t.STYLE = 102] = "STYLE", t[t.SUB = 103] = "SUB", t[t.SUMMARY = 104] = "SUMMARY", t[t.SUP = 105] = "SUP", t[t.TABLE = 106] = "TABLE", t[t.TBODY = 107] = "TBODY", t[t.TEMPLATE = 108] = "TEMPLATE", t[t.TEXTAREA = 109] = "TEXTAREA", t[t.TFOOT = 110] = "TFOOT", t[t.TD = 111] = "TD", t[t.TH = 112] = "TH", t[t.THEAD = 113] = "THEAD", t[t.TITLE = 114] = "TITLE", t[t.TR = 115] = "TR", t[t.TRACK = 116] = "TRACK", t[t.TT = 117] = "TT", t[t.U = 118] = "U", t[t.UL = 119] = "UL", t[t.SVG = 120] = "SVG", t[t.VAR = 121] = "VAR", t[t.WBR = 122] = "WBR", t[t.XMP = 123] = "XMP";
})(E || (E = {}));
const jL = /* @__PURE__ */ new Map([
  [W.A, E.A],
  [W.ADDRESS, E.ADDRESS],
  [W.ANNOTATION_XML, E.ANNOTATION_XML],
  [W.APPLET, E.APPLET],
  [W.AREA, E.AREA],
  [W.ARTICLE, E.ARTICLE],
  [W.ASIDE, E.ASIDE],
  [W.B, E.B],
  [W.BASE, E.BASE],
  [W.BASEFONT, E.BASEFONT],
  [W.BGSOUND, E.BGSOUND],
  [W.BIG, E.BIG],
  [W.BLOCKQUOTE, E.BLOCKQUOTE],
  [W.BODY, E.BODY],
  [W.BR, E.BR],
  [W.BUTTON, E.BUTTON],
  [W.CAPTION, E.CAPTION],
  [W.CENTER, E.CENTER],
  [W.CODE, E.CODE],
  [W.COL, E.COL],
  [W.COLGROUP, E.COLGROUP],
  [W.DD, E.DD],
  [W.DESC, E.DESC],
  [W.DETAILS, E.DETAILS],
  [W.DIALOG, E.DIALOG],
  [W.DIR, E.DIR],
  [W.DIV, E.DIV],
  [W.DL, E.DL],
  [W.DT, E.DT],
  [W.EM, E.EM],
  [W.EMBED, E.EMBED],
  [W.FIELDSET, E.FIELDSET],
  [W.FIGCAPTION, E.FIGCAPTION],
  [W.FIGURE, E.FIGURE],
  [W.FONT, E.FONT],
  [W.FOOTER, E.FOOTER],
  [W.FOREIGN_OBJECT, E.FOREIGN_OBJECT],
  [W.FORM, E.FORM],
  [W.FRAME, E.FRAME],
  [W.FRAMESET, E.FRAMESET],
  [W.H1, E.H1],
  [W.H2, E.H2],
  [W.H3, E.H3],
  [W.H4, E.H4],
  [W.H5, E.H5],
  [W.H6, E.H6],
  [W.HEAD, E.HEAD],
  [W.HEADER, E.HEADER],
  [W.HGROUP, E.HGROUP],
  [W.HR, E.HR],
  [W.HTML, E.HTML],
  [W.I, E.I],
  [W.IMG, E.IMG],
  [W.IMAGE, E.IMAGE],
  [W.INPUT, E.INPUT],
  [W.IFRAME, E.IFRAME],
  [W.KEYGEN, E.KEYGEN],
  [W.LABEL, E.LABEL],
  [W.LI, E.LI],
  [W.LINK, E.LINK],
  [W.LISTING, E.LISTING],
  [W.MAIN, E.MAIN],
  [W.MALIGNMARK, E.MALIGNMARK],
  [W.MARQUEE, E.MARQUEE],
  [W.MATH, E.MATH],
  [W.MENU, E.MENU],
  [W.META, E.META],
  [W.MGLYPH, E.MGLYPH],
  [W.MI, E.MI],
  [W.MO, E.MO],
  [W.MN, E.MN],
  [W.MS, E.MS],
  [W.MTEXT, E.MTEXT],
  [W.NAV, E.NAV],
  [W.NOBR, E.NOBR],
  [W.NOFRAMES, E.NOFRAMES],
  [W.NOEMBED, E.NOEMBED],
  [W.NOSCRIPT, E.NOSCRIPT],
  [W.OBJECT, E.OBJECT],
  [W.OL, E.OL],
  [W.OPTGROUP, E.OPTGROUP],
  [W.OPTION, E.OPTION],
  [W.P, E.P],
  [W.PARAM, E.PARAM],
  [W.PLAINTEXT, E.PLAINTEXT],
  [W.PRE, E.PRE],
  [W.RB, E.RB],
  [W.RP, E.RP],
  [W.RT, E.RT],
  [W.RTC, E.RTC],
  [W.RUBY, E.RUBY],
  [W.S, E.S],
  [W.SCRIPT, E.SCRIPT],
  [W.SEARCH, E.SEARCH],
  [W.SECTION, E.SECTION],
  [W.SELECT, E.SELECT],
  [W.SOURCE, E.SOURCE],
  [W.SMALL, E.SMALL],
  [W.SPAN, E.SPAN],
  [W.STRIKE, E.STRIKE],
  [W.STRONG, E.STRONG],
  [W.STYLE, E.STYLE],
  [W.SUB, E.SUB],
  [W.SUMMARY, E.SUMMARY],
  [W.SUP, E.SUP],
  [W.TABLE, E.TABLE],
  [W.TBODY, E.TBODY],
  [W.TEMPLATE, E.TEMPLATE],
  [W.TEXTAREA, E.TEXTAREA],
  [W.TFOOT, E.TFOOT],
  [W.TD, E.TD],
  [W.TH, E.TH],
  [W.THEAD, E.THEAD],
  [W.TITLE, E.TITLE],
  [W.TR, E.TR],
  [W.TRACK, E.TRACK],
  [W.TT, E.TT],
  [W.U, E.U],
  [W.UL, E.UL],
  [W.SVG, E.SVG],
  [W.VAR, E.VAR],
  [W.WBR, E.WBR],
  [W.XMP, E.XMP]
]);
function Ts(t) {
  var e;
  return (e = jL.get(t)) !== null && e !== void 0 ? e : E.UNKNOWN;
}
const re = E, YL = {
  [ne.HTML]: /* @__PURE__ */ new Set([
    re.ADDRESS,
    re.APPLET,
    re.AREA,
    re.ARTICLE,
    re.ASIDE,
    re.BASE,
    re.BASEFONT,
    re.BGSOUND,
    re.BLOCKQUOTE,
    re.BODY,
    re.BR,
    re.BUTTON,
    re.CAPTION,
    re.CENTER,
    re.COL,
    re.COLGROUP,
    re.DD,
    re.DETAILS,
    re.DIR,
    re.DIV,
    re.DL,
    re.DT,
    re.EMBED,
    re.FIELDSET,
    re.FIGCAPTION,
    re.FIGURE,
    re.FOOTER,
    re.FORM,
    re.FRAME,
    re.FRAMESET,
    re.H1,
    re.H2,
    re.H3,
    re.H4,
    re.H5,
    re.H6,
    re.HEAD,
    re.HEADER,
    re.HGROUP,
    re.HR,
    re.HTML,
    re.IFRAME,
    re.IMG,
    re.INPUT,
    re.LI,
    re.LINK,
    re.LISTING,
    re.MAIN,
    re.MARQUEE,
    re.MENU,
    re.META,
    re.NAV,
    re.NOEMBED,
    re.NOFRAMES,
    re.NOSCRIPT,
    re.OBJECT,
    re.OL,
    re.P,
    re.PARAM,
    re.PLAINTEXT,
    re.PRE,
    re.SCRIPT,
    re.SECTION,
    re.SELECT,
    re.SOURCE,
    re.STYLE,
    re.SUMMARY,
    re.TABLE,
    re.TBODY,
    re.TD,
    re.TEMPLATE,
    re.TEXTAREA,
    re.TFOOT,
    re.TH,
    re.THEAD,
    re.TITLE,
    re.TR,
    re.TRACK,
    re.UL,
    re.WBR,
    re.XMP
  ]),
  [ne.MATHML]: /* @__PURE__ */ new Set([re.MI, re.MO, re.MN, re.MS, re.MTEXT, re.ANNOTATION_XML]),
  [ne.SVG]: /* @__PURE__ */ new Set([re.TITLE, re.FOREIGN_OBJECT, re.DESC]),
  [ne.XLINK]: /* @__PURE__ */ new Set(),
  [ne.XML]: /* @__PURE__ */ new Set(),
  [ne.XMLNS]: /* @__PURE__ */ new Set()
}, ld = /* @__PURE__ */ new Set([re.H1, re.H2, re.H3, re.H4, re.H5, re.H6]);
W.STYLE, W.SCRIPT, W.XMP, W.IFRAME, W.NOEMBED, W.NOFRAMES, W.PLAINTEXT;
var F;
(function(t) {
  t[t.DATA = 0] = "DATA", t[t.RCDATA = 1] = "RCDATA", t[t.RAWTEXT = 2] = "RAWTEXT", t[t.SCRIPT_DATA = 3] = "SCRIPT_DATA", t[t.PLAINTEXT = 4] = "PLAINTEXT", t[t.TAG_OPEN = 5] = "TAG_OPEN", t[t.END_TAG_OPEN = 6] = "END_TAG_OPEN", t[t.TAG_NAME = 7] = "TAG_NAME", t[t.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", t[t.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", t[t.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", t[t.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", t[t.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", t[t.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", t[t.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", t[t.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", t[t.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", t[t.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", t[t.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", t[t.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", t[t.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", t[t.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", t[t.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", t[t.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", t[t.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", t[t.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", t[t.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", t[t.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", t[t.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", t[t.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", t[t.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", t[t.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", t[t.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", t[t.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", t[t.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", t[t.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", t[t.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", t[t.COMMENT_START = 42] = "COMMENT_START", t[t.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", t[t.COMMENT = 44] = "COMMENT", t[t.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", t[t.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", t[t.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", t[t.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", t[t.COMMENT_END = 50] = "COMMENT_END", t[t.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", t[t.DOCTYPE = 52] = "DOCTYPE", t[t.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", t[t.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", t[t.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", t[t.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", t[t.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", t[t.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", t[t.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", t[t.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", t[t.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", t[t.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", t[t.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", t[t.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", t[t.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", t[t.CDATA_SECTION = 68] = "CDATA_SECTION", t[t.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", t[t.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", t[t.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", t[t.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(F || (F = {}));
const dt = {
  DATA: F.DATA,
  RCDATA: F.RCDATA,
  RAWTEXT: F.RAWTEXT,
  SCRIPT_DATA: F.SCRIPT_DATA,
  PLAINTEXT: F.PLAINTEXT,
  CDATA_SECTION: F.CDATA_SECTION
};
function XL(t) {
  return t >= O.DIGIT_0 && t <= O.DIGIT_9;
}
function Ws(t) {
  return t >= O.LATIN_CAPITAL_A && t <= O.LATIN_CAPITAL_Z;
}
function QL(t) {
  return t >= O.LATIN_SMALL_A && t <= O.LATIN_SMALL_Z;
}
function Ar(t) {
  return QL(t) || Ws(t);
}
function K0(t) {
  return Ar(t) || XL(t);
}
function to(t) {
  return t + 32;
}
function EE(t) {
  return t === O.SPACE || t === O.LINE_FEED || t === O.TABULATION || t === O.FORM_FEED;
}
function j0(t) {
  return EE(t) || t === O.SOLIDUS || t === O.GREATER_THAN_SIGN;
}
function ZL(t) {
  return t === O.NULL ? j.nullCharacterReference : t > 1114111 ? j.characterReferenceOutsideUnicodeRange : mE(t) ? j.surrogateCharacterReference : gE(t) ? j.noncharacterCharacterReference : pE(t) || t === O.CARRIAGE_RETURN ? j.controlCharacterReference : null;
}
let JL = class {
  constructor(e, n) {
    this.options = e, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = F.DATA, this.returnState = F.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new BL(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new WL($L, (r, i) => {
      this.preprocessor.pos = this.entityStartPos + i - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(j.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(j.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const i = ZL(r);
        i && this._err(i, 1);
      }
    } : void 0);
  }
  //Errors
  _err(e, n = 0) {
    var r, i;
    (i = (r = this.handler).onParseError) === null || i === void 0 || i.call(r, this.preprocessor.getError(e, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(e) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - e,
      startOffset: this.preprocessor.offset - e,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const e = this._consume();
        this._ensureHibernation() || this._callState(e);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(e) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || e == null || e());
  }
  write(e, n, r) {
    this.active = !0, this.preprocessor.write(e, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(e) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(e) {
    this.consumedAfterSnapshot += e;
    for (let n = 0; n < e; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(e, n) {
    return this.preprocessor.startsWith(e, n) ? (this._advanceBy(e.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Fe.START_TAG,
      tagName: "",
      tagID: E.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Fe.END_TAG,
      tagName: "",
      tagID: E.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(e) {
    this.currentToken = {
      type: Fe.COMMENT,
      data: "",
      location: this.getCurrentLocation(e)
    };
  }
  _createDoctypeToken(e) {
    this.currentToken = {
      type: Fe.DOCTYPE,
      name: e,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(e, n) {
    this.currentCharacterToken = {
      type: e,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(e) {
    this.currentAttr = {
      name: e,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var e, n;
    const r = this.currentToken;
    if (bE(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const i = (e = (n = r.location).attrs) !== null && e !== void 0 ? e : n.attrs = /* @__PURE__ */ Object.create(null);
        i[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(j.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(e) {
    this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const e = this.currentToken;
    this.prepareToken(e), e.tagID = Ts(e.tagName), e.type === Fe.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(j.endTagWithAttributes), e.selfClosing && this._err(j.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(e) {
    this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(e) {
    this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(e) {
    if (this.currentCharacterToken) {
      switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) {
        case Fe.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case Fe.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case Fe.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const e = this.getCurrentLocation(0);
    e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: Fe.EOF, location: e }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(e, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === e) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(e, n);
  }
  _emitCodePoint(e) {
    const n = EE(e) ? Fe.WHITESPACE_CHARACTER : e === O.NULL ? Fe.NULL_CHARACTER : Fe.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(e));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(e) {
    this._appendCharToCurrentCharacterToken(Fe.CHARACTER, e);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = F.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? lr.Attribute : lr.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === F.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === F.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === F.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(e) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(e) {
    switch (this.state) {
      case F.DATA: {
        this._stateData(e);
        break;
      }
      case F.RCDATA: {
        this._stateRcdata(e);
        break;
      }
      case F.RAWTEXT: {
        this._stateRawtext(e);
        break;
      }
      case F.SCRIPT_DATA: {
        this._stateScriptData(e);
        break;
      }
      case F.PLAINTEXT: {
        this._statePlaintext(e);
        break;
      }
      case F.TAG_OPEN: {
        this._stateTagOpen(e);
        break;
      }
      case F.END_TAG_OPEN: {
        this._stateEndTagOpen(e);
        break;
      }
      case F.TAG_NAME: {
        this._stateTagName(e);
        break;
      }
      case F.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(e);
        break;
      }
      case F.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(e);
        break;
      }
      case F.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(e);
        break;
      }
      case F.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(e);
        break;
      }
      case F.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(e);
        break;
      }
      case F.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(e);
        break;
      }
      case F.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(e);
        break;
      }
      case F.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(e);
        break;
      }
      case F.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(e);
        break;
      }
      case F.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(e);
        break;
      }
      case F.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(e);
        break;
      }
      case F.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(e);
        break;
      }
      case F.ATTRIBUTE_NAME: {
        this._stateAttributeName(e);
        break;
      }
      case F.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(e);
        break;
      }
      case F.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(e);
        break;
      }
      case F.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(e);
        break;
      }
      case F.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(e);
        break;
      }
      case F.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(e);
        break;
      }
      case F.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(e);
        break;
      }
      case F.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(e);
        break;
      }
      case F.BOGUS_COMMENT: {
        this._stateBogusComment(e);
        break;
      }
      case F.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(e);
        break;
      }
      case F.COMMENT_START: {
        this._stateCommentStart(e);
        break;
      }
      case F.COMMENT_START_DASH: {
        this._stateCommentStartDash(e);
        break;
      }
      case F.COMMENT: {
        this._stateComment(e);
        break;
      }
      case F.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(e);
        break;
      }
      case F.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(e);
        break;
      }
      case F.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(e);
        break;
      }
      case F.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(e);
        break;
      }
      case F.COMMENT_END_DASH: {
        this._stateCommentEndDash(e);
        break;
      }
      case F.COMMENT_END: {
        this._stateCommentEnd(e);
        break;
      }
      case F.COMMENT_END_BANG: {
        this._stateCommentEndBang(e);
        break;
      }
      case F.DOCTYPE: {
        this._stateDoctype(e);
        break;
      }
      case F.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(e);
        break;
      }
      case F.DOCTYPE_NAME: {
        this._stateDoctypeName(e);
        break;
      }
      case F.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(e);
        break;
      }
      case F.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(e);
        break;
      }
      case F.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(e);
        break;
      }
      case F.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(e);
        break;
      }
      case F.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(e);
        break;
      }
      case F.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(e);
        break;
      }
      case F.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
        break;
      }
      case F.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(e);
        break;
      }
      case F.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(e);
        break;
      }
      case F.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(e);
        break;
      }
      case F.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(e);
        break;
      }
      case F.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(e);
        break;
      }
      case F.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(e);
        break;
      }
      case F.CDATA_SECTION: {
        this._stateCdataSection(e);
        break;
      }
      case F.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(e);
        break;
      }
      case F.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(e);
        break;
      }
      case F.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case F.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(e);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(e) {
    switch (e) {
      case O.LESS_THAN_SIGN: {
        this.state = F.TAG_OPEN;
        break;
      }
      case O.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitCodePoint(e);
        break;
      }
      case O.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(e) {
    switch (e) {
      case O.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(e) {
    switch (e) {
      case O.LESS_THAN_SIGN: {
        this.state = F.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(e) {
    switch (e) {
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(e) {
    switch (e) {
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(e) {
    if (Ar(e))
      this._createStartTagToken(), this.state = F.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case O.EXCLAMATION_MARK: {
          this.state = F.MARKUP_DECLARATION_OPEN;
          break;
        }
        case O.SOLIDUS: {
          this.state = F.END_TAG_OPEN;
          break;
        }
        case O.QUESTION_MARK: {
          this._err(j.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = F.BOGUS_COMMENT, this._stateBogusComment(e);
          break;
        }
        case O.EOF: {
          this._err(j.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(j.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = F.DATA, this._stateData(e);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(e) {
    if (Ar(e))
      this._createEndTagToken(), this.state = F.TAG_NAME, this._stateTagName(e);
    else
      switch (e) {
        case O.GREATER_THAN_SIGN: {
          this._err(j.missingEndTagName), this.state = F.DATA;
          break;
        }
        case O.EOF: {
          this._err(j.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(j.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = F.BOGUS_COMMENT, this._stateBogusComment(e);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case O.SOLIDUS: {
        this.state = F.SELF_CLOSING_START_TAG;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.tagName += ot;
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Ws(e) ? to(e) : e);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(e) {
    e === O.SOLIDUS ? this.state = F.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = F.RCDATA, this._stateRcdata(e));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(e) {
    Ar(e) ? (this.state = F.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = F.RCDATA, this._stateRcdata(e));
  }
  handleSpecialEndTag(e) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = F.BEFORE_ATTRIBUTE_NAME, !1;
      case O.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = F.SELF_CLOSING_START_TAG, !1;
      case O.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = F.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = F.RCDATA, this._stateRcdata(e));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(e) {
    e === O.SOLIDUS ? this.state = F.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = F.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(e) {
    Ar(e) ? (this.state = F.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = F.RAWTEXT, this._stateRawtext(e));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = F.RAWTEXT, this._stateRawtext(e));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(e) {
    switch (e) {
      case O.SOLIDUS: {
        this.state = F.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case O.EXCLAMATION_MARK: {
        this.state = F.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = F.SCRIPT_DATA, this._stateScriptData(e);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(e) {
    Ar(e) ? (this.state = F.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = F.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = F.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(e) {
    e === O.HYPHEN_MINUS ? (this.state = F.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = F.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(e) {
    e === O.HYPHEN_MINUS ? (this.state = F.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = F.SCRIPT_DATA, this._stateScriptData(e));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = F.SCRIPT_DATA_ESCAPED, this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = F.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = F.SCRIPT_DATA_ESCAPED, this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = F.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(e) {
    e === O.SOLIDUS ? this.state = F.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ar(e) ? (this._emitChars("<"), this.state = F.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = F.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(e) {
    Ar(e) ? (this.state = F.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = F.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(e) {
    this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = F.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(e) {
    if (this.preprocessor.startsWith(Ut.SCRIPT, !1) && j0(this.preprocessor.peek(Ut.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < Ut.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = F.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case O.LESS_THAN_SIGN: {
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(ot);
        break;
      }
      case O.EOF: {
        this._err(j.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(e) {
    e === O.SOLIDUS ? (this.state = F.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(e) {
    if (this.preprocessor.startsWith(Ut.SCRIPT, !1) && j0(this.preprocessor.peek(Ut.SCRIPT.length))) {
      this._emitCodePoint(e);
      for (let n = 0; n < Ut.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = F.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = F.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.SOLIDUS:
      case O.GREATER_THAN_SIGN:
      case O.EOF: {
        this.state = F.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case O.EQUALS_SIGN: {
        this._err(j.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = F.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = F.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
      case O.SOLIDUS:
      case O.GREATER_THAN_SIGN:
      case O.EOF: {
        this._leaveAttrName(), this.state = F.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e);
        break;
      }
      case O.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = F.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case O.QUOTATION_MARK:
      case O.APOSTROPHE:
      case O.LESS_THAN_SIGN: {
        this._err(j.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e);
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.name += ot;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Ws(e) ? to(e) : e);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.SOLIDUS: {
        this.state = F.SELF_CLOSING_START_TAG;
        break;
      }
      case O.EQUALS_SIGN: {
        this.state = F.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = F.ATTRIBUTE_NAME, this._stateAttributeName(e);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.QUOTATION_MARK: {
        this.state = F.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        this.state = F.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.missingAttributeValue), this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = F.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(e) {
    switch (e) {
      case O.QUOTATION_MARK: {
        this.state = F.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case O.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += ot;
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(e) {
    switch (e) {
      case O.APOSTROPHE: {
        this.state = F.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case O.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += ot;
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this._leaveAttrValue(), this.state = F.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case O.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), this.currentAttr.value += ot;
        break;
      }
      case O.QUOTATION_MARK:
      case O.APOSTROPHE:
      case O.LESS_THAN_SIGN:
      case O.EQUALS_SIGN:
      case O.GRAVE_ACCENT: {
        this._err(j.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e);
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(e);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this._leaveAttrValue(), this.state = F.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case O.SOLIDUS: {
        this._leaveAttrValue(), this.state = F.SELF_CLOSING_START_TAG;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingWhitespaceBetweenAttributes), this.state = F.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(e) {
    switch (e) {
      case O.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = F.DATA, this.emitCurrentTagToken();
        break;
      }
      case O.EOF: {
        this._err(j.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.unexpectedSolidusInTag), this.state = F.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(e) {
    const n = this.currentToken;
    switch (e) {
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentComment(n);
        break;
      }
      case O.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.data += ot;
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(e) {
    this._consumeSequenceIfMatch(Ut.DASH_DASH, !0) ? (this._createCommentToken(Ut.DASH_DASH.length + 1), this.state = F.COMMENT_START) : this._consumeSequenceIfMatch(Ut.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(Ut.DOCTYPE.length + 1), this.state = F.DOCTYPE) : this._consumeSequenceIfMatch(Ut.CDATA_START, !0) ? this.inForeignNode ? this.state = F.CDATA_SECTION : (this._err(j.cdataInHtmlContent), this._createCommentToken(Ut.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = F.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(j.incorrectlyOpenedComment), this._createCommentToken(2), this.state = F.BOGUS_COMMENT, this._stateBogusComment(e));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(e) {
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.COMMENT_START_DASH;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptClosingOfEmptyComment), this.state = F.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(e) {
    const n = this.currentToken;
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.COMMENT_END;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptClosingOfEmptyComment), this.state = F.DATA, this.emitCurrentComment(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(e) {
    const n = this.currentToken;
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.COMMENT_END_DASH;
        break;
      }
      case O.LESS_THAN_SIGN: {
        n.data += "<", this.state = F.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.data += ot;
        break;
      }
      case O.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(e);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(e) {
    const n = this.currentToken;
    switch (e) {
      case O.EXCLAMATION_MARK: {
        n.data += "!", this.state = F.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case O.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(e) {
    e === O.HYPHEN_MINUS ? this.state = F.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = F.COMMENT, this._stateComment(e));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(e) {
    e === O.HYPHEN_MINUS ? this.state = F.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = F.COMMENT_END_DASH, this._stateCommentEndDash(e));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(e) {
    e !== O.GREATER_THAN_SIGN && e !== O.EOF && this._err(j.nestedComment), this.state = F.COMMENT_END, this._stateCommentEnd(e);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(e) {
    const n = this.currentToken;
    switch (e) {
      case O.HYPHEN_MINUS: {
        this.state = F.COMMENT_END;
        break;
      }
      case O.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(e) {
    const n = this.currentToken;
    switch (e) {
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentComment(n);
        break;
      }
      case O.EXCLAMATION_MARK: {
        this.state = F.COMMENT_END_BANG;
        break;
      }
      case O.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case O.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(e) {
    const n = this.currentToken;
    switch (e) {
      case O.HYPHEN_MINUS: {
        n.data += "--!", this.state = F.COMMENT_END_DASH;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.incorrectlyClosedComment), this.state = F.DATA, this.emitCurrentComment(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = F.COMMENT, this._stateComment(e);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(e) {
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.BEFORE_DOCTYPE_NAME;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingWhitespaceBeforeDoctypeName), this.state = F.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(e) {
    if (Ws(e))
      this._createDoctypeToken(String.fromCharCode(to(e))), this.state = F.DOCTYPE_NAME;
    else
      switch (e) {
        case O.SPACE:
        case O.LINE_FEED:
        case O.TABULATION:
        case O.FORM_FEED:
          break;
        case O.NULL: {
          this._err(j.unexpectedNullCharacter), this._createDoctypeToken(ot), this.state = F.DOCTYPE_NAME;
          break;
        }
        case O.GREATER_THAN_SIGN: {
          this._err(j.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = F.DATA;
          break;
        }
        case O.EOF: {
          this._err(j.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(e)), this.state = F.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.AFTER_DOCTYPE_NAME;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.name += ot;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Ws(e) ? to(e) : e);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Ut.PUBLIC, !1) ? this.state = F.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Ut.SYSTEM, !1) ? this.state = F.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(j.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case O.QUOTATION_MARK: {
        this._err(j.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = F.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        this._err(j.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = F.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.QUOTATION_MARK: {
        n.publicId = "", this.state = F.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        n.publicId = "", this.state = F.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case O.QUOTATION_MARK: {
        this.state = F.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.publicId += ot;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case O.APOSTROPHE: {
        this.state = F.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.publicId += ot;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.QUOTATION_MARK: {
        this._err(j.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        this._err(j.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.QUOTATION_MARK: {
        n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED: {
        this.state = F.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case O.QUOTATION_MARK: {
        this._err(j.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        this._err(j.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.QUOTATION_MARK: {
        n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case O.APOSTROPHE: {
        n.systemId = "", this.state = F.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case O.QUOTATION_MARK: {
        this.state = F.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.systemId += ot;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(e) {
    const n = this.currentToken;
    switch (e) {
      case O.APOSTROPHE: {
        this.state = F.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter), n.systemId += ot;
        break;
      }
      case O.GREATER_THAN_SIGN: {
        this._err(j.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(e);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(e) {
    const n = this.currentToken;
    switch (e) {
      case O.SPACE:
      case O.LINE_FEED:
      case O.TABULATION:
      case O.FORM_FEED:
        break;
      case O.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.EOF: {
        this._err(j.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(j.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = F.BOGUS_DOCTYPE, this._stateBogusDoctype(e);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(e) {
    const n = this.currentToken;
    switch (e) {
      case O.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = F.DATA;
        break;
      }
      case O.NULL: {
        this._err(j.unexpectedNullCharacter);
        break;
      }
      case O.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(e) {
    switch (e) {
      case O.RIGHT_SQUARE_BRACKET: {
        this.state = F.CDATA_SECTION_BRACKET;
        break;
      }
      case O.EOF: {
        this._err(j.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(e);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(e) {
    e === O.RIGHT_SQUARE_BRACKET ? this.state = F.CDATA_SECTION_END : (this._emitChars("]"), this.state = F.CDATA_SECTION, this._stateCdataSection(e));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(e) {
    switch (e) {
      case O.GREATER_THAN_SIGN: {
        this.state = F.DATA;
        break;
      }
      case O.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = F.CDATA_SECTION, this._stateCdataSection(e);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (e < 0)
      if (this.preprocessor.lastChunkWritten)
        e = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    e === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(O.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && K0(this.preprocessor.peek(1)) ? F.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(e) {
    K0(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === O.SEMICOLON && this._err(j.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e));
  }
};
const yE = /* @__PURE__ */ new Set([E.DD, E.DT, E.LI, E.OPTGROUP, E.OPTION, E.P, E.RB, E.RP, E.RT, E.RTC]), Y0 = /* @__PURE__ */ new Set([
  ...yE,
  E.CAPTION,
  E.COLGROUP,
  E.TBODY,
  E.TD,
  E.TFOOT,
  E.TH,
  E.THEAD,
  E.TR
]), pu = /* @__PURE__ */ new Set([
  E.APPLET,
  E.CAPTION,
  E.HTML,
  E.MARQUEE,
  E.OBJECT,
  E.TABLE,
  E.TD,
  E.TEMPLATE,
  E.TH
]), e_ = /* @__PURE__ */ new Set([...pu, E.OL, E.UL]), t_ = /* @__PURE__ */ new Set([...pu, E.BUTTON]), X0 = /* @__PURE__ */ new Set([E.ANNOTATION_XML, E.MI, E.MN, E.MO, E.MS, E.MTEXT]), Q0 = /* @__PURE__ */ new Set([E.DESC, E.FOREIGN_OBJECT, E.TITLE]), n_ = /* @__PURE__ */ new Set([E.TR, E.TEMPLATE, E.HTML]), r_ = /* @__PURE__ */ new Set([E.TBODY, E.TFOOT, E.THEAD, E.TEMPLATE, E.HTML]), i_ = /* @__PURE__ */ new Set([E.TABLE, E.TEMPLATE, E.HTML]), s_ = /* @__PURE__ */ new Set([E.TD, E.TH]);
class a_ {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(e, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = E.UNKNOWN, this.current = e;
  }
  //Index of element
  _indexOf(e) {
    return this.items.lastIndexOf(e, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === E.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === ne.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(e, n) {
    this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, n, !0);
  }
  pop() {
    const e = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0);
  }
  replace(e, n) {
    const r = this._indexOf(e);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(e, n, r) {
    const i = this._indexOf(e) + 1;
    this.items.splice(i, 0, n), this.tagIDs.splice(i, 0, r), this.stackTop++, i === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop);
  }
  popUntilTagNamePopped(e) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(e, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== ne.HTML);
    this.shortenToLength(Math.max(n, 0));
  }
  shortenToLength(e) {
    for (; this.stackTop >= e; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < e);
    }
  }
  popUntilElementPopped(e) {
    const n = this._indexOf(e);
    this.shortenToLength(Math.max(n, 0));
  }
  popUntilPopped(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(Math.max(r, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(ld, ne.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(s_, ne.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(e, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (e.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(e, n) {
    const r = this._indexOfTagNames(e, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(i_, ne.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(r_, ne.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(n_, ne.HTML);
  }
  remove(e) {
    const n = this._indexOf(e);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === E.BODY ? this.items[1] : null;
  }
  contains(e) {
    return this._indexOf(e) > -1;
  }
  getCommonAncestor(e) {
    const n = this._indexOf(e) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === E.HTML;
  }
  //Element in scope
  hasInDynamicScope(e, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case ne.HTML: {
          if (i === e)
            return !0;
          if (n.has(i))
            return !1;
          break;
        }
        case ne.SVG: {
          if (Q0.has(i))
            return !1;
          break;
        }
        case ne.MATHML: {
          if (X0.has(i))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(e) {
    return this.hasInDynamicScope(e, pu);
  }
  hasInListItemScope(e) {
    return this.hasInDynamicScope(e, e_);
  }
  hasInButtonScope(e) {
    return this.hasInDynamicScope(e, t_);
  }
  hasNumberedHeaderInScope() {
    for (let e = this.stackTop; e >= 0; e--) {
      const n = this.tagIDs[e];
      switch (this.treeAdapter.getNamespaceURI(this.items[e])) {
        case ne.HTML: {
          if (ld.has(n))
            return !0;
          if (pu.has(n))
            return !1;
          break;
        }
        case ne.SVG: {
          if (Q0.has(n))
            return !1;
          break;
        }
        case ne.MATHML: {
          if (X0.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === ne.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case E.TABLE:
          case E.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let e = this.stackTop; e >= 0; e--)
      if (this.treeAdapter.getNamespaceURI(this.items[e]) === ne.HTML)
        switch (this.tagIDs[e]) {
          case E.TBODY:
          case E.THEAD:
          case E.TFOOT:
            return !0;
          case E.TABLE:
          case E.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(e) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === ne.HTML)
        switch (this.tagIDs[n]) {
          case e:
            return !0;
          case E.OPTION:
          case E.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && yE.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && Y0.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(e) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== e && Y0.has(this.currentTagId); )
      this.pop();
  }
}
const ql = 3;
var Nn;
(function(t) {
  t[t.Marker = 0] = "Marker", t[t.Element = 1] = "Element";
})(Nn || (Nn = {}));
const Z0 = { type: Nn.Marker };
class o_ {
  constructor(e) {
    this.treeAdapter = e, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(e, n) {
    const r = [], i = n.length, s = this.treeAdapter.getTagName(e), a = this.treeAdapter.getNamespaceURI(e);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === Nn.Marker)
        break;
      const { element: l } = u;
      if (this.treeAdapter.getTagName(l) === s && this.treeAdapter.getNamespaceURI(l) === a) {
        const c = this.treeAdapter.getAttrList(l);
        c.length === i && r.push({ idx: o, attrs: c });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(e) {
    if (this.entries.length < ql)
      return;
    const n = this.treeAdapter.getAttrList(e), r = this._getNoahArkConditionCandidates(e, n);
    if (r.length < ql)
      return;
    const i = new Map(n.map((a) => [a.name, a.value]));
    let s = 0;
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      o.attrs.every((u) => i.get(u.name) === u.value) && (s += 1, s >= ql && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Z0);
  }
  pushElement(e, n) {
    this._ensureNoahArkCondition(e), this.entries.unshift({
      type: Nn.Element,
      element: e,
      token: n
    });
  }
  insertElementAfterBookmark(e, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: Nn.Element,
      element: e,
      token: n
    });
  }
  removeEntry(e) {
    const n = this.entries.indexOf(e);
    n !== -1 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const e = this.entries.indexOf(Z0);
    e === -1 ? this.entries.length = 0 : this.entries.splice(0, e + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(e) {
    const n = this.entries.find((r) => r.type === Nn.Marker || this.treeAdapter.getTagName(r.element) === e);
    return n && n.type === Nn.Element ? n : null;
  }
  getElementEntry(e) {
    return this.entries.find((n) => n.type === Nn.Element && n.element === e);
  }
}
const Ir = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: mn.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(t, e, n) {
    return {
      nodeName: t,
      tagName: t,
      attrs: n,
      namespaceURI: e,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(t) {
    return {
      nodeName: "#comment",
      data: t,
      parentNode: null
    };
  },
  createTextNode(t) {
    return {
      nodeName: "#text",
      value: t,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(t, e) {
    t.childNodes.push(e), e.parentNode = t;
  },
  insertBefore(t, e, n) {
    const r = t.childNodes.indexOf(n);
    t.childNodes.splice(r, 0, e), e.parentNode = t;
  },
  setTemplateContent(t, e) {
    t.content = e;
  },
  getTemplateContent(t) {
    return t.content;
  },
  setDocumentType(t, e, n, r) {
    const i = t.childNodes.find((s) => s.nodeName === "#documentType");
    if (i)
      i.name = e, i.publicId = n, i.systemId = r;
    else {
      const s = {
        nodeName: "#documentType",
        name: e,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Ir.appendChild(t, s);
    }
  },
  setDocumentMode(t, e) {
    t.mode = e;
  },
  getDocumentMode(t) {
    return t.mode;
  },
  detachNode(t) {
    if (t.parentNode) {
      const e = t.parentNode.childNodes.indexOf(t);
      t.parentNode.childNodes.splice(e, 1), t.parentNode = null;
    }
  },
  insertText(t, e) {
    if (t.childNodes.length > 0) {
      const n = t.childNodes[t.childNodes.length - 1];
      if (Ir.isTextNode(n)) {
        n.value += e;
        return;
      }
    }
    Ir.appendChild(t, Ir.createTextNode(e));
  },
  insertTextBefore(t, e, n) {
    const r = t.childNodes[t.childNodes.indexOf(n) - 1];
    r && Ir.isTextNode(r) ? r.value += e : Ir.insertBefore(t, Ir.createTextNode(e), n);
  },
  adoptAttributes(t, e) {
    const n = new Set(t.attrs.map((r) => r.name));
    for (let r = 0; r < e.length; r++)
      n.has(e[r].name) || t.attrs.push(e[r]);
  },
  //Tree traversing
  getFirstChild(t) {
    return t.childNodes[0];
  },
  getChildNodes(t) {
    return t.childNodes;
  },
  getParentNode(t) {
    return t.parentNode;
  },
  getAttrList(t) {
    return t.attrs;
  },
  //Node data
  getTagName(t) {
    return t.tagName;
  },
  getNamespaceURI(t) {
    return t.namespaceURI;
  },
  getTextNodeContent(t) {
    return t.value;
  },
  getCommentNodeContent(t) {
    return t.data;
  },
  getDocumentTypeNodeName(t) {
    return t.name;
  },
  getDocumentTypeNodePublicId(t) {
    return t.publicId;
  },
  getDocumentTypeNodeSystemId(t) {
    return t.systemId;
  },
  //Node types
  isTextNode(t) {
    return t.nodeName === "#text";
  },
  isCommentNode(t) {
    return t.nodeName === "#comment";
  },
  isDocumentTypeNode(t) {
    return t.nodeName === "#documentType";
  },
  isElementNode(t) {
    return Object.prototype.hasOwnProperty.call(t, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = e;
  },
  getNodeSourceCodeLocation(t) {
    return t.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(t, e) {
    t.sourceCodeLocation = { ...t.sourceCodeLocation, ...e };
  }
}, TE = "html", u_ = "about:legacy-compat", l_ = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", SE = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], c_ = [
  ...SE,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], d_ = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), xE = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], f_ = [
  ...xE,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function J0(t, e) {
  return e.some((n) => t.startsWith(n));
}
function h_(t) {
  return t.name === TE && t.publicId === null && (t.systemId === null || t.systemId === u_);
}
function m_(t) {
  if (t.name !== TE)
    return mn.QUIRKS;
  const { systemId: e } = t;
  if (e && e.toLowerCase() === l_)
    return mn.QUIRKS;
  let { publicId: n } = t;
  if (n !== null) {
    if (n = n.toLowerCase(), d_.has(n))
      return mn.QUIRKS;
    let r = e === null ? c_ : SE;
    if (J0(n, r))
      return mn.QUIRKS;
    if (r = e === null ? xE : f_, J0(n, r))
      return mn.LIMITED_QUIRKS;
  }
  return mn.NO_QUIRKS;
}
const em = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, p_ = "definitionurl", g_ = "definitionURL", b_ = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), E_ = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: ne.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: ne.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: ne.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: ne.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: ne.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: ne.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: ne.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: ne.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: ne.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: ne.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: ne.XMLNS }]
]), y_ = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), T_ = /* @__PURE__ */ new Set([
  E.B,
  E.BIG,
  E.BLOCKQUOTE,
  E.BODY,
  E.BR,
  E.CENTER,
  E.CODE,
  E.DD,
  E.DIV,
  E.DL,
  E.DT,
  E.EM,
  E.EMBED,
  E.H1,
  E.H2,
  E.H3,
  E.H4,
  E.H5,
  E.H6,
  E.HEAD,
  E.HR,
  E.I,
  E.IMG,
  E.LI,
  E.LISTING,
  E.MENU,
  E.META,
  E.NOBR,
  E.OL,
  E.P,
  E.PRE,
  E.RUBY,
  E.S,
  E.SMALL,
  E.SPAN,
  E.STRONG,
  E.STRIKE,
  E.SUB,
  E.SUP,
  E.TABLE,
  E.TT,
  E.U,
  E.UL,
  E.VAR
]);
function S_(t) {
  const e = t.tagID;
  return e === E.FONT && t.attrs.some(({ name: r }) => r === ei.COLOR || r === ei.SIZE || r === ei.FACE) || T_.has(e);
}
function vE(t) {
  for (let e = 0; e < t.attrs.length; e++)
    if (t.attrs[e].name === p_) {
      t.attrs[e].name = g_;
      break;
    }
}
function AE(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = b_.get(t.attrs[e].name);
    n != null && (t.attrs[e].name = n);
  }
}
function Kf(t) {
  for (let e = 0; e < t.attrs.length; e++) {
    const n = E_.get(t.attrs[e].name);
    n && (t.attrs[e].prefix = n.prefix, t.attrs[e].name = n.name, t.attrs[e].namespace = n.namespace);
  }
}
function x_(t) {
  const e = y_.get(t.tagName);
  e != null && (t.tagName = e, t.tagID = Ts(t.tagName));
}
function v_(t, e) {
  return e === ne.MATHML && (t === E.MI || t === E.MO || t === E.MN || t === E.MS || t === E.MTEXT);
}
function A_(t, e, n) {
  if (e === ne.MATHML && t === E.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === ei.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === em.TEXT_HTML || i === em.APPLICATION_XML;
      }
  }
  return e === ne.SVG && (t === E.FOREIGN_OBJECT || t === E.DESC || t === E.TITLE);
}
function I_(t, e, n, r) {
  return (!r || r === ne.HTML) && A_(t, e, n) || (!r || r === ne.MATHML) && v_(t, e);
}
const C_ = "hidden", L_ = 8, __ = 3;
var H;
(function(t) {
  t[t.INITIAL = 0] = "INITIAL", t[t.BEFORE_HTML = 1] = "BEFORE_HTML", t[t.BEFORE_HEAD = 2] = "BEFORE_HEAD", t[t.IN_HEAD = 3] = "IN_HEAD", t[t.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", t[t.AFTER_HEAD = 5] = "AFTER_HEAD", t[t.IN_BODY = 6] = "IN_BODY", t[t.TEXT = 7] = "TEXT", t[t.IN_TABLE = 8] = "IN_TABLE", t[t.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", t[t.IN_CAPTION = 10] = "IN_CAPTION", t[t.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", t[t.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", t[t.IN_ROW = 13] = "IN_ROW", t[t.IN_CELL = 14] = "IN_CELL", t[t.IN_SELECT = 15] = "IN_SELECT", t[t.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", t[t.IN_TEMPLATE = 17] = "IN_TEMPLATE", t[t.AFTER_BODY = 18] = "AFTER_BODY", t[t.IN_FRAMESET = 19] = "IN_FRAMESET", t[t.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", t[t.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", t[t.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(H || (H = {}));
const R_ = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, IE = /* @__PURE__ */ new Set([E.TABLE, E.TBODY, E.TFOOT, E.THEAD, E.TR]), tm = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Ir,
  onParseError: null
};
let nm = class {
  constructor(e, n, r = null, i = null) {
    this.fragmentContext = r, this.scriptHandler = i, this.currentToken = null, this.stopped = !1, this.insertionMode = H.INITIAL, this.originalInsertionMode = H.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...tm,
      ...e
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new JL(this.options, this), this.activeFormattingElements = new o_(this.treeAdapter), this.fragmentContextID = r ? Ts(this.treeAdapter.getTagName(r)) : E.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new a_(this.document, this.treeAdapter, this);
  }
  // API
  static parse(e, n) {
    const r = new this(n);
    return r.tokenizer.write(e, !0), r.document;
  }
  static getFragmentParser(e, n) {
    const r = {
      ...tm,
      ...n
    };
    e ?? (e = r.treeAdapter.createElement(W.TEMPLATE, ne.HTML, []));
    const i = r.treeAdapter.createElement("documentmock", ne.HTML, []), s = new this(r, i, e);
    return s.fragmentContextID === E.TEMPLATE && s.tmplInsertionModeStack.unshift(H.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s;
  }
  getFragment() {
    const e = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(e, n), n;
  }
  //Errors
  /** @internal */
  _err(e, n, r) {
    var i;
    if (!this.onParseError)
      return;
    const s = (i = e.location) !== null && i !== void 0 ? i : R_, a = {
      code: n,
      startLine: s.startLine,
      startCol: s.startCol,
      startOffset: s.startOffset,
      endLine: r ? s.startLine : s.endLine,
      endCol: r ? s.startCol : s.endCol,
      endOffset: r ? s.startOffset : s.endOffset
    };
    this.onParseError(a);
  }
  //Stack events
  /** @internal */
  onItemPush(e, n, r) {
    var i, s;
    (s = (i = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(i, e), r && this.openElements.stackTop > 0 && this._setContextModes(e, n);
  }
  /** @internal */
  onItemPop(e, n) {
    var r, i;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, e, this.openElements.current), n) {
      let s, a;
      this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext, a = this.fragmentContextID) : { current: s, currentTagId: a } = this.openElements, this._setContextModes(s, a);
    }
  }
  _setContextModes(e, n) {
    const r = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === ne.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && e !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, e);
  }
  /** @protected */
  _switchToTextParsing(e, n) {
    this._insertElement(e, ne.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = H.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = H.TEXT, this.originalInsertionMode = H.IN_BODY, this.tokenizer.state = dt.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let e = this.fragmentContext;
    for (; e; ) {
      if (this.treeAdapter.getTagName(e) === W.FORM) {
        this.formElement = e;
        break;
      }
      e = this.treeAdapter.getParentNode(e);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== ne.HTML))
      switch (this.fragmentContextID) {
        case E.TITLE:
        case E.TEXTAREA: {
          this.tokenizer.state = dt.RCDATA;
          break;
        }
        case E.STYLE:
        case E.XMP:
        case E.IFRAME:
        case E.NOEMBED:
        case E.NOFRAMES:
        case E.NOSCRIPT: {
          this.tokenizer.state = dt.RAWTEXT;
          break;
        }
        case E.SCRIPT: {
          this.tokenizer.state = dt.SCRIPT_DATA;
          break;
        }
        case E.PLAINTEXT: {
          this.tokenizer.state = dt.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(e) {
    const n = e.name || "", r = e.publicId || "", i = e.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, i), e.location) {
      const a = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      a && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
    }
  }
  /** @protected */
  _attachElementToTree(e, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(e, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(e);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r ?? this.document, e);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location);
  }
  /** @protected */
  _insertElement(e, n) {
    const r = this.treeAdapter.createElement(e.tagName, n, e.attrs);
    this._attachElementToTree(r, e.location), this.openElements.push(r, e.tagID);
  }
  /** @protected */
  _insertFakeElement(e, n) {
    const r = this.treeAdapter.createElement(e, ne.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(e) {
    const n = this.treeAdapter.createElement(e.tagName, ne.HTML, e.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const e = this.treeAdapter.createElement(W.HTML, ne.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, E.HTML);
  }
  /** @protected */
  _appendCommentNode(e, n) {
    const r = this.treeAdapter.createCommentNode(e.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, e.location);
  }
  /** @protected */
  _insertCharacters(e) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, e.chars, r) : this.treeAdapter.insertText(n, e.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, e.chars)), !e.location)
      return;
    const i = this.treeAdapter.getChildNodes(n), s = r ? i.lastIndexOf(r) : i.length, a = i[s - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(a)) {
      const { endLine: u, endCol: l, endOffset: c } = e.location;
      this.treeAdapter.updateNodeSourceCodeLocation(a, { endLine: u, endCol: l, endOffset: c });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(a, e.location);
  }
  /** @protected */
  _adoptNodes(e, n) {
    for (let r = this.treeAdapter.getFirstChild(e); r; r = this.treeAdapter.getFirstChild(e))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(e, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(e) && n.location) {
      const r = n.location, i = this.treeAdapter.getTagName(e), s = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === Fe.END_TAG && i === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(e, s);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(e) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, e.tagID === E.SVG && this.treeAdapter.getTagName(n) === W.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === ne.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (e.tagID === E.MGLYPH || e.tagID === E.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, ne.HTML)
    );
  }
  /** @protected */
  _processToken(e) {
    switch (e.type) {
      case Fe.CHARACTER: {
        this.onCharacter(e);
        break;
      }
      case Fe.NULL_CHARACTER: {
        this.onNullCharacter(e);
        break;
      }
      case Fe.COMMENT: {
        this.onComment(e);
        break;
      }
      case Fe.DOCTYPE: {
        this.onDoctype(e);
        break;
      }
      case Fe.START_TAG: {
        this._processStartTag(e);
        break;
      }
      case Fe.END_TAG: {
        this.onEndTag(e);
        break;
      }
      case Fe.EOF: {
        this.onEof(e);
        break;
      }
      case Fe.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(e);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(e, n, r) {
    const i = this.treeAdapter.getNamespaceURI(n), s = this.treeAdapter.getAttrList(n);
    return I_(e, i, s, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const e = this.activeFormattingElements.entries.length;
    if (e) {
      const n = this.activeFormattingElements.entries.findIndex((i) => i.type === Nn.Marker || this.openElements.contains(i.element)), r = n === -1 ? e - 1 : n - 1;
      for (let i = r; i >= 0; i--) {
        const s = this.activeFormattingElements.entries[i];
        this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)), s.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = H.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(E.P), this.openElements.popUntilTagNamePopped(E.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let e = this.openElements.stackTop; e >= 0; e--)
      switch (e === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
        case E.TR: {
          this.insertionMode = H.IN_ROW;
          return;
        }
        case E.TBODY:
        case E.THEAD:
        case E.TFOOT: {
          this.insertionMode = H.IN_TABLE_BODY;
          return;
        }
        case E.CAPTION: {
          this.insertionMode = H.IN_CAPTION;
          return;
        }
        case E.COLGROUP: {
          this.insertionMode = H.IN_COLUMN_GROUP;
          return;
        }
        case E.TABLE: {
          this.insertionMode = H.IN_TABLE;
          return;
        }
        case E.BODY: {
          this.insertionMode = H.IN_BODY;
          return;
        }
        case E.FRAMESET: {
          this.insertionMode = H.IN_FRAMESET;
          return;
        }
        case E.SELECT: {
          this._resetInsertionModeForSelect(e);
          return;
        }
        case E.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case E.HTML: {
          this.insertionMode = this.headElement ? H.AFTER_HEAD : H.BEFORE_HEAD;
          return;
        }
        case E.TD:
        case E.TH: {
          if (e > 0) {
            this.insertionMode = H.IN_CELL;
            return;
          }
          break;
        }
        case E.HEAD: {
          if (e > 0) {
            this.insertionMode = H.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = H.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(e) {
    if (e > 0)
      for (let n = e - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === E.TEMPLATE)
          break;
        if (r === E.TABLE) {
          this.insertionMode = H.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = H.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(e) {
    return IE.has(e);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let e = this.openElements.stackTop; e >= 0; e--) {
      const n = this.openElements.items[e];
      switch (this.openElements.tagIDs[e]) {
        case E.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === ne.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case E.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[e - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(e) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, e, n.beforeElement) : this.treeAdapter.appendChild(n.parent, e);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(e, n) {
    const r = this.treeAdapter.getNamespaceURI(e);
    return YL[r].has(n);
  }
  /** @internal */
  onCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      sR(this, e);
      return;
    }
    switch (this.insertionMode) {
      case H.INITIAL: {
        Ps(this, e);
        break;
      }
      case H.BEFORE_HTML: {
        Qs(this, e);
        break;
      }
      case H.BEFORE_HEAD: {
        Zs(this, e);
        break;
      }
      case H.IN_HEAD: {
        Js(this, e);
        break;
      }
      case H.IN_HEAD_NO_SCRIPT: {
        ea(this, e);
        break;
      }
      case H.AFTER_HEAD: {
        ta(this, e);
        break;
      }
      case H.IN_BODY:
      case H.IN_CAPTION:
      case H.IN_CELL:
      case H.IN_TEMPLATE: {
        LE(this, e);
        break;
      }
      case H.TEXT:
      case H.IN_SELECT:
      case H.IN_SELECT_IN_TABLE: {
        this._insertCharacters(e);
        break;
      }
      case H.IN_TABLE:
      case H.IN_TABLE_BODY:
      case H.IN_ROW: {
        Wl(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        PE(this, e);
        break;
      }
      case H.IN_COLUMN_GROUP: {
        gu(this, e);
        break;
      }
      case H.AFTER_BODY: {
        bu(this, e);
        break;
      }
      case H.AFTER_AFTER_BODY: {
        zo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(e) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      iR(this, e);
      return;
    }
    switch (this.insertionMode) {
      case H.INITIAL: {
        Ps(this, e);
        break;
      }
      case H.BEFORE_HTML: {
        Qs(this, e);
        break;
      }
      case H.BEFORE_HEAD: {
        Zs(this, e);
        break;
      }
      case H.IN_HEAD: {
        Js(this, e);
        break;
      }
      case H.IN_HEAD_NO_SCRIPT: {
        ea(this, e);
        break;
      }
      case H.AFTER_HEAD: {
        ta(this, e);
        break;
      }
      case H.TEXT: {
        this._insertCharacters(e);
        break;
      }
      case H.IN_TABLE:
      case H.IN_TABLE_BODY:
      case H.IN_ROW: {
        Wl(this, e);
        break;
      }
      case H.IN_COLUMN_GROUP: {
        gu(this, e);
        break;
      }
      case H.AFTER_BODY: {
        bu(this, e);
        break;
      }
      case H.AFTER_AFTER_BODY: {
        zo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onComment(e) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      cd(this, e);
      return;
    }
    switch (this.insertionMode) {
      case H.INITIAL:
      case H.BEFORE_HTML:
      case H.BEFORE_HEAD:
      case H.IN_HEAD:
      case H.IN_HEAD_NO_SCRIPT:
      case H.AFTER_HEAD:
      case H.IN_BODY:
      case H.IN_TABLE:
      case H.IN_CAPTION:
      case H.IN_COLUMN_GROUP:
      case H.IN_TABLE_BODY:
      case H.IN_ROW:
      case H.IN_CELL:
      case H.IN_SELECT:
      case H.IN_SELECT_IN_TABLE:
      case H.IN_TEMPLATE:
      case H.IN_FRAMESET:
      case H.AFTER_FRAMESET: {
        cd(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        Os(this, e);
        break;
      }
      case H.AFTER_BODY: {
        M_(this, e);
        break;
      }
      case H.AFTER_AFTER_BODY:
      case H.AFTER_AFTER_FRAMESET: {
        F_(this, e);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(e) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case H.INITIAL: {
        B_(this, e);
        break;
      }
      case H.BEFORE_HEAD:
      case H.IN_HEAD:
      case H.IN_HEAD_NO_SCRIPT:
      case H.AFTER_HEAD: {
        this._err(e, j.misplacedDoctype);
        break;
      }
      case H.IN_TABLE_TEXT: {
        Os(this, e);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, j.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(e) {
    this.shouldProcessStartTagTokenInForeignContent(e) ? aR(this, e) : this._startTagOutsideForeignContent(e);
  }
  /** @protected */
  _startTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case H.INITIAL: {
        Ps(this, e);
        break;
      }
      case H.BEFORE_HTML: {
        $_(this, e);
        break;
      }
      case H.BEFORE_HEAD: {
        H_(this, e);
        break;
      }
      case H.IN_HEAD: {
        _n(this, e);
        break;
      }
      case H.IN_HEAD_NO_SCRIPT: {
        z_(this, e);
        break;
      }
      case H.AFTER_HEAD: {
        W_(this, e);
        break;
      }
      case H.IN_BODY: {
        Pt(this, e);
        break;
      }
      case H.IN_TABLE: {
        rs(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        Os(this, e);
        break;
      }
      case H.IN_CAPTION: {
        V3(this, e);
        break;
      }
      case H.IN_COLUMN_GROUP: {
        Xf(this, e);
        break;
      }
      case H.IN_TABLE_BODY: {
        sl(this, e);
        break;
      }
      case H.IN_ROW: {
        al(this, e);
        break;
      }
      case H.IN_CELL: {
        q3(this, e);
        break;
      }
      case H.IN_SELECT: {
        ME(this, e);
        break;
      }
      case H.IN_SELECT_IN_TABLE: {
        K3(this, e);
        break;
      }
      case H.IN_TEMPLATE: {
        Y3(this, e);
        break;
      }
      case H.AFTER_BODY: {
        Q3(this, e);
        break;
      }
      case H.IN_FRAMESET: {
        Z3(this, e);
        break;
      }
      case H.AFTER_FRAMESET: {
        eR(this, e);
        break;
      }
      case H.AFTER_AFTER_BODY: {
        nR(this, e);
        break;
      }
      case H.AFTER_AFTER_FRAMESET: {
        rR(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(e) {
    this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? oR(this, e) : this._endTagOutsideForeignContent(e);
  }
  /** @protected */
  _endTagOutsideForeignContent(e) {
    switch (this.insertionMode) {
      case H.INITIAL: {
        Ps(this, e);
        break;
      }
      case H.BEFORE_HTML: {
        U_(this, e);
        break;
      }
      case H.BEFORE_HEAD: {
        V_(this, e);
        break;
      }
      case H.IN_HEAD: {
        G_(this, e);
        break;
      }
      case H.IN_HEAD_NO_SCRIPT: {
        q_(this, e);
        break;
      }
      case H.AFTER_HEAD: {
        K_(this, e);
        break;
      }
      case H.IN_BODY: {
        il(this, e);
        break;
      }
      case H.TEXT: {
        D3(this, e);
        break;
      }
      case H.IN_TABLE: {
        ca(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        Os(this, e);
        break;
      }
      case H.IN_CAPTION: {
        G3(this, e);
        break;
      }
      case H.IN_COLUMN_GROUP: {
        z3(this, e);
        break;
      }
      case H.IN_TABLE_BODY: {
        dd(this, e);
        break;
      }
      case H.IN_ROW: {
        NE(this, e);
        break;
      }
      case H.IN_CELL: {
        W3(this, e);
        break;
      }
      case H.IN_SELECT: {
        FE(this, e);
        break;
      }
      case H.IN_SELECT_IN_TABLE: {
        j3(this, e);
        break;
      }
      case H.IN_TEMPLATE: {
        X3(this, e);
        break;
      }
      case H.AFTER_BODY: {
        $E(this, e);
        break;
      }
      case H.IN_FRAMESET: {
        J3(this, e);
        break;
      }
      case H.AFTER_FRAMESET: {
        tR(this, e);
        break;
      }
      case H.AFTER_AFTER_BODY: {
        zo(this, e);
        break;
      }
    }
  }
  /** @internal */
  onEof(e) {
    switch (this.insertionMode) {
      case H.INITIAL: {
        Ps(this, e);
        break;
      }
      case H.BEFORE_HTML: {
        Qs(this, e);
        break;
      }
      case H.BEFORE_HEAD: {
        Zs(this, e);
        break;
      }
      case H.IN_HEAD: {
        Js(this, e);
        break;
      }
      case H.IN_HEAD_NO_SCRIPT: {
        ea(this, e);
        break;
      }
      case H.AFTER_HEAD: {
        ta(this, e);
        break;
      }
      case H.IN_BODY:
      case H.IN_TABLE:
      case H.IN_CAPTION:
      case H.IN_COLUMN_GROUP:
      case H.IN_TABLE_BODY:
      case H.IN_ROW:
      case H.IN_CELL:
      case H.IN_SELECT:
      case H.IN_SELECT_IN_TABLE: {
        kE(this, e);
        break;
      }
      case H.TEXT: {
        P3(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        Os(this, e);
        break;
      }
      case H.IN_TEMPLATE: {
        BE(this, e);
        break;
      }
      case H.AFTER_BODY:
      case H.IN_FRAMESET:
      case H.AFTER_FRAMESET:
      case H.AFTER_AFTER_BODY:
      case H.AFTER_AFTER_FRAMESET: {
        Yf(this, e);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(e) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === O.LINE_FEED)) {
      if (e.chars.length === 1)
        return;
      e.chars = e.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(e);
      return;
    }
    switch (this.insertionMode) {
      case H.IN_HEAD:
      case H.IN_HEAD_NO_SCRIPT:
      case H.AFTER_HEAD:
      case H.TEXT:
      case H.IN_COLUMN_GROUP:
      case H.IN_SELECT:
      case H.IN_SELECT_IN_TABLE:
      case H.IN_FRAMESET:
      case H.AFTER_FRAMESET: {
        this._insertCharacters(e);
        break;
      }
      case H.IN_BODY:
      case H.IN_CAPTION:
      case H.IN_CELL:
      case H.IN_TEMPLATE:
      case H.AFTER_BODY:
      case H.AFTER_AFTER_BODY:
      case H.AFTER_AFTER_FRAMESET: {
        CE(this, e);
        break;
      }
      case H.IN_TABLE:
      case H.IN_TABLE_BODY:
      case H.IN_ROW: {
        Wl(this, e);
        break;
      }
      case H.IN_TABLE_TEXT: {
        DE(this, e);
        break;
      }
    }
  }
};
function w_(t, e) {
  let n = t.activeFormattingElements.getElementEntryInScopeWithTagName(e.tagName);
  return n ? t.openElements.contains(n.element) ? t.openElements.hasInScope(e.tagID) || (n = null) : (t.activeFormattingElements.removeEntry(n), n = null) : wE(t, e), n;
}
function k_(t, e) {
  let n = null, r = t.openElements.stackTop;
  for (; r >= 0; r--) {
    const i = t.openElements.items[r];
    if (i === e.element)
      break;
    t._isSpecialElement(i, t.openElements.tagIDs[r]) && (n = i);
  }
  return n || (t.openElements.shortenToLength(Math.max(r, 0)), t.activeFormattingElements.removeEntry(e)), n;
}
function D_(t, e, n) {
  let r = e, i = t.openElements.getCommonAncestor(e);
  for (let s = 0, a = i; a !== n; s++, a = i) {
    i = t.openElements.getCommonAncestor(a);
    const o = t.activeFormattingElements.getElementEntry(a), u = o && s >= __;
    !o || u ? (u && t.activeFormattingElements.removeEntry(o), t.openElements.remove(a)) : (a = P_(t, o), r === e && (t.activeFormattingElements.bookmark = o), t.treeAdapter.detachNode(r), t.treeAdapter.appendChild(a, r), r = a);
  }
  return r;
}
function P_(t, e) {
  const n = t.treeAdapter.getNamespaceURI(e.element), r = t.treeAdapter.createElement(e.token.tagName, n, e.token.attrs);
  return t.openElements.replace(e.element, r), e.element = r, r;
}
function O_(t, e, n) {
  const r = t.treeAdapter.getTagName(e), i = Ts(r);
  if (t._isElementCausesFosterParenting(i))
    t._fosterParentElement(n);
  else {
    const s = t.treeAdapter.getNamespaceURI(e);
    i === E.TEMPLATE && s === ne.HTML && (e = t.treeAdapter.getTemplateContent(e)), t.treeAdapter.appendChild(e, n);
  }
}
function N_(t, e, n) {
  const r = t.treeAdapter.getNamespaceURI(n.element), { token: i } = n, s = t.treeAdapter.createElement(i.tagName, r, i.attrs);
  t._adoptNodes(e, s), t.treeAdapter.appendChild(e, s), t.activeFormattingElements.insertElementAfterBookmark(s, i), t.activeFormattingElements.removeEntry(n), t.openElements.remove(n.element), t.openElements.insertAfter(e, s, i.tagID);
}
function jf(t, e) {
  for (let n = 0; n < L_; n++) {
    const r = w_(t, e);
    if (!r)
      break;
    const i = k_(t, r);
    if (!i)
      break;
    t.activeFormattingElements.bookmark = r;
    const s = D_(t, i, r.element), a = t.openElements.getCommonAncestor(r.element);
    t.treeAdapter.detachNode(s), a && O_(t, a, s), N_(t, i, r);
  }
}
function cd(t, e) {
  t._appendCommentNode(e, t.openElements.currentTmplContentOrNode);
}
function M_(t, e) {
  t._appendCommentNode(e, t.openElements.items[0]);
}
function F_(t, e) {
  t._appendCommentNode(e, t.document);
}
function Yf(t, e) {
  if (t.stopped = !0, e.location) {
    const n = t.fragmentContext ? 0 : 2;
    for (let r = t.openElements.stackTop; r >= n; r--)
      t._setEndLocation(t.openElements.items[r], e);
    if (!t.fragmentContext && t.openElements.stackTop >= 0) {
      const r = t.openElements.items[0], i = t.treeAdapter.getNodeSourceCodeLocation(r);
      if (i && !i.endTag && (t._setEndLocation(r, e), t.openElements.stackTop >= 1)) {
        const s = t.openElements.items[1], a = t.treeAdapter.getNodeSourceCodeLocation(s);
        a && !a.endTag && t._setEndLocation(s, e);
      }
    }
  }
}
function B_(t, e) {
  t._setDocumentType(e);
  const n = e.forceQuirks ? mn.QUIRKS : m_(e);
  h_(e) || t._err(e, j.nonConformingDoctype), t.treeAdapter.setDocumentMode(t.document, n), t.insertionMode = H.BEFORE_HTML;
}
function Ps(t, e) {
  t._err(e, j.missingDoctype, !0), t.treeAdapter.setDocumentMode(t.document, mn.QUIRKS), t.insertionMode = H.BEFORE_HTML, t._processToken(e);
}
function $_(t, e) {
  e.tagID === E.HTML ? (t._insertElement(e, ne.HTML), t.insertionMode = H.BEFORE_HEAD) : Qs(t, e);
}
function U_(t, e) {
  const n = e.tagID;
  (n === E.HTML || n === E.HEAD || n === E.BODY || n === E.BR) && Qs(t, e);
}
function Qs(t, e) {
  t._insertFakeRootElement(), t.insertionMode = H.BEFORE_HEAD, t._processToken(e);
}
function H_(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.HEAD: {
      t._insertElement(e, ne.HTML), t.headElement = t.openElements.current, t.insertionMode = H.IN_HEAD;
      break;
    }
    default:
      Zs(t, e);
  }
}
function V_(t, e) {
  const n = e.tagID;
  n === E.HEAD || n === E.BODY || n === E.HTML || n === E.BR ? Zs(t, e) : t._err(e, j.endTagWithoutMatchingOpenElement);
}
function Zs(t, e) {
  t._insertFakeElement(W.HEAD, E.HEAD), t.headElement = t.openElements.current, t.insertionMode = H.IN_HEAD, t._processToken(e);
}
function _n(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.BASE:
    case E.BASEFONT:
    case E.BGSOUND:
    case E.LINK:
    case E.META: {
      t._appendElement(e, ne.HTML), e.ackSelfClosing = !0;
      break;
    }
    case E.TITLE: {
      t._switchToTextParsing(e, dt.RCDATA);
      break;
    }
    case E.NOSCRIPT: {
      t.options.scriptingEnabled ? t._switchToTextParsing(e, dt.RAWTEXT) : (t._insertElement(e, ne.HTML), t.insertionMode = H.IN_HEAD_NO_SCRIPT);
      break;
    }
    case E.NOFRAMES:
    case E.STYLE: {
      t._switchToTextParsing(e, dt.RAWTEXT);
      break;
    }
    case E.SCRIPT: {
      t._switchToTextParsing(e, dt.SCRIPT_DATA);
      break;
    }
    case E.TEMPLATE: {
      t._insertTemplate(e), t.activeFormattingElements.insertMarker(), t.framesetOk = !1, t.insertionMode = H.IN_TEMPLATE, t.tmplInsertionModeStack.unshift(H.IN_TEMPLATE);
      break;
    }
    case E.HEAD: {
      t._err(e, j.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Js(t, e);
  }
}
function G_(t, e) {
  switch (e.tagID) {
    case E.HEAD: {
      t.openElements.pop(), t.insertionMode = H.AFTER_HEAD;
      break;
    }
    case E.BODY:
    case E.BR:
    case E.HTML: {
      Js(t, e);
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
    default:
      t._err(e, j.endTagWithoutMatchingOpenElement);
  }
}
function pi(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.generateImpliedEndTagsThoroughly(), t.openElements.currentTagId !== E.TEMPLATE && t._err(e, j.closingOfElementWithOpenChildElements), t.openElements.popUntilTagNamePopped(E.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode()) : t._err(e, j.endTagWithoutMatchingOpenElement);
}
function Js(t, e) {
  t.openElements.pop(), t.insertionMode = H.AFTER_HEAD, t._processToken(e);
}
function z_(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.BASEFONT:
    case E.BGSOUND:
    case E.HEAD:
    case E.LINK:
    case E.META:
    case E.NOFRAMES:
    case E.STYLE: {
      _n(t, e);
      break;
    }
    case E.NOSCRIPT: {
      t._err(e, j.nestedNoscriptInHead);
      break;
    }
    default:
      ea(t, e);
  }
}
function q_(t, e) {
  switch (e.tagID) {
    case E.NOSCRIPT: {
      t.openElements.pop(), t.insertionMode = H.IN_HEAD;
      break;
    }
    case E.BR: {
      ea(t, e);
      break;
    }
    default:
      t._err(e, j.endTagWithoutMatchingOpenElement);
  }
}
function ea(t, e) {
  const n = e.type === Fe.EOF ? j.openElementsLeftAfterEof : j.disallowedContentInNoscriptInHead;
  t._err(e, n), t.openElements.pop(), t.insertionMode = H.IN_HEAD, t._processToken(e);
}
function W_(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.BODY: {
      t._insertElement(e, ne.HTML), t.framesetOk = !1, t.insertionMode = H.IN_BODY;
      break;
    }
    case E.FRAMESET: {
      t._insertElement(e, ne.HTML), t.insertionMode = H.IN_FRAMESET;
      break;
    }
    case E.BASE:
    case E.BASEFONT:
    case E.BGSOUND:
    case E.LINK:
    case E.META:
    case E.NOFRAMES:
    case E.SCRIPT:
    case E.STYLE:
    case E.TEMPLATE:
    case E.TITLE: {
      t._err(e, j.abandonedHeadElementChild), t.openElements.push(t.headElement, E.HEAD), _n(t, e), t.openElements.remove(t.headElement);
      break;
    }
    case E.HEAD: {
      t._err(e, j.misplacedStartTagForHeadElement);
      break;
    }
    default:
      ta(t, e);
  }
}
function K_(t, e) {
  switch (e.tagID) {
    case E.BODY:
    case E.HTML:
    case E.BR: {
      ta(t, e);
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
    default:
      t._err(e, j.endTagWithoutMatchingOpenElement);
  }
}
function ta(t, e) {
  t._insertFakeElement(W.BODY, E.BODY), t.insertionMode = H.IN_BODY, rl(t, e);
}
function rl(t, e) {
  switch (e.type) {
    case Fe.CHARACTER: {
      LE(t, e);
      break;
    }
    case Fe.WHITESPACE_CHARACTER: {
      CE(t, e);
      break;
    }
    case Fe.COMMENT: {
      cd(t, e);
      break;
    }
    case Fe.START_TAG: {
      Pt(t, e);
      break;
    }
    case Fe.END_TAG: {
      il(t, e);
      break;
    }
    case Fe.EOF: {
      kE(t, e);
      break;
    }
  }
}
function CE(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e);
}
function LE(t, e) {
  t._reconstructActiveFormattingElements(), t._insertCharacters(e), t.framesetOk = !1;
}
function j_(t, e) {
  t.openElements.tmplCount === 0 && t.treeAdapter.adoptAttributes(t.openElements.items[0], e.attrs);
}
function Y_(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  n && t.openElements.tmplCount === 0 && (t.framesetOk = !1, t.treeAdapter.adoptAttributes(n, e.attrs));
}
function X_(t, e) {
  const n = t.openElements.tryPeekProperlyNestedBodyElement();
  t.framesetOk && n && (t.treeAdapter.detachNode(n), t.openElements.popAllUpToHtmlElement(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_FRAMESET);
}
function Q_(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML);
}
function Z_(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t.openElements.currentTagId !== void 0 && ld.has(t.openElements.currentTagId) && t.openElements.pop(), t._insertElement(e, ne.HTML);
}
function J_(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML), t.skipNextNewLine = !0, t.framesetOk = !1;
}
function e3(t, e) {
  const n = t.openElements.tmplCount > 0;
  (!t.formElement || n) && (t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML), n || (t.formElement = t.openElements.current));
}
function t3(t, e) {
  t.framesetOk = !1;
  const n = e.tagID;
  for (let r = t.openElements.stackTop; r >= 0; r--) {
    const i = t.openElements.tagIDs[r];
    if (n === E.LI && i === E.LI || (n === E.DD || n === E.DT) && (i === E.DD || i === E.DT)) {
      t.openElements.generateImpliedEndTagsWithExclusion(i), t.openElements.popUntilTagNamePopped(i);
      break;
    }
    if (i !== E.ADDRESS && i !== E.DIV && i !== E.P && t._isSpecialElement(t.openElements.items[r], i))
      break;
  }
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML);
}
function n3(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML), t.tokenizer.state = dt.PLAINTEXT;
}
function r3(t, e) {
  t.openElements.hasInScope(E.BUTTON) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(E.BUTTON)), t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML), t.framesetOk = !1;
}
function i3(t, e) {
  const n = t.activeFormattingElements.getElementEntryInScopeWithTagName(W.A);
  n && (jf(t, e), t.openElements.remove(n.element), t.activeFormattingElements.removeEntry(n)), t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function s3(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function a3(t, e) {
  t._reconstructActiveFormattingElements(), t.openElements.hasInScope(E.NOBR) && (jf(t, e), t._reconstructActiveFormattingElements()), t._insertElement(e, ne.HTML), t.activeFormattingElements.pushElement(t.openElements.current, e);
}
function o3(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML), t.activeFormattingElements.insertMarker(), t.framesetOk = !1;
}
function u3(t, e) {
  t.treeAdapter.getDocumentMode(t.document) !== mn.QUIRKS && t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._insertElement(e, ne.HTML), t.framesetOk = !1, t.insertionMode = H.IN_TABLE;
}
function _E(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, ne.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function RE(t) {
  const e = bE(t, ei.TYPE);
  return e != null && e.toLowerCase() === C_;
}
function l3(t, e) {
  t._reconstructActiveFormattingElements(), t._appendElement(e, ne.HTML), RE(e) || (t.framesetOk = !1), e.ackSelfClosing = !0;
}
function c3(t, e) {
  t._appendElement(e, ne.HTML), e.ackSelfClosing = !0;
}
function d3(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._appendElement(e, ne.HTML), t.framesetOk = !1, e.ackSelfClosing = !0;
}
function f3(t, e) {
  e.tagName = W.IMG, e.tagID = E.IMG, _E(t, e);
}
function h3(t, e) {
  t._insertElement(e, ne.HTML), t.skipNextNewLine = !0, t.tokenizer.state = dt.RCDATA, t.originalInsertionMode = t.insertionMode, t.framesetOk = !1, t.insertionMode = H.TEXT;
}
function m3(t, e) {
  t.openElements.hasInButtonScope(E.P) && t._closePElement(), t._reconstructActiveFormattingElements(), t.framesetOk = !1, t._switchToTextParsing(e, dt.RAWTEXT);
}
function p3(t, e) {
  t.framesetOk = !1, t._switchToTextParsing(e, dt.RAWTEXT);
}
function rm(t, e) {
  t._switchToTextParsing(e, dt.RAWTEXT);
}
function g3(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML), t.framesetOk = !1, t.insertionMode = t.insertionMode === H.IN_TABLE || t.insertionMode === H.IN_CAPTION || t.insertionMode === H.IN_TABLE_BODY || t.insertionMode === H.IN_ROW || t.insertionMode === H.IN_CELL ? H.IN_SELECT_IN_TABLE : H.IN_SELECT;
}
function b3(t, e) {
  t.openElements.currentTagId === E.OPTION && t.openElements.pop(), t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML);
}
function E3(t, e) {
  t.openElements.hasInScope(E.RUBY) && t.openElements.generateImpliedEndTags(), t._insertElement(e, ne.HTML);
}
function y3(t, e) {
  t.openElements.hasInScope(E.RUBY) && t.openElements.generateImpliedEndTagsWithExclusion(E.RTC), t._insertElement(e, ne.HTML);
}
function T3(t, e) {
  t._reconstructActiveFormattingElements(), vE(e), Kf(e), e.selfClosing ? t._appendElement(e, ne.MATHML) : t._insertElement(e, ne.MATHML), e.ackSelfClosing = !0;
}
function S3(t, e) {
  t._reconstructActiveFormattingElements(), AE(e), Kf(e), e.selfClosing ? t._appendElement(e, ne.SVG) : t._insertElement(e, ne.SVG), e.ackSelfClosing = !0;
}
function im(t, e) {
  t._reconstructActiveFormattingElements(), t._insertElement(e, ne.HTML);
}
function Pt(t, e) {
  switch (e.tagID) {
    case E.I:
    case E.S:
    case E.B:
    case E.U:
    case E.EM:
    case E.TT:
    case E.BIG:
    case E.CODE:
    case E.FONT:
    case E.SMALL:
    case E.STRIKE:
    case E.STRONG: {
      s3(t, e);
      break;
    }
    case E.A: {
      i3(t, e);
      break;
    }
    case E.H1:
    case E.H2:
    case E.H3:
    case E.H4:
    case E.H5:
    case E.H6: {
      Z_(t, e);
      break;
    }
    case E.P:
    case E.DL:
    case E.OL:
    case E.UL:
    case E.DIV:
    case E.DIR:
    case E.NAV:
    case E.MAIN:
    case E.MENU:
    case E.ASIDE:
    case E.CENTER:
    case E.FIGURE:
    case E.FOOTER:
    case E.HEADER:
    case E.HGROUP:
    case E.DIALOG:
    case E.DETAILS:
    case E.ADDRESS:
    case E.ARTICLE:
    case E.SEARCH:
    case E.SECTION:
    case E.SUMMARY:
    case E.FIELDSET:
    case E.BLOCKQUOTE:
    case E.FIGCAPTION: {
      Q_(t, e);
      break;
    }
    case E.LI:
    case E.DD:
    case E.DT: {
      t3(t, e);
      break;
    }
    case E.BR:
    case E.IMG:
    case E.WBR:
    case E.AREA:
    case E.EMBED:
    case E.KEYGEN: {
      _E(t, e);
      break;
    }
    case E.HR: {
      d3(t, e);
      break;
    }
    case E.RB:
    case E.RTC: {
      E3(t, e);
      break;
    }
    case E.RT:
    case E.RP: {
      y3(t, e);
      break;
    }
    case E.PRE:
    case E.LISTING: {
      J_(t, e);
      break;
    }
    case E.XMP: {
      m3(t, e);
      break;
    }
    case E.SVG: {
      S3(t, e);
      break;
    }
    case E.HTML: {
      j_(t, e);
      break;
    }
    case E.BASE:
    case E.LINK:
    case E.META:
    case E.STYLE:
    case E.TITLE:
    case E.SCRIPT:
    case E.BGSOUND:
    case E.BASEFONT:
    case E.TEMPLATE: {
      _n(t, e);
      break;
    }
    case E.BODY: {
      Y_(t, e);
      break;
    }
    case E.FORM: {
      e3(t, e);
      break;
    }
    case E.NOBR: {
      a3(t, e);
      break;
    }
    case E.MATH: {
      T3(t, e);
      break;
    }
    case E.TABLE: {
      u3(t, e);
      break;
    }
    case E.INPUT: {
      l3(t, e);
      break;
    }
    case E.PARAM:
    case E.TRACK:
    case E.SOURCE: {
      c3(t, e);
      break;
    }
    case E.IMAGE: {
      f3(t, e);
      break;
    }
    case E.BUTTON: {
      r3(t, e);
      break;
    }
    case E.APPLET:
    case E.OBJECT:
    case E.MARQUEE: {
      o3(t, e);
      break;
    }
    case E.IFRAME: {
      p3(t, e);
      break;
    }
    case E.SELECT: {
      g3(t, e);
      break;
    }
    case E.OPTION:
    case E.OPTGROUP: {
      b3(t, e);
      break;
    }
    case E.NOEMBED:
    case E.NOFRAMES: {
      rm(t, e);
      break;
    }
    case E.FRAMESET: {
      X_(t, e);
      break;
    }
    case E.TEXTAREA: {
      h3(t, e);
      break;
    }
    case E.NOSCRIPT: {
      t.options.scriptingEnabled ? rm(t, e) : im(t, e);
      break;
    }
    case E.PLAINTEXT: {
      n3(t, e);
      break;
    }
    case E.COL:
    case E.TH:
    case E.TD:
    case E.TR:
    case E.HEAD:
    case E.FRAME:
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD:
    case E.CAPTION:
    case E.COLGROUP:
      break;
    default:
      im(t, e);
  }
}
function x3(t, e) {
  if (t.openElements.hasInScope(E.BODY) && (t.insertionMode = H.AFTER_BODY, t.options.sourceCodeLocationInfo)) {
    const n = t.openElements.tryPeekProperlyNestedBodyElement();
    n && t._setEndLocation(n, e);
  }
}
function v3(t, e) {
  t.openElements.hasInScope(E.BODY) && (t.insertionMode = H.AFTER_BODY, $E(t, e));
}
function A3(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n));
}
function I3(t) {
  const e = t.openElements.tmplCount > 0, { formElement: n } = t;
  e || (t.formElement = null), (n || e) && t.openElements.hasInScope(E.FORM) && (t.openElements.generateImpliedEndTags(), e ? t.openElements.popUntilTagNamePopped(E.FORM) : n && t.openElements.remove(n));
}
function C3(t) {
  t.openElements.hasInButtonScope(E.P) || t._insertFakeElement(W.P, E.P), t._closePElement();
}
function L3(t) {
  t.openElements.hasInListItemScope(E.LI) && (t.openElements.generateImpliedEndTagsWithExclusion(E.LI), t.openElements.popUntilTagNamePopped(E.LI));
}
function _3(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTagsWithExclusion(n), t.openElements.popUntilTagNamePopped(n));
}
function R3(t) {
  t.openElements.hasNumberedHeaderInScope() && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilNumberedHeaderPopped());
}
function w3(t, e) {
  const n = e.tagID;
  t.openElements.hasInScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker());
}
function k3(t) {
  t._reconstructActiveFormattingElements(), t._insertFakeElement(W.BR, E.BR), t.openElements.pop(), t.framesetOk = !1;
}
function wE(t, e) {
  const n = e.tagName, r = e.tagID;
  for (let i = t.openElements.stackTop; i > 0; i--) {
    const s = t.openElements.items[i], a = t.openElements.tagIDs[i];
    if (r === a && (r !== E.UNKNOWN || t.treeAdapter.getTagName(s) === n)) {
      t.openElements.generateImpliedEndTagsWithExclusion(r), t.openElements.stackTop >= i && t.openElements.shortenToLength(i);
      break;
    }
    if (t._isSpecialElement(s, a))
      break;
  }
}
function il(t, e) {
  switch (e.tagID) {
    case E.A:
    case E.B:
    case E.I:
    case E.S:
    case E.U:
    case E.EM:
    case E.TT:
    case E.BIG:
    case E.CODE:
    case E.FONT:
    case E.NOBR:
    case E.SMALL:
    case E.STRIKE:
    case E.STRONG: {
      jf(t, e);
      break;
    }
    case E.P: {
      C3(t);
      break;
    }
    case E.DL:
    case E.UL:
    case E.OL:
    case E.DIR:
    case E.DIV:
    case E.NAV:
    case E.PRE:
    case E.MAIN:
    case E.MENU:
    case E.ASIDE:
    case E.BUTTON:
    case E.CENTER:
    case E.FIGURE:
    case E.FOOTER:
    case E.HEADER:
    case E.HGROUP:
    case E.DIALOG:
    case E.ADDRESS:
    case E.ARTICLE:
    case E.DETAILS:
    case E.SEARCH:
    case E.SECTION:
    case E.SUMMARY:
    case E.LISTING:
    case E.FIELDSET:
    case E.BLOCKQUOTE:
    case E.FIGCAPTION: {
      A3(t, e);
      break;
    }
    case E.LI: {
      L3(t);
      break;
    }
    case E.DD:
    case E.DT: {
      _3(t, e);
      break;
    }
    case E.H1:
    case E.H2:
    case E.H3:
    case E.H4:
    case E.H5:
    case E.H6: {
      R3(t);
      break;
    }
    case E.BR: {
      k3(t);
      break;
    }
    case E.BODY: {
      x3(t, e);
      break;
    }
    case E.HTML: {
      v3(t, e);
      break;
    }
    case E.FORM: {
      I3(t);
      break;
    }
    case E.APPLET:
    case E.OBJECT:
    case E.MARQUEE: {
      w3(t, e);
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
    default:
      wE(t, e);
  }
}
function kE(t, e) {
  t.tmplInsertionModeStack.length > 0 ? BE(t, e) : Yf(t, e);
}
function D3(t, e) {
  var n;
  e.tagID === E.SCRIPT && ((n = t.scriptHandler) === null || n === void 0 || n.call(t, t.openElements.current)), t.openElements.pop(), t.insertionMode = t.originalInsertionMode;
}
function P3(t, e) {
  t._err(e, j.eofInElementThatCanContainOnlyText), t.openElements.pop(), t.insertionMode = t.originalInsertionMode, t.onEof(e);
}
function Wl(t, e) {
  if (t.openElements.currentTagId !== void 0 && IE.has(t.openElements.currentTagId))
    switch (t.pendingCharacterTokens.length = 0, t.hasNonWhitespacePendingCharacterToken = !1, t.originalInsertionMode = t.insertionMode, t.insertionMode = H.IN_TABLE_TEXT, e.type) {
      case Fe.CHARACTER: {
        PE(t, e);
        break;
      }
      case Fe.WHITESPACE_CHARACTER: {
        DE(t, e);
        break;
      }
    }
  else
    Fa(t, e);
}
function O3(t, e) {
  t.openElements.clearBackToTableContext(), t.activeFormattingElements.insertMarker(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_CAPTION;
}
function N3(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_COLUMN_GROUP;
}
function M3(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(W.COLGROUP, E.COLGROUP), t.insertionMode = H.IN_COLUMN_GROUP, Xf(t, e);
}
function F3(t, e) {
  t.openElements.clearBackToTableContext(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_TABLE_BODY;
}
function B3(t, e) {
  t.openElements.clearBackToTableContext(), t._insertFakeElement(W.TBODY, E.TBODY), t.insertionMode = H.IN_TABLE_BODY, sl(t, e);
}
function $3(t, e) {
  t.openElements.hasInTableScope(E.TABLE) && (t.openElements.popUntilTagNamePopped(E.TABLE), t._resetInsertionMode(), t._processStartTag(e));
}
function U3(t, e) {
  RE(e) ? t._appendElement(e, ne.HTML) : Fa(t, e), e.ackSelfClosing = !0;
}
function H3(t, e) {
  !t.formElement && t.openElements.tmplCount === 0 && (t._insertElement(e, ne.HTML), t.formElement = t.openElements.current, t.openElements.pop());
}
function rs(t, e) {
  switch (e.tagID) {
    case E.TD:
    case E.TH:
    case E.TR: {
      B3(t, e);
      break;
    }
    case E.STYLE:
    case E.SCRIPT:
    case E.TEMPLATE: {
      _n(t, e);
      break;
    }
    case E.COL: {
      M3(t, e);
      break;
    }
    case E.FORM: {
      H3(t, e);
      break;
    }
    case E.TABLE: {
      $3(t, e);
      break;
    }
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD: {
      F3(t, e);
      break;
    }
    case E.INPUT: {
      U3(t, e);
      break;
    }
    case E.CAPTION: {
      O3(t, e);
      break;
    }
    case E.COLGROUP: {
      N3(t, e);
      break;
    }
    default:
      Fa(t, e);
  }
}
function ca(t, e) {
  switch (e.tagID) {
    case E.TABLE: {
      t.openElements.hasInTableScope(E.TABLE) && (t.openElements.popUntilTagNamePopped(E.TABLE), t._resetInsertionMode());
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
    case E.BODY:
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.HTML:
    case E.TBODY:
    case E.TD:
    case E.TFOOT:
    case E.TH:
    case E.THEAD:
    case E.TR:
      break;
    default:
      Fa(t, e);
  }
}
function Fa(t, e) {
  const n = t.fosterParentingEnabled;
  t.fosterParentingEnabled = !0, rl(t, e), t.fosterParentingEnabled = n;
}
function DE(t, e) {
  t.pendingCharacterTokens.push(e);
}
function PE(t, e) {
  t.pendingCharacterTokens.push(e), t.hasNonWhitespacePendingCharacterToken = !0;
}
function Os(t, e) {
  let n = 0;
  if (t.hasNonWhitespacePendingCharacterToken)
    for (; n < t.pendingCharacterTokens.length; n++)
      Fa(t, t.pendingCharacterTokens[n]);
  else
    for (; n < t.pendingCharacterTokens.length; n++)
      t._insertCharacters(t.pendingCharacterTokens[n]);
  t.insertionMode = t.originalInsertionMode, t._processToken(e);
}
const OE = /* @__PURE__ */ new Set([E.CAPTION, E.COL, E.COLGROUP, E.TBODY, E.TD, E.TFOOT, E.TH, E.THEAD, E.TR]);
function V3(t, e) {
  const n = e.tagID;
  OE.has(n) ? t.openElements.hasInTableScope(E.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(E.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = H.IN_TABLE, rs(t, e)) : Pt(t, e);
}
function G3(t, e) {
  const n = e.tagID;
  switch (n) {
    case E.CAPTION:
    case E.TABLE: {
      t.openElements.hasInTableScope(E.CAPTION) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(E.CAPTION), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = H.IN_TABLE, n === E.TABLE && ca(t, e));
      break;
    }
    case E.BODY:
    case E.COL:
    case E.COLGROUP:
    case E.HTML:
    case E.TBODY:
    case E.TD:
    case E.TFOOT:
    case E.TH:
    case E.THEAD:
    case E.TR:
      break;
    default:
      il(t, e);
  }
}
function Xf(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.COL: {
      t._appendElement(e, ne.HTML), e.ackSelfClosing = !0;
      break;
    }
    case E.TEMPLATE: {
      _n(t, e);
      break;
    }
    default:
      gu(t, e);
  }
}
function z3(t, e) {
  switch (e.tagID) {
    case E.COLGROUP: {
      t.openElements.currentTagId === E.COLGROUP && (t.openElements.pop(), t.insertionMode = H.IN_TABLE);
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
    case E.COL:
      break;
    default:
      gu(t, e);
  }
}
function gu(t, e) {
  t.openElements.currentTagId === E.COLGROUP && (t.openElements.pop(), t.insertionMode = H.IN_TABLE, t._processToken(e));
}
function sl(t, e) {
  switch (e.tagID) {
    case E.TR: {
      t.openElements.clearBackToTableBodyContext(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_ROW;
      break;
    }
    case E.TH:
    case E.TD: {
      t.openElements.clearBackToTableBodyContext(), t._insertFakeElement(W.TR, E.TR), t.insertionMode = H.IN_ROW, al(t, e);
      break;
    }
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE, rs(t, e));
      break;
    }
    default:
      rs(t, e);
  }
}
function dd(t, e) {
  const n = e.tagID;
  switch (e.tagID) {
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD: {
      t.openElements.hasInTableScope(n) && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE);
      break;
    }
    case E.TABLE: {
      t.openElements.hasTableBodyContextInTableScope() && (t.openElements.clearBackToTableBodyContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE, ca(t, e));
      break;
    }
    case E.BODY:
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.HTML:
    case E.TD:
    case E.TH:
    case E.TR:
      break;
    default:
      ca(t, e);
  }
}
function al(t, e) {
  switch (e.tagID) {
    case E.TH:
    case E.TD: {
      t.openElements.clearBackToTableRowContext(), t._insertElement(e, ne.HTML), t.insertionMode = H.IN_CELL, t.activeFormattingElements.insertMarker();
      break;
    }
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD:
    case E.TR: {
      t.openElements.hasInTableScope(E.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE_BODY, sl(t, e));
      break;
    }
    default:
      rs(t, e);
  }
}
function NE(t, e) {
  switch (e.tagID) {
    case E.TR: {
      t.openElements.hasInTableScope(E.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE_BODY);
      break;
    }
    case E.TABLE: {
      t.openElements.hasInTableScope(E.TR) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE_BODY, dd(t, e));
      break;
    }
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD: {
      (t.openElements.hasInTableScope(e.tagID) || t.openElements.hasInTableScope(E.TR)) && (t.openElements.clearBackToTableRowContext(), t.openElements.pop(), t.insertionMode = H.IN_TABLE_BODY, dd(t, e));
      break;
    }
    case E.BODY:
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.HTML:
    case E.TD:
    case E.TH:
      break;
    default:
      ca(t, e);
  }
}
function q3(t, e) {
  const n = e.tagID;
  OE.has(n) ? (t.openElements.hasInTableScope(E.TD) || t.openElements.hasInTableScope(E.TH)) && (t._closeTableCell(), al(t, e)) : Pt(t, e);
}
function W3(t, e) {
  const n = e.tagID;
  switch (n) {
    case E.TD:
    case E.TH: {
      t.openElements.hasInTableScope(n) && (t.openElements.generateImpliedEndTags(), t.openElements.popUntilTagNamePopped(n), t.activeFormattingElements.clearToLastMarker(), t.insertionMode = H.IN_ROW);
      break;
    }
    case E.TABLE:
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD:
    case E.TR: {
      t.openElements.hasInTableScope(n) && (t._closeTableCell(), NE(t, e));
      break;
    }
    case E.BODY:
    case E.CAPTION:
    case E.COL:
    case E.COLGROUP:
    case E.HTML:
      break;
    default:
      il(t, e);
  }
}
function ME(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.OPTION: {
      t.openElements.currentTagId === E.OPTION && t.openElements.pop(), t._insertElement(e, ne.HTML);
      break;
    }
    case E.OPTGROUP: {
      t.openElements.currentTagId === E.OPTION && t.openElements.pop(), t.openElements.currentTagId === E.OPTGROUP && t.openElements.pop(), t._insertElement(e, ne.HTML);
      break;
    }
    case E.HR: {
      t.openElements.currentTagId === E.OPTION && t.openElements.pop(), t.openElements.currentTagId === E.OPTGROUP && t.openElements.pop(), t._appendElement(e, ne.HTML), e.ackSelfClosing = !0;
      break;
    }
    case E.INPUT:
    case E.KEYGEN:
    case E.TEXTAREA:
    case E.SELECT: {
      t.openElements.hasInSelectScope(E.SELECT) && (t.openElements.popUntilTagNamePopped(E.SELECT), t._resetInsertionMode(), e.tagID !== E.SELECT && t._processStartTag(e));
      break;
    }
    case E.SCRIPT:
    case E.TEMPLATE: {
      _n(t, e);
      break;
    }
  }
}
function FE(t, e) {
  switch (e.tagID) {
    case E.OPTGROUP: {
      t.openElements.stackTop > 0 && t.openElements.currentTagId === E.OPTION && t.openElements.tagIDs[t.openElements.stackTop - 1] === E.OPTGROUP && t.openElements.pop(), t.openElements.currentTagId === E.OPTGROUP && t.openElements.pop();
      break;
    }
    case E.OPTION: {
      t.openElements.currentTagId === E.OPTION && t.openElements.pop();
      break;
    }
    case E.SELECT: {
      t.openElements.hasInSelectScope(E.SELECT) && (t.openElements.popUntilTagNamePopped(E.SELECT), t._resetInsertionMode());
      break;
    }
    case E.TEMPLATE: {
      pi(t, e);
      break;
    }
  }
}
function K3(t, e) {
  const n = e.tagID;
  n === E.CAPTION || n === E.TABLE || n === E.TBODY || n === E.TFOOT || n === E.THEAD || n === E.TR || n === E.TD || n === E.TH ? (t.openElements.popUntilTagNamePopped(E.SELECT), t._resetInsertionMode(), t._processStartTag(e)) : ME(t, e);
}
function j3(t, e) {
  const n = e.tagID;
  n === E.CAPTION || n === E.TABLE || n === E.TBODY || n === E.TFOOT || n === E.THEAD || n === E.TR || n === E.TD || n === E.TH ? t.openElements.hasInTableScope(n) && (t.openElements.popUntilTagNamePopped(E.SELECT), t._resetInsertionMode(), t.onEndTag(e)) : FE(t, e);
}
function Y3(t, e) {
  switch (e.tagID) {
    case E.BASE:
    case E.BASEFONT:
    case E.BGSOUND:
    case E.LINK:
    case E.META:
    case E.NOFRAMES:
    case E.SCRIPT:
    case E.STYLE:
    case E.TEMPLATE:
    case E.TITLE: {
      _n(t, e);
      break;
    }
    case E.CAPTION:
    case E.COLGROUP:
    case E.TBODY:
    case E.TFOOT:
    case E.THEAD: {
      t.tmplInsertionModeStack[0] = H.IN_TABLE, t.insertionMode = H.IN_TABLE, rs(t, e);
      break;
    }
    case E.COL: {
      t.tmplInsertionModeStack[0] = H.IN_COLUMN_GROUP, t.insertionMode = H.IN_COLUMN_GROUP, Xf(t, e);
      break;
    }
    case E.TR: {
      t.tmplInsertionModeStack[0] = H.IN_TABLE_BODY, t.insertionMode = H.IN_TABLE_BODY, sl(t, e);
      break;
    }
    case E.TD:
    case E.TH: {
      t.tmplInsertionModeStack[0] = H.IN_ROW, t.insertionMode = H.IN_ROW, al(t, e);
      break;
    }
    default:
      t.tmplInsertionModeStack[0] = H.IN_BODY, t.insertionMode = H.IN_BODY, Pt(t, e);
  }
}
function X3(t, e) {
  e.tagID === E.TEMPLATE && pi(t, e);
}
function BE(t, e) {
  t.openElements.tmplCount > 0 ? (t.openElements.popUntilTagNamePopped(E.TEMPLATE), t.activeFormattingElements.clearToLastMarker(), t.tmplInsertionModeStack.shift(), t._resetInsertionMode(), t.onEof(e)) : Yf(t, e);
}
function Q3(t, e) {
  e.tagID === E.HTML ? Pt(t, e) : bu(t, e);
}
function $E(t, e) {
  var n;
  if (e.tagID === E.HTML) {
    if (t.fragmentContext || (t.insertionMode = H.AFTER_AFTER_BODY), t.options.sourceCodeLocationInfo && t.openElements.tagIDs[0] === E.HTML) {
      t._setEndLocation(t.openElements.items[0], e);
      const r = t.openElements.items[1];
      r && !(!((n = t.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && t._setEndLocation(r, e);
    }
  } else
    bu(t, e);
}
function bu(t, e) {
  t.insertionMode = H.IN_BODY, rl(t, e);
}
function Z3(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.FRAMESET: {
      t._insertElement(e, ne.HTML);
      break;
    }
    case E.FRAME: {
      t._appendElement(e, ne.HTML), e.ackSelfClosing = !0;
      break;
    }
    case E.NOFRAMES: {
      _n(t, e);
      break;
    }
  }
}
function J3(t, e) {
  e.tagID === E.FRAMESET && !t.openElements.isRootHtmlElementCurrent() && (t.openElements.pop(), !t.fragmentContext && t.openElements.currentTagId !== E.FRAMESET && (t.insertionMode = H.AFTER_FRAMESET));
}
function eR(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.NOFRAMES: {
      _n(t, e);
      break;
    }
  }
}
function tR(t, e) {
  e.tagID === E.HTML && (t.insertionMode = H.AFTER_AFTER_FRAMESET);
}
function nR(t, e) {
  e.tagID === E.HTML ? Pt(t, e) : zo(t, e);
}
function zo(t, e) {
  t.insertionMode = H.IN_BODY, rl(t, e);
}
function rR(t, e) {
  switch (e.tagID) {
    case E.HTML: {
      Pt(t, e);
      break;
    }
    case E.NOFRAMES: {
      _n(t, e);
      break;
    }
  }
}
function iR(t, e) {
  e.chars = ot, t._insertCharacters(e);
}
function sR(t, e) {
  t._insertCharacters(e), t.framesetOk = !1;
}
function UE(t) {
  for (; t.treeAdapter.getNamespaceURI(t.openElements.current) !== ne.HTML && t.openElements.currentTagId !== void 0 && !t._isIntegrationPoint(t.openElements.currentTagId, t.openElements.current); )
    t.openElements.pop();
}
function aR(t, e) {
  if (S_(e))
    UE(t), t._startTagOutsideForeignContent(e);
  else {
    const n = t._getAdjustedCurrentElement(), r = t.treeAdapter.getNamespaceURI(n);
    r === ne.MATHML ? vE(e) : r === ne.SVG && (x_(e), AE(e)), Kf(e), e.selfClosing ? t._appendElement(e, r) : t._insertElement(e, r), e.ackSelfClosing = !0;
  }
}
function oR(t, e) {
  if (e.tagID === E.P || e.tagID === E.BR) {
    UE(t), t._endTagOutsideForeignContent(e);
    return;
  }
  for (let n = t.openElements.stackTop; n > 0; n--) {
    const r = t.openElements.items[n];
    if (t.treeAdapter.getNamespaceURI(r) === ne.HTML) {
      t._endTagOutsideForeignContent(e);
      break;
    }
    const i = t.treeAdapter.getTagName(r);
    if (i.toLowerCase() === e.tagName) {
      e.tagName = i, t.openElements.shortenToLength(n);
      break;
    }
  }
}
W.AREA, W.BASE, W.BASEFONT, W.BGSOUND, W.BR, W.COL, W.EMBED, W.FRAME, W.HR, W.IMG, W.INPUT, W.KEYGEN, W.LINK, W.META, W.PARAM, W.SOURCE, W.TRACK, W.WBR;
const HE = VE("end"), gi = VE("start");
function VE(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
const GE = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return dR;
    if (typeof t == "function")
      return ol(t);
    if (typeof t == "object")
      return Array.isArray(t) ? uR(t) : lR(t);
    if (typeof t == "string")
      return cR(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function uR(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = GE(t[n]);
  return ol(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function lR(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return ol(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function cR(t) {
  return ol(e);
  function e(n) {
    return n && n.type === t;
  }
}
function ol(t) {
  return e;
  function e(n, r, i) {
    return !!(fR(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function dR() {
  return !0;
}
function fR(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const zE = [], hR = !0, Eu = !1, mR = "skip";
function qE(t, e, n, r) {
  let i;
  typeof e == "function" && typeof n != "function" ? (r = n, n = e) : i = e;
  const s = GE(i), a = r ? -1 : 1;
  o(t, void 0, [])();
  function o(u, l, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      u && typeof u == "object" ? u : {}
    );
    if (typeof d.type == "string") {
      const h = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (u.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let h = zE, m, p, g;
      if ((!e || s(u, l, c[c.length - 1] || void 0)) && (h = pR(n(u, c)), h[0] === Eu))
        return h;
      if ("children" in u && u.children) {
        const b = (
          /** @type {UnistParent} */
          u
        );
        if (b.children && h[0] !== mR)
          for (p = (r ? b.children.length : -1) + a, g = c.concat(b); p > -1 && p < b.children.length; ) {
            const y = b.children[p];
            if (m = o(y, p, g)(), m[0] === Eu)
              return m;
            p = typeof m[1] == "number" ? m[1] : p + a;
          }
      }
      return h;
    }
  }
}
function pR(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [hR, t] : t == null ? zE : [t];
}
function ul(t, e, n, r) {
  let i, s, a;
  typeof e == "function" && typeof n != "function" ? (s = void 0, a = e, i = n) : (s = e, a = n, i = r), qE(t, s, o, i);
  function o(u, l) {
    const c = l[l.length - 1], d = c ? c.children.indexOf(u) : void 0;
    return a(u, d, c);
  }
}
const gR = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, bR = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), sm = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function WE(t, e) {
  const n = LR(t), r = qf("type", {
    handlers: { root: ER, element: yR, text: TR, comment: jE, doctype: SR, raw: vR },
    unknown: AR
  }), i = {
    parser: n ? new nm(sm) : nm.getFragmentParser(void 0, sm),
    handle(o) {
      r(o, i);
    },
    stitches: !1,
    options: e || {}
  };
  r(t, i), Ss(i, gi());
  const s = n ? i.parser.document : i.parser.getFragment(), a = dL(s, {
    // To do: support `space`?
    file: i.options.file
  });
  return i.stitches && ul(a, "comment", function(o, u, l) {
    const c = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (c.value.stitch && l && u !== void 0) {
      const d = l.children;
      return d[u] = c.value.stitch, u;
    }
  }), a.type === "root" && a.children.length === 1 && a.children[0].type === t.type ? a.children[0] : a;
}
function KE(t, e) {
  let n = -1;
  if (t)
    for (; ++n < t.length; )
      e.handle(t[n]);
}
function ER(t, e) {
  KE(t.children, e);
}
function yR(t, e) {
  IR(t, e), KE(t.children, e), CR(t, e);
}
function TR(t, e) {
  e.parser.tokenizer.state > 4 && (e.parser.tokenizer.state = 0);
  const n = {
    type: Fe.CHARACTER,
    chars: t.value,
    location: Ba(t)
  };
  Ss(e, gi(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function SR(t, e) {
  const n = {
    type: Fe.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: Ba(t)
  };
  Ss(e, gi(t)), e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken);
}
function xR(t, e) {
  e.stitches = !0;
  const n = _R(t);
  if ("children" in t && "children" in n) {
    const r = (
      /** @type {Root} */
      WE({ type: "root", children: t.children }, e.options)
    );
    n.children = r.children;
  }
  jE({ type: "comment", value: { stitch: n } }, e);
}
function jE(t, e) {
  const n = t.value, r = {
    type: Fe.COMMENT,
    data: n,
    location: Ba(t)
  };
  Ss(e, gi(t)), e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken);
}
function vR(t, e) {
  if (e.parser.tokenizer.preprocessor.html = "", e.parser.tokenizer.preprocessor.pos = -1, e.parser.tokenizer.preprocessor.lastGapPos = -2, e.parser.tokenizer.preprocessor.gapStack = [], e.parser.tokenizer.preprocessor.skipNextNewLine = !1, e.parser.tokenizer.preprocessor.lastChunkWritten = !1, e.parser.tokenizer.preprocessor.endOfChunkHit = !1, e.parser.tokenizer.preprocessor.isEol = !1, YE(e, gi(t)), e.parser.tokenizer.write(
    e.options.tagfilter ? t.value.replace(gR, "&lt;$1$2") : t.value,
    !1
  ), e.parser.tokenizer._runParsingLoop(), e.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  e.parser.tokenizer.state === 78) {
    e.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = e.parser.tokenizer._consume();
    e.parser.tokenizer._callState(n);
  }
}
function AR(t, e) {
  const n = (
    /** @type {Nodes} */
    t
  );
  if (e.options.passThrough && e.options.passThrough.includes(n.type))
    xR(n, e);
  else {
    let r = "";
    throw bR.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Ss(t, e) {
  YE(t, e);
  const n = t.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = t.parser.tokenizer.preprocessor.line, n.location.endCol = t.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = t.parser.tokenizer.preprocessor.offset + 1, t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken)), t.parser.tokenizer.paused = !1, t.parser.tokenizer.inLoop = !1, t.parser.tokenizer.active = !1, t.parser.tokenizer.returnState = dt.DATA, t.parser.tokenizer.charRefCode = -1, t.parser.tokenizer.consumedAfterSnapshot = -1, t.parser.tokenizer.currentLocation = null, t.parser.tokenizer.currentCharacterToken = null, t.parser.tokenizer.currentToken = null, t.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function YE(t, e) {
  if (e && e.offset !== void 0) {
    const n = {
      startLine: e.line,
      startCol: e.column,
      startOffset: e.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    t.parser.tokenizer.preprocessor.lineStartPos = -e.column + 1, t.parser.tokenizer.preprocessor.droppedBufferSize = e.offset, t.parser.tokenizer.preprocessor.line = e.line, t.parser.tokenizer.currentLocation = n;
  }
}
function IR(t, e) {
  const n = t.tagName.toLowerCase();
  if (e.parser.tokenizer.state === dt.PLAINTEXT) return;
  Ss(e, gi(t));
  const r = e.parser.openElements.current;
  let i = "namespaceURI" in r ? r.namespaceURI : Qr.html;
  i === Qr.html && n === "svg" && (i = Qr.svg);
  const s = CL(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...t, children: [] },
    { space: i === Qr.svg ? "svg" : "html" }
  ), a = {
    type: Fe.START_TAG,
    tagName: n,
    tagID: Ts(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in s ? s.attrs : [],
    location: Ba(t)
  };
  e.parser.currentToken = a, e.parser._processToken(e.parser.currentToken), e.parser.tokenizer.lastStartTagName = n;
}
function CR(t, e) {
  const n = t.tagName.toLowerCase();
  if (!e.parser.tokenizer.inForeignNode && hE.includes(n) || e.parser.tokenizer.state === dt.PLAINTEXT) return;
  Ss(e, HE(t));
  const r = {
    type: Fe.END_TAG,
    tagName: n,
    tagID: Ts(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: Ba(t)
  };
  e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken), // Current element is closed.
  n === e.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (e.parser.tokenizer.state === dt.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  e.parser.tokenizer.state === dt.RAWTEXT || // `<script>`
  e.parser.tokenizer.state === dt.SCRIPT_DATA) && (e.parser.tokenizer.state = dt.DATA);
}
function LR(t) {
  const e = t.type === "root" ? t.children[0] : t;
  return !!(e && (e.type === "doctype" || e.type === "element" && e.tagName.toLowerCase() === "html"));
}
function Ba(t) {
  const e = gi(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = HE(t) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: e.line,
    startCol: e.column,
    startOffset: e.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function _R(t) {
  return "children" in t ? ns({ ...t, children: [] }) : ns(t);
}
function RR(t) {
  return function(e, n) {
    return (
      /** @type {Root} */
      WE(e, { ...t, file: n })
    );
  };
}
class $a {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
}
$a.prototype.normal = {};
$a.prototype.property = {};
$a.prototype.space = void 0;
function XE(t, e) {
  const n = {}, r = {};
  for (const i of t)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new $a(n, r, e);
}
function fd(t) {
  return t.toLowerCase();
}
class Qt {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
}
Qt.prototype.attribute = "";
Qt.prototype.booleanish = !1;
Qt.prototype.boolean = !1;
Qt.prototype.commaOrSpaceSeparated = !1;
Qt.prototype.commaSeparated = !1;
Qt.prototype.defined = !1;
Qt.prototype.mustUseProperty = !1;
Qt.prototype.number = !1;
Qt.prototype.overloadedBoolean = !1;
Qt.prototype.property = "";
Qt.prototype.spaceSeparated = !1;
Qt.prototype.space = void 0;
let wR = 0;
const De = bi(), pt = bi(), hd = bi(), ue = bi(), rt = bi(), qi = bi(), rn = bi();
function bi() {
  return 2 ** ++wR;
}
const md = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: De,
  booleanish: pt,
  commaOrSpaceSeparated: rn,
  commaSeparated: qi,
  number: ue,
  overloadedBoolean: hd,
  spaceSeparated: rt
}, Symbol.toStringTag, { value: "Module" })), Kl = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(md)
);
class Qf extends Qt {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, i) {
    let s = -1;
    if (super(e, n), am(this, "space", i), typeof r == "number")
      for (; ++s < Kl.length; ) {
        const a = Kl[s];
        am(this, Kl[s], (r & md[a]) === md[a]);
      }
  }
}
Qf.prototype.defined = !0;
function am(t, e, n) {
  n && (t[e] = n);
}
function xs(t) {
  const e = {}, n = {};
  for (const [r, i] of Object.entries(t.properties)) {
    const s = new Qf(
      r,
      t.transform(t.attributes || {}, r),
      i,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[fd(r)] = r, n[fd(s.attribute)] = r;
  }
  return new $a(e, n, t.space);
}
const QE = xs({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: pt,
    ariaAutoComplete: null,
    ariaBusy: pt,
    ariaChecked: pt,
    ariaColCount: ue,
    ariaColIndex: ue,
    ariaColSpan: ue,
    ariaControls: rt,
    ariaCurrent: null,
    ariaDescribedBy: rt,
    ariaDetails: null,
    ariaDisabled: pt,
    ariaDropEffect: rt,
    ariaErrorMessage: null,
    ariaExpanded: pt,
    ariaFlowTo: rt,
    ariaGrabbed: pt,
    ariaHasPopup: null,
    ariaHidden: pt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: rt,
    ariaLevel: ue,
    ariaLive: null,
    ariaModal: pt,
    ariaMultiLine: pt,
    ariaMultiSelectable: pt,
    ariaOrientation: null,
    ariaOwns: rt,
    ariaPlaceholder: null,
    ariaPosInSet: ue,
    ariaPressed: pt,
    ariaReadOnly: pt,
    ariaRelevant: null,
    ariaRequired: pt,
    ariaRoleDescription: rt,
    ariaRowCount: ue,
    ariaRowIndex: ue,
    ariaRowSpan: ue,
    ariaSelected: pt,
    ariaSetSize: ue,
    ariaSort: null,
    ariaValueMax: ue,
    ariaValueMin: ue,
    ariaValueNow: ue,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function ZE(t, e) {
  return e in t ? t[e] : e;
}
function JE(t, e) {
  return ZE(t, e.toLowerCase());
}
const kR = xs({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: qi,
    acceptCharset: rt,
    accessKey: rt,
    action: null,
    allow: null,
    allowFullScreen: De,
    allowPaymentRequest: De,
    allowUserMedia: De,
    alt: null,
    as: null,
    async: De,
    autoCapitalize: null,
    autoComplete: rt,
    autoFocus: De,
    autoPlay: De,
    blocking: rt,
    capture: null,
    charSet: null,
    checked: De,
    cite: null,
    className: rt,
    cols: ue,
    colSpan: null,
    content: null,
    contentEditable: pt,
    controls: De,
    controlsList: rt,
    coords: ue | qi,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: De,
    defer: De,
    dir: null,
    dirName: null,
    disabled: De,
    download: hd,
    draggable: pt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: De,
    formTarget: null,
    headers: rt,
    height: ue,
    hidden: hd,
    high: ue,
    href: null,
    hrefLang: null,
    htmlFor: rt,
    httpEquiv: rt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: De,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: De,
    itemId: null,
    itemProp: rt,
    itemRef: rt,
    itemScope: De,
    itemType: rt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: De,
    low: ue,
    manifest: null,
    max: null,
    maxLength: ue,
    media: null,
    method: null,
    min: null,
    minLength: ue,
    multiple: De,
    muted: De,
    name: null,
    nonce: null,
    noModule: De,
    noValidate: De,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: De,
    optimum: ue,
    pattern: null,
    ping: rt,
    placeholder: null,
    playsInline: De,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: De,
    referrerPolicy: null,
    rel: rt,
    required: De,
    reversed: De,
    rows: ue,
    rowSpan: ue,
    sandbox: rt,
    scope: null,
    scoped: De,
    seamless: De,
    selected: De,
    shadowRootClonable: De,
    shadowRootDelegatesFocus: De,
    shadowRootMode: null,
    shape: null,
    size: ue,
    sizes: null,
    slot: null,
    span: ue,
    spellCheck: pt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ue,
    step: null,
    style: null,
    tabIndex: ue,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: De,
    useMap: null,
    value: pt,
    width: ue,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: rt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ue,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ue,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: De,
    // Lists. Use CSS to reduce space between items instead
    declare: De,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ue,
    // `<img>` and `<object>`
    leftMargin: ue,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ue,
    // `<body>`
    marginWidth: ue,
    // `<body>`
    noResize: De,
    // `<frame>`
    noHref: De,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: De,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: De,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ue,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: pt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ue,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ue,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: De,
    disableRemotePlayback: De,
    prefix: null,
    property: null,
    results: ue,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: JE
}), DR = xs({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: rn,
    accentHeight: ue,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ue,
    amplitude: ue,
    arabicForm: null,
    ascent: ue,
    attributeName: null,
    attributeType: null,
    azimuth: ue,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ue,
    by: null,
    calcMode: null,
    capHeight: ue,
    className: rt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ue,
    diffuseConstant: ue,
    direction: null,
    display: null,
    dur: null,
    divisor: ue,
    dominantBaseline: null,
    download: De,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ue,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ue,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ue,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: qi,
    g2: qi,
    glyphName: qi,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ue,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ue,
    horizOriginX: ue,
    horizOriginY: ue,
    id: null,
    ideographic: ue,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ue,
    k: ue,
    k1: ue,
    k2: ue,
    k3: ue,
    k4: ue,
    kernelMatrix: rn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ue,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ue,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ue,
    overlineThickness: ue,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ue,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: rt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ue,
    pointsAtY: ue,
    pointsAtZ: ue,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: rn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: rn,
    rev: rn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: rn,
    requiredFeatures: rn,
    requiredFonts: rn,
    requiredFormats: rn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ue,
    specularExponent: ue,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ue,
    strikethroughThickness: ue,
    string: null,
    stroke: null,
    strokeDashArray: rn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ue,
    strokeOpacity: ue,
    strokeWidth: null,
    style: null,
    surfaceScale: ue,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: rn,
    tabIndex: ue,
    tableValues: null,
    target: null,
    targetX: ue,
    targetY: ue,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: rn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ue,
    underlineThickness: ue,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ue,
    values: null,
    vAlphabetic: ue,
    vMathematical: ue,
    vectorEffect: null,
    vHanging: ue,
    vIdeographic: ue,
    version: null,
    vertAdvY: ue,
    vertOriginX: ue,
    vertOriginY: ue,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ue,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: ZE
}), ey = xs({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), ty = xs({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: JE
}), ny = xs({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), PR = /[A-Z]/g, om = /-[a-z]/g, OR = /^data[-\w.:]+$/i;
function NR(t, e) {
  const n = fd(e);
  let r = e, i = Qt;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && OR.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(om, FR);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!om.test(s)) {
        let a = s.replace(PR, MR);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    i = Qf;
  }
  return new i(r, e);
}
function MR(t) {
  return "-" + t.toLowerCase();
}
function FR(t) {
  return t.charAt(1).toUpperCase();
}
const BR = XE([QE, kR, ey, ty, ny], "html"), ry = XE([QE, DR, ey, ty, ny], "svg"), $R = /["&'<>`]/g, UR = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, HR = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), VR = /[|\\{}()[\]^$+*?.]/g, um = /* @__PURE__ */ new WeakMap();
function GR(t, e) {
  if (t = t.replace(
    e.subset ? zR(e.subset) : $R,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(UR, n).replace(HR, r);
  function n(i, s, a) {
    return e.format(
      (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(s + 2),
      e
    );
  }
  function r(i, s, a) {
    return e.format(
      i.charCodeAt(0),
      a.charCodeAt(s + 1),
      e
    );
  }
}
function zR(t) {
  let e = um.get(t);
  return e || (e = qR(t), um.set(t, e)), e;
}
function qR(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(VR, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const WR = /[\dA-Fa-f]/;
function KR(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !WR.test(String.fromCharCode(e)) ? r : r + ";";
}
const jR = /\d/;
function YR(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !jR.test(String.fromCharCode(e)) ? r : r + ";";
}
const XR = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], jl = {
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  fnof: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  bull: "",
  hellip: "",
  prime: "",
  Prime: "",
  oline: "",
  frasl: "",
  weierp: "",
  image: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: "",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  circ: "",
  tilde: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  permil: "",
  lsaquo: "",
  rsaquo: "",
  euro: ""
}, QR = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], iy = {}.hasOwnProperty, pd = {};
let no;
for (no in jl)
  iy.call(jl, no) && (pd[jl[no]] = no);
const ZR = /[^\dA-Za-z]/;
function JR(t, e, n, r) {
  const i = String.fromCharCode(t);
  if (iy.call(pd, i)) {
    const s = pd[i], a = "&" + s;
    return n && XR.includes(s) && !QR.includes(s) && (!r || e && e !== 61 && ZR.test(String.fromCharCode(e))) ? a : a + ";";
  }
  return "";
}
function ew(t, e, n) {
  let r = KR(t, e, n.omitOptionalSemicolons), i;
  if ((n.useNamedReferences || n.useShortestReferences) && (i = JR(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !i) && n.useShortestReferences) {
    const s = YR(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return i && (!n.useShortestReferences || i.length < r.length) ? i : r;
}
function Wi(t, e) {
  return GR(t, Object.assign({ format: ew }, e));
}
const tw = /^>|^->|<!--|-->|--!>|<!-$/g, nw = [">"], rw = ["<", ">"];
function iw(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Wi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: nw
    })
  ) + ">" : "<!--" + t.value.replace(tw, i) + "-->";
  function i(s) {
    return Wi(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: rw
      })
    );
  }
}
function sw(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
function yu(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(e);
  for (; i !== -1; )
    r++, i = n.indexOf(e, i + e.length);
  return r;
}
const aw = /[ \t\n\f\r]/g;
function Zf(t) {
  return typeof t == "object" ? t.type === "text" ? lm(t.value) : !1 : lm(t);
}
function lm(t) {
  return t.replace(aw, "") === "";
}
const St = ay(1), sy = ay(-1), ow = [];
function ay(t) {
  return e;
  function e(n, r, i) {
    const s = n ? n.children : ow;
    let a = (r || 0) + t, o = s[a];
    if (!i)
      for (; o && Zf(o); )
        a += t, o = s[a];
    return o;
  }
}
const uw = {}.hasOwnProperty;
function oy(t) {
  return e;
  function e(n, r, i) {
    return uw.call(t, n.tagName) && t[n.tagName](n, r, i);
  }
}
const Jf = oy({
  body: cw,
  caption: Yl,
  colgroup: Yl,
  dd: mw,
  dt: hw,
  head: Yl,
  html: lw,
  li: fw,
  optgroup: pw,
  option: gw,
  p: dw,
  rp: cm,
  rt: cm,
  tbody: Ew,
  td: dm,
  tfoot: yw,
  th: dm,
  thead: bw,
  tr: Tw
});
function Yl(t, e, n) {
  const r = St(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && Zf(r.value.charAt(0)));
}
function lw(t, e, n) {
  const r = St(n, e);
  return !r || r.type !== "comment";
}
function cw(t, e, n) {
  const r = St(n, e);
  return !r || r.type !== "comment";
}
function dw(t, e, n) {
  const r = St(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function fw(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function hw(t, e, n) {
  const r = St(n, e);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function mw(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function cm(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function pw(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function gw(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function bw(t, e, n) {
  const r = St(n, e);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function Ew(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function yw(t, e, n) {
  return !St(n, e);
}
function Tw(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function dm(t, e, n) {
  const r = St(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const Sw = oy({
  body: Aw,
  colgroup: Iw,
  head: vw,
  html: xw,
  tbody: Cw
});
function xw(t) {
  const e = St(t, -1);
  return !e || e.type !== "comment";
}
function vw(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (e.has(r.tagName)) return !1;
      e.add(r.tagName);
    }
  const n = t.children[0];
  return !n || n.type === "element";
}
function Aw(t) {
  const e = St(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && Zf(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Iw(t, e, n) {
  const r = sy(n, e), i = St(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && Jf(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "col");
}
function Cw(t, e, n) {
  const r = sy(n, e), i = St(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && Jf(r, n.children.indexOf(r), n) ? !1 : !!(i && i.type === "element" && i.tagName === "tr");
}
const ro = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Lw(t, e, n, r) {
  const i = r.schema, s = i.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let a = i.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const o = [];
  let u;
  i.space === "html" && t.tagName === "svg" && (r.schema = ry);
  const l = _w(r, t.properties), c = r.all(
    i.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = i, c && (a = !1), (l || !s || !Sw(t, e, n)) && (o.push("<", t.tagName, l ? " " + l : ""), a && (i.space === "svg" || r.settings.closeSelfClosing) && (u = l.charAt(l.length - 1), (!r.settings.tightSelfClosing || u === "/" || u && u !== '"' && u !== "'") && o.push(" "), o.push("/")), o.push(">")), o.push(c), !a && (!s || !Jf(t, e, n)) && o.push("</" + t.tagName + ">"), o.join("");
}
function _w(t, e) {
  const n = [];
  let r = -1, i;
  if (e) {
    for (i in e)
      if (e[i] !== null && e[i] !== void 0) {
        const s = Rw(t, i, e[i]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function Rw(t, e, n) {
  const r = NR(t.schema, e), i = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let a = t.quote, o;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const u = Wi(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: ro.name[i][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? Gb : zb)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? u : (t.settings.preferUnquoted && (o = Wi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: ro.unquoted[i][s]
    })
  )), o !== n && (t.settings.quoteSmart && yu(n, a) > yu(n, t.alternative) && (a = t.alternative), o = a + Wi(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (a === "'" ? ro.single : ro.double)[i][s],
      attribute: !0
    })
  ) + a), u + (o && "=" + o));
}
const ww = ["<", "&"];
function uy(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Wi(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: ww
    })
  );
}
function kw(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : uy(t, e, n, r);
}
function Dw(t, e, n, r) {
  return r.all(t);
}
const Pw = qf("type", {
  invalid: Ow,
  unknown: Nw,
  handlers: { comment: iw, doctype: sw, element: Lw, raw: kw, root: Dw, text: uy }
});
function Ow(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function Nw(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const Mw = {}, Fw = {}, Bw = [];
function $w(t, e) {
  const n = e || Mw, r = n.quote || '"', i = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: Uw,
    all: Hw,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || hE,
      characterReferences: n.characterReferences || Fw,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? ry : BR,
    quote: r,
    alternative: i
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function Uw(t, e, n) {
  return Pw(t, e, n, this);
}
function Hw(t) {
  const e = [], n = t && t.children || Bw;
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
function Vw(t) {
  const e = this, n = { ...e.data("settings"), ...t };
  e.compiler = r;
  function r(i) {
    return $w(i, n);
  }
}
const Gw = ly(new RegExp("\\p{P}|\\p{S}", "u")), zw = ly(/\s/);
function ly(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function qw(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const cy = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return Yw;
    if (typeof t == "function")
      return ll(t);
    if (typeof t == "object")
      return Array.isArray(t) ? Ww(t) : Kw(t);
    if (typeof t == "string")
      return jw(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function Ww(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = cy(t[n]);
  return ll(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function Kw(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return ll(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function jw(t) {
  return ll(e);
  function e(n) {
    return n && n.type === t;
  }
}
function ll(t) {
  return e;
  function e(n, r, i) {
    return !!(Xw(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function Yw() {
  return !0;
}
function Xw(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
function Qw(t, e, n) {
  const i = cy((n || {}).ignore || []), s = Zw(e);
  let a = -1;
  for (; ++a < s.length; )
    qE(t, "text", o);
  function o(l, c) {
    let d = -1, f;
    for (; ++d < c.length; ) {
      const h = c[d], m = f ? f.children : void 0;
      if (i(
        h,
        m ? m.indexOf(h) : void 0,
        f
      ))
        return;
      f = h;
    }
    if (f)
      return u(l, c);
  }
  function u(l, c) {
    const d = c[c.length - 1], f = s[a][0], h = s[a][1];
    let m = 0;
    const g = d.children.indexOf(l);
    let b = !1, y = [];
    f.lastIndex = 0;
    let T = f.exec(l.value);
    for (; T; ) {
      const S = T.index, I = {
        index: T.index,
        input: T.input,
        stack: [...c, l]
      };
      let C = h(...T, I);
      if (typeof C == "string" && (C = C.length > 0 ? { type: "text", value: C } : void 0), C === !1 ? f.lastIndex = S + 1 : (m !== S && y.push({
        type: "text",
        value: l.value.slice(m, S)
      }), Array.isArray(C) ? y.push(...C) : C && y.push(C), m = S + T[0].length, b = !0), !f.global)
        break;
      T = f.exec(l.value);
    }
    return b ? (m < l.value.length && y.push({ type: "text", value: l.value.slice(m) }), d.children.splice(g, 1, ...y)) : y = [l], g + y.length;
  }
}
function Zw(t) {
  const e = [];
  if (!Array.isArray(t))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !t[0] || Array.isArray(t[0]) ? t : [t];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    e.push([Jw(i[0]), ek(i[1])]);
  }
  return e;
}
function Jw(t) {
  return typeof t == "string" ? new RegExp(qw(t), "g") : t;
}
function ek(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}
const Xl = "phrasing", Ql = ["autolink", "link", "image", "label"];
function tk() {
  return {
    transforms: [uk],
    enter: {
      literalAutolink: rk,
      literalAutolinkEmail: Zl,
      literalAutolinkHttp: Zl,
      literalAutolinkWww: Zl
    },
    exit: {
      literalAutolink: ok,
      literalAutolinkEmail: ak,
      literalAutolinkHttp: ik,
      literalAutolinkWww: sk
    }
  };
}
function nk() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Xl,
        notInConstruct: Ql
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Xl,
        notInConstruct: Ql
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Xl,
        notInConstruct: Ql
      }
    ]
  };
}
function rk(t) {
  this.enter({ type: "link", title: null, url: "", children: [] }, t);
}
function Zl(t) {
  this.config.enter.autolinkProtocol.call(this, t);
}
function ik(t) {
  this.config.exit.autolinkProtocol.call(this, t);
}
function sk(t) {
  this.config.exit.data.call(this, t);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(t);
}
function ak(t) {
  this.config.exit.autolinkEmail.call(this, t);
}
function ok(t) {
  this.exit(t);
}
function uk(t) {
  Qw(
    t,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, lk],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), ck]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function lk(t, e, n, r, i) {
  let s = "";
  if (!dy(i) || (/^w/i.test(e) && (n = e + n, e = "", s = "http://"), !dk(n)))
    return !1;
  const a = fk(n + r);
  if (!a[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: s + e + a[0],
    children: [{ type: "text", value: e + a[0] }]
  };
  return a[1] ? [o, { type: "text", value: a[1] }] : o;
}
function ck(t, e, n, r) {
  return (
    // Not an expected previous character.
    !dy(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + n,
      children: [{ type: "text", value: e + "@" + n }]
    }
  );
}
function dk(t) {
  const e = t.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function fk(t) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(t);
  if (!e)
    return [t, void 0];
  t = t.slice(0, e.index);
  let n = e[0], r = n.indexOf(")");
  const i = yu(t, "(");
  let s = yu(t, ")");
  for (; r !== -1 && i > s; )
    t += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), s++;
  return [t, n];
}
function dy(t, e) {
  const n = t.input.charCodeAt(t.index - 1);
  return (t.index === 0 || zw(n) || Gw(n)) && // If its an email, the previous character should not be a slash.
  (!e || n !== 47);
}
function fy(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
hy.peek = Sk;
function hk() {
  this.buffer();
}
function mk(t) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, t);
}
function pk() {
  this.buffer();
}
function gk(t) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    t
  );
}
function bk(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = fy(
    this.sliceSerialize(t)
  ).toLowerCase(), n.label = e;
}
function Ek(t) {
  this.exit(t);
}
function yk(t) {
  const e = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = fy(
    this.sliceSerialize(t)
  ).toLowerCase(), n.label = e;
}
function Tk(t) {
  this.exit(t);
}
function Sk() {
  return "[";
}
function hy(t, e, n, r) {
  const i = n.createTracker(r);
  let s = i.move("[^");
  const a = n.enter("footnoteReference"), o = n.enter("reference");
  return s += i.move(
    n.safe(n.associationId(t), { after: "]", before: s })
  ), o(), a(), s += i.move("]"), s;
}
function xk() {
  return {
    enter: {
      gfmFootnoteCallString: hk,
      gfmFootnoteCall: mk,
      gfmFootnoteDefinitionLabelString: pk,
      gfmFootnoteDefinition: gk
    },
    exit: {
      gfmFootnoteCallString: bk,
      gfmFootnoteCall: Ek,
      gfmFootnoteDefinitionLabelString: yk,
      gfmFootnoteDefinition: Tk
    }
  };
}
function vk(t) {
  let e = !1;
  return t && t.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: hy },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, s, a) {
    const o = s.createTracker(a);
    let u = o.move("[^");
    const l = s.enter("footnoteDefinition"), c = s.enter("label");
    return u += o.move(
      s.safe(s.associationId(r), { before: u, after: "]" })
    ), c(), u += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), u += o.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, o.current()),
        e ? my : Ak
      )
    )), l(), u;
  }
}
function Ak(t, e, n) {
  return e === 0 ? t : my(t, e, n);
}
function my(t, e, n) {
  return (n ? "" : "    ") + t;
}
const Ik = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
py.peek = wk;
function Ck() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: _k },
    exit: { strikethrough: Rk }
  };
}
function Lk() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Ik
      }
    ],
    handlers: { delete: py }
  };
}
function _k(t) {
  this.enter({ type: "delete", children: [] }, t);
}
function Rk(t) {
  this.exit(t);
}
function py(t, e, n, r) {
  const i = n.createTracker(r), s = n.enter("strikethrough");
  let a = i.move("~~");
  return a += n.containerPhrasing(t, {
    ...i.current(),
    before: a,
    after: "~"
  }), a += i.move("~~"), s(), a;
}
function wk() {
  return "~";
}
function kk(t) {
  return t.length;
}
function Dk(t, e) {
  const n = e || {}, r = (n.align || []).concat(), i = n.stringLength || kk, s = [], a = [], o = [], u = [];
  let l = 0, c = -1;
  for (; ++c < t.length; ) {
    const p = [], g = [];
    let b = -1;
    for (t[c].length > l && (l = t[c].length); ++b < t[c].length; ) {
      const y = Pk(t[c][b]);
      if (n.alignDelimiters !== !1) {
        const T = i(y);
        g[b] = T, (u[b] === void 0 || T > u[b]) && (u[b] = T);
      }
      p.push(y);
    }
    a[c] = p, o[c] = g;
  }
  let d = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++d < l; )
      s[d] = fm(r[d]);
  else {
    const p = fm(r);
    for (; ++d < l; )
      s[d] = p;
  }
  d = -1;
  const f = [], h = [];
  for (; ++d < l; ) {
    const p = s[d];
    let g = "", b = "";
    p === 99 ? (g = ":", b = ":") : p === 108 ? g = ":" : p === 114 && (b = ":");
    let y = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      u[d] - g.length - b.length
    );
    const T = g + "-".repeat(y) + b;
    n.alignDelimiters !== !1 && (y = g.length + y + b.length, y > u[d] && (u[d] = y), h[d] = y), f[d] = T;
  }
  a.splice(1, 0, f), o.splice(1, 0, h), c = -1;
  const m = [];
  for (; ++c < a.length; ) {
    const p = a[c], g = o[c];
    d = -1;
    const b = [];
    for (; ++d < l; ) {
      const y = p[d] || "";
      let T = "", S = "";
      if (n.alignDelimiters !== !1) {
        const I = u[d] - (g[d] || 0), C = s[d];
        C === 114 ? T = " ".repeat(I) : C === 99 ? I % 2 ? (T = " ".repeat(I / 2 + 0.5), S = " ".repeat(I / 2 - 0.5)) : (T = " ".repeat(I / 2), S = T) : S = " ".repeat(I);
      }
      n.delimiterStart !== !1 && !d && b.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && y === "") && (n.delimiterStart !== !1 || d) && b.push(" "), n.alignDelimiters !== !1 && b.push(T), b.push(y), n.alignDelimiters !== !1 && b.push(S), n.padding !== !1 && b.push(" "), (n.delimiterEnd !== !1 || d !== l - 1) && b.push("|");
    }
    m.push(
      n.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return m.join(`
`);
}
function Pk(t) {
  return t == null ? "" : String(t);
}
function fm(t) {
  const e = typeof t == "string" ? t.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function Ok(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const a = n.indentLines(
    n.containerFlow(t, s.current()),
    Nk
  );
  return i(), a;
}
function Nk(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function Mk(t, e) {
  return hm(t, e.inConstruct, !0) && !hm(t, e.notInConstruct, !1);
}
function hm(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function mm(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && Mk(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function gy(t, e) {
  const n = String(t);
  let r = n.indexOf(e), i = r, s = 0, a = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > a && (a = s) : s = 1, i = r + e.length, r = n.indexOf(e, i);
  return a;
}
function Fk(t, e) {
  return !!(e.options.fences === !1 && t.value && // If theres no info
  !t.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(t.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function Bk(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function $k(t, e, n, r) {
  const i = Bk(n), s = t.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (Fk(t, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(s, Uk);
    return d(), f;
  }
  const o = n.createTracker(r), u = i.repeat(Math.max(gy(s, i) + 1, 3)), l = n.enter("codeFenced");
  let c = o.move(u);
  if (t.lang) {
    const d = n.enter(`codeFencedLang${a}`);
    c += o.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (t.lang && t.meta) {
    const d = n.enter(`codeFencedMeta${a}`);
    c += o.move(" "), c += o.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), s && (c += o.move(s + `
`)), c += o.move(u), l(), c;
}
function Uk(t, e, n) {
  return (n ? "" : "    ") + t;
}
function eh(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function Hk(t, e, n, r) {
  const i = eh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("[");
  return l += u.move(
    n.safe(n.associationId(t), {
      before: l,
      after: "]",
      ...u.current()
    })
  ), l += u.move("]: "), o(), // If theres no url, or
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : `
`,
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), a(), l;
}
function Vk(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function da(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function Gk(t) {
  return t !== null && (t < 0 || t === 32);
}
const zk = by(new RegExp("\\p{P}|\\p{S}", "u")), qk = by(/\s/);
function by(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function pm(t) {
  if (t === null || Gk(t) || qk(t))
    return 1;
  if (zk(t))
    return 2;
}
function Tu(t, e, n) {
  const r = pm(t), i = pm(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Ey.peek = Wk;
function Ey(t, e, n, r) {
  const i = Vk(n), s = n.enter("emphasis"), a = n.createTracker(r), o = a.move(i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Tu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = da(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Tu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + da(d));
  const h = a.move(i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function Wk(t, e, n) {
  return n.options.emphasis || "*";
}
const Kk = {};
function yy(t, e) {
  const n = Kk, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return Ty(t, r, i);
}
function Ty(t, e, n) {
  if (jk(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return gm(t.children, e, n);
  }
  return Array.isArray(t) ? gm(t, e, n) : "";
}
function gm(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = Ty(t[i], e, n);
  return r.join("");
}
function jk(t) {
  return !!(t && typeof t == "object");
}
function Yk(t, e) {
  let n = !1;
  return ul(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Eu;
  }), !!((!t.depth || t.depth < 3) && yy(t) && (e.options.setext || n));
}
function Xk(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (Yk(t, n)) {
    const c = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), o = n.enter("headingAtx"), u = n.enter("phrasing");
  s.move(a + " ");
  let l = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(l) && (l = da(l.charCodeAt(0)) + l.slice(1)), l = l ? a + " " + l : a, n.options.closeAtx && (l += " " + a), u(), o(), l;
}
Sy.peek = Qk;
function Sy(t) {
  return t.value || "";
}
function Qk() {
  return "<";
}
xy.peek = Zk;
function xy(t, e, n, r) {
  const i = eh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("![");
  return l += u.move(
    n.safe(t.alt, { before: l, after: "]", ...u.current() })
  ), l += u.move("]("), o(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), l += u.move(")"), a(), l;
}
function Zk() {
  return "!";
}
vy.peek = Jk;
function vy(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const l = n.safe(t.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function Jk() {
  return "!";
}
Ay.peek = eD;
function Ay(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const a = n.unsafe[s], o = n.compilePattern(a);
    let u;
    if (a.atBreak)
      for (; u = o.exec(r); ) {
        let l = u.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(u.index + 1);
      }
  }
  return i + r + i;
}
function eD() {
  return "`";
}
function Iy(t, e) {
  const n = yy(t);
  return !!(!e.options.resourceLink && // If theres a url
  t.url && // And theres a no title
  !t.title && // And the content of `node` is a single text node
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(t.url));
}
Cy.peek = tD;
function Cy(t, e, n, r) {
  const i = eh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let o, u;
  if (Iy(t, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = a.move("<");
    return d += a.move(
      n.containerPhrasing(t, {
        before: d,
        after: ">",
        ...a.current()
      })
    ), d += a.move(">"), o(), n.stack = c, d;
  }
  o = n.enter("link"), u = n.enter("label");
  let l = a.move("[");
  return l += a.move(
    n.containerPhrasing(t, {
      before: l,
      after: "](",
      ...a.current()
    })
  ), l += a.move("]("), u(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (u = n.enter("destinationLiteral"), l += a.move("<"), l += a.move(
    n.safe(t.url, { before: l, after: ">", ...a.current() })
  ), l += a.move(">")) : (u = n.enter("destinationRaw"), l += a.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...a.current()
    })
  )), u(), t.title && (u = n.enter(`title${s}`), l += a.move(" " + i), l += a.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...a.current()
    })
  ), l += a.move(i), u()), l += a.move(")"), o(), l;
}
function tD(t, e, n) {
  return Iy(t, n) ? "<" : "[";
}
Ly.peek = nD;
function Ly(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const l = n.containerPhrasing(t, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function nD() {
  return "[";
}
function th(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function rD(t) {
  const e = th(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function iD(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function _y(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function sD(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let a = t.ordered ? iD(n) : th(n);
  const o = t.ordered ? a === "." ? ")" : "." : rD(n);
  let u = e && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const c = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), _y(n) === a && c
    ) {
      let d = -1;
      for (; ++d < t.children.length; ) {
        const f = t.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (a = o), n.bulletCurrent = a;
  const l = n.containerFlow(t, r);
  return n.bulletLastUsed = a, n.bulletCurrent = s, i(), l;
}
function aD(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function oD(t, e, n, r) {
  const i = aD(n);
  let s = n.bulletCurrent || th(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let a = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (a = Math.ceil(a / 4) * 4);
  const o = n.createTracker(r);
  o.move(s + " ".repeat(a - s.length)), o.shift(a);
  const u = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(t, o.current()),
    c
  );
  return u(), l;
  function c(d, f, h) {
    return f ? (h ? "" : " ".repeat(a)) + d : (h ? s : s + " ".repeat(a - s.length)) + d;
  }
}
function uD(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), a = n.containerPhrasing(t, r);
  return s(), i(), a;
}
const Ry = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return fD;
    if (typeof t == "function")
      return cl(t);
    if (typeof t == "object")
      return Array.isArray(t) ? lD(t) : cD(t);
    if (typeof t == "string")
      return dD(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function lD(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Ry(t[n]);
  return cl(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function cD(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return cl(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function dD(t) {
  return cl(e);
  function e(n) {
    return n && n.type === t;
  }
}
function cl(t) {
  return e;
  function e(n, r, i) {
    return !!(hD(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function fD() {
  return !0;
}
function hD(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const mD = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Ry([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function pD(t, e, n, r) {
  return (t.children.some(function(a) {
    return mD(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function gD(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
wy.peek = bD;
function wy(t, e, n, r) {
  const i = gD(n), s = n.enter("strong"), a = n.createTracker(r), o = a.move(i + i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Tu(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = da(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Tu(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + da(d));
  const h = a.move(i + i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function bD(t, e, n) {
  return n.options.strong || "*";
}
function ED(t, e, n, r) {
  return n.safe(t.value, r);
}
function yD(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function TD(t, e, n) {
  const r = (_y(n) + (n.options.ruleSpaces ? " " : "")).repeat(yD(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const SD = {
  blockquote: Ok,
  break: mm,
  code: $k,
  definition: Hk,
  emphasis: Ey,
  hardBreak: mm,
  heading: Xk,
  html: Sy,
  image: xy,
  imageReference: vy,
  inlineCode: Ay,
  link: Cy,
  linkReference: Ly,
  list: sD,
  listItem: oD,
  paragraph: uD,
  root: pD,
  strong: wy,
  text: ED,
  thematicBreak: TD
}, bm = document.createElement("i");
function nh(t) {
  const e = "&" + t + ";";
  bm.innerHTML = e;
  const n = bm.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && t !== "semi" || n === e ? !1 : n
  );
}
function xD() {
  return {
    enter: {
      table: vD,
      tableData: Em,
      tableHeader: Em,
      tableRow: ID
    },
    exit: {
      codeText: CD,
      table: AD,
      tableData: Jl,
      tableHeader: Jl,
      tableRow: Jl
    }
  };
}
function vD(t) {
  const e = t._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    t
  ), this.data.inTable = !0;
}
function AD(t) {
  this.exit(t), this.data.inTable = void 0;
}
function ID(t) {
  this.enter({ type: "tableRow", children: [] }, t);
}
function Jl(t) {
  this.exit(t);
}
function Em(t) {
  this.enter({ type: "tableCell", children: [] }, t);
}
function CD(t) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, LD));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = e, this.exit(t);
}
function LD(t, e) {
  return e === "|" ? e : t;
}
function _D(t) {
  const e = t || {}, n = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: a,
      tableCell: u,
      tableRow: o
    }
  };
  function a(h, m, p, g) {
    return l(c(h, p, g), h.align);
  }
  function o(h, m, p, g) {
    const b = d(h, p, g), y = l([b]);
    return y.slice(0, y.indexOf(`
`));
  }
  function u(h, m, p, g) {
    const b = p.enter("tableCell"), y = p.enter("phrasing"), T = p.containerPhrasing(h, {
      ...g,
      before: s,
      after: s
    });
    return y(), b(), T;
  }
  function l(h, m) {
    return Dk(h, {
      align: m,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function c(h, m, p) {
    const g = h.children;
    let b = -1;
    const y = [], T = m.enter("table");
    for (; ++b < g.length; )
      y[b] = d(g[b], m, p);
    return T(), y;
  }
  function d(h, m, p) {
    const g = h.children;
    let b = -1;
    const y = [], T = m.enter("tableRow");
    for (; ++b < g.length; )
      y[b] = u(g[b], h, m, p);
    return T(), y;
  }
  function f(h, m, p) {
    let g = SD.inlineCode(h, m, p);
    return p.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function RD(t, e, n, r) {
  const i = n.enter("blockquote"), s = n.createTracker(r);
  s.move("> "), s.shift(2);
  const a = n.indentLines(
    n.containerFlow(t, s.current()),
    wD
  );
  return i(), a;
}
function wD(t, e, n) {
  return ">" + (n ? "" : " ") + t;
}
function kD(t, e) {
  return ym(t, e.inConstruct, !0) && !ym(t, e.notInConstruct, !1);
}
function ym(t, e, n) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return n;
  let r = -1;
  for (; ++r < e.length; )
    if (t.includes(e[r]))
      return !0;
  return !1;
}
function Tm(t, e, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && kD(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function DD(t, e) {
  return !!(e.options.fences === !1 && t.value && // If theres no info
  !t.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(t.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value));
}
function PD(t) {
  const e = t.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function OD(t, e, n, r) {
  const i = PD(n), s = t.value || "", a = i === "`" ? "GraveAccent" : "Tilde";
  if (DD(t, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(s, ND);
    return d(), f;
  }
  const o = n.createTracker(r), u = i.repeat(Math.max(gy(s, i) + 1, 3)), l = n.enter("codeFenced");
  let c = o.move(u);
  if (t.lang) {
    const d = n.enter(`codeFencedLang${a}`);
    c += o.move(
      n.safe(t.lang, {
        before: c,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (t.lang && t.meta) {
    const d = n.enter(`codeFencedMeta${a}`);
    c += o.move(" "), c += o.move(
      n.safe(t.meta, {
        before: c,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return c += o.move(`
`), s && (c += o.move(s + `
`)), c += o.move(u), l(), c;
}
function ND(t, e, n) {
  return (n ? "" : "    ") + t;
}
function rh(t) {
  const e = t.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function MD(t, e, n, r) {
  const i = rh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("[");
  return l += u.move(
    n.safe(n.associationId(t), {
      before: l,
      after: "]",
      ...u.current()
    })
  ), l += u.move("]: "), o(), // If theres no url, or
  !t.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : `
`,
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), a(), l;
}
function FD(t) {
  const e = t.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function fa(t) {
  return "&#x" + t.toString(16).toUpperCase() + ";";
}
function BD(t) {
  return t !== null && (t < 0 || t === 32);
}
const $D = ky(new RegExp("\\p{P}|\\p{S}", "u")), UD = ky(/\s/);
function ky(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Sm(t) {
  if (t === null || BD(t) || UD(t))
    return 1;
  if ($D(t))
    return 2;
}
function Su(t, e, n) {
  const r = Sm(t), i = Sm(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Dy.peek = HD;
function Dy(t, e, n, r) {
  const i = FD(n), s = n.enter("emphasis"), a = n.createTracker(r), o = a.move(i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Su(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = fa(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Su(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + fa(d));
  const h = a.move(i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function HD(t, e, n) {
  return n.options.emphasis || "*";
}
const VD = {};
function Py(t, e) {
  const n = VD, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return Oy(t, r, i);
}
function Oy(t, e, n) {
  if (GD(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return xm(t.children, e, n);
  }
  return Array.isArray(t) ? xm(t, e, n) : "";
}
function xm(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = Oy(t[i], e, n);
  return r.join("");
}
function GD(t) {
  return !!(t && typeof t == "object");
}
function zD(t, e) {
  let n = !1;
  return ul(t, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Eu;
  }), !!((!t.depth || t.depth < 3) && Py(t) && (e.options.setext || n));
}
function qD(t, e, n, r) {
  const i = Math.max(Math.min(6, t.depth || 1), 1), s = n.createTracker(r);
  if (zD(t, n)) {
    const c = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(t, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return d(), c(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const a = "#".repeat(i), o = n.enter("headingAtx"), u = n.enter("phrasing");
  s.move(a + " ");
  let l = n.containerPhrasing(t, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(l) && (l = fa(l.charCodeAt(0)) + l.slice(1)), l = l ? a + " " + l : a, n.options.closeAtx && (l += " " + a), u(), o(), l;
}
Ny.peek = WD;
function Ny(t) {
  return t.value || "";
}
function WD() {
  return "<";
}
My.peek = KD;
function My(t, e, n, r) {
  const i = rh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let l = u.move("![");
  return l += u.move(
    n.safe(t.alt, { before: l, after: "]", ...u.current() })
  ), l += u.move("]("), o(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (o = n.enter("destinationLiteral"), l += u.move("<"), l += u.move(
    n.safe(t.url, { before: l, after: ">", ...u.current() })
  ), l += u.move(">")) : (o = n.enter("destinationRaw"), l += u.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...u.current()
    })
  )), o(), t.title && (o = n.enter(`title${s}`), l += u.move(" " + i), l += u.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...u.current()
    })
  ), l += u.move(i), o()), l += u.move(")"), a(), l;
}
function KD() {
  return "!";
}
Fy.peek = jD;
function Fy(t, e, n, r) {
  const i = t.referenceType, s = n.enter("imageReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const l = n.safe(t.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function jD() {
  return "!";
}
By.peek = YD;
function By(t, e, n) {
  let r = t.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length; ) {
    const a = n.unsafe[s], o = n.compilePattern(a);
    let u;
    if (a.atBreak)
      for (; u = o.exec(r); ) {
        let l = u.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(u.index + 1);
      }
  }
  return i + r + i;
}
function YD() {
  return "`";
}
function $y(t, e) {
  const n = Py(t);
  return !!(!e.options.resourceLink && // If theres a url
  t.url && // And theres a no title
  !t.title && // And the content of `node` is a single text node
  t.children && t.children.length === 1 && t.children[0].type === "text" && // And if the url is the same as the content
  (n === t.url || "mailto:" + n === t.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(t.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(t.url));
}
Uy.peek = XD;
function Uy(t, e, n, r) {
  const i = rh(n), s = i === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
  let o, u;
  if ($y(t, n)) {
    const c = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = a.move("<");
    return d += a.move(
      n.containerPhrasing(t, {
        before: d,
        after: ">",
        ...a.current()
      })
    ), d += a.move(">"), o(), n.stack = c, d;
  }
  o = n.enter("link"), u = n.enter("label");
  let l = a.move("[");
  return l += a.move(
    n.containerPhrasing(t, {
      before: l,
      after: "](",
      ...a.current()
    })
  ), l += a.move("]("), u(), // If theres no url but there is a title
  !t.url && t.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(t.url) ? (u = n.enter("destinationLiteral"), l += a.move("<"), l += a.move(
    n.safe(t.url, { before: l, after: ">", ...a.current() })
  ), l += a.move(">")) : (u = n.enter("destinationRaw"), l += a.move(
    n.safe(t.url, {
      before: l,
      after: t.title ? " " : ")",
      ...a.current()
    })
  )), u(), t.title && (u = n.enter(`title${s}`), l += a.move(" " + i), l += a.move(
    n.safe(t.title, {
      before: l,
      after: i,
      ...a.current()
    })
  ), l += a.move(i), u()), l += a.move(")"), o(), l;
}
function XD(t, e, n) {
  return $y(t, n) ? "<" : "[";
}
Hy.peek = QD;
function Hy(t, e, n, r) {
  const i = t.referenceType, s = n.enter("linkReference");
  let a = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const l = n.containerPhrasing(t, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(l + "]["), a();
  const c = n.stack;
  n.stack = [], a = n.enter("reference");
  const d = n.safe(n.associationId(t), {
    before: u,
    after: "]",
    ...o.current()
  });
  return a(), n.stack = c, s(), i === "full" || !l || l !== d ? u += o.move(d + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function QD() {
  return "[";
}
function ih(t) {
  const e = t.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function ZD(t) {
  const e = ih(t), n = t.options.bulletOther;
  if (!n)
    return e === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function JD(t) {
  const e = t.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function Vy(t) {
  const e = t.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function eP(t, e, n, r) {
  const i = n.enter("list"), s = n.bulletCurrent;
  let a = t.ordered ? JD(n) : ih(n);
  const o = t.ordered ? a === "." ? ")" : "." : ZD(n);
  let u = e && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
  if (!t.ordered) {
    const c = t.children ? t.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (a === "*" || a === "-") && // Empty first list item:
      c && (!c.children || !c.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), Vy(n) === a && c
    ) {
      let d = -1;
      for (; ++d < t.children.length; ) {
        const f = t.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (a = o), n.bulletCurrent = a;
  const l = n.containerFlow(t, r);
  return n.bulletLastUsed = a, n.bulletCurrent = s, i(), l;
}
function tP(t) {
  const e = t.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function nP(t, e, n, r) {
  const i = tP(n);
  let s = n.bulletCurrent || ih(n);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) + s);
  let a = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || t.spread)) && (a = Math.ceil(a / 4) * 4);
  const o = n.createTracker(r);
  o.move(s + " ".repeat(a - s.length)), o.shift(a);
  const u = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(t, o.current()),
    c
  );
  return u(), l;
  function c(d, f, h) {
    return f ? (h ? "" : " ".repeat(a)) + d : (h ? s : s + " ".repeat(a - s.length)) + d;
  }
}
function rP(t, e, n, r) {
  const i = n.enter("paragraph"), s = n.enter("phrasing"), a = n.containerPhrasing(t, r);
  return s(), i(), a;
}
const Gy = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return oP;
    if (typeof t == "function")
      return dl(t);
    if (typeof t == "object")
      return Array.isArray(t) ? iP(t) : sP(t);
    if (typeof t == "string")
      return aP(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function iP(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Gy(t[n]);
  return dl(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function sP(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return dl(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function aP(t) {
  return dl(e);
  function e(n) {
    return n && n.type === t;
  }
}
function dl(t) {
  return e;
  function e(n, r, i) {
    return !!(uP(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function oP() {
  return !0;
}
function uP(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const lP = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Gy([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function cP(t, e, n, r) {
  return (t.children.some(function(a) {
    return lP(a);
  }) ? n.containerPhrasing : n.containerFlow).call(n, t, r);
}
function dP(t) {
  const e = t.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
zy.peek = fP;
function zy(t, e, n, r) {
  const i = dP(n), s = n.enter("strong"), a = n.createTracker(r), o = a.move(i + i);
  let u = a.move(
    n.containerPhrasing(t, {
      after: i,
      before: o,
      ...a.current()
    })
  );
  const l = u.charCodeAt(0), c = Su(
    r.before.charCodeAt(r.before.length - 1),
    l,
    i
  );
  c.inside && (u = fa(l) + u.slice(1));
  const d = u.charCodeAt(u.length - 1), f = Su(r.after.charCodeAt(0), d, i);
  f.inside && (u = u.slice(0, -1) + fa(d));
  const h = a.move(i + i);
  return s(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: c.outside
  }, o + u + h;
}
function fP(t, e, n) {
  return n.options.strong || "*";
}
function hP(t, e, n, r) {
  return n.safe(t.value, r);
}
function mP(t) {
  const e = t.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function pP(t, e, n) {
  const r = (Vy(n) + (n.options.ruleSpaces ? " " : "")).repeat(mP(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const gP = {
  blockquote: RD,
  break: Tm,
  code: OD,
  definition: MD,
  emphasis: Dy,
  hardBreak: Tm,
  heading: qD,
  html: Ny,
  image: My,
  imageReference: Fy,
  inlineCode: By,
  link: Uy,
  linkReference: Hy,
  list: eP,
  listItem: nP,
  paragraph: rP,
  root: cP,
  strong: zy,
  text: hP,
  thematicBreak: pP
};
function bP() {
  return {
    exit: {
      taskListCheckValueChecked: vm,
      taskListCheckValueUnchecked: vm,
      paragraph: yP
    }
  };
}
function EP() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: TP }
  };
}
function vm(t) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = t.type === "taskListCheckValueChecked";
}
function yP(t) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, a;
      for (; ++s < i.length; ) {
        const o = i[s];
        if (o.type === "paragraph") {
          a = o;
          break;
        }
      }
      a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(t);
}
function TP(t, e, n, r) {
  const i = t.children[0], s = typeof t.checked == "boolean" && i && i.type === "paragraph", a = "[" + (t.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  s && o.move(a);
  let u = gP.listItem(t, e, n, {
    ...r,
    ...o.current()
  });
  return s && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), u;
  function l(c) {
    return c + a;
  }
}
function SP() {
  return [
    tk(),
    xk(),
    Ck(),
    xD(),
    bP()
  ];
}
function xP(t) {
  return {
    extensions: [
      nk(),
      vk(t),
      Lk(),
      _D(t),
      EP()
    ]
  };
}
function vP(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
const Am = {}.hasOwnProperty;
function AP(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    IP(e, t[n]);
  return e;
}
function IP(t, e) {
  let n;
  for (n in e) {
    const i = (Am.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let a;
    if (s)
      for (a in s) {
        Am.call(i, a) || (i[a] = []);
        const o = s[a];
        CP(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function CP(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  vP(t, 0, 0, r);
}
const ha = fl(/[A-Za-z]/), sh = fl(/[\dA-Za-z]/);
function LP(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
function is(t) {
  return t !== null && (t < 0 || t === 32);
}
const qy = fl(new RegExp("\\p{P}|\\p{S}", "u")), ma = fl(/\s/);
function fl(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
const _P = {
  tokenize: OP,
  partial: !0
}, Wy = {
  tokenize: NP,
  partial: !0
}, Ky = {
  tokenize: MP,
  partial: !0
}, jy = {
  tokenize: FP,
  partial: !0
}, RP = {
  tokenize: BP,
  partial: !0
}, Yy = {
  name: "wwwAutolink",
  tokenize: DP,
  previous: Qy
}, Xy = {
  name: "protocolAutolink",
  tokenize: PP,
  previous: Zy
}, gr = {
  name: "emailAutolink",
  tokenize: kP,
  previous: Jy
}, Yn = {};
function wP() {
  return {
    text: Yn
  };
}
let qr = 48;
for (; qr < 123; )
  Yn[qr] = gr, qr++, qr === 58 ? qr = 65 : qr === 91 && (qr = 97);
Yn[43] = gr;
Yn[45] = gr;
Yn[46] = gr;
Yn[95] = gr;
Yn[72] = [gr, Xy];
Yn[104] = [gr, Xy];
Yn[87] = [gr, Yy];
Yn[119] = [gr, Yy];
function kP(t, e, n) {
  const r = this;
  let i, s;
  return a;
  function a(d) {
    return !gd(d) || !Jy.call(r, r.previous) || ah(r.events) ? n(d) : (t.enter("literalAutolink"), t.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return gd(d) ? (t.consume(d), o) : d === 64 ? (t.consume(d), u) : n(d);
  }
  function u(d) {
    return d === 46 ? t.check(RP, c, l)(d) : d === 45 || d === 95 || sh(d) ? (s = !0, t.consume(d), u) : c(d);
  }
  function l(d) {
    return t.consume(d), i = !0, u;
  }
  function c(d) {
    return s && i && ha(r.previous) ? (t.exit("literalAutolinkEmail"), t.exit("literalAutolink"), e(d)) : n(d);
  }
}
function DP(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return a !== 87 && a !== 119 || !Qy.call(r, r.previous) || ah(r.events) ? n(a) : (t.enter("literalAutolink"), t.enter("literalAutolinkWww"), t.check(_P, t.attempt(Wy, t.attempt(Ky, s), n), n)(a));
  }
  function s(a) {
    return t.exit("literalAutolinkWww"), t.exit("literalAutolink"), e(a);
  }
}
function PP(t, e, n) {
  const r = this;
  let i = "", s = !1;
  return a;
  function a(d) {
    return (d === 72 || d === 104) && Zy.call(r, r.previous) && !ah(r.events) ? (t.enter("literalAutolink"), t.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), t.consume(d), o) : n(d);
  }
  function o(d) {
    if (ha(d) && i.length < 5)
      return i += String.fromCodePoint(d), t.consume(d), o;
    if (d === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return t.consume(d), u;
    }
    return n(d);
  }
  function u(d) {
    return d === 47 ? (t.consume(d), s ? l : (s = !0, u)) : n(d);
  }
  function l(d) {
    return d === null || LP(d) || is(d) || ma(d) || qy(d) ? n(d) : t.attempt(Wy, t.attempt(Ky, c), n)(d);
  }
  function c(d) {
    return t.exit("literalAutolinkHttp"), t.exit("literalAutolink"), e(d);
  }
}
function OP(t, e, n) {
  let r = 0;
  return i;
  function i(a) {
    return (a === 87 || a === 119) && r < 3 ? (r++, t.consume(a), i) : a === 46 && r === 3 ? (t.consume(a), s) : n(a);
  }
  function s(a) {
    return a === null ? n(a) : e(a);
  }
}
function NP(t, e, n) {
  let r, i, s;
  return a;
  function a(l) {
    return l === 46 || l === 95 ? t.check(jy, u, o)(l) : l === null || is(l) || ma(l) || l !== 45 && qy(l) ? u(l) : (s = !0, t.consume(l), a);
  }
  function o(l) {
    return l === 95 ? r = !0 : (i = r, r = void 0), t.consume(l), a;
  }
  function u(l) {
    return i || r || !s ? n(l) : e(l);
  }
}
function MP(t, e) {
  let n = 0, r = 0;
  return i;
  function i(a) {
    return a === 40 ? (n++, t.consume(a), i) : a === 41 && r < n ? s(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? t.check(jy, e, s)(a) : a === null || is(a) || ma(a) ? e(a) : (t.consume(a), i);
  }
  function s(a) {
    return a === 41 && r++, t.consume(a), i;
  }
}
function FP(t, e, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (t.consume(o), r) : o === 38 ? (t.consume(o), s) : o === 93 ? (t.consume(o), i) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || is(o) || ma(o) ? e(o) : n(o)
    );
  }
  function i(o) {
    return o === null || o === 40 || o === 91 || is(o) || ma(o) ? e(o) : r(o);
  }
  function s(o) {
    return ha(o) ? a(o) : n(o);
  }
  function a(o) {
    return o === 59 ? (t.consume(o), r) : ha(o) ? (t.consume(o), a) : n(o);
  }
}
function BP(t, e, n) {
  return r;
  function r(s) {
    return t.consume(s), i;
  }
  function i(s) {
    return sh(s) ? n(s) : e(s);
  }
}
function Qy(t) {
  return t === null || t === 40 || t === 42 || t === 95 || t === 91 || t === 93 || t === 126 || is(t);
}
function Zy(t) {
  return !ha(t);
}
function Jy(t) {
  return !(t === 47 || gd(t));
}
function gd(t) {
  return t === 43 || t === 45 || t === 46 || t === 95 || sh(t);
}
function ah(t) {
  let e = t.length, n = !1;
  for (; e--; ) {
    const r = t[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return t.length > 0 && !n && (t[t.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function $P(t) {
  return t !== null && t < -2;
}
function xu(t) {
  return t !== null && (t < 0 || t === 32);
}
function bd(t) {
  return t === -2 || t === -1 || t === 32;
}
function oh(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return bd(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return bd(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const UP = {
  partial: !0,
  tokenize: HP
};
function HP(t, e, n) {
  return r;
  function r(s) {
    return bd(s) ? oh(t, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || $P(s) ? e(s) : n(s);
  }
}
function uh(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const VP = {
  tokenize: XP,
  partial: !0
};
function GP() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: KP,
        continuation: {
          tokenize: jP
        },
        exit: YP
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: WP
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: zP,
        resolveTo: qP
      }
    }
  };
}
function zP(t, e, n) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a;
  for (; i--; ) {
    const u = r.events[i][1];
    if (u.type === "labelImage") {
      a = u;
      break;
    }
    if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
      break;
  }
  return o;
  function o(u) {
    if (!a || !a._balanced)
      return n(u);
    const l = uh(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }));
    return l.codePointAt(0) !== 94 || !s.includes(l.slice(1)) ? n(u) : (t.enter("gfmFootnoteCallLabelMarker"), t.consume(u), t.exit("gfmFootnoteCallLabelMarker"), e(u));
  }
}
function qP(t, e) {
  let n = t.length;
  for (; n--; )
    if (t[n][1].type === "labelImage" && t[n][0] === "enter") {
      t[n][1];
      break;
    }
  t[n + 1][1].type = "data", t[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, t[n + 3][1].start),
    end: Object.assign({}, t[t.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, t[n + 3][1].end),
    end: Object.assign({}, t[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, t[t.length - 1][1].start)
  }, a = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    t[n + 1],
    t[n + 2],
    ["enter", r, e],
    // The `[`
    t[n + 3],
    t[n + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", a, e],
    ["exit", a, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    t[t.length - 2],
    t[t.length - 1],
    ["exit", r, e]
  ];
  return t.splice(n, t.length - n + 1, ...o), t;
}
function WP(t, e, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, a;
  return o;
  function o(d) {
    return t.enter("gfmFootnoteCall"), t.enter("gfmFootnoteCallLabelMarker"), t.consume(d), t.exit("gfmFootnoteCallLabelMarker"), u;
  }
  function u(d) {
    return d !== 94 ? n(d) : (t.enter("gfmFootnoteCallMarker"), t.consume(d), t.exit("gfmFootnoteCallMarker"), t.enter("gfmFootnoteCallString"), t.enter("chunkString").contentType = "string", l);
  }
  function l(d) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      d === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || xu(d)
    )
      return n(d);
    if (d === 93) {
      t.exit("chunkString");
      const f = t.exit("gfmFootnoteCallString");
      return i.includes(uh(r.sliceSerialize(f))) ? (t.enter("gfmFootnoteCallLabelMarker"), t.consume(d), t.exit("gfmFootnoteCallLabelMarker"), t.exit("gfmFootnoteCall"), e) : n(d);
    }
    return xu(d) || (a = !0), s++, t.consume(d), d === 92 ? c : l;
  }
  function c(d) {
    return d === 91 || d === 92 || d === 93 ? (t.consume(d), s++, l) : l(d);
  }
}
function KP(t, e, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, a = 0, o;
  return u;
  function u(m) {
    return t.enter("gfmFootnoteDefinition")._container = !0, t.enter("gfmFootnoteDefinitionLabel"), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionLabelMarker"), l;
  }
  function l(m) {
    return m === 94 ? (t.enter("gfmFootnoteDefinitionMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionMarker"), t.enter("gfmFootnoteDefinitionLabelString"), t.enter("chunkString").contentType = "string", c) : n(m);
  }
  function c(m) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      m === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || xu(m)
    )
      return n(m);
    if (m === 93) {
      t.exit("chunkString");
      const p = t.exit("gfmFootnoteDefinitionLabelString");
      return s = uh(r.sliceSerialize(p)), t.enter("gfmFootnoteDefinitionLabelMarker"), t.consume(m), t.exit("gfmFootnoteDefinitionLabelMarker"), t.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return xu(m) || (o = !0), a++, t.consume(m), m === 92 ? d : c;
  }
  function d(m) {
    return m === 91 || m === 92 || m === 93 ? (t.consume(m), a++, c) : c(m);
  }
  function f(m) {
    return m === 58 ? (t.enter("definitionMarker"), t.consume(m), t.exit("definitionMarker"), i.includes(s) || i.push(s), oh(t, h, "gfmFootnoteDefinitionWhitespace")) : n(m);
  }
  function h(m) {
    return e(m);
  }
}
function jP(t, e, n) {
  return t.check(UP, e, t.attempt(VP, e, n));
}
function YP(t) {
  t.exit("gfmFootnoteDefinition");
}
function XP(t, e, n) {
  const r = this;
  return oh(t, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? e(s) : n(s);
  }
}
function ec(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
function QP(t) {
  return t !== null && (t < 0 || t === 32);
}
const ZP = eT(new RegExp("\\p{P}|\\p{S}", "u")), JP = eT(/\s/);
function eT(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function Im(t) {
  if (t === null || QP(t) || JP(t))
    return 1;
  if (ZP(t))
    return 2;
}
function e6(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
function t6(t) {
  let n = (t || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(a, o) {
    let u = -1;
    for (; ++u < a.length; )
      if (a[u][0] === "enter" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._close) {
        let l = u;
        for (; l--; )
          if (a[l][0] === "exit" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._open && // If the sizes are the same:
          a[u][1].end.offset - a[u][1].start.offset === a[l][1].end.offset - a[l][1].start.offset) {
            a[u][1].type = "strikethroughSequence", a[l][1].type = "strikethroughSequence";
            const c = {
              type: "strikethrough",
              start: Object.assign({}, a[l][1].start),
              end: Object.assign({}, a[u][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, a[l][1].end),
              end: Object.assign({}, a[u][1].start)
            }, f = [["enter", c, o], ["enter", a[l][1], o], ["exit", a[l][1], o], ["enter", d, o]], h = o.parser.constructs.insideSpan.null;
            h && ec(f, f.length, 0, e6(h, a.slice(l + 1, u), o)), ec(f, f.length, 0, [["exit", d, o], ["enter", a[u][1], o], ["exit", a[u][1], o], ["exit", c, o]]), ec(a, l - 1, u - l + 3, f), u = l + f.length - 2;
            break;
          }
      }
    for (u = -1; ++u < a.length; )
      a[u][1].type === "strikethroughSequenceTemporary" && (a[u][1].type = "data");
    return a;
  }
  function s(a, o, u) {
    const l = this.previous, c = this.events;
    let d = 0;
    return f;
    function f(m) {
      return l === 126 && c[c.length - 1][1].type !== "characterEscape" ? u(m) : (a.enter("strikethroughSequenceTemporary"), h(m));
    }
    function h(m) {
      const p = Im(l);
      if (m === 126)
        return d > 1 ? u(m) : (a.consume(m), d++, h);
      if (d < 2 && !n) return u(m);
      const g = a.exit("strikethroughSequenceTemporary"), b = Im(m);
      return g._open = !b || b === 2 && !!p, g._close = !p || p === 2 && !!b, o(m);
    }
  }
}
function io(t) {
  return t !== null && t < -2;
}
function Cm(t) {
  return t !== null && (t < 0 || t === 32);
}
function Yr(t) {
  return t === -2 || t === -1 || t === 32;
}
function Ns(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Yr(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Yr(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
class n6 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, n, r) {
    r6(this, e, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, a) {
      return s[0] - a[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(e.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), e.length = this.map[n][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function r6(t, e, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < t.map.length; ) {
      if (t.map[i][0] === e) {
        t.map[i][1] += n, t.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    t.map.push([e, n, r]);
  }
}
function i6(t, e) {
  let n = !1;
  const r = [];
  for (; e < t.length; ) {
    const i = t[e];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(t[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (t[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    e += 1;
  }
  return r;
}
function s6() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: a6,
        resolveAll: o6
      }
    }
  };
}
function a6(t, e, n) {
  const r = this;
  let i = 0, s = 0, a;
  return o;
  function o(A) {
    let L = r.events.length - 1;
    for (; L > -1; ) {
      const G = r.events[L][1].type;
      if (G === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      G === "linePrefix") L--;
      else break;
    }
    const P = L > -1 ? r.events[L][1].type : null, $ = P === "tableHead" || P === "tableRow" ? C : u;
    return $ === C && r.parser.lazy[r.now().line] ? n(A) : $(A);
  }
  function u(A) {
    return t.enter("tableHead"), t.enter("tableRow"), l(A);
  }
  function l(A) {
    return A === 124 || (a = !0, s += 1), c(A);
  }
  function c(A) {
    return A === null ? n(A) : io(A) ? s > 1 ? (s = 0, r.interrupt = !0, t.exit("tableRow"), t.enter("lineEnding"), t.consume(A), t.exit("lineEnding"), h) : n(A) : Yr(A) ? Ns(t, c, "whitespace")(A) : (s += 1, a && (a = !1, i += 1), A === 124 ? (t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), a = !0, c) : (t.enter("data"), d(A)));
  }
  function d(A) {
    return A === null || A === 124 || Cm(A) ? (t.exit("data"), c(A)) : (t.consume(A), A === 92 ? f : d);
  }
  function f(A) {
    return A === 92 || A === 124 ? (t.consume(A), d) : d(A);
  }
  function h(A) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(A) : (t.enter("tableDelimiterRow"), a = !1, Yr(A) ? Ns(t, m, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : m(A));
  }
  function m(A) {
    return A === 45 || A === 58 ? g(A) : A === 124 ? (a = !0, t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), p) : I(A);
  }
  function p(A) {
    return Yr(A) ? Ns(t, g, "whitespace")(A) : g(A);
  }
  function g(A) {
    return A === 58 ? (s += 1, a = !0, t.enter("tableDelimiterMarker"), t.consume(A), t.exit("tableDelimiterMarker"), b) : A === 45 ? (s += 1, b(A)) : A === null || io(A) ? S(A) : I(A);
  }
  function b(A) {
    return A === 45 ? (t.enter("tableDelimiterFiller"), y(A)) : I(A);
  }
  function y(A) {
    return A === 45 ? (t.consume(A), y) : A === 58 ? (a = !0, t.exit("tableDelimiterFiller"), t.enter("tableDelimiterMarker"), t.consume(A), t.exit("tableDelimiterMarker"), T) : (t.exit("tableDelimiterFiller"), T(A));
  }
  function T(A) {
    return Yr(A) ? Ns(t, S, "whitespace")(A) : S(A);
  }
  function S(A) {
    return A === 124 ? m(A) : A === null || io(A) ? !a || i !== s ? I(A) : (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(A)) : I(A);
  }
  function I(A) {
    return n(A);
  }
  function C(A) {
    return t.enter("tableRow"), _(A);
  }
  function _(A) {
    return A === 124 ? (t.enter("tableCellDivider"), t.consume(A), t.exit("tableCellDivider"), _) : A === null || io(A) ? (t.exit("tableRow"), e(A)) : Yr(A) ? Ns(t, _, "whitespace")(A) : (t.enter("data"), R(A));
  }
  function R(A) {
    return A === null || A === 124 || Cm(A) ? (t.exit("data"), _(A)) : (t.consume(A), A === 92 ? k : R);
  }
  function k(A) {
    return A === 92 || A === 124 ? (t.consume(A), R) : R(A);
  }
}
function o6(t, e) {
  let n = -1, r = !0, i = 0, s = [0, 0, 0, 0], a = [0, 0, 0, 0], o = !1, u = 0, l, c, d;
  const f = new n6();
  for (; ++n < t.length; ) {
    const h = t[n], m = h[1];
    h[0] === "enter" ? m.type === "tableHead" ? (o = !1, u !== 0 && (Lm(f, e, u, l, c), c = void 0, u = 0), l = {
      type: "table",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, f.add(n, 0, [["enter", l, e]])) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (r = !0, d = void 0, s = [0, 0, 0, 0], a = [0, n + 1, 0, 0], o && (o = !1, c = {
      type: "tableBody",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, f.add(n, 0, [["enter", c, e]])), i = m.type === "tableDelimiterRow" ? 2 : c ? 3 : 1) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (s[1] !== 0 && (a[0] = a[1], d = so(f, e, s, i, void 0, d), s = [0, 0, 0, 0]), a[2] = n)) : m.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (a[0] = a[1], d = so(f, e, s, i, void 0, d)), s = a, a = [s[1], n, 0, 0])) : m.type === "tableHead" ? (o = !0, u = n) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (u = n, s[1] !== 0 ? (a[0] = a[1], d = so(f, e, s, i, n, d)) : a[1] !== 0 && (d = so(f, e, a, i, n, d)), i = 0) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") && (a[3] = n);
  }
  for (u !== 0 && Lm(f, e, u, l, c), f.consume(e.events), n = -1; ++n < e.events.length; ) {
    const h = e.events[n];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = i6(e.events, n));
  }
  return t;
}
function so(t, e, n, r, i, s) {
  const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (s.end = Object.assign({}, Ni(e.events, n[0])), t.add(n[0], 0, [["exit", s, e]]));
  const u = Ni(e.events, n[1]);
  if (s = {
    type: a,
    start: Object.assign({}, u),
    // Note: correct end is set later.
    end: Object.assign({}, u)
  }, t.add(n[1], 0, [["enter", s, e]]), n[2] !== 0) {
    const l = Ni(e.events, n[2]), c = Ni(e.events, n[3]), d = {
      type: o,
      start: Object.assign({}, l),
      end: Object.assign({}, c)
    };
    if (t.add(n[2], 0, [["enter", d, e]]), r !== 2) {
      const f = e.events[n[2]], h = e.events[n[3]];
      if (f[1].end = Object.assign({}, h[1].end), f[1].type = "chunkText", f[1].contentType = "text", n[3] > n[2] + 1) {
        const m = n[2] + 1, p = n[3] - n[2] - 1;
        t.add(m, p, []);
      }
    }
    t.add(n[3] + 1, 0, [["exit", d, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, Ni(e.events, i)), t.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function Lm(t, e, n, r, i) {
  const s = [], a = Ni(e.events, n);
  i && (i.end = Object.assign({}, a), s.push(["exit", i, e])), r.end = Object.assign({}, a), s.push(["exit", r, e]), t.add(n + 1, 0, s);
}
function Ni(t, e) {
  const n = t[e], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
function u6(t) {
  return t !== null && t < -2;
}
function l6(t) {
  return t !== null && (t < 0 || t === 32);
}
function Ed(t) {
  return t === -2 || t === -1 || t === 32;
}
function c6(t, e, n, r) {
  const i = Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Ed(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Ed(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const d6 = {
  name: "tasklistCheck",
  tokenize: h6
};
function f6() {
  return {
    text: {
      91: d6
    }
  };
}
function h6(t, e, n) {
  const r = this;
  return i;
  function i(u) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(u) : (t.enter("taskListCheck"), t.enter("taskListCheckMarker"), t.consume(u), t.exit("taskListCheckMarker"), s)
    );
  }
  function s(u) {
    return l6(u) ? (t.enter("taskListCheckValueUnchecked"), t.consume(u), t.exit("taskListCheckValueUnchecked"), a) : u === 88 || u === 120 ? (t.enter("taskListCheckValueChecked"), t.consume(u), t.exit("taskListCheckValueChecked"), a) : n(u);
  }
  function a(u) {
    return u === 93 ? (t.enter("taskListCheckMarker"), t.consume(u), t.exit("taskListCheckMarker"), t.exit("taskListCheck"), o) : n(u);
  }
  function o(u) {
    return u6(u) ? e(u) : Ed(u) ? t.check({
      tokenize: m6
    }, e, n)(u) : n(u);
  }
}
function m6(t, e, n) {
  return c6(t, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : e(i);
  }
}
function p6(t) {
  return AP([
    wP(),
    GP(),
    t6(t),
    s6(),
    f6()
  ]);
}
const g6 = {};
function b6(t) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), n = t || g6, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(p6(n)), s.push(SP()), a.push(xP(n));
}
const E6 = {};
function y6(t, e) {
  const n = E6, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return tT(t, r, i);
}
function tT(t, e, n) {
  if (T6(t)) {
    if ("value" in t)
      return t.type === "html" && !n ? "" : t.value;
    if (e && "alt" in t && t.alt)
      return t.alt;
    if ("children" in t)
      return _m(t.children, e, n);
  }
  return Array.isArray(t) ? _m(t, e, n) : "";
}
function _m(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; )
    r[i] = tT(t[i], e, n);
  return r.join("");
}
function T6(t) {
  return !!(t && typeof t == "object");
}
function zn(t, e, n, r) {
  const i = t.length;
  let s = 0, a;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4)
    a = Array.from(r), a.unshift(e, n), t.splice(...a);
  else
    for (n && t.splice(e, n); s < r.length; )
      a = r.slice(s, s + 1e4), a.unshift(e, 0), t.splice(...a), s += 1e4, e += 1e4;
}
function pn(t, e) {
  return t.length > 0 ? (zn(t, t.length, 0, e), t) : e;
}
const Rm = {}.hasOwnProperty;
function S6(t) {
  const e = {};
  let n = -1;
  for (; ++n < t.length; )
    x6(e, t[n]);
  return e;
}
function x6(t, e) {
  let n;
  for (n in e) {
    const i = (Rm.call(t, n) ? t[n] : void 0) || (t[n] = {}), s = e[n];
    let a;
    if (s)
      for (a in s) {
        Rm.call(i, a) || (i[a] = []);
        const o = s[a];
        v6(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function v6(t, e) {
  let n = -1;
  const r = [];
  for (; ++n < e.length; )
    (e[n].add === "after" ? t : r).push(e[n]);
  zn(t, 0, 0, r);
}
function nT(t, e) {
  const n = Number.parseInt(t, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Ki(t) {
  return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Fn = Br(/[A-Za-z]/), An = Br(/[\dA-Za-z]/), A6 = Br(/[#-'*+\--9=?A-Z^-~]/);
function yd(t) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    t !== null && (t < 32 || t === 127)
  );
}
const Td = Br(/\d/), I6 = Br(/[\dA-Fa-f]/), C6 = Br(/[!-/:-@[-`{-~]/);
function ve(t) {
  return t !== null && t < -2;
}
function Wt(t) {
  return t !== null && (t < 0 || t === 32);
}
function Ve(t) {
  return t === -2 || t === -1 || t === 32;
}
const L6 = Br(new RegExp("\\p{P}|\\p{S}", "u")), _6 = Br(/\s/);
function Br(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function it(t, e, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return a;
  function a(u) {
    return Ve(u) ? (t.enter(n), o(u)) : e(u);
  }
  function o(u) {
    return Ve(u) && s++ < i ? (t.consume(u), o) : (t.exit(n), e(u));
  }
}
const R6 = {
  tokenize: w6
};
function w6(t) {
  const e = t.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return e;
  function r(o) {
    if (o === null) {
      t.consume(o);
      return;
    }
    return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), it(t, e, "linePrefix");
  }
  function i(o) {
    return t.enter("paragraph"), s(o);
  }
  function s(o) {
    const u = t.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = u), n = u, a(o);
  }
  function a(o) {
    if (o === null) {
      t.exit("chunkText"), t.exit("paragraph"), t.consume(o);
      return;
    }
    return ve(o) ? (t.consume(o), t.exit("chunkText"), s) : (t.consume(o), a);
  }
}
const k6 = {
  tokenize: D6
}, wm = {
  tokenize: P6
};
function D6(t) {
  const e = this, n = [];
  let r = 0, i, s, a;
  return o;
  function o(T) {
    if (r < n.length) {
      const S = n[r];
      return e.containerState = S[1], t.attempt(S[0].continuation, u, l)(T);
    }
    return l(T);
  }
  function u(T) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && y();
      const S = e.events.length;
      let I = S, C;
      for (; I--; )
        if (e.events[I][0] === "exit" && e.events[I][1].type === "chunkFlow") {
          C = e.events[I][1].end;
          break;
        }
      b(r);
      let _ = S;
      for (; _ < e.events.length; )
        e.events[_][1].end = {
          ...C
        }, _++;
      return zn(e.events, I + 1, 0, e.events.slice(S)), e.events.length = _, l(T);
    }
    return o(T);
  }
  function l(T) {
    if (r === n.length) {
      if (!i)
        return f(T);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(T);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, t.check(wm, c, d)(T);
  }
  function c(T) {
    return i && y(), b(r), f(T);
  }
  function d(T) {
    return e.parser.lazy[e.now().line] = r !== n.length, a = e.now().offset, m(T);
  }
  function f(T) {
    return e.containerState = {}, t.attempt(wm, h, m)(T);
  }
  function h(T) {
    return r++, n.push([e.currentConstruct, e.containerState]), f(T);
  }
  function m(T) {
    if (T === null) {
      i && y(), b(0), t.consume(T);
      return;
    }
    return i = i || e.parser.flow(e.now()), t.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), p(T);
  }
  function p(T) {
    if (T === null) {
      g(t.exit("chunkFlow"), !0), b(0), t.consume(T);
      return;
    }
    return ve(T) ? (t.consume(T), g(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, o) : (t.consume(T), p);
  }
  function g(T, S) {
    const I = e.sliceStream(T);
    if (S && I.push(null), T.previous = s, s && (s.next = T), s = T, i.defineSkip(T.start), i.write(I), e.parser.lazy[T.start.line]) {
      let C = i.events.length;
      for (; C--; )
        if (
          // The token starts before the line ending
          i.events[C][1].start.offset < a && // and either is not ended yet
          (!i.events[C][1].end || // or ends after it.
          i.events[C][1].end.offset > a)
        )
          return;
      const _ = e.events.length;
      let R = _, k, A;
      for (; R--; )
        if (e.events[R][0] === "exit" && e.events[R][1].type === "chunkFlow") {
          if (k) {
            A = e.events[R][1].end;
            break;
          }
          k = !0;
        }
      for (b(r), C = _; C < e.events.length; )
        e.events[C][1].end = {
          ...A
        }, C++;
      zn(e.events, R + 1, 0, e.events.slice(_)), e.events.length = C;
    }
  }
  function b(T) {
    let S = n.length;
    for (; S-- > T; ) {
      const I = n[S];
      e.containerState = I[1], I[0].exit.call(e, t);
    }
    n.length = T;
  }
  function y() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function P6(t, e, n) {
  return it(t, t.attempt(this.parser.constructs.document, e, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function km(t) {
  if (t === null || Wt(t) || _6(t))
    return 1;
  if (L6(t))
    return 2;
}
function lh(t, e, n) {
  const r = [];
  let i = -1;
  for (; ++i < t.length; ) {
    const s = t[i].resolveAll;
    s && !r.includes(s) && (e = s(e, n), r.push(s));
  }
  return e;
}
const Sd = {
  name: "attention",
  resolveAll: O6,
  tokenize: N6
};
function O6(t, e) {
  let n = -1, r, i, s, a, o, u, l, c;
  for (; ++n < t.length; )
    if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) {
      for (r = n; r--; )
        if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && // If the markers are the same:
        e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) {
          if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3))
            continue;
          u = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...t[r][1].end
          }, f = {
            ...t[n][1].start
          };
          Dm(d, -u), Dm(f, u), a = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...t[r][1].end
            }
          }, o = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...t[n][1].start
            },
            end: f
          }, s = {
            type: u > 1 ? "strongText" : "emphasisText",
            start: {
              ...t[r][1].end
            },
            end: {
              ...t[n][1].start
            }
          }, i = {
            type: u > 1 ? "strong" : "emphasis",
            start: {
              ...a.start
            },
            end: {
              ...o.end
            }
          }, t[r][1].end = {
            ...a.start
          }, t[n][1].start = {
            ...o.end
          }, l = [], t[r][1].end.offset - t[r][1].start.offset && (l = pn(l, [["enter", t[r][1], e], ["exit", t[r][1], e]])), l = pn(l, [["enter", i, e], ["enter", a, e], ["exit", a, e], ["enter", s, e]]), l = pn(l, lh(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e)), l = pn(l, [["exit", s, e], ["enter", o, e], ["exit", o, e], ["exit", i, e]]), t[n][1].end.offset - t[n][1].start.offset ? (c = 2, l = pn(l, [["enter", t[n][1], e], ["exit", t[n][1], e]])) : c = 0, zn(t, r - 1, n - r + 3, l), n = r + l.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < t.length; )
    t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
  return t;
}
function N6(t, e) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = km(r);
  let s;
  return a;
  function a(u) {
    return s = u, t.enter("attentionSequence"), o(u);
  }
  function o(u) {
    if (u === s)
      return t.consume(u), o;
    const l = t.exit("attentionSequence"), c = km(u), d = !c || c === 2 && i || n.includes(u), f = !i || i === 2 && c || n.includes(r);
    return l._open = !!(s === 42 ? d : d && (i || !f)), l._close = !!(s === 42 ? f : f && (c || !d)), e(u);
  }
}
function Dm(t, e) {
  t.column += e, t.offset += e, t._bufferIndex += e;
}
const M6 = {
  name: "autolink",
  tokenize: F6
};
function F6(t, e, n) {
  let r = 0;
  return i;
  function i(h) {
    return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), s;
  }
  function s(h) {
    return Fn(h) ? (t.consume(h), a) : h === 64 ? n(h) : l(h);
  }
  function a(h) {
    return h === 43 || h === 45 || h === 46 || An(h) ? (r = 1, o(h)) : l(h);
  }
  function o(h) {
    return h === 58 ? (t.consume(h), r = 0, u) : (h === 43 || h === 45 || h === 46 || An(h)) && r++ < 32 ? (t.consume(h), o) : (r = 0, l(h));
  }
  function u(h) {
    return h === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.exit("autolink"), e) : h === null || h === 32 || h === 60 || yd(h) ? n(h) : (t.consume(h), u);
  }
  function l(h) {
    return h === 64 ? (t.consume(h), c) : A6(h) ? (t.consume(h), l) : n(h);
  }
  function c(h) {
    return An(h) ? d(h) : n(h);
  }
  function d(h) {
    return h === 46 ? (t.consume(h), r = 0, c) : h === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(h), t.exit("autolinkMarker"), t.exit("autolink"), e) : f(h);
  }
  function f(h) {
    if ((h === 45 || An(h)) && r++ < 63) {
      const m = h === 45 ? f : d;
      return t.consume(h), m;
    }
    return n(h);
  }
}
const hl = {
  partial: !0,
  tokenize: B6
};
function B6(t, e, n) {
  return r;
  function r(s) {
    return Ve(s) ? it(t, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || ve(s) ? e(s) : n(s);
  }
}
const rT = {
  continuation: {
    tokenize: U6
  },
  exit: H6,
  name: "blockQuote",
  tokenize: $6
};
function $6(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    if (a === 62) {
      const o = r.containerState;
      return o.open || (t.enter("blockQuote", {
        _container: !0
      }), o.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(a), t.exit("blockQuoteMarker"), s;
    }
    return n(a);
  }
  function s(a) {
    return Ve(a) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(a), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(a));
  }
}
function U6(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return Ve(a) ? it(t, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : s(a);
  }
  function s(a) {
    return t.attempt(rT, e, n)(a);
  }
}
function H6(t) {
  t.exit("blockQuote");
}
const iT = {
  name: "characterEscape",
  tokenize: V6
};
function V6(t, e, n) {
  return r;
  function r(s) {
    return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(s), t.exit("escapeMarker"), i;
  }
  function i(s) {
    return C6(s) ? (t.enter("characterEscapeValue"), t.consume(s), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(s);
  }
}
const sT = {
  name: "characterReference",
  tokenize: G6
};
function G6(t, e, n) {
  const r = this;
  let i = 0, s, a;
  return o;
  function o(d) {
    return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), u;
  }
  function u(d) {
    return d === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(d), t.exit("characterReferenceMarkerNumeric"), l) : (t.enter("characterReferenceValue"), s = 31, a = An, c(d));
  }
  function l(d) {
    return d === 88 || d === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(d), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), s = 6, a = I6, c) : (t.enter("characterReferenceValue"), s = 7, a = Td, c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const f = t.exit("characterReferenceValue");
      return a === An && !nh(r.sliceSerialize(f)) ? n(d) : (t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), t.exit("characterReference"), e);
    }
    return a(d) && i++ < s ? (t.consume(d), c) : n(d);
  }
}
const Pm = {
  partial: !0,
  tokenize: q6
}, Om = {
  concrete: !0,
  name: "codeFenced",
  tokenize: z6
};
function z6(t, e, n) {
  const r = this, i = {
    partial: !0,
    tokenize: I
  };
  let s = 0, a = 0, o;
  return u;
  function u(C) {
    return l(C);
  }
  function l(C) {
    const _ = r.events[r.events.length - 1];
    return s = _ && _[1].type === "linePrefix" ? _[2].sliceSerialize(_[1], !0).length : 0, o = C, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), c(C);
  }
  function c(C) {
    return C === o ? (a++, t.consume(C), c) : a < 3 ? n(C) : (t.exit("codeFencedFenceSequence"), Ve(C) ? it(t, d, "whitespace")(C) : d(C));
  }
  function d(C) {
    return C === null || ve(C) ? (t.exit("codeFencedFence"), r.interrupt ? e(C) : t.check(Pm, p, S)(C)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", {
      contentType: "string"
    }), f(C));
  }
  function f(C) {
    return C === null || ve(C) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), d(C)) : Ve(C) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), it(t, h, "whitespace")(C)) : C === 96 && C === o ? n(C) : (t.consume(C), f);
  }
  function h(C) {
    return C === null || ve(C) ? d(C) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", {
      contentType: "string"
    }), m(C));
  }
  function m(C) {
    return C === null || ve(C) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), d(C)) : C === 96 && C === o ? n(C) : (t.consume(C), m);
  }
  function p(C) {
    return t.attempt(i, S, g)(C);
  }
  function g(C) {
    return t.enter("lineEnding"), t.consume(C), t.exit("lineEnding"), b;
  }
  function b(C) {
    return s > 0 && Ve(C) ? it(t, y, "linePrefix", s + 1)(C) : y(C);
  }
  function y(C) {
    return C === null || ve(C) ? t.check(Pm, p, S)(C) : (t.enter("codeFlowValue"), T(C));
  }
  function T(C) {
    return C === null || ve(C) ? (t.exit("codeFlowValue"), y(C)) : (t.consume(C), T);
  }
  function S(C) {
    return t.exit("codeFenced"), e(C);
  }
  function I(C, _, R) {
    let k = 0;
    return A;
    function A(N) {
      return C.enter("lineEnding"), C.consume(N), C.exit("lineEnding"), L;
    }
    function L(N) {
      return C.enter("codeFencedFence"), Ve(N) ? it(C, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : P(N);
    }
    function P(N) {
      return N === o ? (C.enter("codeFencedFenceSequence"), $(N)) : R(N);
    }
    function $(N) {
      return N === o ? (k++, C.consume(N), $) : k >= a ? (C.exit("codeFencedFenceSequence"), Ve(N) ? it(C, G, "whitespace")(N) : G(N)) : R(N);
    }
    function G(N) {
      return N === null || ve(N) ? (C.exit("codeFencedFence"), _(N)) : R(N);
    }
  }
}
function q6(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return a === null ? n(a) : (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), s);
  }
  function s(a) {
    return r.parser.lazy[r.now().line] ? n(a) : e(a);
  }
}
const tc = {
  name: "codeIndented",
  tokenize: K6
}, W6 = {
  partial: !0,
  tokenize: j6
};
function K6(t, e, n) {
  const r = this;
  return i;
  function i(l) {
    return t.enter("codeIndented"), it(t, s, "linePrefix", 5)(l);
  }
  function s(l) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(l) : n(l);
  }
  function a(l) {
    return l === null ? u(l) : ve(l) ? t.attempt(W6, a, u)(l) : (t.enter("codeFlowValue"), o(l));
  }
  function o(l) {
    return l === null || ve(l) ? (t.exit("codeFlowValue"), a(l)) : (t.consume(l), o);
  }
  function u(l) {
    return t.exit("codeIndented"), e(l);
  }
}
function j6(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return r.parser.lazy[r.now().line] ? n(a) : ve(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), i) : it(t, s, "linePrefix", 5)(a);
  }
  function s(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : ve(a) ? i(a) : n(a);
  }
}
const Y6 = {
  name: "codeText",
  previous: Q6,
  resolve: X6,
  tokenize: Z6
};
function X6(t) {
  let e = t.length - 4, n = 3, r, i;
  if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) {
    for (r = n; ++r < e; )
      if (t[r][1].type === "codeTextData") {
        t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2;
        break;
      }
  }
  for (r = n - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData", r !== i + 2 && (t[i][1].end = t[r - 1][1].end, t.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return t;
}
function Q6(t) {
  return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Z6(t, e, n) {
  let r = 0, i, s;
  return a;
  function a(d) {
    return t.enter("codeText"), t.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (t.consume(d), r++, o) : (t.exit("codeTextSequence"), u(d));
  }
  function u(d) {
    return d === null ? n(d) : d === 32 ? (t.enter("space"), t.consume(d), t.exit("space"), u) : d === 96 ? (s = t.enter("codeTextSequence"), i = 0, c(d)) : ve(d) ? (t.enter("lineEnding"), t.consume(d), t.exit("lineEnding"), u) : (t.enter("codeTextData"), l(d));
  }
  function l(d) {
    return d === null || d === 32 || d === 96 || ve(d) ? (t.exit("codeTextData"), u(d)) : (t.consume(d), l);
  }
  function c(d) {
    return d === 96 ? (t.consume(d), i++, c) : i === r ? (t.exit("codeTextSequence"), t.exit("codeText"), e(d)) : (s.type = "codeTextData", l(d));
  }
}
class J6 {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Ms(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), Ms(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), Ms(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const n = this.left.splice(e, Number.POSITIVE_INFINITY);
        Ms(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        Ms(this.left, n.reverse());
      }
  }
}
function Ms(t, e) {
  let n = 0;
  if (e.length < 1e4)
    t.push(...e);
  else
    for (; n < e.length; )
      t.push(...e.slice(n, n + 1e4)), n += 1e4;
}
function aT(t) {
  const e = {};
  let n = -1, r, i, s, a, o, u, l;
  const c = new J6(t);
  for (; ++n < c.length; ) {
    for (; n in e; )
      n = e[n];
    if (r = c.get(n), n && r[1].type === "chunkFlow" && c.get(n - 1)[1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, s = 0, s < u.length && u[s][1].type === "lineEndingBlank" && (s += 2), s < u.length && u[s][1].type === "content"))
      for (; ++s < u.length && u[s][1].type !== "content"; )
        u[s][1].type === "chunkText" && (u[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, eO(c, n)), n = e[n], l = !0);
    else if (r[1]._container) {
      for (s = n, i = void 0; s--; )
        if (a = c.get(s), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank")
          a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = s);
        else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...c.get(i)[1].start
      }, o = c.slice(i, n), o.unshift(r), c.splice(i, n - i + 1, o));
    }
  }
  return zn(t, 0, Number.POSITIVE_INFINITY, c.slice(0)), !l;
}
function eO(t, e) {
  const n = t.get(e)[1], r = t.get(e)[2];
  let i = e - 1;
  const s = [];
  let a = n._tokenizer;
  a || (a = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0));
  const o = a.events, u = [], l = {};
  let c, d, f = -1, h = n, m = 0, p = 0;
  const g = [p];
  for (; h; ) {
    for (; t.get(++i)[1] !== h; )
      ;
    s.push(i), h._tokenizer || (c = r.sliceStream(h), h.next || c.push(null), d && a.defineSkip(h.start), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = h, h = h.next;
  }
  for (h = n; ++f < o.length; )
    // Find a void token that includes a break.
    o[f][0] === "exit" && o[f - 1][0] === "enter" && o[f][1].type === o[f - 1][1].type && o[f][1].start.line !== o[f][1].end.line && (p = f + 1, g.push(p), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (a.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const b = o.slice(g[f], g[f + 1]), y = s.pop();
    u.push([y, y + b.length - 1]), t.splice(y, 2, b);
  }
  for (u.reverse(), f = -1; ++f < u.length; )
    l[m + u[f][0]] = m + u[f][1], m += u[f][1] - u[f][0] - 1;
  return l;
}
const tO = {
  resolve: rO,
  tokenize: iO
}, nO = {
  partial: !0,
  tokenize: sO
};
function rO(t) {
  return aT(t), t;
}
function iO(t, e) {
  let n;
  return r;
  function r(o) {
    return t.enter("content"), n = t.enter("chunkContent", {
      contentType: "content"
    }), i(o);
  }
  function i(o) {
    return o === null ? s(o) : ve(o) ? t.check(nO, a, s)(o) : (t.consume(o), i);
  }
  function s(o) {
    return t.exit("chunkContent"), t.exit("content"), e(o);
  }
  function a(o) {
    return t.consume(o), t.exit("chunkContent"), n.next = t.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function sO(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), it(t, s, "linePrefix");
  }
  function s(a) {
    if (a === null || ve(a))
      return n(a);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? e(a) : t.interrupt(r.parser.constructs.flow, n, e)(a);
  }
}
function oT(t, e, n, r, i, s, a, o, u) {
  const l = u || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(b) {
    return b === 60 ? (t.enter(r), t.enter(i), t.enter(s), t.consume(b), t.exit(s), f) : b === null || b === 32 || b === 41 || yd(b) ? n(b) : (t.enter(r), t.enter(a), t.enter(o), t.enter("chunkString", {
      contentType: "string"
    }), p(b));
  }
  function f(b) {
    return b === 62 ? (t.enter(s), t.consume(b), t.exit(s), t.exit(i), t.exit(r), e) : (t.enter(o), t.enter("chunkString", {
      contentType: "string"
    }), h(b));
  }
  function h(b) {
    return b === 62 ? (t.exit("chunkString"), t.exit(o), f(b)) : b === null || b === 60 || ve(b) ? n(b) : (t.consume(b), b === 92 ? m : h);
  }
  function m(b) {
    return b === 60 || b === 62 || b === 92 ? (t.consume(b), h) : h(b);
  }
  function p(b) {
    return !c && (b === null || b === 41 || Wt(b)) ? (t.exit("chunkString"), t.exit(o), t.exit(a), t.exit(r), e(b)) : c < l && b === 40 ? (t.consume(b), c++, p) : b === 41 ? (t.consume(b), c--, p) : b === null || b === 32 || b === 40 || yd(b) ? n(b) : (t.consume(b), b === 92 ? g : p);
  }
  function g(b) {
    return b === 40 || b === 41 || b === 92 ? (t.consume(b), p) : p(b);
  }
}
function uT(t, e, n, r, i, s) {
  const a = this;
  let o = 0, u;
  return l;
  function l(h) {
    return t.enter(r), t.enter(i), t.consume(h), t.exit(i), t.enter(s), c;
  }
  function c(h) {
    return o > 999 || h === null || h === 91 || h === 93 && !u || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !o && "_hiddenFootnoteSupport" in a.parser.constructs ? n(h) : h === 93 ? (t.exit(s), t.enter(i), t.consume(h), t.exit(i), t.exit(r), e) : ve(h) ? (t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), c) : (t.enter("chunkString", {
      contentType: "string"
    }), d(h));
  }
  function d(h) {
    return h === null || h === 91 || h === 93 || ve(h) || o++ > 999 ? (t.exit("chunkString"), c(h)) : (t.consume(h), u || (u = !Ve(h)), h === 92 ? f : d);
  }
  function f(h) {
    return h === 91 || h === 92 || h === 93 ? (t.consume(h), o++, d) : d(h);
  }
}
function lT(t, e, n, r, i, s) {
  let a;
  return o;
  function o(f) {
    return f === 34 || f === 39 || f === 40 ? (t.enter(r), t.enter(i), t.consume(f), t.exit(i), a = f === 40 ? 41 : f, u) : n(f);
  }
  function u(f) {
    return f === a ? (t.enter(i), t.consume(f), t.exit(i), t.exit(r), e) : (t.enter(s), l(f));
  }
  function l(f) {
    return f === a ? (t.exit(s), u(a)) : f === null ? n(f) : ve(f) ? (t.enter("lineEnding"), t.consume(f), t.exit("lineEnding"), it(t, l, "linePrefix")) : (t.enter("chunkString", {
      contentType: "string"
    }), c(f));
  }
  function c(f) {
    return f === a || f === null || ve(f) ? (t.exit("chunkString"), l(f)) : (t.consume(f), f === 92 ? d : c);
  }
  function d(f) {
    return f === a || f === 92 ? (t.consume(f), c) : c(f);
  }
}
function na(t, e) {
  let n;
  return r;
  function r(i) {
    return ve(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), n = !0, r) : Ve(i) ? it(t, r, n ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const aO = {
  name: "definition",
  tokenize: uO
}, oO = {
  partial: !0,
  tokenize: lO
};
function uO(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(h) {
    return t.enter("definition"), a(h);
  }
  function a(h) {
    return uT.call(
      r,
      t,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function o(h) {
    return i = Ki(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (t.enter("definitionMarker"), t.consume(h), t.exit("definitionMarker"), u) : n(h);
  }
  function u(h) {
    return Wt(h) ? na(t, l)(h) : l(h);
  }
  function l(h) {
    return oT(
      t,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function c(h) {
    return t.attempt(oO, d, d)(h);
  }
  function d(h) {
    return Ve(h) ? it(t, f, "whitespace")(h) : f(h);
  }
  function f(h) {
    return h === null || ve(h) ? (t.exit("definition"), r.parser.defined.push(i), e(h)) : n(h);
  }
}
function lO(t, e, n) {
  return r;
  function r(o) {
    return Wt(o) ? na(t, i)(o) : n(o);
  }
  function i(o) {
    return lT(t, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function s(o) {
    return Ve(o) ? it(t, a, "whitespace")(o) : a(o);
  }
  function a(o) {
    return o === null || ve(o) ? e(o) : n(o);
  }
}
const cO = {
  name: "hardBreakEscape",
  tokenize: dO
};
function dO(t, e, n) {
  return r;
  function r(s) {
    return t.enter("hardBreakEscape"), t.consume(s), i;
  }
  function i(s) {
    return ve(s) ? (t.exit("hardBreakEscape"), e(s)) : n(s);
  }
}
const fO = {
  name: "headingAtx",
  resolve: hO,
  tokenize: mO
};
function hO(t, e) {
  let n = t.length - 2, r = 3, i, s;
  return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: t[r][1].start,
    end: t[n][1].end
  }, s = {
    type: "chunkText",
    start: t[r][1].start,
    end: t[n][1].end,
    contentType: "text"
  }, zn(t, r, n - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), t;
}
function mO(t, e, n) {
  let r = 0;
  return i;
  function i(c) {
    return t.enter("atxHeading"), s(c);
  }
  function s(c) {
    return t.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && r++ < 6 ? (t.consume(c), a) : c === null || Wt(c) ? (t.exit("atxHeadingSequence"), o(c)) : n(c);
  }
  function o(c) {
    return c === 35 ? (t.enter("atxHeadingSequence"), u(c)) : c === null || ve(c) ? (t.exit("atxHeading"), e(c)) : Ve(c) ? it(t, o, "whitespace")(c) : (t.enter("atxHeadingText"), l(c));
  }
  function u(c) {
    return c === 35 ? (t.consume(c), u) : (t.exit("atxHeadingSequence"), o(c));
  }
  function l(c) {
    return c === null || c === 35 || Wt(c) ? (t.exit("atxHeadingText"), o(c)) : (t.consume(c), l);
  }
}
const pO = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Nm = ["pre", "script", "style", "textarea"], gO = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: yO,
  tokenize: TO
}, bO = {
  partial: !0,
  tokenize: xO
}, EO = {
  partial: !0,
  tokenize: SO
};
function yO(t) {
  let e = t.length;
  for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t;
}
function TO(t, e, n) {
  const r = this;
  let i, s, a, o, u;
  return l;
  function l(D) {
    return c(D);
  }
  function c(D) {
    return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(D), d;
  }
  function d(D) {
    return D === 33 ? (t.consume(D), f) : D === 47 ? (t.consume(D), s = !0, p) : D === 63 ? (t.consume(D), i = 3, r.interrupt ? e : w) : Fn(D) ? (t.consume(D), a = String.fromCharCode(D), g) : n(D);
  }
  function f(D) {
    return D === 45 ? (t.consume(D), i = 2, h) : D === 91 ? (t.consume(D), i = 5, o = 0, m) : Fn(D) ? (t.consume(D), i = 4, r.interrupt ? e : w) : n(D);
  }
  function h(D) {
    return D === 45 ? (t.consume(D), r.interrupt ? e : w) : n(D);
  }
  function m(D) {
    const te = "CDATA[";
    return D === te.charCodeAt(o++) ? (t.consume(D), o === te.length ? r.interrupt ? e : P : m) : n(D);
  }
  function p(D) {
    return Fn(D) ? (t.consume(D), a = String.fromCharCode(D), g) : n(D);
  }
  function g(D) {
    if (D === null || D === 47 || D === 62 || Wt(D)) {
      const te = D === 47, he = a.toLowerCase();
      return !te && !s && Nm.includes(he) ? (i = 1, r.interrupt ? e(D) : P(D)) : pO.includes(a.toLowerCase()) ? (i = 6, te ? (t.consume(D), b) : r.interrupt ? e(D) : P(D)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(D) : s ? y(D) : T(D));
    }
    return D === 45 || An(D) ? (t.consume(D), a += String.fromCharCode(D), g) : n(D);
  }
  function b(D) {
    return D === 62 ? (t.consume(D), r.interrupt ? e : P) : n(D);
  }
  function y(D) {
    return Ve(D) ? (t.consume(D), y) : A(D);
  }
  function T(D) {
    return D === 47 ? (t.consume(D), A) : D === 58 || D === 95 || Fn(D) ? (t.consume(D), S) : Ve(D) ? (t.consume(D), T) : A(D);
  }
  function S(D) {
    return D === 45 || D === 46 || D === 58 || D === 95 || An(D) ? (t.consume(D), S) : I(D);
  }
  function I(D) {
    return D === 61 ? (t.consume(D), C) : Ve(D) ? (t.consume(D), I) : T(D);
  }
  function C(D) {
    return D === null || D === 60 || D === 61 || D === 62 || D === 96 ? n(D) : D === 34 || D === 39 ? (t.consume(D), u = D, _) : Ve(D) ? (t.consume(D), C) : R(D);
  }
  function _(D) {
    return D === u ? (t.consume(D), u = null, k) : D === null || ve(D) ? n(D) : (t.consume(D), _);
  }
  function R(D) {
    return D === null || D === 34 || D === 39 || D === 47 || D === 60 || D === 61 || D === 62 || D === 96 || Wt(D) ? I(D) : (t.consume(D), R);
  }
  function k(D) {
    return D === 47 || D === 62 || Ve(D) ? T(D) : n(D);
  }
  function A(D) {
    return D === 62 ? (t.consume(D), L) : n(D);
  }
  function L(D) {
    return D === null || ve(D) ? P(D) : Ve(D) ? (t.consume(D), L) : n(D);
  }
  function P(D) {
    return D === 45 && i === 2 ? (t.consume(D), U) : D === 60 && i === 1 ? (t.consume(D), B) : D === 62 && i === 4 ? (t.consume(D), Y) : D === 63 && i === 3 ? (t.consume(D), w) : D === 93 && i === 5 ? (t.consume(D), K) : ve(D) && (i === 6 || i === 7) ? (t.exit("htmlFlowData"), t.check(bO, J, $)(D)) : D === null || ve(D) ? (t.exit("htmlFlowData"), $(D)) : (t.consume(D), P);
  }
  function $(D) {
    return t.check(EO, G, J)(D);
  }
  function G(D) {
    return t.enter("lineEnding"), t.consume(D), t.exit("lineEnding"), N;
  }
  function N(D) {
    return D === null || ve(D) ? $(D) : (t.enter("htmlFlowData"), P(D));
  }
  function U(D) {
    return D === 45 ? (t.consume(D), w) : P(D);
  }
  function B(D) {
    return D === 47 ? (t.consume(D), a = "", V) : P(D);
  }
  function V(D) {
    if (D === 62) {
      const te = a.toLowerCase();
      return Nm.includes(te) ? (t.consume(D), Y) : P(D);
    }
    return Fn(D) && a.length < 8 ? (t.consume(D), a += String.fromCharCode(D), V) : P(D);
  }
  function K(D) {
    return D === 93 ? (t.consume(D), w) : P(D);
  }
  function w(D) {
    return D === 62 ? (t.consume(D), Y) : D === 45 && i === 2 ? (t.consume(D), w) : P(D);
  }
  function Y(D) {
    return D === null || ve(D) ? (t.exit("htmlFlowData"), J(D)) : (t.consume(D), Y);
  }
  function J(D) {
    return t.exit("htmlFlow"), e(D);
  }
}
function SO(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return ve(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), s) : n(a);
  }
  function s(a) {
    return r.parser.lazy[r.now().line] ? n(a) : e(a);
  }
}
function xO(t, e, n) {
  return r;
  function r(i) {
    return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), t.attempt(hl, e, n);
  }
}
const vO = {
  name: "htmlText",
  tokenize: AO
};
function AO(t, e, n) {
  const r = this;
  let i, s, a;
  return o;
  function o(w) {
    return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(w), u;
  }
  function u(w) {
    return w === 33 ? (t.consume(w), l) : w === 47 ? (t.consume(w), I) : w === 63 ? (t.consume(w), T) : Fn(w) ? (t.consume(w), R) : n(w);
  }
  function l(w) {
    return w === 45 ? (t.consume(w), c) : w === 91 ? (t.consume(w), s = 0, m) : Fn(w) ? (t.consume(w), y) : n(w);
  }
  function c(w) {
    return w === 45 ? (t.consume(w), h) : n(w);
  }
  function d(w) {
    return w === null ? n(w) : w === 45 ? (t.consume(w), f) : ve(w) ? (a = d, B(w)) : (t.consume(w), d);
  }
  function f(w) {
    return w === 45 ? (t.consume(w), h) : d(w);
  }
  function h(w) {
    return w === 62 ? U(w) : w === 45 ? f(w) : d(w);
  }
  function m(w) {
    const Y = "CDATA[";
    return w === Y.charCodeAt(s++) ? (t.consume(w), s === Y.length ? p : m) : n(w);
  }
  function p(w) {
    return w === null ? n(w) : w === 93 ? (t.consume(w), g) : ve(w) ? (a = p, B(w)) : (t.consume(w), p);
  }
  function g(w) {
    return w === 93 ? (t.consume(w), b) : p(w);
  }
  function b(w) {
    return w === 62 ? U(w) : w === 93 ? (t.consume(w), b) : p(w);
  }
  function y(w) {
    return w === null || w === 62 ? U(w) : ve(w) ? (a = y, B(w)) : (t.consume(w), y);
  }
  function T(w) {
    return w === null ? n(w) : w === 63 ? (t.consume(w), S) : ve(w) ? (a = T, B(w)) : (t.consume(w), T);
  }
  function S(w) {
    return w === 62 ? U(w) : T(w);
  }
  function I(w) {
    return Fn(w) ? (t.consume(w), C) : n(w);
  }
  function C(w) {
    return w === 45 || An(w) ? (t.consume(w), C) : _(w);
  }
  function _(w) {
    return ve(w) ? (a = _, B(w)) : Ve(w) ? (t.consume(w), _) : U(w);
  }
  function R(w) {
    return w === 45 || An(w) ? (t.consume(w), R) : w === 47 || w === 62 || Wt(w) ? k(w) : n(w);
  }
  function k(w) {
    return w === 47 ? (t.consume(w), U) : w === 58 || w === 95 || Fn(w) ? (t.consume(w), A) : ve(w) ? (a = k, B(w)) : Ve(w) ? (t.consume(w), k) : U(w);
  }
  function A(w) {
    return w === 45 || w === 46 || w === 58 || w === 95 || An(w) ? (t.consume(w), A) : L(w);
  }
  function L(w) {
    return w === 61 ? (t.consume(w), P) : ve(w) ? (a = L, B(w)) : Ve(w) ? (t.consume(w), L) : k(w);
  }
  function P(w) {
    return w === null || w === 60 || w === 61 || w === 62 || w === 96 ? n(w) : w === 34 || w === 39 ? (t.consume(w), i = w, $) : ve(w) ? (a = P, B(w)) : Ve(w) ? (t.consume(w), P) : (t.consume(w), G);
  }
  function $(w) {
    return w === i ? (t.consume(w), i = void 0, N) : w === null ? n(w) : ve(w) ? (a = $, B(w)) : (t.consume(w), $);
  }
  function G(w) {
    return w === null || w === 34 || w === 39 || w === 60 || w === 61 || w === 96 ? n(w) : w === 47 || w === 62 || Wt(w) ? k(w) : (t.consume(w), G);
  }
  function N(w) {
    return w === 47 || w === 62 || Wt(w) ? k(w) : n(w);
  }
  function U(w) {
    return w === 62 ? (t.consume(w), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(w);
  }
  function B(w) {
    return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(w), t.exit("lineEnding"), V;
  }
  function V(w) {
    return Ve(w) ? it(t, K, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(w) : K(w);
  }
  function K(w) {
    return t.enter("htmlTextData"), a(w);
  }
}
const ch = {
  name: "labelEnd",
  resolveAll: _O,
  resolveTo: RO,
  tokenize: wO
}, IO = {
  tokenize: kO
}, CO = {
  tokenize: DO
}, LO = {
  tokenize: PO
};
function _O(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.length; ) {
    const r = t[e][1];
    if (n.push(t[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return t.length !== n.length && zn(t, 0, t.length, n), t;
}
function RO(t, e) {
  let n = t.length, r = 0, i, s, a, o;
  for (; n--; )
    if (i = t[n][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = n);
  const u = {
    type: t[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...t[s][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  }, l = {
    type: "label",
    start: {
      ...t[s][1].start
    },
    end: {
      ...t[a][1].end
    }
  }, c = {
    type: "labelText",
    start: {
      ...t[s + r + 2][1].end
    },
    end: {
      ...t[a - 2][1].start
    }
  };
  return o = [["enter", u, e], ["enter", l, e]], o = pn(o, t.slice(s + 1, s + r + 3)), o = pn(o, [["enter", c, e]]), o = pn(o, lh(e.parser.constructs.insideSpan.null, t.slice(s + r + 4, a - 3), e)), o = pn(o, [["exit", c, e], t[a - 2], t[a - 1], ["exit", l, e]]), o = pn(o, t.slice(a + 1)), o = pn(o, [["exit", u, e]]), zn(t, s, t.length, o), t;
}
function wO(t, e, n) {
  const r = this;
  let i = r.events.length, s, a;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return o;
  function o(f) {
    return s ? s._inactive ? d(f) : (a = r.parser.defined.includes(Ki(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(f), t.exit("labelMarker"), t.exit("labelEnd"), u) : n(f);
  }
  function u(f) {
    return f === 40 ? t.attempt(IO, c, a ? c : d)(f) : f === 91 ? t.attempt(CO, c, a ? l : d)(f) : a ? c(f) : d(f);
  }
  function l(f) {
    return t.attempt(LO, c, d)(f);
  }
  function c(f) {
    return e(f);
  }
  function d(f) {
    return s._balanced = !0, n(f);
  }
}
function kO(t, e, n) {
  return r;
  function r(d) {
    return t.enter("resource"), t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), i;
  }
  function i(d) {
    return Wt(d) ? na(t, s)(d) : s(d);
  }
  function s(d) {
    return d === 41 ? c(d) : oT(t, a, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function a(d) {
    return Wt(d) ? na(t, u)(d) : c(d);
  }
  function o(d) {
    return n(d);
  }
  function u(d) {
    return d === 34 || d === 39 || d === 40 ? lT(t, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function l(d) {
    return Wt(d) ? na(t, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), t.exit("resource"), e) : n(d);
  }
}
function DO(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return uT.call(r, t, s, a, "reference", "referenceMarker", "referenceString")(o);
  }
  function s(o) {
    return r.parser.defined.includes(Ki(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(o) : n(o);
  }
  function a(o) {
    return n(o);
  }
}
function PO(t, e, n) {
  return r;
  function r(s) {
    return t.enter("reference"), t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (t.enter("referenceMarker"), t.consume(s), t.exit("referenceMarker"), t.exit("reference"), e) : n(s);
  }
}
const OO = {
  name: "labelStartImage",
  resolveAll: ch.resolveAll,
  tokenize: NO
};
function NO(t, e, n) {
  const r = this;
  return i;
  function i(o) {
    return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(o), t.exit("labelImageMarker"), s;
  }
  function s(o) {
    return o === 91 ? (t.enter("labelMarker"), t.consume(o), t.exit("labelMarker"), t.exit("labelImage"), a) : n(o);
  }
  function a(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : e(o);
  }
}
const MO = {
  name: "labelStartLink",
  resolveAll: ch.resolveAll,
  tokenize: FO
};
function FO(t, e, n) {
  const r = this;
  return i;
  function i(a) {
    return t.enter("labelLink"), t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelLink"), s;
  }
  function s(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a);
  }
}
const nc = {
  name: "lineEnding",
  tokenize: BO
};
function BO(t, e) {
  return n;
  function n(r) {
    return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), it(t, e, "linePrefix");
  }
}
const qo = {
  name: "thematicBreak",
  tokenize: $O
};
function $O(t, e, n) {
  let r = 0, i;
  return s;
  function s(l) {
    return t.enter("thematicBreak"), a(l);
  }
  function a(l) {
    return i = l, o(l);
  }
  function o(l) {
    return l === i ? (t.enter("thematicBreakSequence"), u(l)) : r >= 3 && (l === null || ve(l)) ? (t.exit("thematicBreak"), e(l)) : n(l);
  }
  function u(l) {
    return l === i ? (t.consume(l), r++, u) : (t.exit("thematicBreakSequence"), Ve(l) ? it(t, o, "whitespace")(l) : o(l));
  }
}
const Vt = {
  continuation: {
    tokenize: GO
  },
  exit: qO,
  name: "list",
  tokenize: VO
}, UO = {
  partial: !0,
  tokenize: WO
}, HO = {
  partial: !0,
  tokenize: zO
};
function VO(t, e, n) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return o;
  function o(h) {
    const m = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : Td(h)) {
      if (r.containerState.type || (r.containerState.type = m, t.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return t.enter("listItemPrefix"), h === 42 || h === 45 ? t.check(qo, n, l)(h) : l(h);
      if (!r.interrupt || h === 49)
        return t.enter("listItemPrefix"), t.enter("listItemValue"), u(h);
    }
    return n(h);
  }
  function u(h) {
    return Td(h) && ++a < 10 ? (t.consume(h), u) : (!r.interrupt || a < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (t.exit("listItemValue"), l(h)) : n(h);
  }
  function l(h) {
    return t.enter("listItemMarker"), t.consume(h), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, t.check(
      hl,
      // Cant be empty when interrupting.
      r.interrupt ? n : c,
      t.attempt(UO, f, d)
    );
  }
  function c(h) {
    return r.containerState.initialBlankLine = !0, s++, f(h);
  }
  function d(h) {
    return Ve(h) ? (t.enter("listItemPrefixWhitespace"), t.consume(h), t.exit("listItemPrefixWhitespace"), f) : n(h);
  }
  function f(h) {
    return r.containerState.size = s + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(h);
  }
}
function GO(t, e, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, t.check(hl, i, s);
  function i(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, it(t, e, "listItemIndent", r.containerState.size + 1)(o);
  }
  function s(o) {
    return r.containerState.furtherBlankLines || !Ve(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(HO, e, a)(o));
  }
  function a(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, it(t, t.attempt(Vt, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function zO(t, e, n) {
  const r = this;
  return it(t, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? e(s) : n(s);
  }
}
function qO(t) {
  t.exit(this.containerState.type);
}
function WO(t, e, n) {
  const r = this;
  return it(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const a = r.events[r.events.length - 1];
    return !Ve(s) && a && a[1].type === "listItemPrefixWhitespace" ? e(s) : n(s);
  }
}
const Mm = {
  name: "setextUnderline",
  resolveTo: KO,
  tokenize: jO
};
function KO(t, e) {
  let n = t.length, r, i, s;
  for (; n--; )
    if (t[n][0] === "enter") {
      if (t[n][1].type === "content") {
        r = n;
        break;
      }
      t[n][1].type === "paragraph" && (i = n);
    } else
      t[n][1].type === "content" && t.splice(n, 1), !s && t[n][1].type === "definition" && (s = n);
  const a = {
    type: "setextHeading",
    start: {
      ...t[r][1].start
    },
    end: {
      ...t[t.length - 1][1].end
    }
  };
  return t[i][1].type = "setextHeadingText", s ? (t.splice(i, 0, ["enter", a, e]), t.splice(s + 1, 0, ["exit", t[r][1], e]), t[r][1].end = {
    ...t[s][1].end
  }) : t[r][1] = a, t.push(["exit", a, e]), t;
}
function jO(t, e, n) {
  const r = this;
  let i;
  return s;
  function s(l) {
    let c = r.events.length, d;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        d = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (t.enter("setextHeadingLine"), i = l, a(l)) : n(l);
  }
  function a(l) {
    return t.enter("setextHeadingLineSequence"), o(l);
  }
  function o(l) {
    return l === i ? (t.consume(l), o) : (t.exit("setextHeadingLineSequence"), Ve(l) ? it(t, u, "lineSuffix")(l) : u(l));
  }
  function u(l) {
    return l === null || ve(l) ? (t.exit("setextHeadingLine"), e(l)) : n(l);
  }
}
const YO = {
  tokenize: XO
};
function XO(t) {
  const e = this, n = t.attempt(
    // Try to parse a blank line.
    hl,
    r,
    // Try to parse initial flow (essentially, only code).
    t.attempt(this.parser.constructs.flowInitial, i, it(t, t.attempt(this.parser.constructs.flow, i, t.attempt(tO, i)), "linePrefix"))
  );
  return n;
  function r(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEndingBlank"), t.consume(s), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n;
  }
  function i(s) {
    if (s === null) {
      t.consume(s);
      return;
    }
    return t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), e.currentConstruct = void 0, n;
  }
}
const QO = {
  resolveAll: dT()
}, ZO = cT("string"), JO = cT("text");
function cT(t) {
  return {
    resolveAll: dT(t === "text" ? e4 : void 0),
    tokenize: e
  };
  function e(n) {
    const r = this, i = this.parser.constructs[t], s = n.attempt(i, a, o);
    return a;
    function a(c) {
      return l(c) ? s(c) : o(c);
    }
    function o(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), u;
    }
    function u(c) {
      return l(c) ? (n.exit("data"), s(c)) : (n.consume(c), u);
    }
    function l(c) {
      if (c === null)
        return !0;
      const d = i[c];
      let f = -1;
      if (d)
        for (; ++f < d.length; ) {
          const h = d[f];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function dT(t) {
  return e;
  function e(n, r) {
    let i = -1, s;
    for (; ++i <= n.length; )
      s === void 0 ? n[i] && n[i][1].type === "data" && (s = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== s + 2 && (n[s][1].end = n[i - 1][1].end, n.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return t ? t(n, r) : n;
  }
}
function e4(t, e) {
  let n = 0;
  for (; ++n <= t.length; )
    if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") {
      const r = t[n - 1][1], i = e.sliceStream(r);
      let s = i.length, a = -1, o = 0, u;
      for (; s--; ) {
        const l = i[s];
        if (typeof l == "string") {
          for (a = l.length; l.charCodeAt(a - 1) === 32; )
            o++, a--;
          if (a) break;
          a = -1;
        } else if (l === -2)
          u = !0, o++;
        else if (l !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && n === t.length && (o = 0), o) {
        const l = {
          type: n === t.length || u || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? a : r.start._bufferIndex + a,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...l.start
        }, r.start.offset === r.end.offset ? Object.assign(r, l) : (t.splice(n, 0, ["enter", l, e], ["exit", l, e]), n += 2);
      }
      n++;
    }
  return t;
}
const t4 = {
  42: Vt,
  43: Vt,
  45: Vt,
  48: Vt,
  49: Vt,
  50: Vt,
  51: Vt,
  52: Vt,
  53: Vt,
  54: Vt,
  55: Vt,
  56: Vt,
  57: Vt,
  62: rT
}, n4 = {
  91: aO
}, r4 = {
  [-2]: tc,
  [-1]: tc,
  32: tc
}, i4 = {
  35: fO,
  42: qo,
  45: [Mm, qo],
  60: gO,
  61: Mm,
  95: qo,
  96: Om,
  126: Om
}, s4 = {
  38: sT,
  92: iT
}, a4 = {
  [-5]: nc,
  [-4]: nc,
  [-3]: nc,
  33: OO,
  38: sT,
  42: Sd,
  60: [M6, vO],
  91: MO,
  92: [cO, iT],
  93: ch,
  95: Sd,
  96: Y6
}, o4 = {
  null: [Sd, QO]
}, u4 = {
  null: [42, 95]
}, l4 = {
  null: []
}, c4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: u4,
  contentInitial: n4,
  disable: l4,
  document: t4,
  flow: i4,
  flowInitial: r4,
  insideSpan: o4,
  string: s4,
  text: a4
}, Symbol.toStringTag, { value: "Module" }));
function d4(t, e, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, s = [];
  let a = [], o = [];
  const u = {
    attempt: _(I),
    check: _(C),
    consume: y,
    enter: T,
    exit: S,
    interrupt: _(C, {
      interrupt: !0
    })
  }, l = {
    code: null,
    containerState: {},
    defineSkip: p,
    events: [],
    now: m,
    parser: t,
    previous: null,
    sliceSerialize: f,
    sliceStream: h,
    write: d
  };
  let c = e.tokenize.call(l, u);
  return e.resolveAll && s.push(e), l;
  function d(L) {
    return a = pn(a, L), g(), a[a.length - 1] !== null ? [] : (R(e, 0), l.events = lh(s, l.events, l), l.events);
  }
  function f(L, P) {
    return h4(h(L), P);
  }
  function h(L) {
    return f4(a, L);
  }
  function m() {
    const {
      _bufferIndex: L,
      _index: P,
      line: $,
      column: G,
      offset: N
    } = r;
    return {
      _bufferIndex: L,
      _index: P,
      line: $,
      column: G,
      offset: N
    };
  }
  function p(L) {
    i[L.line] = L.column, A();
  }
  function g() {
    let L;
    for (; r._index < a.length; ) {
      const P = a[r._index];
      if (typeof P == "string")
        for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < P.length; )
          b(P.charCodeAt(r._bufferIndex));
      else
        b(P);
    }
  }
  function b(L) {
    c = c(L);
  }
  function y(L) {
    ve(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, A()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    a[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = L;
  }
  function T(L, P) {
    const $ = P || {};
    return $.type = L, $.start = m(), l.events.push(["enter", $, l]), o.push($), $;
  }
  function S(L) {
    const P = o.pop();
    return P.end = m(), l.events.push(["exit", P, l]), P;
  }
  function I(L, P) {
    R(L, P.from);
  }
  function C(L, P) {
    P.restore();
  }
  function _(L, P) {
    return $;
    function $(G, N, U) {
      let B, V, K, w;
      return Array.isArray(G) ? (
        /* c8 ignore next 1 */
        J(G)
      ) : "tokenize" in G ? (
        // Looks like a construct.
        J([
          /** @type {Construct} */
          G
        ])
      ) : Y(G);
      function Y(ie) {
        return X;
        function X(fe) {
          const Te = fe !== null && ie[fe], me = fe !== null && ie.null, ye = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Te) ? Te : Te ? [Te] : [],
            ...Array.isArray(me) ? me : me ? [me] : []
          ];
          return J(ye)(fe);
        }
      }
      function J(ie) {
        return B = ie, V = 0, ie.length === 0 ? U : D(ie[V]);
      }
      function D(ie) {
        return X;
        function X(fe) {
          return w = k(), K = ie, ie.partial || (l.currentConstruct = ie), ie.name && l.parser.constructs.disable.null.includes(ie.name) ? he() : ie.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            P ? Object.assign(Object.create(l), P) : l,
            u,
            te,
            he
          )(fe);
        }
      }
      function te(ie) {
        return L(K, w), N;
      }
      function he(ie) {
        return w.restore(), ++V < B.length ? D(B[V]) : U;
      }
    }
  }
  function R(L, P) {
    L.resolveAll && !s.includes(L) && s.push(L), L.resolve && zn(l.events, P, l.events.length - P, L.resolve(l.events.slice(P), l)), L.resolveTo && (l.events = L.resolveTo(l.events, l));
  }
  function k() {
    const L = m(), P = l.previous, $ = l.currentConstruct, G = l.events.length, N = Array.from(o);
    return {
      from: G,
      restore: U
    };
    function U() {
      r = L, l.previous = P, l.currentConstruct = $, l.events.length = G, o = N, A();
    }
  }
  function A() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function f4(t, e) {
  const n = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let a;
  if (n === i)
    a = [t[n].slice(r, s)];
  else {
    if (a = t.slice(n, i), r > -1) {
      const o = a[0];
      typeof o == "string" ? a[0] = o.slice(r) : a.shift();
    }
    s > 0 && a.push(t[i].slice(0, s));
  }
  return a;
}
function h4(t, e) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < t.length; ) {
    const s = t[n];
    let a;
    if (typeof s == "string")
      a = s;
    else switch (s) {
      case -5: {
        a = "\r";
        break;
      }
      case -4: {
        a = `
`;
        break;
      }
      case -3: {
        a = `\r
`;
        break;
      }
      case -2: {
        a = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        a = " ";
        break;
      }
      default:
        a = String.fromCharCode(s);
    }
    i = s === -2, r.push(a);
  }
  return r.join("");
}
function m4(t) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      S6([c4, ...(t || {}).extensions || []])
    ),
    content: i(R6),
    defined: [],
    document: i(k6),
    flow: i(YO),
    lazy: {},
    string: i(ZO),
    text: i(JO)
  };
  return r;
  function i(s) {
    return a;
    function a(o) {
      return d4(r, s, o);
    }
  }
}
function p4(t) {
  for (; !aT(t); )
    ;
  return t;
}
const Fm = /[\0\t\n\r]/g;
function g4() {
  let t = 1, e = "", n = !0, r;
  return i;
  function i(s, a, o) {
    const u = [];
    let l, c, d, f, h;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(a || void 0).decode(s)), d = 0, e = "", n && (s.charCodeAt(0) === 65279 && d++, n = void 0); d < s.length; ) {
      if (Fm.lastIndex = d, l = Fm.exec(s), f = l && l.index !== void 0 ? l.index : s.length, h = s.charCodeAt(f), !l) {
        e = s.slice(d);
        break;
      }
      if (h === 10 && d === f && r)
        u.push(-3), r = void 0;
      else
        switch (r && (u.push(-5), r = void 0), d < f && (u.push(s.slice(d, f)), t += f - d), h) {
          case 0: {
            u.push(65533), t++;
            break;
          }
          case 9: {
            for (c = Math.ceil(t / 4) * 4, u.push(-2); t++ < c; ) u.push(-1);
            break;
          }
          case 10: {
            u.push(-4), t = 1;
            break;
          }
          default:
            r = !0, t = 1;
        }
      d = f + 1;
    }
    return o && (r && u.push(-5), e && u.push(e), u.push(null)), u;
  }
}
const b4 = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function E4(t) {
  return t.replace(b4, y4);
}
function y4(t, e, n) {
  if (e)
    return e;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), s = i === 120 || i === 88;
    return nT(n.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return nh(n) || t;
}
function Wo(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? Bm(t.position) : "start" in t || "end" in t ? Bm(t) : "line" in t || "column" in t ? xd(t) : "";
}
function xd(t) {
  return $m(t && t.line) + ":" + $m(t && t.column);
}
function Bm(t) {
  return xd(t && t.start) + "-" + xd(t && t.end);
}
function $m(t) {
  return t && typeof t == "number" ? t : 1;
}
const fT = {}.hasOwnProperty;
function T4(t, e, n) {
  return typeof e != "string" && (n = e, e = void 0), S4(n)(p4(m4(n).document().write(g4()(t, e, !0))));
}
function S4(t) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(Ot),
      autolinkProtocol: k,
      autolinkEmail: k,
      atxHeading: s(bt),
      blockQuote: s(me),
      characterEscape: k,
      characterReference: k,
      codeFenced: s(ye),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: s(ye, a),
      codeText: s(Ee, a),
      codeTextData: k,
      data: k,
      codeFlowValue: k,
      definition: s(He),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: s(at),
      hardBreakEscape: s(Le),
      hardBreakTrailing: s(Le),
      htmlFlow: s(Ke, a),
      htmlFlowData: k,
      htmlText: s(Ke, a),
      htmlTextData: k,
      image: s(kt),
      label: a,
      link: s(Ot),
      listItem: s(Tr),
      listItemValue: f,
      listOrdered: s($t, d),
      listUnordered: s($t),
      paragraph: s(er),
      reference: D,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: s(bt),
      strong: s(Ya),
      thematicBreak: s(Xa)
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: I,
      autolink: u(),
      autolinkEmail: Te,
      autolinkProtocol: fe,
      blockQuote: u(),
      characterEscapeValue: A,
      characterReferenceMarkerHexadecimal: he,
      characterReferenceMarkerNumeric: he,
      characterReferenceValue: ie,
      characterReference: X,
      codeFenced: u(g),
      codeFencedFence: p,
      codeFencedFenceInfo: h,
      codeFencedFenceMeta: m,
      codeFlowValue: A,
      codeIndented: u(b),
      codeText: u(N),
      codeTextData: A,
      data: A,
      definition: u(),
      definitionDestinationString: S,
      definitionLabelString: y,
      definitionTitleString: T,
      emphasis: u(),
      hardBreakEscape: u(P),
      hardBreakTrailing: u(P),
      htmlFlow: u($),
      htmlFlowData: A,
      htmlText: u(G),
      htmlTextData: A,
      image: u(B),
      label: K,
      labelText: V,
      lineEnding: L,
      link: u(U),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: te,
      resourceDestinationString: w,
      resourceTitleString: Y,
      resource: J,
      setextHeading: u(R),
      setextHeadingLineSequence: _,
      setextHeadingText: C,
      strong: u(),
      thematicBreak: u()
    }
  };
  hT(e, (t || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(Q) {
    let ce = {
      type: "root",
      children: []
    };
    const Ie = {
      stack: [ce],
      tokenStack: [],
      config: e,
      enter: o,
      exit: l,
      buffer: a,
      resume: c,
      data: n
    }, Ne = [];
    let Ge = -1;
    for (; ++Ge < Q.length; )
      if (Q[Ge][1].type === "listOrdered" || Q[Ge][1].type === "listUnordered")
        if (Q[Ge][0] === "enter")
          Ne.push(Ge);
        else {
          const It = Ne.pop();
          Ge = i(Q, It, Ge);
        }
    for (Ge = -1; ++Ge < Q.length; ) {
      const It = e[Q[Ge][0]];
      fT.call(It, Q[Ge][1].type) && It[Q[Ge][1].type].call(Object.assign({
        sliceSerialize: Q[Ge][2].sliceSerialize
      }, Ie), Q[Ge][1]);
    }
    if (Ie.tokenStack.length > 0) {
      const It = Ie.tokenStack[Ie.tokenStack.length - 1];
      (It[1] || Um).call(Ie, void 0, It[0]);
    }
    for (ce.position = {
      start: Sr(Q.length > 0 ? Q[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Sr(Q.length > 0 ? Q[Q.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ge = -1; ++Ge < e.transforms.length; )
      ce = e.transforms[Ge](ce) || ce;
    return ce;
  }
  function i(Q, ce, Ie) {
    let Ne = ce - 1, Ge = -1, It = !1, zr, tr, _s, Rs;
    for (; ++Ne <= Ie; ) {
      const Jt = Q[Ne];
      switch (Jt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Jt[0] === "enter" ? Ge++ : Ge--, Rs = void 0;
          break;
        }
        case "lineEndingBlank": {
          Jt[0] === "enter" && (zr && !Rs && !Ge && !_s && (_s = Ne), Rs = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Rs = void 0;
      }
      if (!Ge && Jt[0] === "enter" && Jt[1].type === "listItemPrefix" || Ge === -1 && Jt[0] === "exit" && (Jt[1].type === "listUnordered" || Jt[1].type === "listOrdered")) {
        if (zr) {
          let vi = Ne;
          for (tr = void 0; vi--; ) {
            const nr = Q[vi];
            if (nr[1].type === "lineEnding" || nr[1].type === "lineEndingBlank") {
              if (nr[0] === "exit") continue;
              tr && (Q[tr][1].type = "lineEndingBlank", It = !0), nr[1].type = "lineEnding", tr = vi;
            } else if (!(nr[1].type === "linePrefix" || nr[1].type === "blockQuotePrefix" || nr[1].type === "blockQuotePrefixWhitespace" || nr[1].type === "blockQuoteMarker" || nr[1].type === "listItemIndent")) break;
          }
          _s && (!tr || _s < tr) && (zr._spread = !0), zr.end = Object.assign({}, tr ? Q[tr][1].start : Jt[1].end), Q.splice(tr || Ne, 0, ["exit", zr, Jt[2]]), Ne++, Ie++;
        }
        if (Jt[1].type === "listItemPrefix") {
          const vi = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Jt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          zr = vi, Q.splice(Ne, 0, ["enter", vi, Jt[2]]), Ne++, Ie++, _s = void 0, Rs = !0;
        }
      }
    }
    return Q[ce][1]._spread = It, Ie;
  }
  function s(Q, ce) {
    return Ie;
    function Ie(Ne) {
      o.call(this, Q(Ne), Ne), ce && ce.call(this, Ne);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(Q, ce, Ie) {
    this.stack[this.stack.length - 1].children.push(Q), this.stack.push(Q), this.tokenStack.push([ce, Ie || void 0]), Q.position = {
      start: Sr(ce.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function u(Q) {
    return ce;
    function ce(Ie) {
      Q && Q.call(this, Ie), l.call(this, Ie);
    }
  }
  function l(Q, ce) {
    const Ie = this.stack.pop(), Ne = this.tokenStack.pop();
    if (Ne)
      Ne[0].type !== Q.type && (ce ? ce.call(this, Q, Ne[0]) : (Ne[1] || Um).call(this, Q, Ne[0]));
    else throw new Error("Cannot close `" + Q.type + "` (" + Wo({
      start: Q.start,
      end: Q.end
    }) + "): its not open");
    Ie.position.end = Sr(Q.end);
  }
  function c() {
    return y6(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(Q) {
    if (this.data.expectingFirstListItemValue) {
      const ce = this.stack[this.stack.length - 2];
      ce.start = Number.parseInt(this.sliceSerialize(Q), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function h() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.lang = Q;
  }
  function m() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.meta = Q;
  }
  function p() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.value = Q.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.value = Q.replace(/(\r?\n|\r)$/g, "");
  }
  function y(Q) {
    const ce = this.resume(), Ie = this.stack[this.stack.length - 1];
    Ie.label = ce, Ie.identifier = Ki(this.sliceSerialize(Q)).toLowerCase();
  }
  function T() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.title = Q;
  }
  function S() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.url = Q;
  }
  function I(Q) {
    const ce = this.stack[this.stack.length - 1];
    if (!ce.depth) {
      const Ie = this.sliceSerialize(Q).length;
      ce.depth = Ie;
    }
  }
  function C() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function _(Q) {
    const ce = this.stack[this.stack.length - 1];
    ce.depth = this.sliceSerialize(Q).codePointAt(0) === 61 ? 1 : 2;
  }
  function R() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function k(Q) {
    const Ie = this.stack[this.stack.length - 1].children;
    let Ne = Ie[Ie.length - 1];
    (!Ne || Ne.type !== "text") && (Ne = xi(), Ne.position = {
      start: Sr(Q.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Ie.push(Ne)), this.stack.push(Ne);
  }
  function A(Q) {
    const ce = this.stack.pop();
    ce.value += this.sliceSerialize(Q), ce.position.end = Sr(Q.end);
  }
  function L(Q) {
    const ce = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ie = ce.children[ce.children.length - 1];
      Ie.position.end = Sr(Q.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(ce.type) && (k.call(this, Q), A.call(this, Q));
  }
  function P() {
    this.data.atHardBreak = !0;
  }
  function $() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.value = Q;
  }
  function G() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.value = Q;
  }
  function N() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.value = Q;
  }
  function U() {
    const Q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ce = this.data.referenceType || "shortcut";
      Q.type += "Reference", Q.referenceType = ce, delete Q.url, delete Q.title;
    } else
      delete Q.identifier, delete Q.label;
    this.data.referenceType = void 0;
  }
  function B() {
    const Q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ce = this.data.referenceType || "shortcut";
      Q.type += "Reference", Q.referenceType = ce, delete Q.url, delete Q.title;
    } else
      delete Q.identifier, delete Q.label;
    this.data.referenceType = void 0;
  }
  function V(Q) {
    const ce = this.sliceSerialize(Q), Ie = this.stack[this.stack.length - 2];
    Ie.label = E4(ce), Ie.identifier = Ki(ce).toLowerCase();
  }
  function K() {
    const Q = this.stack[this.stack.length - 1], ce = this.resume(), Ie = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ie.type === "link") {
      const Ne = Q.children;
      Ie.children = Ne;
    } else
      Ie.alt = ce;
  }
  function w() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.url = Q;
  }
  function Y() {
    const Q = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.title = Q;
  }
  function J() {
    this.data.inReference = void 0;
  }
  function D() {
    this.data.referenceType = "collapsed";
  }
  function te(Q) {
    const ce = this.resume(), Ie = this.stack[this.stack.length - 1];
    Ie.label = ce, Ie.identifier = Ki(this.sliceSerialize(Q)).toLowerCase(), this.data.referenceType = "full";
  }
  function he(Q) {
    this.data.characterReferenceType = Q.type;
  }
  function ie(Q) {
    const ce = this.sliceSerialize(Q), Ie = this.data.characterReferenceType;
    let Ne;
    Ie ? (Ne = nT(ce, Ie === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ne = nh(ce);
    const Ge = this.stack[this.stack.length - 1];
    Ge.value += Ne;
  }
  function X(Q) {
    const ce = this.stack.pop();
    ce.position.end = Sr(Q.end);
  }
  function fe(Q) {
    A.call(this, Q);
    const ce = this.stack[this.stack.length - 1];
    ce.url = this.sliceSerialize(Q);
  }
  function Te(Q) {
    A.call(this, Q);
    const ce = this.stack[this.stack.length - 1];
    ce.url = "mailto:" + this.sliceSerialize(Q);
  }
  function me() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ye() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ee() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function He() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function at() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function bt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Le() {
    return {
      type: "break"
    };
  }
  function Ke() {
    return {
      type: "html",
      value: ""
    };
  }
  function kt() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Ot() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function $t(Q) {
    return {
      type: "list",
      ordered: Q.type === "listOrdered",
      start: null,
      spread: Q._spread,
      children: []
    };
  }
  function Tr(Q) {
    return {
      type: "listItem",
      spread: Q._spread,
      checked: null,
      children: []
    };
  }
  function er() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ya() {
    return {
      type: "strong",
      children: []
    };
  }
  function xi() {
    return {
      type: "text",
      value: ""
    };
  }
  function Xa() {
    return {
      type: "thematicBreak"
    };
  }
}
function Sr(t) {
  return {
    line: t.line,
    column: t.column,
    offset: t.offset
  };
}
function hT(t, e) {
  let n = -1;
  for (; ++n < e.length; ) {
    const r = e[n];
    Array.isArray(r) ? hT(t, r) : x4(t, r);
  }
}
function x4(t, e) {
  let n;
  for (n in e)
    if (fT.call(e, n))
      switch (n) {
        case "canContainEols": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "transforms": {
          const r = e[n];
          r && t[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[n];
          r && Object.assign(t[n], r);
          break;
        }
      }
}
function Um(t, e) {
  throw t ? new Error("Cannot close `" + t.type + "` (" + Wo({
    start: t.start,
    end: t.end
  }) + "): a different token (`" + e.type + "`, " + Wo({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Wo({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function v4(t) {
  const e = this;
  e.parser = n;
  function n(r) {
    return T4(r, {
      ...e.data("settings"),
      ...t,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
function A4(t, e) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: t.wrap(t.all(e), !0)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function I4(t, e) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return t.patch(e, n), [t.applyData(e, n), { type: "text", value: `
` }];
}
function C4(t, e) {
  const n = e.value ? e.value + `
` : "", r = {};
  e.lang && (r.className = ["language-" + e.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return e.meta && (i.data = { meta: e.meta }), t.patch(e, i), i = t.applyData(e, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, t.patch(e, i), i;
}
function L4(t, e) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function _4(t, e) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Hm = R4(/[\dA-Za-z]/);
function R4(t) {
  return e;
  function e(n) {
    return n !== null && n > -1 && t.test(String.fromCharCode(n));
  }
}
function vs(t) {
  const e = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < t.length; ) {
    const s = t.charCodeAt(n);
    let a = "";
    if (s === 37 && Hm(t.charCodeAt(n + 1)) && Hm(t.charCodeAt(n + 2)))
      i = 2;
    else if (s < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (a = String.fromCharCode(s));
    else if (s > 55295 && s < 57344) {
      const o = t.charCodeAt(n + 1);
      s < 56320 && o > 56319 && o < 57344 ? (a = String.fromCharCode(s, o), i = 1) : a = "";
    } else
      a = String.fromCharCode(s);
    a && (e.push(t.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0);
  }
  return e.join("") + t.slice(r);
}
function w4(t, e) {
  const n = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", r = String(e.identifier).toUpperCase(), i = vs(r.toLowerCase()), s = t.footnoteOrder.indexOf(r);
  let a, o = t.footnoteCounts.get(r);
  o === void 0 ? (o = 0, t.footnoteOrder.push(r), a = t.footnoteOrder.length) : a = s + 1, o += 1, t.footnoteCounts.set(r, o);
  const u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  t.patch(e, u);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return t.patch(e, l), t.applyData(e, l);
}
function k4(t, e) {
  const n = {
    type: "element",
    tagName: "h" + e.depth,
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function D4(t, e) {
  if (t.options.allowDangerousHtml) {
    const n = { type: "raw", value: e.value };
    return t.patch(e, n), t.applyData(e, n);
  }
}
function mT(t, e) {
  const n = e.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")
    return [{ type: "text", value: "![" + e.alt + r }];
  const i = t.all(e), s = i[0];
  s && s.type === "text" ? s.value = "[" + s.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += r : i.push({ type: "text", value: r }), i;
}
function P4(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return mT(t, e);
  const i = { src: vs(r.url || ""), alt: e.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = { type: "element", tagName: "img", properties: i, children: [] };
  return t.patch(e, s), t.applyData(e, s);
}
function O4(t, e) {
  const n = { src: vs(e.url) };
  e.alt !== null && e.alt !== void 0 && (n.alt = e.alt), e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return t.patch(e, r), t.applyData(e, r);
}
function N4(t, e) {
  const n = { type: "text", value: e.value.replace(/\r?\n|\r/g, " ") };
  t.patch(e, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return t.patch(e, r), t.applyData(e, r);
}
function M4(t, e) {
  const n = String(e.identifier).toUpperCase(), r = t.definitionById.get(n);
  if (!r)
    return mT(t, e);
  const i = { href: vs(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const s = {
    type: "element",
    tagName: "a",
    properties: i,
    children: t.all(e)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function F4(t, e) {
  const n = { href: vs(e.url) };
  e.title !== null && e.title !== void 0 && (n.title = e.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function B4(t, e, n) {
  const r = t.all(e), i = n ? $4(n) : pT(e), s = {}, a = [];
  if (typeof e.checked == "boolean") {
    const c = r[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: e.checked, disabled: !0 },
      children: []
    }), s.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const c = r[o];
    (i || o !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const u = r[r.length - 1];
  u && (i || u.type !== "element" || u.tagName !== "p") && a.push({ type: "text", value: `
` });
  const l = { type: "element", tagName: "li", properties: s, children: a };
  return t.patch(e, l), t.applyData(e, l);
}
function $4(t) {
  let e = !1;
  if (t.type === "list") {
    e = t.spread || !1;
    const n = t.children;
    let r = -1;
    for (; !e && ++r < n.length; )
      e = pT(n[r]);
  }
  return e;
}
function pT(t) {
  const e = t.spread;
  return e ?? t.children.length > 1;
}
function U4(t, e) {
  const n = {}, r = t.all(e);
  let i = -1;
  for (typeof e.start == "number" && e.start !== 1 && (n.start = e.start); ++i < r.length; ) {
    const a = r[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const s = {
    type: "element",
    tagName: e.ordered ? "ol" : "ul",
    properties: n,
    children: t.wrap(r, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function H4(t, e) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
function V4(t, e) {
  const n = { type: "root", children: t.wrap(t.all(e)) };
  return t.patch(e, n), t.applyData(e, n);
}
function G4(t, e) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const gT = ET("end"), bT = ET("start");
function ET(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function z4(t) {
  const e = bT(t), n = gT(t);
  if (e && n)
    return { start: e, end: n };
}
function q4(t, e) {
  const n = t.all(e), r = n.shift(), i = [];
  if (r) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: t.wrap([r], !0)
    };
    t.patch(e.children[0], a), i.push(a);
  }
  if (n.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: t.wrap(n, !0)
    }, o = bT(e.children[1]), u = gT(e.children[e.children.length - 1]);
    o && u && (a.position = { start: o, end: u }), i.push(a);
  }
  const s = {
    type: "element",
    tagName: "table",
    properties: {},
    children: t.wrap(i, !0)
  };
  return t.patch(e, s), t.applyData(e, s);
}
function W4(t, e, n) {
  const r = n ? n.children : void 0, s = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, o = a ? a.length : e.children.length;
  let u = -1;
  const l = [];
  for (; ++u < o; ) {
    const d = e.children[u], f = {}, h = a ? a[u] : void 0;
    h && (f.align = h);
    let m = { type: "element", tagName: s, properties: f, children: [] };
    d && (m.children = t.all(d), t.patch(d, m), m = t.applyData(d, m)), l.push(m);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: t.wrap(l, !0)
  };
  return t.patch(e, c), t.applyData(e, c);
}
function K4(t, e) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Vm = 9, Gm = 32;
function j4(t) {
  const e = String(t), n = /\r?\n|\r/g;
  let r = n.exec(e), i = 0;
  const s = [];
  for (; r; )
    s.push(
      zm(e.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(e);
  return s.push(zm(e.slice(i), i > 0, !1)), s.join("");
}
function zm(t, e, n) {
  let r = 0, i = t.length;
  if (e) {
    let s = t.codePointAt(r);
    for (; s === Vm || s === Gm; )
      r++, s = t.codePointAt(r);
  }
  if (n) {
    let s = t.codePointAt(i - 1);
    for (; s === Vm || s === Gm; )
      i--, s = t.codePointAt(i - 1);
  }
  return i > r ? t.slice(r, i) : "";
}
function Y4(t, e) {
  const n = { type: "text", value: j4(String(e.value)) };
  return t.patch(e, n), t.applyData(e, n);
}
function X4(t, e) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return t.patch(e, n), t.applyData(e, n);
}
const Q4 = {
  blockquote: A4,
  break: I4,
  code: C4,
  delete: L4,
  emphasis: _4,
  footnoteReference: w4,
  heading: k4,
  html: D4,
  imageReference: P4,
  image: O4,
  inlineCode: N4,
  linkReference: M4,
  link: F4,
  listItem: B4,
  list: U4,
  paragraph: H4,
  // @ts-expect-error: root is different, but hard to type.
  root: V4,
  strong: G4,
  table: q4,
  tableCell: K4,
  tableRow: W4,
  text: Y4,
  thematicBreak: X4,
  toml: ao,
  yaml: ao,
  definition: ao,
  footnoteDefinition: ao
};
function ao() {
}
function Z4(t, e) {
  const n = [{ type: "text", value: "" }];
  return e > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(e) }]
  }), n;
}
function J4(t, e) {
  return "Back to reference " + (t + 1) + (e > 1 ? "-" + e : "");
}
function eN(t) {
  const e = typeof t.options.clobberPrefix == "string" ? t.options.clobberPrefix : "user-content-", n = t.options.footnoteBackContent || Z4, r = t.options.footnoteBackLabel || J4, i = t.options.footnoteLabel || "Footnotes", s = t.options.footnoteLabelTagName || "h2", a = t.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let u = -1;
  for (; ++u < t.footnoteOrder.length; ) {
    const l = t.footnoteById.get(
      t.footnoteOrder[u]
    );
    if (!l)
      continue;
    const c = t.all(l), d = String(l.identifier).toUpperCase(), f = vs(d.toLowerCase());
    let h = 0;
    const m = [], p = t.footnoteCounts.get(d);
    for (; p !== void 0 && ++h <= p; ) {
      m.length > 0 && m.push({ type: "text", value: " " });
      let y = typeof n == "string" ? n : n(u, h);
      typeof y == "string" && (y = { type: "text", value: y }), m.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + e + "fnref-" + f + (h > 1 ? "-" + h : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(u, h),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(y) ? y : [y]
      });
    }
    const g = c[c.length - 1];
    if (g && g.type === "element" && g.tagName === "p") {
      const y = g.children[g.children.length - 1];
      y && y.type === "text" ? y.value += " " : g.children.push({ type: "text", value: " " }), g.children.push(...m);
    } else
      c.push(...m);
    const b = {
      type: "element",
      tagName: "li",
      properties: { id: e + "fn-" + f },
      children: t.wrap(c, !0)
    };
    t.patch(l, b), o.push(b);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: s,
          properties: {
            ...ns(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: t.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const vd = {}.hasOwnProperty, tN = {};
function nN(t, e) {
  const n = e || tN, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = { ...Q4, ...n.handlers }, o = {
    all: l,
    applyData: iN,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: s,
    footnoteOrder: [],
    handlers: a,
    one: u,
    options: n,
    patch: rN,
    wrap: aN
  };
  return ul(t, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? r : i, f = String(c.identifier).toUpperCase();
      d.has(f) || d.set(f, c);
    }
  }), o;
  function u(c, d) {
    const f = c.type, h = o.handlers[f];
    if (vd.call(o.handlers, f) && h)
      return h(o, c, d);
    if (o.options.passThrough && o.options.passThrough.includes(f)) {
      if ("children" in c) {
        const { children: p, ...g } = c, b = ns(g);
        return b.children = o.all(c), b;
      }
      return ns(c);
    }
    return (o.options.unknownHandler || sN)(o, c, d);
  }
  function l(c) {
    const d = [];
    if ("children" in c) {
      const f = c.children;
      let h = -1;
      for (; ++h < f.length; ) {
        const m = o.one(f[h], c);
        if (m) {
          if (h && f[h - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = qm(m.value)), !Array.isArray(m) && m.type === "element")) {
            const p = m.children[0];
            p && p.type === "text" && (p.value = qm(p.value));
          }
          Array.isArray(m) ? d.push(...m) : d.push(m);
        }
      }
    }
    return d;
  }
}
function rN(t, e) {
  t.position && (e.position = z4(t));
}
function iN(t, e) {
  let n = e;
  if (t && t.data) {
    const r = t.data.hName, i = t.data.hChildren, s = t.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const a = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: a };
      }
    n.type === "element" && s && Object.assign(n.properties, ns(s)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function sN(t, e) {
  const n = e.data || {}, r = "value" in e && !(vd.call(n, "hProperties") || vd.call(n, "hChildren")) ? { type: "text", value: e.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: t.all(e)
  };
  return t.patch(e, r), t.applyData(e, r);
}
function aN(t, e) {
  const n = [];
  let r = -1;
  for (e && n.push({ type: "text", value: `
` }); ++r < t.length; )
    r && n.push({ type: "text", value: `
` }), n.push(t[r]);
  return e && t.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function qm(t) {
  let e = 0, n = t.charCodeAt(e);
  for (; n === 9 || n === 32; )
    e++, n = t.charCodeAt(e);
  return t.slice(e);
}
function Wm(t, e) {
  const n = nN(t, e), r = n.one(t, void 0), i = eN(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && s.children.push({ type: "text", value: `
` }, i), s;
}
function oN(t, e) {
  return t && "run" in t ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      Wm(n, { file: r, ...e })
    );
    await t.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Wm(n, { file: r, ...t || e })
    );
  };
}
function Km(t) {
  if (t)
    throw t;
}
var Ae = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yT(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function uN(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var Ko = Object.prototype.hasOwnProperty, TT = Object.prototype.toString, jm = Object.defineProperty, Ym = Object.getOwnPropertyDescriptor, Xm = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : TT.call(e) === "[object Array]";
}, Qm = function(e) {
  if (!e || TT.call(e) !== "[object Object]")
    return !1;
  var n = Ko.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Ko.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !n && !r)
    return !1;
  var i;
  for (i in e)
    ;
  return typeof i > "u" || Ko.call(e, i);
}, Zm = function(e, n) {
  jm && n.name === "__proto__" ? jm(e, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : e[n.name] = n.newValue;
}, Jm = function(e, n) {
  if (n === "__proto__")
    if (Ko.call(e, n)) {
      if (Ym)
        return Ym(e, n).value;
    } else return;
  return e[n];
}, lN = function t() {
  var e, n, r, i, s, a, o = arguments[0], u = 1, l = arguments.length, c = !1;
  for (typeof o == "boolean" && (c = o, o = arguments[1] || {}, u = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); u < l; ++u)
    if (e = arguments[u], e != null)
      for (n in e)
        r = Jm(o, n), i = Jm(e, n), o !== i && (c && i && (Qm(i) || (s = Xm(i))) ? (s ? (s = !1, a = r && Xm(r) ? r : []) : a = r && Qm(r) ? r : {}, Zm(o, { name: n, newValue: t(c, a, i) })) : typeof i < "u" && Zm(o, { name: n, newValue: i }));
  return o;
};
const rc = /* @__PURE__ */ yT(lN);
function Ad(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function cN() {
  const t = [], e = { run: n, use: r };
  return e;
  function n(...i) {
    let s = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    o(null, ...i);
    function o(u, ...l) {
      const c = t[++s];
      let d = -1;
      if (u) {
        a(u);
        return;
      }
      for (; ++d < i.length; )
        (l[d] === null || l[d] === void 0) && (l[d] = i[d]);
      i = l, c ? dN(c, o)(...l) : a(null, ...l);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return t.push(i), e;
  }
}
function dN(t, e) {
  let n;
  return r;
  function r(...a) {
    const o = t.length > a.length;
    let u;
    o && a.push(i);
    try {
      u = t.apply(this, a);
    } catch (l) {
      const c = (
        /** @type {Error} */
        l
      );
      if (o && n)
        throw c;
      return i(c);
    }
    o || (u && u.then && typeof u.then == "function" ? u.then(s, i) : u instanceof Error ? i(u) : s(u));
  }
  function i(a, ...o) {
    n || (n = !0, e(a, ...o));
  }
  function s(a) {
    i(null, a);
  }
}
function fN(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? ep(t.position) : "start" in t || "end" in t ? ep(t) : "line" in t || "column" in t ? Id(t) : "";
}
function Id(t) {
  return tp(t && t.line) + ":" + tp(t && t.column);
}
function ep(t) {
  return Id(t && t.start) + "-" + Id(t && t.end);
}
function tp(t) {
  return t && typeof t == "number" ? t : 1;
}
class Zt extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", s = {}, a = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof e == "string" ? i = e : !s.cause && e && (a = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? s.ruleId = r : (s.source = r.slice(0, u), s.ruleId = r.slice(u + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const u = s.ancestors[s.ancestors.length - 1];
      u && (s.place = u.position);
    }
    const o = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = o ? o.line : void 0, this.name = fN(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = a && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
Zt.prototype.file = "";
Zt.prototype.name = "";
Zt.prototype.reason = "";
Zt.prototype.message = "";
Zt.prototype.stack = "";
Zt.prototype.column = void 0;
Zt.prototype.line = void 0;
Zt.prototype.ancestors = void 0;
Zt.prototype.cause = void 0;
Zt.prototype.fatal = void 0;
Zt.prototype.place = void 0;
Zt.prototype.ruleId = void 0;
Zt.prototype.source = void 0;
const Pn = { basename: hN, dirname: mN, extname: pN, join: gN, sep: "/" };
function hN(t, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  Ua(t);
  let n = 0, r = -1, i = t.length, s;
  if (e === void 0 || e.length === 0 || e.length > t.length) {
    for (; i--; )
      if (t.codePointAt(i) === 47) {
        if (s) {
          n = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : t.slice(n, r);
  }
  if (e === t)
    return "";
  let a = -1, o = e.length - 1;
  for (; i--; )
    if (t.codePointAt(i) === 47) {
      if (s) {
        n = i + 1;
        break;
      }
    } else
      a < 0 && (s = !0, a = i + 1), o > -1 && (t.codePointAt(i) === e.codePointAt(o--) ? o < 0 && (r = i) : (o = -1, r = a));
  return n === r ? r = a : r < 0 && (r = t.length), t.slice(n, r);
}
function mN(t) {
  if (Ua(t), t.length === 0)
    return ".";
  let e = -1, n = t.length, r;
  for (; --n; )
    if (t.codePointAt(n) === 47) {
      if (r) {
        e = n;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? t.codePointAt(0) === 47 ? "/" : "." : e === 1 && t.codePointAt(0) === 47 ? "//" : t.slice(0, e);
}
function pN(t) {
  Ua(t);
  let e = t.length, n = -1, r = 0, i = -1, s = 0, a;
  for (; e--; ) {
    const o = t.codePointAt(e);
    if (o === 47) {
      if (a) {
        r = e + 1;
        break;
      }
      continue;
    }
    n < 0 && (a = !0, n = e + 1), o === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === n - 1 && i === r + 1 ? "" : t.slice(i, n);
}
function gN(...t) {
  let e = -1, n;
  for (; ++e < t.length; )
    Ua(t[e]), t[e] && (n = n === void 0 ? t[e] : n + "/" + t[e]);
  return n === void 0 ? "." : bN(n);
}
function bN(t) {
  Ua(t);
  const e = t.codePointAt(0) === 47;
  let n = EN(t, !e);
  return n.length === 0 && !e && (n = "."), n.length > 0 && t.codePointAt(t.length - 1) === 47 && (n += "/"), e ? "/" + n : n;
}
function EN(t, e) {
  let n = "", r = 0, i = -1, s = 0, a = -1, o, u;
  for (; ++a <= t.length; ) {
    if (a < t.length)
      o = t.codePointAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(i === a - 1 || s === 1)) if (i !== a - 1 && s === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (u = n.lastIndexOf("/"), u !== n.length - 1) {
              u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), i = a, s = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = a, s = 0;
            continue;
          }
        }
        e && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + t.slice(i + 1, a) : n = t.slice(i + 1, a), r = a - i - 1;
      i = a, s = 0;
    } else o === 46 && s > -1 ? s++ : s = -1;
  }
  return n;
}
function Ua(t) {
  if (typeof t != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(t)
    );
}
const yN = { cwd: TN };
function TN() {
  return "/";
}
function Cd(t) {
  return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && // @ts-expect-error: indexing is fine.
  t.auth === void 0);
}
function SN(t) {
  if (typeof t == "string")
    t = new URL(t);
  else if (!Cd(t)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + t + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (t.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return xN(t);
}
function xN(t) {
  if (t.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = t.pathname;
  let n = -1;
  for (; ++n < e.length; )
    if (e.codePointAt(n) === 37 && e.codePointAt(n + 1) === 50) {
      const r = e.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const ic = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class vN {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let n;
    e ? Cd(e) ? n = { path: e } : typeof e == "string" || AN(e) ? n = { value: e } : n = e : n = {}, this.cwd = "cwd" in n ? "" : yN.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < ic.length; ) {
      const s = ic[r];
      s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]);
    }
    let i;
    for (i in n)
      ic.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Pn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    ac(e, "basename"), sc(e, "basename"), this.path = Pn.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Pn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    np(this.basename, "dirname"), this.path = Pn.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Pn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (sc(e, "extname"), np(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Pn.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Cd(e) && (e = SN(e)), ac(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Pn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    ac(e, "stem"), sc(e, "stem"), this.path = Pn.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, n, r) {
    const i = this.message(e, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, n, r) {
    const i = this.message(e, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, n, r) {
    const i = new Zt(
      // @ts-expect-error: the overloads are fine.
      e,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function sc(t, e) {
  if (t && t.includes(Pn.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + Pn.sep + "`"
    );
}
function ac(t, e) {
  if (!t)
    throw new Error("`" + e + "` cannot be empty");
}
function np(t, e) {
  if (!t)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function AN(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
const IN = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(t) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[t], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), CN = {}.hasOwnProperty;
let LN = class ST extends IN {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = cN();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new ST()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      e.use(...r);
    }
    return e.data(rc(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, n) {
    return typeof e == "string" ? arguments.length === 2 ? (lc("data", this.frozen), this.namespace[e] = n, this) : CN.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (lc("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const n = oo(e), r = this.parser || this.Parser;
    return oc("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, n) {
    const r = this;
    return this.freeze(), oc("process", this.parser || this.Parser), uc("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(s, a) {
      const o = oo(e), u = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(u, o, function(c, d, f) {
        if (c || !d || !f)
          return l(c);
        const h = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), m = r.stringify(h, f);
        wN(m) ? f.value = m : f.result = m, l(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function l(c, d) {
        c || !d ? a(c) : s ? s(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let n = !1, r;
    return this.freeze(), oc("processSync", this.parser || this.Parser), uc("processSync", this.compiler || this.Compiler), this.process(e, i), ip("processSync", "process", n), r;
    function i(s, a) {
      n = !0, Km(s), r = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, n, r) {
    rp(e), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s);
    function s(a, o) {
      const u = oo(n);
      i.run(e, u, l);
      function l(c, d, f) {
        const h = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || e
        );
        c ? o(c) : a ? a(h) : r(void 0, h, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, n) {
    let r = !1, i;
    return this.run(e, n, s), ip("runSync", "run", r), i;
    function s(a, o) {
      Km(a), i = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, n) {
    this.freeze();
    const r = oo(n), i = this.compiler || this.Compiler;
    return uc("stringify", i), rp(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...n) {
    const r = this.attachers, i = this.namespace;
    if (lc("use", this.frozen), e != null) if (typeof e == "function")
      u(e, n);
    else if (typeof e == "object")
      Array.isArray(e) ? o(e) : a(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(l) {
      if (typeof l == "function")
        u(l, []);
      else if (typeof l == "object")
        if (Array.isArray(l)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            l
          );
          u(c, d);
        } else
          a(l);
      else
        throw new TypeError("Expected usable value, not `" + l + "`");
    }
    function a(l) {
      if (!("plugins" in l) && !("settings" in l))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(l.plugins), l.settings && (i.settings = rc(!0, i.settings, l.settings));
    }
    function o(l) {
      let c = -1;
      if (l != null) if (Array.isArray(l))
        for (; ++c < l.length; ) {
          const d = l[c];
          s(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + l + "`");
    }
    function u(l, c) {
      let d = -1, f = -1;
      for (; ++d < r.length; )
        if (r[d][0] === l) {
          f = d;
          break;
        }
      if (f === -1)
        r.push([l, ...c]);
      else if (c.length > 0) {
        let [h, ...m] = c;
        const p = r[f][1];
        Ad(p) && Ad(h) && (h = rc(!0, p, h)), r[f] = [l, h, ...m];
      }
    }
  }
};
const _N = new LN().freeze();
function oc(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `parser`");
}
function uc(t, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + t + "` without `compiler`");
}
function lc(t, e) {
  if (e)
    throw new Error(
      "Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function rp(t) {
  if (!Ad(t) || typeof t.type != "string")
    throw new TypeError("Expected node, got `" + t + "`");
}
function ip(t, e, n) {
  if (!n)
    throw new Error(
      "`" + t + "` finished async. Use `" + e + "` instead"
    );
}
function oo(t) {
  return RN(t) ? t : new vN(t);
}
function RN(t) {
  return !!(t && typeof t == "object" && "message" in t && "messages" in t);
}
function wN(t) {
  return typeof t == "string" || kN(t);
}
function kN(t) {
  return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t);
}
var xT = { exports: {} }, Fs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sp;
function DN() {
  if (sp)
    return Fs;
  sp = 1;
  var t = v, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, u, l) {
    var c, d = {}, f = null, h = null;
    l !== void 0 && (f = "" + l), u.key !== void 0 && (f = "" + u.key), u.ref !== void 0 && (h = u.ref);
    for (c in u)
      r.call(u, c) && !s.hasOwnProperty(c) && (d[c] = u[c]);
    if (o && o.defaultProps)
      for (c in u = o.defaultProps, u)
        d[c] === void 0 && (d[c] = u[c]);
    return { $$typeof: e, type: o, key: f, ref: h, props: d, _owner: i.current };
  }
  return Fs.Fragment = n, Fs.jsx = a, Fs.jsxs = a, Fs;
}
xT.exports = DN();
var PN = xT.exports;
async function ON(t) {
  const e = await _N().use(v4).use(b6).use(oN, { allowDangerousHtml: !0 }).use(RR).use(Vw).processSync(t);
  return String(e);
}
function NN(t) {
  const [e, n] = v.useState("");
  return v.useEffect(() => {
    (async () => {
      const r = await ON(t);
      n(r);
    })();
  }, [t]), { html: e, jsx: /* @__PURE__ */ PN.jsx("div", { dangerouslySetInnerHTML: { __html: e } }) };
}
const MN = ({
  value: t,
  handleClick: e
}) => {
  const n = NN(t);
  return /* @__PURE__ */ v.createElement(el, { onClick: e }, /* @__PURE__ */ v.createElement(
    tl,
    {
      dangerouslySetInnerHTML: { __html: n.html }
    }
  ));
}, ap = ({
  value: t,
  handleClick: e,
  isContentSearch: n
}) => /* @__PURE__ */ v.createElement(el, { onClick: e }, /* @__PURE__ */ v.createElement(
  tl,
  {
    dangerouslySetInnerHTML: { __html: t },
    "data-content-search": n
  }
));
function vn(t, e) {
  this.message = t, this.error = e;
}
vn.prototype = Object.create(Error.prototype);
const dh = /([0-9]+)?:?([0-9]{2}):([0-9]{2}\.[0-9]{2,3})/;
function FN(t, e) {
  e || (e = {});
  const { meta: n = !1, strict: r = !0 } = e;
  if (typeof t != "string")
    throw new vn("Input must be a string");
  t = t.trim(), t = t.replace(/\r\n/g, `
`), t = t.replace(/\r/g, `
`);
  const i = t.split(`

`), s = i.shift();
  if (!s.startsWith("WEBVTT"))
    throw new vn('Must start with "WEBVTT"');
  const a = s.split(`
`), o = a[0].replace("WEBVTT", "");
  if (o.length > 0 && o[0] !== " " && o[0] !== "	")
    throw new vn("Header comment must start with space or tab");
  if (i.length === 0 && a.length === 1)
    return { valid: !0, strict: r, cues: [], errors: [] };
  if (!n && a.length > 1 && a[1] !== "")
    throw new vn("Missing blank line after signature");
  const { cues: u, errors: l } = $N(i, r);
  if (r && l.length > 0)
    throw l[0];
  const c = n ? BN(a) : null, d = { valid: l.length === 0, strict: r, cues: u, errors: l };
  return n && (d.meta = c), d;
}
function BN(t) {
  const e = {};
  return t.slice(1).forEach((n) => {
    const r = n.indexOf(":"), i = n.slice(0, r).trim(), s = n.slice(r + 1).trim();
    e[i] = s;
  }), Object.keys(e).length > 0 ? e : null;
}
function $N(t, e) {
  const n = [];
  return {
    cues: t.map((i, s) => {
      try {
        return UN(i, s, e);
      } catch (a) {
        return n.push(a), null;
      }
    }).filter(Boolean),
    errors: n
  };
}
function UN(t, e, n) {
  let r = "", i = 0, s = 0.01, a = "", o = "";
  const u = t.split(`
`).filter(Boolean);
  if (u.length > 0 && u[0].trim().startsWith("NOTE"))
    return null;
  if (u.length === 1 && !u[0].includes("-->"))
    throw new vn(`Cue identifier cannot be standalone (cue #${e})`);
  if (u.length > 1 && !(u[0].includes("-->") || u[1].includes("-->"))) {
    const c = `Cue identifier needs to be followed by timestamp (cue #${e})`;
    throw new vn(c);
  }
  u.length > 1 && u[1].includes("-->") && (r = u.shift());
  const l = typeof u[0] == "string" && u[0].split(" --> ");
  if (l.length !== 2 || !op(l[0]) || !op(l[1]))
    throw new vn(`Invalid cue timestamp (cue #${e})`);
  if (i = up(l[0]), s = up(l[1]), n) {
    if (i > s)
      throw new vn(`Start timestamp greater than end (cue #${e})`);
    if (s <= i)
      throw new vn(`End must be greater than start (cue #${e})`);
  }
  if (!n && s < i)
    throw new vn(
      `End must be greater or equal to start when not strict (cue #${e})`
    );
  return o = l[1].replace(dh, "").trim(), u.shift(), a = u.join(`
`), a ? { identifier: r, start: i, end: s, text: a, styles: o } : !1;
}
function op(t) {
  return dh.test(t);
}
function up(t) {
  const e = t.match(dh);
  let n = parseFloat(e[1] || 0) * 60 * 60;
  return n += parseFloat(e[2]) * 60, n += parseFloat(e[3]), n;
}
var vT = { parse: FN };
function Mt(t, e) {
  this.message = t, this.error = e;
}
Mt.prototype = Object.create(Error.prototype);
function HN(t) {
  if (!t)
    throw new Mt("Input must be non-null");
  if (typeof t != "object")
    throw new Mt("Input must be an object");
  if (Array.isArray(t))
    throw new Mt("Input cannot be array");
  if (!t.valid)
    throw new Mt("Input must be valid");
  let e = `WEBVTT
`;
  if (t.meta) {
    if (typeof t.meta != "object" || Array.isArray(t.meta))
      throw new Mt("Metadata must be an object");
    Object.entries(t.meta).forEach((r) => {
      if (typeof r[1] != "string")
        throw new Mt(`Metadata value for "${r[0]}" must be string`);
      e += `${r[0]}: ${r[1]}
`;
    });
  }
  let n = null;
  return t.cues.forEach((r, i) => {
    if (n && n > r.start)
      throw new Mt(`Cue number ${i} is not in chronological order`);
    n = r.start, e += `
`, e += VN(r), e += `
`;
  }), e;
}
function VN(t) {
  if (typeof t != "object")
    throw new Mt("Cue malformed: not of type object");
  if (typeof t.identifier != "string" && typeof t.identifier != "number" && t.identifier !== null)
    throw new Mt(`Cue malformed: identifier value is not a string.
    ${JSON.stringify(t)}`);
  if (isNaN(t.start))
    throw new Mt(`Cue malformed: null start value.
    ${JSON.stringify(t)}`);
  if (isNaN(t.end))
    throw new Mt(`Cue malformed: null end value.
    ${JSON.stringify(t)}`);
  if (t.start >= t.end)
    throw new Mt(`Cue malformed: start timestamp greater than end
    ${JSON.stringify(t)}`);
  if (typeof t.text != "string")
    throw new Mt(`Cue malformed: null text value.
    ${JSON.stringify(t)}`);
  if (typeof t.styles != "string")
    throw new Mt(`Cue malformed: null styles value.
    ${JSON.stringify(t)}`);
  let e = "";
  t.identifier.length > 0 && (e += `${t.identifier}
`);
  const n = lp(t.start), r = lp(t.end);
  return e += `${n} --> ${r}`, e += t.styles ? ` ${t.styles}` : "", e += `
${t.text}`, e;
}
function lp(t) {
  const e = uo(GN(t), 2), n = uo(zN(t), 2), r = uo(qN(t), 2), i = uo(WN(t), 3);
  return `${e}:${n}:${r}.${i}`;
}
function uo(t, e) {
  let n = `${t}`;
  for (; n.length < e; )
    n = `0${n}`;
  return n;
}
function GN(t) {
  return Math.floor(t / 60 / 60);
}
function zN(t) {
  return Math.floor(t / 60) % 60;
}
function qN(t) {
  return Math.floor(t % 60);
}
function WN(t) {
  return Math.floor((t % 1).toFixed(4) * 1e3);
}
var KN = { compile: HN };
const jN = vT.parse;
function YN(t, e) {
  e = e || 10;
  const n = jN(t), r = [];
  let i = [], s = null, a = 0, o = 0;
  return n.cues.forEach((u, l) => {
    const c = l === 0, d = l === n.cues.length - 1, f = u.start, h = u.end, m = d ? 1 / 0 : n.cues[l + 1].start, p = c ? h : h - f, g = c ? 0 : f - n.cues[l - 1].end;
    a = a + p + g, `${l}`, r.length + 1, s && (i.push(s), a += s.end - o, s = null), i.push(u);
    let b = m - h < e && g < e && a > e;
    if (XN(
      o,
      e,
      m,
      g
    )) {
      const y = QN(
        d,
        h,
        e,
        a,
        o
      );
      r.push({ duration: y, cues: i }), o += y, a = 0, i = [];
    } else
      b = !1;
    b && (s = u);
  }), r;
}
function XN(t, e, n, r) {
  const i = AT(r, e);
  return (r <= e || i + t < n) && n - t >= e;
}
function QN(t, e, n, r, i) {
  let s = n;
  return r > n && (s = AT(r - n, n)), t ? s = parseFloat((e - i).toFixed(2)) : s = Math.round(s), s;
}
function AT(t, e) {
  return t += e - t % e, t;
}
var IT = { segment: YN };
const CT = IT.segment;
function ZN(t, e, n) {
  typeof n > "u" && (n = "900000");
  const r = CT(t, e), i = [];
  return r.forEach((s, a) => {
    const o = `WEBVTT
X-TIMESTAMP-MAP=MPEGTS:${n},LOCAL:00:00:00.000

${n8(s.cues)}
`, u = LT(a);
    i.push({ filename: u, content: o });
  }), i;
}
function JN(t, e) {
  const n = CT(t, e), r = e8(n);
  return `#EXTM3U
#EXT-X-TARGETDURATION:${Math.round(t8(n))}
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
${r}
#EXT-X-ENDLIST
`;
}
function lo(t, e) {
  return `${"0".repeat(Math.max(0, e - t.toString().length))}${t}`;
}
function LT(t) {
  return `${t}.vtt`;
}
function e8(t) {
  const e = [];
  return t.forEach((n, r) => {
    e.push(`#EXTINF:${n.duration.toFixed(5)},
${LT(r)}`);
  }), e.join(`
`);
}
function t8(t) {
  let e = 0;
  return t.forEach((n) => {
    n.duration > e && (e = n.duration);
  }), e;
}
function n8(t) {
  const e = [];
  return t.forEach((n) => {
    e.push(r8(n));
  }), e.join(`

`);
}
function r8(t) {
  const e = [];
  t.identifier && e.push(t.identifier);
  const n = cp(t.start), r = cp(t.end), i = t.styles ? `${t.styles}` : "";
  return e.push(`${n} --> ${r} ${i}`), e.push(t.text), e.join(`
`);
}
function cp(t) {
  const e = (t % 1).toFixed(3);
  t = Math.round(t - e);
  const n = Math.floor(t / 3600), r = Math.floor((t - n * 3600) / 60), i = t - n * 3600 - r * 60;
  return `${`${lo(n, 2)}:`}${lo(r, 2)}:${lo(i, 2)}.${lo(e * 1e3, 3)}`;
}
var i8 = { hlsSegment: ZN, hlsSegmentPlaylist: JN };
const s8 = vT.parse, a8 = KN.compile, o8 = IT.segment, u8 = i8;
var l8 = { parse: s8, compile: a8, segment: o8, hls: u8 };
const c8 = () => {
  function t(u) {
    return u.map((l) => {
      const c = l.identifier || ts();
      return { ...l, identifier: c };
    });
  }
  function e(u) {
    var f;
    const l = [], c = [], d = t(u);
    for (const h of d) {
      for (; c.length > 0 && c[c.length - 1].end <= h.start; )
        c.pop();
      c.length > 0 ? (c[c.length - 1].children || (c[c.length - 1].children = []), (f = c[c.length - 1].children) == null || f.push(h), c.push(h)) : (l.push(h), c.push(h));
    }
    return l;
  }
  function n(u, l = []) {
    return l.some(
      (c) => u.start >= c.start && u.end <= c.end
    );
  }
  function r(u = []) {
    return u.sort((l, c) => l.start - c.start);
  }
  function i(u) {
    const l = u.replace(
      /<(c|v|i|b|u|lang|ruby)(?:\.([^\s>]+))?(?:\s([^>]+))?>/g,
      (c, d, f, h) => {
        const m = document.createElement(d);
        return f && (m.className = f.replace(/\./g, " ")), (h == null ? void 0 : h.length) > 0 && (m.title = h), m.outerHTML.replace(new RegExp(`</${d}>$`), "");
      }
    );
    return console.log("normalizeVttTags", l), l;
  }
  function s(u) {
    var l;
    for (const c of u.children)
      s(c);
    if (u.localName === "c" || u.localName === "v") {
      const c = document.createElement("span");
      for (const d of u.attributes)
        c.setAttribute(d.name, d.value);
      c.innerHTML = u.innerHTML, (l = u.parentNode) == null || l.replaceChild(c, u);
    }
  }
  function a(u) {
    const l = i(u), c = document.createElement("div");
    return c.innerHTML = l, s(c), c.innerHTML;
  }
  function o(u) {
    return new Promise((l, c) => {
      const d = l8.parse(u);
      d.errors && d.errors.length && c(d.errors), l(
        d.cues.map((f) => ({
          identifier: f.identifier || ts(),
          start: f.start,
          end: f.end,
          align: f.align,
          html: a(f.text),
          text: f.text || ""
        }))
      );
    });
  }
  return {
    addIdentifiersToParsedCues: t,
    createNestedCues: e,
    isChild: n,
    orderCuesByTime: r,
    parseVttData: o
  };
};
function fh(t) {
  const [e, n] = M.useState(void 0);
  return wt(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let a, o;
        if ("borderBoxSize" in s) {
          const u = s.borderBoxSize, l = Array.isArray(u) ? u[0] : u;
          a = l.inlineSize, o = l.blockSize;
        } else
          a = t.offsetWidth, o = t.offsetHeight;
        n({ width: a, height: o });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
function hh(t) {
  const e = M.useRef({ value: t, previous: t });
  return M.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t]);
}
var mh = "Radio", [d8, _T] = jn(mh), [f8, h8] = d8(mh), RT = M.forwardRef(
  (t, e) => {
    const {
      __scopeRadio: n,
      name: r,
      checked: i = !1,
      required: s,
      disabled: a,
      value: o = "on",
      onCheck: u,
      form: l,
      ...c
    } = t, [d, f] = M.useState(null), h = Je(e, (g) => f(g)), m = M.useRef(!1), p = d ? l || !!d.closest("form") : !0;
    return /* @__PURE__ */ es(f8, { scope: n, checked: i, disabled: a, children: [
      /* @__PURE__ */ ee(
        $e.button,
        {
          type: "button",
          role: "radio",
          "aria-checked": i,
          "data-state": PT(i),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: o,
          ...c,
          ref: h,
          onClick: Oe(t.onClick, (g) => {
            i || u == null || u(), p && (m.current = g.isPropagationStopped(), m.current || g.stopPropagation());
          })
        }
      ),
      p && /* @__PURE__ */ ee(
        DT,
        {
          control: d,
          bubbles: !m.current,
          name: r,
          value: o,
          checked: i,
          required: s,
          disabled: a,
          form: l,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
RT.displayName = mh;
var wT = "RadioIndicator", kT = M.forwardRef(
  (t, e) => {
    const { __scopeRadio: n, forceMount: r, ...i } = t, s = h8(wT, n);
    return /* @__PURE__ */ ee(Da, { present: r || s.checked, children: /* @__PURE__ */ ee(
      $e.span,
      {
        "data-state": PT(s.checked),
        "data-disabled": s.disabled ? "" : void 0,
        ...i,
        ref: e
      }
    ) });
  }
);
kT.displayName = wT;
var m8 = "RadioBubbleInput", DT = M.forwardRef(
  ({
    __scopeRadio: t,
    control: e,
    checked: n,
    bubbles: r = !0,
    ...i
  }, s) => {
    const a = M.useRef(null), o = Je(a, s), u = hh(n), l = fh(e);
    return M.useEffect(() => {
      const c = a.current;
      if (!c) return;
      const d = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        d,
        "checked"
      ).set;
      if (u !== n && h) {
        const m = new Event("click", { bubbles: r });
        h.call(c, n), c.dispatchEvent(m);
      }
    }, [u, n, r]), /* @__PURE__ */ ee(
      $e.input,
      {
        type: "radio",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: o,
        style: {
          ...i.style,
          ...l,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
DT.displayName = m8;
function PT(t) {
  return t ? "checked" : "unchecked";
}
var p8 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], ml = "RadioGroup", [g8] = jn(ml, [
  Zu,
  _T
]), OT = Zu(), NT = _T(), [b8, E8] = g8(ml), MT = M.forwardRef(
  (t, e) => {
    const {
      __scopeRadioGroup: n,
      name: r,
      defaultValue: i,
      value: s,
      required: a = !1,
      disabled: o = !1,
      orientation: u,
      dir: l,
      loop: c = !0,
      onValueChange: d,
      ...f
    } = t, h = OT(n), m = Qu(l), [p, g] = kr({
      prop: s,
      defaultProp: i ?? null,
      onChange: d,
      caller: ml
    });
    return /* @__PURE__ */ ee(
      b8,
      {
        scope: n,
        name: r,
        required: a,
        disabled: o,
        value: p,
        onValueChange: g,
        children: /* @__PURE__ */ ee(
          Tb,
          {
            asChild: !0,
            ...h,
            orientation: u,
            dir: m,
            loop: c,
            children: /* @__PURE__ */ ee(
              $e.div,
              {
                role: "radiogroup",
                "aria-required": a,
                "aria-orientation": u,
                "data-disabled": o ? "" : void 0,
                dir: m,
                ...f,
                ref: e
              }
            )
          }
        )
      }
    );
  }
);
MT.displayName = ml;
var FT = "RadioGroupItem", BT = M.forwardRef(
  (t, e) => {
    const { __scopeRadioGroup: n, disabled: r, ...i } = t, s = E8(FT, n), a = s.disabled || r, o = OT(n), u = NT(n), l = M.useRef(null), c = Je(e, l), d = s.value === i.value, f = M.useRef(!1);
    return M.useEffect(() => {
      const h = (p) => {
        p8.includes(p.key) && (f.current = !0);
      }, m = () => f.current = !1;
      return document.addEventListener("keydown", h), document.addEventListener("keyup", m), () => {
        document.removeEventListener("keydown", h), document.removeEventListener("keyup", m);
      };
    }, []), /* @__PURE__ */ ee(
      Sb,
      {
        asChild: !0,
        ...o,
        focusable: !a,
        active: d,
        children: /* @__PURE__ */ ee(
          RT,
          {
            disabled: a,
            required: s.required,
            checked: d,
            ...u,
            ...i,
            name: s.name,
            ref: c,
            onCheck: () => s.onValueChange(i.value),
            onKeyDown: Oe((h) => {
              h.key === "Enter" && h.preventDefault();
            }),
            onFocus: Oe(i.onFocus, () => {
              var h;
              f.current && ((h = l.current) == null || h.click());
            })
          }
        )
      }
    );
  }
);
BT.displayName = FT;
var y8 = "RadioGroupIndicator", T8 = M.forwardRef(
  (t, e) => {
    const { __scopeRadioGroup: n, ...r } = t, i = NT(n);
    return /* @__PURE__ */ ee(kT, { ...i, ...r, ref: e });
  }
);
T8.displayName = y8;
var $T = MT, UT = BT;
const S8 = le($T, {
  display: "flex",
  flexDirection: "column",
  width: "100%"
}), HT = le(UT, {
  ...Db,
  justifyContent: "space-between",
  textAlign: "left",
  flexGrow: 1,
  margin: 0,
  marginLeft: "-1rem",
  padding: "0.618rem 1rem",
  width: "calc(100% + 2rem)",
  fontSize: "1rem",
  strong: {
    marginLeft: "1rem"
  },
  "&:hover": {
    color: "$accent"
  },
  "&[aria-checked='true']": {
    background: "#6662"
  }
}), x8 = 750, v8 = (t) => {
  for (; t && t !== document.body; ) {
    const e = window.getComputedStyle(t).overflowY;
    if (e !== "visible" && e !== "hidden" && t.scrollHeight > t.clientHeight)
      return t;
    t = t.parentNode;
  }
  return null;
}, A8 = ({ html: t, text: e, start: n, end: r }) => {
  var p, g;
  const i = jt(), {
    activePlayer: s,
    configOptions: a,
    isAutoScrollEnabled: o,
    isUserScrolling: u
  } = st(), l = (g = (p = a == null ? void 0 : a.informationPanel) == null ? void 0 : p.vtt) == null ? void 0 : g.autoScroll, [c, d] = Be(!1), f = ms(null), h = s;
  Se(() => (h == null || h.addEventListener("timeupdate", () => {
    const { currentTime: b } = h;
    d(n <= b && b < r);
  }), () => document.removeEventListener("timeupdate", () => {
  })), [r, n, h]), Se(() => {
    var y;
    const b = (T) => {
      i({ type: "updateAutoScrolling", isAutoScrolling: !0 }), T(), setTimeout(
        () => i({ type: "updateAutoScrolling", isAutoScrolling: !1 }),
        x8
      );
    };
    if (o && c && f.current && !u) {
      const T = f.current;
      if (T && T instanceof HTMLElement) {
        const S = v8(T);
        if (S && S instanceof HTMLElement) {
          let I;
          switch ((y = l == null ? void 0 : l.settings) == null ? void 0 : y.block) {
            case "center":
              const C = S.getBoundingClientRect();
              I = T.offsetTop + T.offsetHeight - Math.floor((C.bottom - C.top) / 2);
              break;
            case "end":
              I = T.offsetTop + T.offsetHeight - (S.clientHeight - T.clientHeight) + 2;
              break;
            default:
              I = T.offsetTop - 2;
              break;
          }
          b(
            () => {
              var C;
              return S.scrollTo({
                top: I,
                left: 0,
                behavior: (C = l == null ? void 0 : l.settings) == null ? void 0 : C.behavior
              });
            }
          );
        }
      }
    }
  }, [
    l,
    c,
    u,
    o,
    i
  ]);
  const m = () => {
    h && (h.pause(), h.currentTime = n, h.play());
  };
  return /* @__PURE__ */ v.createElement(
    HT,
    {
      ref: f,
      "aria-checked": c,
      "data-testid": "information-panel-cue",
      onClick: m,
      value: e
    },
    /* @__PURE__ */ v.createElement(
      "div",
      {
        className: "webvtt-cue",
        dangerouslySetInnerHTML: { __html: t }
      }
    ),
    /* @__PURE__ */ v.createElement("strong", null, j1(n))
  );
}, I8 = le("ul", {
  listStyle: "none",
  paddingLeft: "1rem",
  position: "relative",
  "&&:first-child": {
    paddingLeft: "0"
  },
  "& li ul": {
    [`& ${HT}`]: {
      backgroundColor: "unset",
      "&::before": {
        content: "none"
      },
      "&::after": {
        content: "none"
      }
    }
  },
  "&:first-child": {
    margin: "0 0 1.618rem"
  }
}), VT = ({ items: t }) => /* @__PURE__ */ v.createElement(I8, null, t.map((e) => {
  const { html: n, text: r, start: i, end: s, children: a, identifier: o } = e;
  return /* @__PURE__ */ v.createElement("li", { key: o }, /* @__PURE__ */ v.createElement(A8, { html: n, text: r, start: i, end: s }), a && /* @__PURE__ */ v.createElement(VT, { items: a }));
})), C8 = ({
  inlineCues: t,
  label: e,
  vttUri: n
}) => {
  const [r, i] = v.useState(
    t || []
  ), { createNestedCues: s, orderCuesByTime: a, parseVttData: o } = c8(), [u, l] = v.useState();
  return Se(
    () => {
      !t && n && fetch(n, {
        redirect: "follow",
        headers: {
          Accept: "text/vtt, text/plain, */*"
        }
      }).then((c) => {
        if (!c.ok)
          throw new Error(`HTTP error! status: ${c.status}`);
        return c.text();
      }).then((c) => {
        o(c).then((d) => {
          const f = a(d), h = s(f);
          i(h);
        });
      }).catch((c) => {
        console.error(n, c.toString()), l(c);
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n, t]
  ), /* @__PURE__ */ v.createElement(
    S8,
    {
      "data-testid": "annotation-item-vtt",
      "aria-label": `${kf(e)}`
    },
    u && /* @__PURE__ */ v.createElement("div", { "data-testid": "error-message" }, "Network Error: ", u.toString()),
    /* @__PURE__ */ v.createElement(VT, { items: r })
  );
}, L8 = (t) => {
  var r;
  if (!t) return "LTR";
  const e = [
    "ar",
    "fa",
    "ur",
    "ps",
    "dv",
    "sd",
    "ug",
    "ku",
    "he",
    "yi",
    "jrb",
    "jpr",
    "nqo"
  ], n = Array.isArray(t) ? (r = t[0]) == null ? void 0 : r.split("-")[0] : t == null ? void 0 : t.split("-")[0];
  return e.includes(n) ? "RTL" : "LTR";
}, _8 = (t) => {
  var n, r, i, s, a;
  let e = {
    id: typeof t == "string" ? t : t.source
  };
  if (typeof t == "string") {
    if (t.includes("#xywh=")) {
      const o = t.split("#xywh=");
      if (o && o[1]) {
        const [u, l, c, d] = o[1].split(",").map((f) => Number(f));
        e = {
          id: o[0],
          rect: {
            x: u,
            y: l,
            w: c,
            h: d
          }
        };
      }
    } else if (t.includes("#t=")) {
      const o = t.split("#t=");
      o && o[1] && (e = {
        id: o[0],
        t: o[1]
      });
    }
  } else if (typeof t == "object") {
    if (((n = t.selector) == null ? void 0 : n.type) === "PointSelector")
      e = {
        id: t.source,
        point: {
          x: t.selector.x,
          y: t.selector.y
        }
      };
    else if (((r = t.selector) == null ? void 0 : r.type) === "SvgSelector")
      e = {
        id: t.source,
        svg: t.selector.value
      };
    else if (((i = t.selector) == null ? void 0 : i.type) === "FragmentSelector" && (s = t.selector) != null && s.value.includes("xywh=") && t.source.type == "Canvas" && t.source.id) {
      const o = (a = t.selector) == null ? void 0 : a.value.split("xywh=");
      if (o && o[1]) {
        const [u, l, c, d] = o[1].split(",").map((f) => Number(f));
        e = {
          id: t.source.id,
          rect: {
            x: u,
            y: l,
            w: c,
            h: d
          }
        };
      }
    }
  }
  return e;
};
function R8(t) {
  return t ? Array.isArray(t) ? t : [t] : [];
}
function w8(t, e) {
  if (!t) return !1;
  if (!e) return !0;
  if (e.length === 0) return !1;
  const n = R8(t.motivation);
  return n.length === 0 ? !1 : n.some(
    (r) => e.includes(r)
  );
}
const ph = ({
  annotation: t,
  targetResource: e,
  isContentSearch: n,
  isContentState: r
}) => {
  var $, G, N, U, B, V, K;
  const { target: i } = t, s = ($ = i == null ? void 0 : i.selector) == null ? void 0 : $.type, a = ((N = (G = i == null ? void 0 : i.selector) == null ? void 0 : G.value) == null ? void 0 : N.split("=")[1]) || "full", [o, u] = a !== "full" ? a == null ? void 0 : a.split(",").slice(2) : [100, 100], c = `${e}/${a}/!${((w, Y) => {
    const D = Math.max(w, Y), te = Math.round(w / D * 100), he = Math.round(Y / D * 100);
    return [te, he].join(",");
  })(o, u)}/0/default.jpg`, d = st(), f = jt(), { openSeadragonViewer: h, vault: m, visibleCanvases: p } = d, g = t != null && t.body ? (U = t == null ? void 0 : t.body) == null ? void 0 : U.map((w) => m.get(w.id)) : [], {
    format: b = s === "PointSelector" ? "text/vtt" : "text/plain",
    language: y = "none",
    value: T = "",
    // @ts-ignore
    chars: S = ""
  } = g[0] ? g[0] : {}, I = s === "PointSelector" ? "text/vtt" : b, C = ((B = g[0]) == null ? void 0 : B.label) || { none: ["t"] }, _ = T || S || "None", R = y ? L8(y).toLocaleLowerCase() : "LTR", k = (
    // @ts-ignore
    s === "PointSelector" && ((V = i == null ? void 0 : i.selector) != null && V.t) ? [
      {
        // @ts-ignore
        start: (K = i == null ? void 0 : i.selector) == null ? void 0 : K.t,
        end: 0,
        html: _,
        text: _,
        styles: "",
        children: []
      }
    ] : void 0
  );
  function A() {
    var Y;
    const w = h == null ? void 0 : h.getOverlayById(t.id);
    if (w && (h != null && h.viewport)) {
      w != null && w.element && ((Y = w.element) == null || Y.focus());
      const J = w == null ? void 0 : w.getBounds(h.viewport);
      J.x -= 0.2, J.y -= 0.2, J.width += 0.5, J.height += 0.5, h.viewport.fitBounds(J, !1);
    }
  }
  Se(() => {
    if (!h || !r) return;
    const w = setInterval(() => {
      (h == null ? void 0 : h.getOverlayById(t.id)) && (A(), h.container.className = "clover-iiif-content-state", clearInterval(w));
    }, 1e3);
    return () => clearInterval(w);
  }, [h, r]);
  function L(w) {
    var te;
    w.preventDefault(), w.stopPropagation();
    const Y = ((te = t == null ? void 0 : t.target) == null ? void 0 : te.source) || (t == null ? void 0 : t.target), J = Y == null ? void 0 : Y.id;
    p.map((he) => he.id).includes(J) ? A() : f({
      type: "updateActiveCanvas",
      canvasId: J
    });
  }
  function P() {
    var w, Y, J;
    switch (I) {
      case "text/plain":
        return /* @__PURE__ */ v.createElement(
          ap,
          {
            value: _,
            handleClick: L,
            isContentSearch: n
          }
        );
      case "text/html":
        return /* @__PURE__ */ v.createElement(kC, { value: _, handleClick: L });
      case "text/markdown":
        return /* @__PURE__ */ v.createElement(MN, { value: _, handleClick: L });
      case "text/vtt":
        return /* @__PURE__ */ v.createElement(
          C8,
          {
            inlineCues: k,
            label: C,
            vttUri: ((w = g[0]) == null ? void 0 : w.id) || void 0
          }
        );
      case ((Y = b == null ? void 0 : b.match(/^image\//)) == null ? void 0 : Y.input):
        const D = ((J = g.find((te) => {
          var he;
          return !((he = te.id) != null && he.includes("vault://"));
        })) == null ? void 0 : J.id) || "";
        return /* @__PURE__ */ v.createElement(
          DC,
          {
            caption: T,
            handleClick: L,
            imageUri: D
          }
        );
      default:
        return /* @__PURE__ */ v.createElement(ap, { value: _, handleClick: L });
    }
  }
  if (b)
    return /* @__PURE__ */ v.createElement(
      wC,
      {
        dir: R,
        "data-format": b,
        "data-content": _,
        className: "clover-iiif-annotation-item"
      },
      /* @__PURE__ */ v.createElement(
        "span",
        {
          style: {
            backgroundImage: `url(${c})`,
            backgroundSize: "cover",
            backgroundPosition: "center"
          }
        }
      ),
      P()
    );
}, GT = (t, e = "none") => {
  if (!t) return null;
  if (typeof t == "string") return [t];
  if (!t[e]) {
    const n = Object.getOwnPropertyNames(t);
    if (n.length > 0) return t[n[0]];
  }
  return !t[e] || !Array.isArray(t[e]) ? null : t[e];
}, fn = (t, e = "none", n = ", ") => {
  const r = GT(t, e);
  return Array.isArray(r) ? r.join(`${n}`) : r;
};
var zT = {}, pa = {}, gh = {}, ga = {}, bh = {};
Object.defineProperty(bh, "__esModule", { value: !0 });
bh.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(t) {
    return t.charCodeAt(0);
  })
);
var Eh = {};
Object.defineProperty(Eh, "__esModule", { value: !0 });
Eh.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(t) {
    return t.charCodeAt(0);
  })
);
var Ld = {};
(function(t) {
  var e;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceCodePoint = t.fromCodePoint = void 0;
  var n = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  t.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(s) {
    var a = "";
    return s > 65535 && (s -= 65536, a += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), a += String.fromCharCode(s), a;
  };
  function r(s) {
    var a;
    return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (a = n.get(s)) !== null && a !== void 0 ? a : s;
  }
  t.replaceCodePoint = r;
  function i(s) {
    return (0, t.fromCodePoint)(r(s));
  }
  t.default = i;
})(Ld);
(function(t) {
  var e = Ae && Ae.__createBinding || (Object.create ? function(L, P, $, G) {
    G === void 0 && (G = $);
    var N = Object.getOwnPropertyDescriptor(P, $);
    (!N || ("get" in N ? !P.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return P[$];
    } }), Object.defineProperty(L, G, N);
  } : function(L, P, $, G) {
    G === void 0 && (G = $), L[G] = P[$];
  }), n = Ae && Ae.__setModuleDefault || (Object.create ? function(L, P) {
    Object.defineProperty(L, "default", { enumerable: !0, value: P });
  } : function(L, P) {
    L.default = P;
  }), r = Ae && Ae.__importStar || function(L) {
    if (L && L.__esModule) return L;
    var P = {};
    if (L != null) for (var $ in L) $ !== "default" && Object.prototype.hasOwnProperty.call(L, $) && e(P, L, $);
    return n(P, L), P;
  }, i = Ae && Ae.__importDefault || function(L) {
    return L && L.__esModule ? L : { default: L };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXML = t.decodeHTMLStrict = t.decodeHTMLAttribute = t.decodeHTML = t.determineBranch = t.EntityDecoder = t.DecodingMode = t.BinTrieFlags = t.fromCodePoint = t.replaceCodePoint = t.decodeCodePoint = t.xmlDecodeTree = t.htmlDecodeTree = void 0;
  var s = i(bh);
  t.htmlDecodeTree = s.default;
  var a = i(Eh);
  t.xmlDecodeTree = a.default;
  var o = r(Ld);
  t.decodeCodePoint = o.default;
  var u = Ld;
  Object.defineProperty(t, "replaceCodePoint", { enumerable: !0, get: function() {
    return u.replaceCodePoint;
  } }), Object.defineProperty(t, "fromCodePoint", { enumerable: !0, get: function() {
    return u.fromCodePoint;
  } });
  var l;
  (function(L) {
    L[L.NUM = 35] = "NUM", L[L.SEMI = 59] = "SEMI", L[L.EQUALS = 61] = "EQUALS", L[L.ZERO = 48] = "ZERO", L[L.NINE = 57] = "NINE", L[L.LOWER_A = 97] = "LOWER_A", L[L.LOWER_F = 102] = "LOWER_F", L[L.LOWER_X = 120] = "LOWER_X", L[L.LOWER_Z = 122] = "LOWER_Z", L[L.UPPER_A = 65] = "UPPER_A", L[L.UPPER_F = 70] = "UPPER_F", L[L.UPPER_Z = 90] = "UPPER_Z";
  })(l || (l = {}));
  var c = 32, d;
  (function(L) {
    L[L.VALUE_LENGTH = 49152] = "VALUE_LENGTH", L[L.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", L[L.JUMP_TABLE = 127] = "JUMP_TABLE";
  })(d = t.BinTrieFlags || (t.BinTrieFlags = {}));
  function f(L) {
    return L >= l.ZERO && L <= l.NINE;
  }
  function h(L) {
    return L >= l.UPPER_A && L <= l.UPPER_F || L >= l.LOWER_A && L <= l.LOWER_F;
  }
  function m(L) {
    return L >= l.UPPER_A && L <= l.UPPER_Z || L >= l.LOWER_A && L <= l.LOWER_Z || f(L);
  }
  function p(L) {
    return L === l.EQUALS || m(L);
  }
  var g;
  (function(L) {
    L[L.EntityStart = 0] = "EntityStart", L[L.NumericStart = 1] = "NumericStart", L[L.NumericDecimal = 2] = "NumericDecimal", L[L.NumericHex = 3] = "NumericHex", L[L.NamedEntity = 4] = "NamedEntity";
  })(g || (g = {}));
  var b;
  (function(L) {
    L[L.Legacy = 0] = "Legacy", L[L.Strict = 1] = "Strict", L[L.Attribute = 2] = "Attribute";
  })(b = t.DecodingMode || (t.DecodingMode = {}));
  var y = (
    /** @class */
    function() {
      function L(P, $, G) {
        this.decodeTree = P, this.emitCodePoint = $, this.errors = G, this.state = g.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = b.Strict;
      }
      return L.prototype.startEntity = function(P) {
        this.decodeMode = P, this.state = g.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }, L.prototype.write = function(P, $) {
        switch (this.state) {
          case g.EntityStart:
            return P.charCodeAt($) === l.NUM ? (this.state = g.NumericStart, this.consumed += 1, this.stateNumericStart(P, $ + 1)) : (this.state = g.NamedEntity, this.stateNamedEntity(P, $));
          case g.NumericStart:
            return this.stateNumericStart(P, $);
          case g.NumericDecimal:
            return this.stateNumericDecimal(P, $);
          case g.NumericHex:
            return this.stateNumericHex(P, $);
          case g.NamedEntity:
            return this.stateNamedEntity(P, $);
        }
      }, L.prototype.stateNumericStart = function(P, $) {
        return $ >= P.length ? -1 : (P.charCodeAt($) | c) === l.LOWER_X ? (this.state = g.NumericHex, this.consumed += 1, this.stateNumericHex(P, $ + 1)) : (this.state = g.NumericDecimal, this.stateNumericDecimal(P, $));
      }, L.prototype.addToNumericResult = function(P, $, G, N) {
        if ($ !== G) {
          var U = G - $;
          this.result = this.result * Math.pow(N, U) + parseInt(P.substr($, U), N), this.consumed += U;
        }
      }, L.prototype.stateNumericHex = function(P, $) {
        for (var G = $; $ < P.length; ) {
          var N = P.charCodeAt($);
          if (f(N) || h(N))
            $ += 1;
          else
            return this.addToNumericResult(P, G, $, 16), this.emitNumericEntity(N, 3);
        }
        return this.addToNumericResult(P, G, $, 16), -1;
      }, L.prototype.stateNumericDecimal = function(P, $) {
        for (var G = $; $ < P.length; ) {
          var N = P.charCodeAt($);
          if (f(N))
            $ += 1;
          else
            return this.addToNumericResult(P, G, $, 10), this.emitNumericEntity(N, 2);
        }
        return this.addToNumericResult(P, G, $, 10), -1;
      }, L.prototype.emitNumericEntity = function(P, $) {
        var G;
        if (this.consumed <= $)
          return (G = this.errors) === null || G === void 0 || G.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (P === l.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === b.Strict)
          return 0;
        return this.emitCodePoint((0, o.replaceCodePoint)(this.result), this.consumed), this.errors && (P !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }, L.prototype.stateNamedEntity = function(P, $) {
        for (var G = this.decodeTree, N = G[this.treeIndex], U = (N & d.VALUE_LENGTH) >> 14; $ < P.length; $++, this.excess++) {
          var B = P.charCodeAt($);
          if (this.treeIndex = S(G, N, this.treeIndex + Math.max(1, U), B), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === b.Attribute && // We shouldn't have consumed any characters after the entity,
            (U === 0 || // And there should be no invalid characters.
            p(B)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (N = G[this.treeIndex], U = (N & d.VALUE_LENGTH) >> 14, U !== 0) {
            if (B === l.SEMI)
              return this.emitNamedEntityData(this.treeIndex, U, this.consumed + this.excess);
            this.decodeMode !== b.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }, L.prototype.emitNotTerminatedNamedEntity = function() {
        var P, $ = this, G = $.result, N = $.decodeTree, U = (N[G] & d.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(G, U, this.consumed), (P = this.errors) === null || P === void 0 || P.missingSemicolonAfterCharacterReference(), this.consumed;
      }, L.prototype.emitNamedEntityData = function(P, $, G) {
        var N = this.decodeTree;
        return this.emitCodePoint($ === 1 ? N[P] & ~d.VALUE_LENGTH : N[P + 1], G), $ === 3 && this.emitCodePoint(N[P + 2], G), G;
      }, L.prototype.end = function() {
        var P;
        switch (this.state) {
          case g.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== b.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          case g.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case g.NumericHex:
            return this.emitNumericEntity(0, 3);
          case g.NumericStart:
            return (P = this.errors) === null || P === void 0 || P.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case g.EntityStart:
            return 0;
        }
      }, L;
    }()
  );
  t.EntityDecoder = y;
  function T(L) {
    var P = "", $ = new y(L, function(G) {
      return P += (0, o.fromCodePoint)(G);
    });
    return function(N, U) {
      for (var B = 0, V = 0; (V = N.indexOf("&", V)) >= 0; ) {
        P += N.slice(B, V), $.startEntity(U);
        var K = $.write(
          N,
          // Skip the "&"
          V + 1
        );
        if (K < 0) {
          B = V + $.end();
          break;
        }
        B = V + K, V = K === 0 ? B + 1 : B;
      }
      var w = P + N.slice(B);
      return P = "", w;
    };
  }
  function S(L, P, $, G) {
    var N = (P & d.BRANCH_LENGTH) >> 7, U = P & d.JUMP_TABLE;
    if (N === 0)
      return U !== 0 && G === U ? $ : -1;
    if (U) {
      var B = G - U;
      return B < 0 || B >= N ? -1 : L[$ + B] - 1;
    }
    for (var V = $, K = V + N - 1; V <= K; ) {
      var w = V + K >>> 1, Y = L[w];
      if (Y < G)
        V = w + 1;
      else if (Y > G)
        K = w - 1;
      else
        return L[w + N];
    }
    return -1;
  }
  t.determineBranch = S;
  var I = T(s.default), C = T(a.default);
  function _(L, P) {
    return P === void 0 && (P = b.Legacy), I(L, P);
  }
  t.decodeHTML = _;
  function R(L) {
    return I(L, b.Attribute);
  }
  t.decodeHTMLAttribute = R;
  function k(L) {
    return I(L, b.Strict);
  }
  t.decodeHTMLStrict = k;
  function A(L) {
    return C(L, b.Strict);
  }
  t.decodeXML = A;
})(ga);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.QuoteType = void 0;
  var e = ga, n;
  (function(f) {
    f[f.Tab = 9] = "Tab", f[f.NewLine = 10] = "NewLine", f[f.FormFeed = 12] = "FormFeed", f[f.CarriageReturn = 13] = "CarriageReturn", f[f.Space = 32] = "Space", f[f.ExclamationMark = 33] = "ExclamationMark", f[f.Number = 35] = "Number", f[f.Amp = 38] = "Amp", f[f.SingleQuote = 39] = "SingleQuote", f[f.DoubleQuote = 34] = "DoubleQuote", f[f.Dash = 45] = "Dash", f[f.Slash = 47] = "Slash", f[f.Zero = 48] = "Zero", f[f.Nine = 57] = "Nine", f[f.Semi = 59] = "Semi", f[f.Lt = 60] = "Lt", f[f.Eq = 61] = "Eq", f[f.Gt = 62] = "Gt", f[f.Questionmark = 63] = "Questionmark", f[f.UpperA = 65] = "UpperA", f[f.LowerA = 97] = "LowerA", f[f.UpperF = 70] = "UpperF", f[f.LowerF = 102] = "LowerF", f[f.UpperZ = 90] = "UpperZ", f[f.LowerZ = 122] = "LowerZ", f[f.LowerX = 120] = "LowerX", f[f.OpeningSquareBracket = 91] = "OpeningSquareBracket";
  })(n || (n = {}));
  var r;
  (function(f) {
    f[f.Text = 1] = "Text", f[f.BeforeTagName = 2] = "BeforeTagName", f[f.InTagName = 3] = "InTagName", f[f.InSelfClosingTag = 4] = "InSelfClosingTag", f[f.BeforeClosingTagName = 5] = "BeforeClosingTagName", f[f.InClosingTagName = 6] = "InClosingTagName", f[f.AfterClosingTagName = 7] = "AfterClosingTagName", f[f.BeforeAttributeName = 8] = "BeforeAttributeName", f[f.InAttributeName = 9] = "InAttributeName", f[f.AfterAttributeName = 10] = "AfterAttributeName", f[f.BeforeAttributeValue = 11] = "BeforeAttributeValue", f[f.InAttributeValueDq = 12] = "InAttributeValueDq", f[f.InAttributeValueSq = 13] = "InAttributeValueSq", f[f.InAttributeValueNq = 14] = "InAttributeValueNq", f[f.BeforeDeclaration = 15] = "BeforeDeclaration", f[f.InDeclaration = 16] = "InDeclaration", f[f.InProcessingInstruction = 17] = "InProcessingInstruction", f[f.BeforeComment = 18] = "BeforeComment", f[f.CDATASequence = 19] = "CDATASequence", f[f.InSpecialComment = 20] = "InSpecialComment", f[f.InCommentLike = 21] = "InCommentLike", f[f.BeforeSpecialS = 22] = "BeforeSpecialS", f[f.SpecialStartSequence = 23] = "SpecialStartSequence", f[f.InSpecialTag = 24] = "InSpecialTag", f[f.BeforeEntity = 25] = "BeforeEntity", f[f.BeforeNumericEntity = 26] = "BeforeNumericEntity", f[f.InNamedEntity = 27] = "InNamedEntity", f[f.InNumericEntity = 28] = "InNumericEntity", f[f.InHexEntity = 29] = "InHexEntity";
  })(r || (r = {}));
  function i(f) {
    return f === n.Space || f === n.NewLine || f === n.Tab || f === n.FormFeed || f === n.CarriageReturn;
  }
  function s(f) {
    return f === n.Slash || f === n.Gt || i(f);
  }
  function a(f) {
    return f >= n.Zero && f <= n.Nine;
  }
  function o(f) {
    return f >= n.LowerA && f <= n.LowerZ || f >= n.UpperA && f <= n.UpperZ;
  }
  function u(f) {
    return f >= n.UpperA && f <= n.UpperF || f >= n.LowerA && f <= n.LowerF;
  }
  var l;
  (function(f) {
    f[f.NoValue = 0] = "NoValue", f[f.Unquoted = 1] = "Unquoted", f[f.Single = 2] = "Single", f[f.Double = 3] = "Double";
  })(l = t.QuoteType || (t.QuoteType = {}));
  var c = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
    // `</title`
  }, d = (
    /** @class */
    function() {
      function f(h, m) {
        var p = h.xmlMode, g = p === void 0 ? !1 : p, b = h.decodeEntities, y = b === void 0 ? !0 : b;
        this.cbs = m, this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = g, this.decodeEntities = y, this.entityTrie = g ? e.xmlDecodeTree : e.htmlDecodeTree;
      }
      return f.prototype.reset = function() {
        this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
      }, f.prototype.write = function(h) {
        this.offset += this.buffer.length, this.buffer = h, this.parse();
      }, f.prototype.end = function() {
        this.running && this.finish();
      }, f.prototype.pause = function() {
        this.running = !1;
      }, f.prototype.resume = function() {
        this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
      }, f.prototype.getIndex = function() {
        return this.index;
      }, f.prototype.getSectionStart = function() {
        return this.sectionStart;
      }, f.prototype.stateText = function(h) {
        h === n.Lt || !this.decodeEntities && this.fastForwardTo(n.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = r.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && h === n.Amp && (this.state = r.BeforeEntity);
      }, f.prototype.stateSpecialStartSequence = function(h) {
        var m = this.sequenceIndex === this.currentSequence.length, p = m ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          s(h)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (h | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!p)
          this.isSpecial = !1;
        else if (!m) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0, this.state = r.InTagName, this.stateInTagName(h);
      }, f.prototype.stateInSpecialTag = function(h) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (h === n.Gt || i(h)) {
            var m = this.index - this.currentSequence.length;
            if (this.sectionStart < m) {
              var p = this.index;
              this.index = m, this.cbs.ontext(this.sectionStart, m), this.index = p;
            }
            this.isSpecial = !1, this.sectionStart = m + 2, this.stateInClosingTagName(h);
            return;
          }
          this.sequenceIndex = 0;
        }
        (h | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === c.TitleEnd ? this.decodeEntities && h === n.Amp && (this.state = r.BeforeEntity) : this.fastForwardTo(n.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(h === n.Lt);
      }, f.prototype.stateCDATASequence = function(h) {
        h === c.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === c.Cdata.length && (this.state = r.InCommentLike, this.currentSequence = c.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = r.InDeclaration, this.stateInDeclaration(h));
      }, f.prototype.fastForwardTo = function(h) {
        for (; ++this.index < this.buffer.length + this.offset; )
          if (this.buffer.charCodeAt(this.index - this.offset) === h)
            return !0;
        return this.index = this.buffer.length + this.offset - 1, !1;
      }, f.prototype.stateInCommentLike = function(h) {
        h === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = r.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : h !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
      }, f.prototype.isTagStartChar = function(h) {
        return this.xmlMode ? !s(h) : o(h);
      }, f.prototype.startSpecial = function(h, m) {
        this.isSpecial = !0, this.currentSequence = h, this.sequenceIndex = m, this.state = r.SpecialStartSequence;
      }, f.prototype.stateBeforeTagName = function(h) {
        if (h === n.ExclamationMark)
          this.state = r.BeforeDeclaration, this.sectionStart = this.index + 1;
        else if (h === n.Questionmark)
          this.state = r.InProcessingInstruction, this.sectionStart = this.index + 1;
        else if (this.isTagStartChar(h)) {
          var m = h | 32;
          this.sectionStart = this.index, !this.xmlMode && m === c.TitleEnd[2] ? this.startSpecial(c.TitleEnd, 3) : this.state = !this.xmlMode && m === c.ScriptEnd[2] ? r.BeforeSpecialS : r.InTagName;
        } else h === n.Slash ? this.state = r.BeforeClosingTagName : (this.state = r.Text, this.stateText(h));
      }, f.prototype.stateInTagName = function(h) {
        s(h) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
      }, f.prototype.stateBeforeClosingTagName = function(h) {
        i(h) || (h === n.Gt ? this.state = r.Text : (this.state = this.isTagStartChar(h) ? r.InClosingTagName : r.InSpecialComment, this.sectionStart = this.index));
      }, f.prototype.stateInClosingTagName = function(h) {
        (h === n.Gt || i(h)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterClosingTagName, this.stateAfterClosingTagName(h));
      }, f.prototype.stateAfterClosingTagName = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeAttributeName = function(h) {
        h === n.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = r.InSpecialTag, this.sequenceIndex = 0) : this.state = r.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : h === n.Slash ? this.state = r.InSelfClosingTag : i(h) || (this.state = r.InAttributeName, this.sectionStart = this.index);
      }, f.prototype.stateInSelfClosingTag = function(h) {
        h === n.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : i(h) || (this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
      }, f.prototype.stateInAttributeName = function(h) {
        (h === n.Eq || s(h)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterAttributeName, this.stateAfterAttributeName(h));
      }, f.prototype.stateAfterAttributeName = function(h) {
        h === n.Eq ? this.state = r.BeforeAttributeValue : h === n.Slash || h === n.Gt ? (this.cbs.onattribend(l.NoValue, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : i(h) || (this.cbs.onattribend(l.NoValue, this.index), this.state = r.InAttributeName, this.sectionStart = this.index);
      }, f.prototype.stateBeforeAttributeValue = function(h) {
        h === n.DoubleQuote ? (this.state = r.InAttributeValueDq, this.sectionStart = this.index + 1) : h === n.SingleQuote ? (this.state = r.InAttributeValueSq, this.sectionStart = this.index + 1) : i(h) || (this.sectionStart = this.index, this.state = r.InAttributeValueNq, this.stateInAttributeValueNoQuotes(h));
      }, f.prototype.handleInAttributeValue = function(h, m) {
        h === m || !this.decodeEntities && this.fastForwardTo(m) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(m === n.DoubleQuote ? l.Double : l.Single, this.index), this.state = r.BeforeAttributeName) : this.decodeEntities && h === n.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
      }, f.prototype.stateInAttributeValueDoubleQuotes = function(h) {
        this.handleInAttributeValue(h, n.DoubleQuote);
      }, f.prototype.stateInAttributeValueSingleQuotes = function(h) {
        this.handleInAttributeValue(h, n.SingleQuote);
      }, f.prototype.stateInAttributeValueNoQuotes = function(h) {
        i(h) || h === n.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(l.Unquoted, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : this.decodeEntities && h === n.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
      }, f.prototype.stateBeforeDeclaration = function(h) {
        h === n.OpeningSquareBracket ? (this.state = r.CDATASequence, this.sequenceIndex = 0) : this.state = h === n.Dash ? r.BeforeComment : r.InDeclaration;
      }, f.prototype.stateInDeclaration = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateInProcessingInstruction = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeComment = function(h) {
        h === n.Dash ? (this.state = r.InCommentLike, this.currentSequence = c.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = r.InDeclaration;
      }, f.prototype.stateInSpecialComment = function(h) {
        (h === n.Gt || this.fastForwardTo(n.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = r.Text, this.sectionStart = this.index + 1);
      }, f.prototype.stateBeforeSpecialS = function(h) {
        var m = h | 32;
        m === c.ScriptEnd[3] ? this.startSpecial(c.ScriptEnd, 4) : m === c.StyleEnd[3] ? this.startSpecial(c.StyleEnd, 4) : (this.state = r.InTagName, this.stateInTagName(h));
      }, f.prototype.stateBeforeEntity = function(h) {
        this.entityExcess = 1, this.entityResult = 0, h === n.Number ? this.state = r.BeforeNumericEntity : h === n.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = r.InNamedEntity, this.stateInNamedEntity(h));
      }, f.prototype.stateInNamedEntity = function(h) {
        if (this.entityExcess += 1, this.trieIndex = (0, e.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, h), this.trieIndex < 0) {
          this.emitNamedEntity(), this.index--;
          return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var m = this.trieCurrent & e.BinTrieFlags.VALUE_LENGTH;
        if (m) {
          var p = (m >> 14) - 1;
          if (!this.allowLegacyEntity() && h !== n.Semi)
            this.trieIndex += p;
          else {
            var g = this.index - this.entityExcess + 1;
            g > this.sectionStart && this.emitPartial(this.sectionStart, g), this.entityResult = this.trieIndex, this.trieIndex += p, this.entityExcess = 0, this.sectionStart = this.index + 1, p === 0 && this.emitNamedEntity();
          }
        }
      }, f.prototype.emitNamedEntity = function() {
        if (this.state = this.baseState, this.entityResult !== 0) {
          var h = (this.entityTrie[this.entityResult] & e.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (h) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~e.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3:
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
          }
        }
      }, f.prototype.stateBeforeNumericEntity = function(h) {
        (h | 32) === n.LowerX ? (this.entityExcess++, this.state = r.InHexEntity) : (this.state = r.InNumericEntity, this.stateInNumericEntity(h));
      }, f.prototype.emitNumericEntity = function(h) {
        var m = this.index - this.entityExcess - 1, p = m + 2 + +(this.state === r.InHexEntity);
        p !== this.index && (m > this.sectionStart && this.emitPartial(this.sectionStart, m), this.sectionStart = this.index + Number(h), this.emitCodePoint((0, e.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
      }, f.prototype.stateInNumericEntity = function(h) {
        h === n.Semi ? this.emitNumericEntity(!0) : a(h) ? (this.entityResult = this.entityResult * 10 + (h - n.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
      }, f.prototype.stateInHexEntity = function(h) {
        h === n.Semi ? this.emitNumericEntity(!0) : a(h) ? (this.entityResult = this.entityResult * 16 + (h - n.Zero), this.entityExcess++) : u(h) ? (this.entityResult = this.entityResult * 16 + ((h | 32) - n.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
      }, f.prototype.allowLegacyEntity = function() {
        return !this.xmlMode && (this.baseState === r.Text || this.baseState === r.InSpecialTag);
      }, f.prototype.cleanup = function() {
        this.running && this.sectionStart !== this.index && (this.state === r.Text || this.state === r.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === r.InAttributeValueDq || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
      }, f.prototype.shouldContinue = function() {
        return this.index < this.buffer.length + this.offset && this.running;
      }, f.prototype.parse = function() {
        for (; this.shouldContinue(); ) {
          var h = this.buffer.charCodeAt(this.index - this.offset);
          switch (this.state) {
            case r.Text: {
              this.stateText(h);
              break;
            }
            case r.SpecialStartSequence: {
              this.stateSpecialStartSequence(h);
              break;
            }
            case r.InSpecialTag: {
              this.stateInSpecialTag(h);
              break;
            }
            case r.CDATASequence: {
              this.stateCDATASequence(h);
              break;
            }
            case r.InAttributeValueDq: {
              this.stateInAttributeValueDoubleQuotes(h);
              break;
            }
            case r.InAttributeName: {
              this.stateInAttributeName(h);
              break;
            }
            case r.InCommentLike: {
              this.stateInCommentLike(h);
              break;
            }
            case r.InSpecialComment: {
              this.stateInSpecialComment(h);
              break;
            }
            case r.BeforeAttributeName: {
              this.stateBeforeAttributeName(h);
              break;
            }
            case r.InTagName: {
              this.stateInTagName(h);
              break;
            }
            case r.InClosingTagName: {
              this.stateInClosingTagName(h);
              break;
            }
            case r.BeforeTagName: {
              this.stateBeforeTagName(h);
              break;
            }
            case r.AfterAttributeName: {
              this.stateAfterAttributeName(h);
              break;
            }
            case r.InAttributeValueSq: {
              this.stateInAttributeValueSingleQuotes(h);
              break;
            }
            case r.BeforeAttributeValue: {
              this.stateBeforeAttributeValue(h);
              break;
            }
            case r.BeforeClosingTagName: {
              this.stateBeforeClosingTagName(h);
              break;
            }
            case r.AfterClosingTagName: {
              this.stateAfterClosingTagName(h);
              break;
            }
            case r.BeforeSpecialS: {
              this.stateBeforeSpecialS(h);
              break;
            }
            case r.InAttributeValueNq: {
              this.stateInAttributeValueNoQuotes(h);
              break;
            }
            case r.InSelfClosingTag: {
              this.stateInSelfClosingTag(h);
              break;
            }
            case r.InDeclaration: {
              this.stateInDeclaration(h);
              break;
            }
            case r.BeforeDeclaration: {
              this.stateBeforeDeclaration(h);
              break;
            }
            case r.BeforeComment: {
              this.stateBeforeComment(h);
              break;
            }
            case r.InProcessingInstruction: {
              this.stateInProcessingInstruction(h);
              break;
            }
            case r.InNamedEntity: {
              this.stateInNamedEntity(h);
              break;
            }
            case r.BeforeEntity: {
              this.stateBeforeEntity(h);
              break;
            }
            case r.InHexEntity: {
              this.stateInHexEntity(h);
              break;
            }
            case r.InNumericEntity: {
              this.stateInNumericEntity(h);
              break;
            }
            default:
              this.stateBeforeNumericEntity(h);
          }
          this.index++;
        }
        this.cleanup();
      }, f.prototype.finish = function() {
        this.state === r.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
      }, f.prototype.handleTrailingData = function() {
        var h = this.buffer.length + this.offset;
        this.state === r.InCommentLike ? this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, h, 0) : this.cbs.oncomment(this.sectionStart, h, 0) : this.state === r.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InTagName || this.state === r.BeforeAttributeName || this.state === r.BeforeAttributeValue || this.state === r.AfterAttributeName || this.state === r.InAttributeName || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueDq || this.state === r.InAttributeValueNq || this.state === r.InClosingTagName || this.cbs.ontext(this.sectionStart, h);
      }, f.prototype.emitPartial = function(h, m) {
        this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribdata(h, m) : this.cbs.ontext(h, m);
      }, f.prototype.emitCodePoint = function(h) {
        this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribentity(h) : this.cbs.ontextentity(h);
      }, f;
    }()
  );
  t.default = d;
})(gh);
var k8 = Ae && Ae.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(e, n);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[n];
  } }), Object.defineProperty(t, r, i);
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), D8 = Ae && Ae.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), P8 = Ae && Ae.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && k8(e, t, n);
  return D8(e, t), e;
};
Object.defineProperty(pa, "__esModule", { value: !0 });
pa.Parser = void 0;
var co = P8(gh), dp = ga, Ci = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), Ye = /* @__PURE__ */ new Set(["p"]), fp = /* @__PURE__ */ new Set(["thead", "tbody"]), hp = /* @__PURE__ */ new Set(["dd", "dt"]), mp = /* @__PURE__ */ new Set(["rt", "rp"]), O8 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", Ye],
  ["h1", Ye],
  ["h2", Ye],
  ["h3", Ye],
  ["h4", Ye],
  ["h5", Ye],
  ["h6", Ye],
  ["select", Ci],
  ["input", Ci],
  ["output", Ci],
  ["button", Ci],
  ["datalist", Ci],
  ["textarea", Ci],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", hp],
  ["dt", hp],
  ["address", Ye],
  ["article", Ye],
  ["aside", Ye],
  ["blockquote", Ye],
  ["details", Ye],
  ["div", Ye],
  ["dl", Ye],
  ["fieldset", Ye],
  ["figcaption", Ye],
  ["figure", Ye],
  ["footer", Ye],
  ["form", Ye],
  ["header", Ye],
  ["hr", Ye],
  ["main", Ye],
  ["nav", Ye],
  ["ol", Ye],
  ["pre", Ye],
  ["section", Ye],
  ["table", Ye],
  ["ul", Ye],
  ["rt", mp],
  ["rp", mp],
  ["tbody", fp],
  ["tfoot", fp]
]), N8 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), pp = /* @__PURE__ */ new Set(["math", "svg"]), gp = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), M8 = /\s|\//, F8 = (
  /** @class */
  function() {
    function t(e, n) {
      n === void 0 && (n = {});
      var r, i, s, a, o;
      this.options = n, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = e ?? {}, this.lowerCaseTagNames = (r = n.lowerCaseTags) !== null && r !== void 0 ? r : !n.xmlMode, this.lowerCaseAttributeNames = (i = n.lowerCaseAttributeNames) !== null && i !== void 0 ? i : !n.xmlMode, this.tokenizer = new ((s = n.Tokenizer) !== null && s !== void 0 ? s : co.default)(this.options, this), (o = (a = this.cbs).onparserinit) === null || o === void 0 || o.call(a, this);
    }
    return t.prototype.ontext = function(e, n) {
      var r, i, s = this.getSlice(e, n);
      this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, s), this.startIndex = n;
    }, t.prototype.ontextentity = function(e) {
      var n, r, i = this.tokenizer.getSectionStart();
      this.endIndex = i - 1, (r = (n = this.cbs).ontext) === null || r === void 0 || r.call(n, (0, dp.fromCodePoint)(e)), this.startIndex = i;
    }, t.prototype.isVoidElement = function(e) {
      return !this.options.xmlMode && N8.has(e);
    }, t.prototype.onopentagname = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
    }, t.prototype.emitOpenTag = function(e) {
      var n, r, i, s;
      this.openTagStart = this.startIndex, this.tagname = e;
      var a = !this.options.xmlMode && O8.get(e);
      if (a)
        for (; this.stack.length > 0 && a.has(this.stack[this.stack.length - 1]); ) {
          var o = this.stack.pop();
          (r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, o, !0);
        }
      this.isVoidElement(e) || (this.stack.push(e), pp.has(e) ? this.foreignContext.push(!0) : gp.has(e) && this.foreignContext.push(!1)), (s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, e), this.cbs.onopentag && (this.attribs = {});
    }, t.prototype.endOpenTag = function(e) {
      var n, r;
      this.startIndex = this.openTagStart, this.attribs && ((r = (n = this.cbs).onopentag) === null || r === void 0 || r.call(n, this.tagname, this.attribs, e), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
    }, t.prototype.onopentagend = function(e) {
      this.endIndex = e, this.endOpenTag(!1), this.startIndex = e + 1;
    }, t.prototype.onclosetag = function(e, n) {
      var r, i, s, a, o, u;
      this.endIndex = n;
      var l = this.getSlice(e, n);
      if (this.lowerCaseTagNames && (l = l.toLowerCase()), (pp.has(l) || gp.has(l)) && this.foreignContext.pop(), this.isVoidElement(l))
        !this.options.xmlMode && l === "br" && ((i = (r = this.cbs).onopentagname) === null || i === void 0 || i.call(r, "br"), (a = (s = this.cbs).onopentag) === null || a === void 0 || a.call(s, "br", {}, !0), (u = (o = this.cbs).onclosetag) === null || u === void 0 || u.call(o, "br", !1));
      else {
        var c = this.stack.lastIndexOf(l);
        if (c !== -1)
          if (this.cbs.onclosetag)
            for (var d = this.stack.length - c; d--; )
              this.cbs.onclosetag(this.stack.pop(), d !== 0);
          else
            this.stack.length = c;
        else !this.options.xmlMode && l === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
      }
      this.startIndex = n + 1;
    }, t.prototype.onselfclosingtag = function(e) {
      this.endIndex = e, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = e + 1) : this.onopentagend(e);
    }, t.prototype.closeCurrentTag = function(e) {
      var n, r, i = this.tagname;
      this.endOpenTag(e), this.stack[this.stack.length - 1] === i && ((r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, i, !e), this.stack.pop());
    }, t.prototype.onattribname = function(e, n) {
      this.startIndex = e;
      var r = this.getSlice(e, n);
      this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
    }, t.prototype.onattribdata = function(e, n) {
      this.attribvalue += this.getSlice(e, n);
    }, t.prototype.onattribentity = function(e) {
      this.attribvalue += (0, dp.fromCodePoint)(e);
    }, t.prototype.onattribend = function(e, n) {
      var r, i;
      this.endIndex = n, (i = (r = this.cbs).onattribute) === null || i === void 0 || i.call(r, this.attribname, this.attribvalue, e === co.QuoteType.Double ? '"' : e === co.QuoteType.Single ? "'" : e === co.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
    }, t.prototype.getInstructionName = function(e) {
      var n = e.search(M8), r = n < 0 ? e : e.substr(0, n);
      return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
    }, t.prototype.ondeclaration = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      if (this.cbs.onprocessinginstruction) {
        var i = this.getInstructionName(r);
        this.cbs.onprocessinginstruction("!".concat(i), "!".concat(r));
      }
      this.startIndex = n + 1;
    }, t.prototype.onprocessinginstruction = function(e, n) {
      this.endIndex = n;
      var r = this.getSlice(e, n);
      if (this.cbs.onprocessinginstruction) {
        var i = this.getInstructionName(r);
        this.cbs.onprocessinginstruction("?".concat(i), "?".concat(r));
      }
      this.startIndex = n + 1;
    }, t.prototype.oncomment = function(e, n, r) {
      var i, s, a, o;
      this.endIndex = n, (s = (i = this.cbs).oncomment) === null || s === void 0 || s.call(i, this.getSlice(e, n - r)), (o = (a = this.cbs).oncommentend) === null || o === void 0 || o.call(a), this.startIndex = n + 1;
    }, t.prototype.oncdata = function(e, n, r) {
      var i, s, a, o, u, l, c, d, f, h;
      this.endIndex = n;
      var m = this.getSlice(e, n - r);
      this.options.xmlMode || this.options.recognizeCDATA ? ((s = (i = this.cbs).oncdatastart) === null || s === void 0 || s.call(i), (o = (a = this.cbs).ontext) === null || o === void 0 || o.call(a, m), (l = (u = this.cbs).oncdataend) === null || l === void 0 || l.call(u)) : ((d = (c = this.cbs).oncomment) === null || d === void 0 || d.call(c, "[CDATA[".concat(m, "]]")), (h = (f = this.cbs).oncommentend) === null || h === void 0 || h.call(f)), this.startIndex = n + 1;
    }, t.prototype.onend = function() {
      var e, n;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var r = this.stack.length; r > 0; this.cbs.onclosetag(this.stack[--r], !0))
          ;
      }
      (n = (e = this.cbs).onend) === null || n === void 0 || n.call(e);
    }, t.prototype.reset = function() {
      var e, n, r, i;
      (n = (e = this.cbs).onreset) === null || n === void 0 || n.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (i = (r = this.cbs).onparserinit) === null || i === void 0 || i.call(r, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
    }, t.prototype.parseComplete = function(e) {
      this.reset(), this.end(e);
    }, t.prototype.getSlice = function(e, n) {
      for (; e - this.bufferOffset >= this.buffers[0].length; )
        this.shiftBuffer();
      for (var r = this.buffers[0].slice(e - this.bufferOffset, n - this.bufferOffset); n - this.bufferOffset > this.buffers[0].length; )
        this.shiftBuffer(), r += this.buffers[0].slice(0, n - this.bufferOffset);
      return r;
    }, t.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
    }, t.prototype.write = function(e) {
      var n, r;
      if (this.ended) {
        (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(e), this.tokenizer.running && (this.tokenizer.write(e), this.writeIndex++);
    }, t.prototype.end = function(e) {
      var n, r;
      if (this.ended) {
        (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".end() after done!"));
        return;
      }
      e && this.write(e), this.ended = !0, this.tokenizer.end();
    }, t.prototype.pause = function() {
      this.tokenizer.pause();
    }, t.prototype.resume = function() {
      for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      this.ended && this.tokenizer.end();
    }, t.prototype.parseChunk = function(e) {
      this.write(e);
    }, t.prototype.done = function(e) {
      this.end(e);
    }, t;
  }()
);
pa.Parser = F8;
var dr = {}, As = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
  var e;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(e = t.ElementType || (t.ElementType = {}));
  function n(r) {
    return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
  }
  t.isTag = n, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
})(As);
var Ue = {}, $r = Ae && Ae.__extends || /* @__PURE__ */ function() {
  var t = function(e, n) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]);
    }, t(e, n);
  };
  return function(e, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    t(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), ra = Ae && Ae.__assign || function() {
  return ra = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, ra.apply(this, arguments);
};
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.cloneNode = Ue.hasChildren = Ue.isDocument = Ue.isDirective = Ue.isComment = Ue.isText = Ue.isCDATA = Ue.isTag = Ue.Element = Ue.Document = Ue.CDATA = Ue.NodeWithChildren = Ue.ProcessingInstruction = Ue.Comment = Ue.Text = Ue.DataNode = Ue.Node = void 0;
var Kt = As, yh = (
  /** @class */
  function() {
    function t() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(e) {
        this.parent = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(e) {
        this.prev = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(e) {
        this.next = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.cloneNode = function(e) {
      return e === void 0 && (e = !1), Th(this, e);
    }, t;
  }()
);
Ue.Node = yh;
var pl = (
  /** @class */
  function(t) {
    $r(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(e.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(yh)
);
Ue.DataNode = pl;
var qT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Kt.ElementType.Text, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pl)
);
Ue.Text = qT;
var WT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Kt.ElementType.Comment, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pl)
);
Ue.Comment = WT;
var KT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e(n, r) {
      var i = t.call(this, r) || this;
      return i.name = n, i.type = Kt.ElementType.Directive, i;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pl)
);
Ue.ProcessingInstruction = KT;
var gl = (
  /** @class */
  function(t) {
    $r(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(e.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(yh)
);
Ue.NodeWithChildren = gl;
var jT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Kt.ElementType.CDATA, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(gl)
);
Ue.CDATA = jT;
var YT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = Kt.ElementType.Root, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(gl)
);
Ue.Document = YT;
var XT = (
  /** @class */
  function(t) {
    $r(e, t);
    function e(n, r, i, s) {
      i === void 0 && (i = []), s === void 0 && (s = n === "script" ? Kt.ElementType.Script : n === "style" ? Kt.ElementType.Style : Kt.ElementType.Tag);
      var a = t.call(this, i) || this;
      return a.name = n, a.attribs = r, a.type = s, a;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var i, s;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (i = n["x-attribsNamespace"]) === null || i === void 0 ? void 0 : i[r],
            prefix: (s = n["x-attribsPrefix"]) === null || s === void 0 ? void 0 : s[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(gl)
);
Ue.Element = XT;
function QT(t) {
  return (0, Kt.isTag)(t);
}
Ue.isTag = QT;
function ZT(t) {
  return t.type === Kt.ElementType.CDATA;
}
Ue.isCDATA = ZT;
function JT(t) {
  return t.type === Kt.ElementType.Text;
}
Ue.isText = JT;
function eS(t) {
  return t.type === Kt.ElementType.Comment;
}
Ue.isComment = eS;
function tS(t) {
  return t.type === Kt.ElementType.Directive;
}
Ue.isDirective = tS;
function nS(t) {
  return t.type === Kt.ElementType.Root;
}
Ue.isDocument = nS;
function B8(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
Ue.hasChildren = B8;
function Th(t, e) {
  e === void 0 && (e = !1);
  var n;
  if (JT(t))
    n = new qT(t.data);
  else if (eS(t))
    n = new WT(t.data);
  else if (QT(t)) {
    var r = e ? cc(t.children) : [], i = new XT(t.name, ra({}, t.attribs), r);
    r.forEach(function(u) {
      return u.parent = i;
    }), t.namespace != null && (i.namespace = t.namespace), t["x-attribsNamespace"] && (i["x-attribsNamespace"] = ra({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (i["x-attribsPrefix"] = ra({}, t["x-attribsPrefix"])), n = i;
  } else if (ZT(t)) {
    var r = e ? cc(t.children) : [], s = new jT(r);
    r.forEach(function(l) {
      return l.parent = s;
    }), n = s;
  } else if (nS(t)) {
    var r = e ? cc(t.children) : [], a = new YT(r);
    r.forEach(function(l) {
      return l.parent = a;
    }), t["x-mode"] && (a["x-mode"] = t["x-mode"]), n = a;
  } else if (tS(t)) {
    var o = new KT(t.name, t.data);
    t["x-name"] != null && (o["x-name"] = t["x-name"], o["x-publicId"] = t["x-publicId"], o["x-systemId"] = t["x-systemId"]), n = o;
  } else
    throw new Error("Not implemented yet: ".concat(t.type));
  return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n;
}
Ue.cloneNode = Th;
function cc(t) {
  for (var e = t.map(function(r) {
    return Th(r, !0);
  }), n = 1; n < e.length; n++)
    e[n].prev = e[n - 1], e[n - 1].next = e[n];
  return e;
}
(function(t) {
  var e = Ae && Ae.__createBinding || (Object.create ? function(o, u, l, c) {
    c === void 0 && (c = l);
    var d = Object.getOwnPropertyDescriptor(u, l);
    (!d || ("get" in d ? !u.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return u[l];
    } }), Object.defineProperty(o, c, d);
  } : function(o, u, l, c) {
    c === void 0 && (c = l), o[c] = u[l];
  }), n = Ae && Ae.__exportStar || function(o, u) {
    for (var l in o) l !== "default" && !Object.prototype.hasOwnProperty.call(u, l) && e(u, o, l);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
  var r = As, i = Ue;
  n(Ue, t);
  var s = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function o(u, l, c) {
        this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = s), typeof u == "object" && (l = u, u = void 0), this.callback = u ?? null, this.options = l ?? s, this.elementCB = c ?? null;
      }
      return o.prototype.onparserinit = function(u) {
        this.parser = u;
      }, o.prototype.onreset = function() {
        this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, o.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, o.prototype.onerror = function(u) {
        this.handleCallback(u);
      }, o.prototype.onclosetag = function() {
        this.lastNode = null;
        var u = this.tagStack.pop();
        this.options.withEndIndices && (u.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(u);
      }, o.prototype.onopentag = function(u, l) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new i.Element(u, l, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, o.prototype.ontext = function(u) {
        var l = this.lastNode;
        if (l && l.type === r.ElementType.Text)
          l.data += u, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
        else {
          var c = new i.Text(u);
          this.addNode(c), this.lastNode = c;
        }
      }, o.prototype.oncomment = function(u) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += u;
          return;
        }
        var l = new i.Comment(u);
        this.addNode(l), this.lastNode = l;
      }, o.prototype.oncommentend = function() {
        this.lastNode = null;
      }, o.prototype.oncdatastart = function() {
        var u = new i.Text(""), l = new i.CDATA([u]);
        this.addNode(l), u.parent = l, this.lastNode = u;
      }, o.prototype.oncdataend = function() {
        this.lastNode = null;
      }, o.prototype.onprocessinginstruction = function(u, l) {
        var c = new i.ProcessingInstruction(u, l);
        this.addNode(c);
      }, o.prototype.handleCallback = function(u) {
        if (typeof this.callback == "function")
          this.callback(u, this.dom);
        else if (u)
          throw u;
      }, o.prototype.addNode = function(u) {
        var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
        this.options.withStartIndices && (u.startIndex = this.parser.startIndex), this.options.withEndIndices && (u.endIndex = this.parser.endIndex), l.children.push(u), c && (u.prev = c, c.next = u), u.parent = l, this.lastNode = null;
      }, o;
    }()
  );
  t.DomHandler = a, t.default = a;
})(dr);
var jo = {}, Ur = {}, Ha = {}, rS = {}, ii = {}, Sh = {};
Object.defineProperty(Sh, "__esModule", { value: !0 });
function fo(t) {
  for (var e = 1; e < t.length; e++)
    t[e][0] += t[e - 1][0] + 1;
  return t;
}
Sh.default = new Map(/* @__PURE__ */ fo([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ fo([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ fo([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ fo([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
var vu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.getCodePoint = t.xmlReplacer = void 0, t.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var e = /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  t.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? function(i, s) {
    return i.codePointAt(s);
  } : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(i, s) {
      return (i.charCodeAt(s) & 64512) === 55296 ? (i.charCodeAt(s) - 55296) * 1024 + i.charCodeAt(s + 1) - 56320 + 65536 : i.charCodeAt(s);
    }
  );
  function n(i) {
    for (var s = "", a = 0, o; (o = t.xmlReplacer.exec(i)) !== null; ) {
      var u = o.index, l = i.charCodeAt(u), c = e.get(l);
      c !== void 0 ? (s += i.substring(a, u) + c, a = u + 1) : (s += "".concat(i.substring(a, u), "&#x").concat((0, t.getCodePoint)(i, u).toString(16), ";"), a = t.xmlReplacer.lastIndex += +((l & 64512) === 55296));
    }
    return s + i.substr(a);
  }
  t.encodeXML = n, t.escape = n;
  function r(i, s) {
    return function(o) {
      for (var u, l = 0, c = ""; u = i.exec(o); )
        l !== u.index && (c += o.substring(l, u.index)), c += s.get(u[0].charCodeAt(0)), l = u.index + 1;
      return c + o.substring(l);
    };
  }
  t.escapeUTF8 = r(/[&<>'"]/g, e), t.escapeAttribute = r(/["&\u00A0]/g, /* @__PURE__ */ new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ])), t.escapeText = r(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
})(vu);
var $8 = Ae && Ae.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.encodeNonAsciiHTML = ii.encodeHTML = void 0;
var U8 = $8(Sh), iS = vu, H8 = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
function V8(t) {
  return sS(H8, t);
}
ii.encodeHTML = V8;
function G8(t) {
  return sS(iS.xmlReplacer, t);
}
ii.encodeNonAsciiHTML = G8;
function sS(t, e) {
  for (var n = "", r = 0, i; (i = t.exec(e)) !== null; ) {
    var s = i.index;
    n += e.substring(r, s);
    var a = e.charCodeAt(s), o = U8.default.get(a);
    if (typeof o == "object") {
      if (s + 1 < e.length) {
        var u = e.charCodeAt(s + 1), l = typeof o.n == "number" ? o.n === u ? o.o : void 0 : o.n.get(u);
        if (l !== void 0) {
          n += l, r = t.lastIndex += 1;
          continue;
        }
      }
      o = o.v;
    }
    if (o !== void 0)
      n += o, r = s + 1;
    else {
      var c = (0, iS.getCodePoint)(e, s);
      n += "&#x".concat(c.toString(16), ";"), r = t.lastIndex += +(c !== a);
    }
  }
  return n + e.substr(r);
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXMLStrict = t.decodeHTML5Strict = t.decodeHTML4Strict = t.decodeHTML5 = t.decodeHTML4 = t.decodeHTMLAttribute = t.decodeHTMLStrict = t.decodeHTML = t.decodeXML = t.DecodingMode = t.EntityDecoder = t.encodeHTML5 = t.encodeHTML4 = t.encodeNonAsciiHTML = t.encodeHTML = t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.encode = t.decodeStrict = t.decode = t.EncodingMode = t.EntityLevel = void 0;
  var e = ga, n = ii, r = vu, i;
  (function(f) {
    f[f.XML = 0] = "XML", f[f.HTML = 1] = "HTML";
  })(i = t.EntityLevel || (t.EntityLevel = {}));
  var s;
  (function(f) {
    f[f.UTF8 = 0] = "UTF8", f[f.ASCII = 1] = "ASCII", f[f.Extensive = 2] = "Extensive", f[f.Attribute = 3] = "Attribute", f[f.Text = 4] = "Text";
  })(s = t.EncodingMode || (t.EncodingMode = {}));
  function a(f, h) {
    h === void 0 && (h = i.XML);
    var m = typeof h == "number" ? h : h.level;
    if (m === i.HTML) {
      var p = typeof h == "object" ? h.mode : void 0;
      return (0, e.decodeHTML)(f, p);
    }
    return (0, e.decodeXML)(f);
  }
  t.decode = a;
  function o(f, h) {
    var m;
    h === void 0 && (h = i.XML);
    var p = typeof h == "number" ? { level: h } : h;
    return (m = p.mode) !== null && m !== void 0 || (p.mode = e.DecodingMode.Strict), a(f, p);
  }
  t.decodeStrict = o;
  function u(f, h) {
    h === void 0 && (h = i.XML);
    var m = typeof h == "number" ? { level: h } : h;
    return m.mode === s.UTF8 ? (0, r.escapeUTF8)(f) : m.mode === s.Attribute ? (0, r.escapeAttribute)(f) : m.mode === s.Text ? (0, r.escapeText)(f) : m.level === i.HTML ? m.mode === s.ASCII ? (0, n.encodeNonAsciiHTML)(f) : (0, n.encodeHTML)(f) : (0, r.encodeXML)(f);
  }
  t.encode = u;
  var l = vu;
  Object.defineProperty(t, "encodeXML", { enumerable: !0, get: function() {
    return l.encodeXML;
  } }), Object.defineProperty(t, "escape", { enumerable: !0, get: function() {
    return l.escape;
  } }), Object.defineProperty(t, "escapeUTF8", { enumerable: !0, get: function() {
    return l.escapeUTF8;
  } }), Object.defineProperty(t, "escapeAttribute", { enumerable: !0, get: function() {
    return l.escapeAttribute;
  } }), Object.defineProperty(t, "escapeText", { enumerable: !0, get: function() {
    return l.escapeText;
  } });
  var c = ii;
  Object.defineProperty(t, "encodeHTML", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } }), Object.defineProperty(t, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return c.encodeNonAsciiHTML;
  } }), Object.defineProperty(t, "encodeHTML4", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } }), Object.defineProperty(t, "encodeHTML5", { enumerable: !0, get: function() {
    return c.encodeHTML;
  } });
  var d = ga;
  Object.defineProperty(t, "EntityDecoder", { enumerable: !0, get: function() {
    return d.EntityDecoder;
  } }), Object.defineProperty(t, "DecodingMode", { enumerable: !0, get: function() {
    return d.DecodingMode;
  } }), Object.defineProperty(t, "decodeXML", { enumerable: !0, get: function() {
    return d.decodeXML;
  } }), Object.defineProperty(t, "decodeHTML", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTMLAttribute", { enumerable: !0, get: function() {
    return d.decodeHTMLAttribute;
  } }), Object.defineProperty(t, "decodeHTML4", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML5", { enumerable: !0, get: function() {
    return d.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return d.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeXMLStrict", { enumerable: !0, get: function() {
    return d.decodeXML;
  } });
})(rS);
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.attributeNames = ss.elementNames = void 0;
ss.elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map(function(t) {
  return [t.toLowerCase(), t];
}));
ss.attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map(function(t) {
  return [t.toLowerCase(), t];
}));
var Ui = Ae && Ae.__assign || function() {
  return Ui = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Ui.apply(this, arguments);
}, z8 = Ae && Ae.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n);
  var i = Object.getOwnPropertyDescriptor(e, n);
  (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return e[n];
  } }), Object.defineProperty(t, r, i);
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), q8 = Ae && Ae.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), W8 = Ae && Ae.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var n in t) n !== "default" && Object.prototype.hasOwnProperty.call(t, n) && z8(e, t, n);
  return q8(e, t), e;
};
Object.defineProperty(Ha, "__esModule", { value: !0 });
Ha.render = void 0;
var rr = W8(As), Au = rS, aS = ss, K8 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function j8(t) {
  return t.replace(/"/g, "&quot;");
}
function Y8(t, e) {
  var n;
  if (t) {
    var r = ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) === !1 ? j8 : e.xmlMode || e.encodeEntities !== "utf8" ? Au.encodeXML : Au.escapeAttribute;
    return Object.keys(t).map(function(i) {
      var s, a, o = (s = t[i]) !== null && s !== void 0 ? s : "";
      return e.xmlMode === "foreign" && (i = (a = aS.attributeNames.get(i)) !== null && a !== void 0 ? a : i), !e.emptyAttrs && !e.xmlMode && o === "" ? i : "".concat(i, '="').concat(r(o), '"');
    }).join(" ");
  }
}
var bp = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function bl(t, e) {
  e === void 0 && (e = {});
  for (var n = ("length" in t) ? t : [t], r = "", i = 0; i < n.length; i++)
    r += X8(n[i], e);
  return r;
}
Ha.render = bl;
Ha.default = bl;
function X8(t, e) {
  switch (t.type) {
    case rr.Root:
      return bl(t.children, e);
    case rr.Doctype:
    case rr.Directive:
      return eM(t);
    case rr.Comment:
      return rM(t);
    case rr.CDATA:
      return nM(t);
    case rr.Script:
    case rr.Style:
    case rr.Tag:
      return J8(t, e);
    case rr.Text:
      return tM(t, e);
  }
}
var Q8 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]), Z8 = /* @__PURE__ */ new Set(["svg", "math"]);
function J8(t, e) {
  var n;
  e.xmlMode === "foreign" && (t.name = (n = aS.elementNames.get(t.name)) !== null && n !== void 0 ? n : t.name, t.parent && Q8.has(t.parent.name) && (e = Ui(Ui({}, e), { xmlMode: !1 }))), !e.xmlMode && Z8.has(t.name) && (e = Ui(Ui({}, e), { xmlMode: "foreign" }));
  var r = "<".concat(t.name), i = Y8(t.attribs, e);
  return i && (r += " ".concat(i)), t.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== !1
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && bp.has(t.name)
  )) ? (e.xmlMode || (r += " "), r += "/>") : (r += ">", t.children.length > 0 && (r += bl(t.children, e)), (e.xmlMode || !bp.has(t.name)) && (r += "</".concat(t.name, ">"))), r;
}
function eM(t) {
  return "<".concat(t.data, ">");
}
function tM(t, e) {
  var n, r = t.data || "";
  return ((n = e.encodeEntities) !== null && n !== void 0 ? n : e.decodeEntities) !== !1 && !(!e.xmlMode && t.parent && K8.has(t.parent.name)) && (r = e.xmlMode || e.encodeEntities !== "utf8" ? (0, Au.encodeXML)(r) : (0, Au.escapeText)(r)), r;
}
function nM(t) {
  return "<![CDATA[".concat(t.children[0].data, "]]>");
}
function rM(t) {
  return "<!--".concat(t.data, "-->");
}
var iM = Ae && Ae.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.getOuterHTML = oS;
Ur.getInnerHTML = oM;
Ur.getText = Yo;
Ur.textContent = _d;
Ur.innerText = Rd;
var Vn = dr, sM = iM(Ha), aM = As;
function oS(t, e) {
  return (0, sM.default)(t, e);
}
function oM(t, e) {
  return (0, Vn.hasChildren)(t) ? t.children.map(function(n) {
    return oS(n, e);
  }).join("") : "";
}
function Yo(t) {
  return Array.isArray(t) ? t.map(Yo).join("") : (0, Vn.isTag)(t) ? t.name === "br" ? `
` : Yo(t.children) : (0, Vn.isCDATA)(t) ? Yo(t.children) : (0, Vn.isText)(t) ? t.data : "";
}
function _d(t) {
  return Array.isArray(t) ? t.map(_d).join("") : (0, Vn.hasChildren)(t) && !(0, Vn.isComment)(t) ? _d(t.children) : (0, Vn.isText)(t) ? t.data : "";
}
function Rd(t) {
  return Array.isArray(t) ? t.map(Rd).join("") : (0, Vn.hasChildren)(t) && (t.type === aM.ElementType.Tag || (0, Vn.isCDATA)(t)) ? Rd(t.children) : (0, Vn.isText)(t) ? t.data : "";
}
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.getChildren = uS;
Xn.getParent = lS;
Xn.getSiblings = uM;
Xn.getAttributeValue = lM;
Xn.hasAttrib = cM;
Xn.getName = dM;
Xn.nextElementSibling = fM;
Xn.prevElementSibling = hM;
var xh = dr;
function uS(t) {
  return (0, xh.hasChildren)(t) ? t.children : [];
}
function lS(t) {
  return t.parent || null;
}
function uM(t) {
  var e, n, r = lS(t);
  if (r != null)
    return uS(r);
  for (var i = [t], s = t.prev, a = t.next; s != null; )
    i.unshift(s), e = s, s = e.prev;
  for (; a != null; )
    i.push(a), n = a, a = n.next;
  return i;
}
function lM(t, e) {
  var n;
  return (n = t.attribs) === null || n === void 0 ? void 0 : n[e];
}
function cM(t, e) {
  return t.attribs != null && Object.prototype.hasOwnProperty.call(t.attribs, e) && t.attribs[e] != null;
}
function dM(t) {
  return t.name;
}
function fM(t) {
  for (var e, n = t.next; n !== null && !(0, xh.isTag)(n); )
    e = n, n = e.next;
  return n;
}
function hM(t) {
  for (var e, n = t.prev; n !== null && !(0, xh.isTag)(n); )
    e = n, n = e.prev;
  return n;
}
var Hr = {};
Object.defineProperty(Hr, "__esModule", { value: !0 });
Hr.removeElement = Va;
Hr.replaceElement = mM;
Hr.appendChild = pM;
Hr.append = gM;
Hr.prependChild = bM;
Hr.prepend = EM;
function Va(t) {
  if (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.parent) {
    var e = t.parent.children, n = e.lastIndexOf(t);
    n >= 0 && e.splice(n, 1);
  }
  t.next = null, t.prev = null, t.parent = null;
}
function mM(t, e) {
  var n = e.prev = t.prev;
  n && (n.next = e);
  var r = e.next = t.next;
  r && (r.prev = e);
  var i = e.parent = t.parent;
  if (i) {
    var s = i.children;
    s[s.lastIndexOf(t)] = e, t.parent = null;
  }
}
function pM(t, e) {
  if (Va(e), e.next = null, e.parent = t, t.children.push(e) > 1) {
    var n = t.children[t.children.length - 2];
    n.next = e, e.prev = n;
  } else
    e.prev = null;
}
function gM(t, e) {
  Va(e);
  var n = t.parent, r = t.next;
  if (e.next = r, e.prev = t, t.next = e, e.parent = n, r) {
    if (r.prev = e, n) {
      var i = n.children;
      i.splice(i.lastIndexOf(r), 0, e);
    }
  } else n && n.children.push(e);
}
function bM(t, e) {
  if (Va(e), e.parent = t, e.prev = null, t.children.unshift(e) !== 1) {
    var n = t.children[1];
    n.prev = e, e.next = n;
  } else
    e.next = null;
}
function EM(t, e) {
  Va(e);
  var n = t.parent;
  if (n) {
    var r = n.children;
    r.splice(r.indexOf(t), 0, e);
  }
  t.prev && (t.prev.next = e), e.parent = n, e.prev = t.prev, e.next = t, t.prev = e;
}
var br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
br.filter = yM;
br.find = cS;
br.findOneChild = TM;
br.findOne = dS;
br.existsOne = fS;
br.findAll = SM;
var si = dr;
function yM(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), cS(t, Array.isArray(e) ? e : [e], n, r);
}
function cS(t, e, n, r) {
  for (var i = [], s = [Array.isArray(e) ? e : [e]], a = [0]; ; ) {
    if (a[0] >= s[0].length) {
      if (a.length === 1)
        return i;
      s.shift(), a.shift();
      continue;
    }
    var o = s[0][a[0]++];
    if (t(o) && (i.push(o), --r <= 0))
      return i;
    n && (0, si.hasChildren)(o) && o.children.length > 0 && (a.unshift(0), s.unshift(o.children));
  }
}
function TM(t, e) {
  return e.find(t);
}
function dS(t, e, n) {
  n === void 0 && (n = !0);
  for (var r = Array.isArray(e) ? e : [e], i = 0; i < r.length; i++) {
    var s = r[i];
    if ((0, si.isTag)(s) && t(s))
      return s;
    if (n && (0, si.hasChildren)(s) && s.children.length > 0) {
      var a = dS(t, s.children, !0);
      if (a)
        return a;
    }
  }
  return null;
}
function fS(t, e) {
  return (Array.isArray(e) ? e : [e]).some(function(n) {
    return (0, si.isTag)(n) && t(n) || (0, si.hasChildren)(n) && fS(t, n.children);
  });
}
function SM(t, e) {
  for (var n = [], r = [Array.isArray(e) ? e : [e]], i = [0]; ; ) {
    if (i[0] >= r[0].length) {
      if (r.length === 1)
        return n;
      r.shift(), i.shift();
      continue;
    }
    var s = r[0][i[0]++];
    (0, si.isTag)(s) && t(s) && n.push(s), (0, si.hasChildren)(s) && s.children.length > 0 && (i.unshift(0), r.unshift(s.children));
  }
}
var Er = {};
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.testElement = vM;
Er.getElements = AM;
Er.getElementById = IM;
Er.getElementsByTagName = CM;
Er.getElementsByClassName = LM;
Er.getElementsByTagType = _M;
var Xr = dr, Ga = br, Iu = {
  tag_name: function(t) {
    return typeof t == "function" ? function(e) {
      return (0, Xr.isTag)(e) && t(e.name);
    } : t === "*" ? Xr.isTag : function(e) {
      return (0, Xr.isTag)(e) && e.name === t;
    };
  },
  tag_type: function(t) {
    return typeof t == "function" ? function(e) {
      return t(e.type);
    } : function(e) {
      return e.type === t;
    };
  },
  tag_contains: function(t) {
    return typeof t == "function" ? function(e) {
      return (0, Xr.isText)(e) && t(e.data);
    } : function(e) {
      return (0, Xr.isText)(e) && e.data === t;
    };
  }
};
function vh(t, e) {
  return typeof e == "function" ? function(n) {
    return (0, Xr.isTag)(n) && e(n.attribs[t]);
  } : function(n) {
    return (0, Xr.isTag)(n) && n.attribs[t] === e;
  };
}
function xM(t, e) {
  return function(n) {
    return t(n) || e(n);
  };
}
function hS(t) {
  var e = Object.keys(t).map(function(n) {
    var r = t[n];
    return Object.prototype.hasOwnProperty.call(Iu, n) ? Iu[n](r) : vh(n, r);
  });
  return e.length === 0 ? null : e.reduce(xM);
}
function vM(t, e) {
  var n = hS(t);
  return n ? n(e) : !0;
}
function AM(t, e, n, r) {
  r === void 0 && (r = 1 / 0);
  var i = hS(t);
  return i ? (0, Ga.filter)(i, e, n, r) : [];
}
function IM(t, e, n) {
  return n === void 0 && (n = !0), Array.isArray(e) || (e = [e]), (0, Ga.findOne)(vh("id", t), e, n);
}
function CM(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, Ga.filter)(Iu.tag_name(t), e, n, r);
}
function LM(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, Ga.filter)(vh("class", t), e, n, r);
}
function _M(t, e, n, r) {
  return n === void 0 && (n = !0), r === void 0 && (r = 1 / 0), (0, Ga.filter)(Iu.tag_type(t), e, n, r);
}
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.DocumentPosition = void 0;
Ei.removeSubsets = RM;
Ei.compareDocumentPosition = mS;
Ei.uniqueSort = wM;
var Ep = dr;
function RM(t) {
  for (var e = t.length; --e >= 0; ) {
    var n = t[e];
    if (e > 0 && t.lastIndexOf(n, e - 1) >= 0) {
      t.splice(e, 1);
      continue;
    }
    for (var r = n.parent; r; r = r.parent)
      if (t.includes(r)) {
        t.splice(e, 1);
        break;
      }
  }
  return t;
}
var xn;
(function(t) {
  t[t.DISCONNECTED = 1] = "DISCONNECTED", t[t.PRECEDING = 2] = "PRECEDING", t[t.FOLLOWING = 4] = "FOLLOWING", t[t.CONTAINS = 8] = "CONTAINS", t[t.CONTAINED_BY = 16] = "CONTAINED_BY";
})(xn || (Ei.DocumentPosition = xn = {}));
function mS(t, e) {
  var n = [], r = [];
  if (t === e)
    return 0;
  for (var i = (0, Ep.hasChildren)(t) ? t : t.parent; i; )
    n.unshift(i), i = i.parent;
  for (i = (0, Ep.hasChildren)(e) ? e : e.parent; i; )
    r.unshift(i), i = i.parent;
  for (var s = Math.min(n.length, r.length), a = 0; a < s && n[a] === r[a]; )
    a++;
  if (a === 0)
    return xn.DISCONNECTED;
  var o = n[a - 1], u = o.children, l = n[a], c = r[a];
  return u.indexOf(l) > u.indexOf(c) ? o === e ? xn.FOLLOWING | xn.CONTAINED_BY : xn.FOLLOWING : o === t ? xn.PRECEDING | xn.CONTAINS : xn.PRECEDING;
}
function wM(t) {
  return t = t.filter(function(e, n, r) {
    return !r.includes(e, n + 1);
  }), t.sort(function(e, n) {
    var r = mS(e, n);
    return r & xn.PRECEDING ? -1 : r & xn.FOLLOWING ? 1 : 0;
  }), t;
}
var Ah = {};
Object.defineProperty(Ah, "__esModule", { value: !0 });
Ah.getFeed = DM;
var kM = Ur, za = Er;
function DM(t) {
  var e = Cu(FM, t);
  return e ? e.name === "feed" ? PM(e) : OM(e) : null;
}
function PM(t) {
  var e, n = t.children, r = {
    type: "atom",
    items: (0, za.getElementsByTagName)("entry", n).map(function(a) {
      var o, u = a.children, l = { media: pS(u) };
      Gt(l, "id", "id", u), Gt(l, "title", "title", u);
      var c = (o = Cu("link", u)) === null || o === void 0 ? void 0 : o.attribs.href;
      c && (l.link = c);
      var d = wr("summary", u) || wr("content", u);
      d && (l.description = d);
      var f = wr("updated", u);
      return f && (l.pubDate = new Date(f)), l;
    })
  };
  Gt(r, "id", "id", n), Gt(r, "title", "title", n);
  var i = (e = Cu("link", n)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (r.link = i), Gt(r, "description", "subtitle", n);
  var s = wr("updated", n);
  return s && (r.updated = new Date(s)), Gt(r, "author", "email", n, !0), r;
}
function OM(t) {
  var e, n, r = (n = (e = Cu("channel", t.children)) === null || e === void 0 ? void 0 : e.children) !== null && n !== void 0 ? n : [], i = {
    type: t.name.substr(0, 3),
    id: "",
    items: (0, za.getElementsByTagName)("item", t.children).map(function(a) {
      var o = a.children, u = { media: pS(o) };
      Gt(u, "id", "guid", o), Gt(u, "title", "title", o), Gt(u, "link", "link", o), Gt(u, "description", "description", o);
      var l = wr("pubDate", o) || wr("dc:date", o);
      return l && (u.pubDate = new Date(l)), u;
    })
  };
  Gt(i, "title", "title", r), Gt(i, "link", "link", r), Gt(i, "description", "description", r);
  var s = wr("lastBuildDate", r);
  return s && (i.updated = new Date(s)), Gt(i, "author", "managingEditor", r, !0), i;
}
var NM = ["url", "type", "lang"], MM = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function pS(t) {
  return (0, za.getElementsByTagName)("media:content", t).map(function(e) {
    for (var n = e.attribs, r = {
      medium: n.medium,
      isDefault: !!n.isDefault
    }, i = 0, s = NM; i < s.length; i++) {
      var a = s[i];
      n[a] && (r[a] = n[a]);
    }
    for (var o = 0, u = MM; o < u.length; o++) {
      var a = u[o];
      n[a] && (r[a] = parseInt(n[a], 10));
    }
    return n.expression && (r.expression = n.expression), r;
  });
}
function Cu(t, e) {
  return (0, za.getElementsByTagName)(t, e, !0, 1)[0];
}
function wr(t, e, n) {
  return n === void 0 && (n = !1), (0, kM.textContent)((0, za.getElementsByTagName)(t, e, n, 1)).trim();
}
function Gt(t, e, n, r, i) {
  i === void 0 && (i = !1);
  var s = wr(n, r, i);
  s && (t[e] = s);
}
function FM(t) {
  return t === "rss" || t === "feed" || t === "rdf:RDF";
}
(function(t) {
  var e = Ae && Ae.__createBinding || (Object.create ? function(i, s, a, o) {
    o === void 0 && (o = a);
    var u = Object.getOwnPropertyDescriptor(s, a);
    (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
      return s[a];
    } }), Object.defineProperty(i, o, u);
  } : function(i, s, a, o) {
    o === void 0 && (o = a), i[o] = s[a];
  }), n = Ae && Ae.__exportStar || function(i, s) {
    for (var a in i) a !== "default" && !Object.prototype.hasOwnProperty.call(s, a) && e(s, i, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.hasChildren = t.isDocument = t.isComment = t.isText = t.isCDATA = t.isTag = void 0, n(Ur, t), n(Xn, t), n(Hr, t), n(br, t), n(Er, t), n(Ei, t), n(Ah, t);
  var r = dr;
  Object.defineProperty(t, "isTag", { enumerable: !0, get: function() {
    return r.isTag;
  } }), Object.defineProperty(t, "isCDATA", { enumerable: !0, get: function() {
    return r.isCDATA;
  } }), Object.defineProperty(t, "isText", { enumerable: !0, get: function() {
    return r.isText;
  } }), Object.defineProperty(t, "isComment", { enumerable: !0, get: function() {
    return r.isComment;
  } }), Object.defineProperty(t, "isDocument", { enumerable: !0, get: function() {
    return r.isDocument;
  } }), Object.defineProperty(t, "hasChildren", { enumerable: !0, get: function() {
    return r.hasChildren;
  } });
})(jo);
(function(t) {
  var e = Ae && Ae.__createBinding || (Object.create ? function(b, y, T, S) {
    S === void 0 && (S = T);
    var I = Object.getOwnPropertyDescriptor(y, T);
    (!I || ("get" in I ? !y.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return y[T];
    } }), Object.defineProperty(b, S, I);
  } : function(b, y, T, S) {
    S === void 0 && (S = T), b[S] = y[T];
  }), n = Ae && Ae.__setModuleDefault || (Object.create ? function(b, y) {
    Object.defineProperty(b, "default", { enumerable: !0, value: y });
  } : function(b, y) {
    b.default = y;
  }), r = Ae && Ae.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var y = {};
    if (b != null) for (var T in b) T !== "default" && Object.prototype.hasOwnProperty.call(b, T) && e(y, b, T);
    return n(y, b), y;
  }, i = Ae && Ae.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomUtils = t.parseFeed = t.getFeed = t.ElementType = t.Tokenizer = t.createDomStream = t.parseDOM = t.parseDocument = t.DefaultHandler = t.DomHandler = t.Parser = void 0;
  var s = pa, a = pa;
  Object.defineProperty(t, "Parser", { enumerable: !0, get: function() {
    return a.Parser;
  } });
  var o = dr, u = dr;
  Object.defineProperty(t, "DomHandler", { enumerable: !0, get: function() {
    return u.DomHandler;
  } }), Object.defineProperty(t, "DefaultHandler", { enumerable: !0, get: function() {
    return u.DomHandler;
  } });
  function l(b, y) {
    var T = new o.DomHandler(void 0, y);
    return new s.Parser(T, y).end(b), T.root;
  }
  t.parseDocument = l;
  function c(b, y) {
    return l(b, y).children;
  }
  t.parseDOM = c;
  function d(b, y, T) {
    var S = new o.DomHandler(b, y, T);
    return new s.Parser(S, y);
  }
  t.createDomStream = d;
  var f = gh;
  Object.defineProperty(t, "Tokenizer", { enumerable: !0, get: function() {
    return i(f).default;
  } }), t.ElementType = r(As);
  var h = jo, m = jo;
  Object.defineProperty(t, "getFeed", { enumerable: !0, get: function() {
    return m.getFeed;
  } });
  var p = { xmlMode: !0 };
  function g(b, y) {
    return y === void 0 && (y = p), (0, h.getFeed)(c(b, y));
  }
  t.parseFeed = g, t.DomUtils = r(jo);
})(zT);
var BM = (t) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, Ih = {};
Object.defineProperty(Ih, "__esModule", { value: !0 });
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function yp(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function $M(t) {
  var e, n;
  return yp(t) === !1 ? !1 : (e = t.constructor, e === void 0 ? !0 : (n = e.prototype, !(yp(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
Ih.isPlainObject = $M;
var UM = function(e) {
  return HM(e) && !VM(e);
};
function HM(t) {
  return !!t && typeof t == "object";
}
function VM(t) {
  var e = Object.prototype.toString.call(t);
  return e === "[object RegExp]" || e === "[object Date]" || qM(t);
}
var GM = typeof Symbol == "function" && Symbol.for, zM = GM ? Symbol.for("react.element") : 60103;
function qM(t) {
  return t.$$typeof === zM;
}
function WM(t) {
  return Array.isArray(t) ? [] : {};
}
function ba(t, e) {
  return e.clone !== !1 && e.isMergeableObject(t) ? as(WM(t), t, e) : t;
}
function KM(t, e, n) {
  return t.concat(e).map(function(r) {
    return ba(r, n);
  });
}
function jM(t, e) {
  if (!e.customMerge)
    return as;
  var n = e.customMerge(t);
  return typeof n == "function" ? n : as;
}
function YM(t) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter(function(e) {
    return Object.propertyIsEnumerable.call(t, e);
  }) : [];
}
function Tp(t) {
  return Object.keys(t).concat(YM(t));
}
function gS(t, e) {
  try {
    return e in t;
  } catch {
    return !1;
  }
}
function XM(t, e) {
  return gS(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e));
}
function QM(t, e, n) {
  var r = {};
  return n.isMergeableObject(t) && Tp(t).forEach(function(i) {
    r[i] = ba(t[i], n);
  }), Tp(e).forEach(function(i) {
    XM(t, i) || (gS(t, i) && n.isMergeableObject(e[i]) ? r[i] = jM(i, n)(t[i], e[i], n) : r[i] = ba(e[i], n));
  }), r;
}
function as(t, e, n) {
  n = n || {}, n.arrayMerge = n.arrayMerge || KM, n.isMergeableObject = n.isMergeableObject || UM, n.cloneUnlessOtherwiseSpecified = ba;
  var r = Array.isArray(e), i = Array.isArray(t), s = r === i;
  return s ? r ? n.arrayMerge(t, e, n) : QM(t, e, n) : ba(e, n);
}
as.all = function(e, n) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(r, i) {
    return as(r, i, n);
  }, {});
};
var ZM = as, JM = ZM, bS = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.parseSrcset = n();
  })(Ae, function() {
    return function(e) {
      function n(S) {
        return S === " " || // space
        S === "	" || // horizontal tab
        S === `
` || // new line
        S === "\f" || // form feed
        S === "\r";
      }
      function r(S) {
        var I, C = S.exec(e.substring(g));
        if (C)
          return I = C[0], g += I.length, I;
      }
      for (var i = e.length, s = /^[ \t\n\r\u000c]+/, a = /^[, \t\n\r\u000c]+/, o = /^[^ \t\n\r\u000c]+/, u = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, d, f, h, m, p, g = 0, b = []; ; ) {
        if (r(a), g >= i)
          return b;
        d = r(o), f = [], d.slice(-1) === "," ? (d = d.replace(u, ""), T()) : y();
      }
      function y() {
        for (r(s), h = "", m = "in descriptor"; ; ) {
          if (p = e.charAt(g), m === "in descriptor")
            if (n(p))
              h && (f.push(h), h = "", m = "after descriptor");
            else if (p === ",") {
              g += 1, h && f.push(h), T();
              return;
            } else if (p === "(")
              h = h + p, m = "in parens";
            else if (p === "") {
              h && f.push(h), T();
              return;
            } else
              h = h + p;
          else if (m === "in parens")
            if (p === ")")
              h = h + p, m = "in descriptor";
            else if (p === "") {
              f.push(h), T();
              return;
            } else
              h = h + p;
          else if (m === "after descriptor" && !n(p))
            if (p === "") {
              T();
              return;
            } else
              m = "in descriptor", g -= 1;
          g += 1;
        }
      }
      function T() {
        var S = !1, I, C, _, R, k = {}, A, L, P, $, G;
        for (R = 0; R < f.length; R++)
          A = f[R], L = A[A.length - 1], P = A.substring(0, A.length - 1), $ = parseInt(P, 10), G = parseFloat(P), l.test(P) && L === "w" ? ((I || C) && (S = !0), $ === 0 ? S = !0 : I = $) : c.test(P) && L === "x" ? ((I || C || _) && (S = !0), G < 0 ? S = !0 : C = G) : l.test(P) && L === "h" ? ((_ || C) && (S = !0), $ === 0 ? S = !0 : _ = $) : S = !0;
        S ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + A + "'.") : (k.url = d, I && (k.w = I), C && (k.d = C), _ && (k.h = _), b.push(k));
      }
    };
  });
})(bS);
var e5 = bS.exports, Ch = { exports: {} }, Re = String, ES = function() {
  return { isColorSupported: !1, reset: Re, bold: Re, dim: Re, italic: Re, underline: Re, inverse: Re, hidden: Re, strikethrough: Re, black: Re, red: Re, green: Re, yellow: Re, blue: Re, magenta: Re, cyan: Re, white: Re, gray: Re, bgBlack: Re, bgRed: Re, bgGreen: Re, bgYellow: Re, bgBlue: Re, bgMagenta: Re, bgCyan: Re, bgWhite: Re, blackBright: Re, redBright: Re, greenBright: Re, yellowBright: Re, blueBright: Re, magentaBright: Re, cyanBright: Re, whiteBright: Re, bgBlackBright: Re, bgRedBright: Re, bgGreenBright: Re, bgYellowBright: Re, bgBlueBright: Re, bgMagentaBright: Re, bgCyanBright: Re, bgWhiteBright: Re };
};
Ch.exports = ES();
Ch.exports.createColors = ES;
var t5 = Ch.exports;
const n5 = {}, r5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: n5
}, Symbol.toStringTag, { value: "Module" })), Rn = /* @__PURE__ */ uN(r5);
let Sp = t5, xp = Rn, wd = class yS extends Error {
  constructor(e, n, r, i, s, a) {
    super(e), this.name = "CssSyntaxError", this.reason = e, s && (this.file = s), i && (this.source = i), a && (this.plugin = a), typeof n < "u" && typeof r < "u" && (typeof n == "number" ? (this.line = n, this.column = r) : (this.line = n.line, this.column = n.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, yS);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let n = this.source;
    e == null && (e = Sp.isColorSupported), xp && e && (n = xp(n));
    let r = n.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, r.length), a = String(s).length, o, u;
    if (e) {
      let { bold: l, gray: c, red: d } = Sp.createColors(!0);
      o = (f) => l(d(f)), u = (f) => c(f);
    } else
      o = u = (l) => l;
    return r.slice(i, s).map((l, c) => {
      let d = i + 1 + c, f = " " + (" " + d).slice(-a) + " | ";
      if (d === this.line) {
        let h = u(f.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return o(">") + u(f) + l + `
 ` + h + o("^");
      }
      return " " + u(f) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Lh = wd;
wd.default = wd;
var qa = {};
qa.isClean = Symbol("isClean");
qa.my = Symbol("my");
const vp = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function i5(t) {
  return t[0].toUpperCase() + t.slice(1);
}
let kd = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, n) {
    let r = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : i && (r += " "), e.nodes)
      this.block(e, r + i);
    else {
      let s = (e.raws.between || "") + (n ? ";" : "");
      this.builder(r + i + s, e);
    }
  }
  beforeAfter(e, n) {
    let r;
    e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : n === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
    let i = e.parent, s = 0;
    for (; i && i.type !== "root"; )
      s += 1, i = i.parent;
    if (r.includes(`
`)) {
      let a = this.raw(e, null, "indent");
      if (a.length)
        for (let o = 0; o < s; o++) r += a;
    }
    return r;
  }
  block(e, n) {
    let r = this.raw(e, "between", "beforeOpen");
    this.builder(n + r + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  body(e) {
    let n = e.nodes.length - 1;
    for (; n > 0 && e.nodes[n].type === "comment"; )
      n -= 1;
    let r = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let s = e.nodes[i], a = this.raw(s, "before");
      a && this.builder(a), this.stringify(s, n !== i || r);
    }
  }
  comment(e) {
    let n = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
    this.builder("/*" + n + e.text + r + "*/", e);
  }
  decl(e, n) {
    let r = this.raw(e, "between", "colon"), i = e.prop + r + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), n && (i += ";"), this.builder(i, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, n, r) {
    let i;
    if (r || (r = n), n && (i = e.raws[n], typeof i < "u"))
      return i;
    let s = e.parent;
    if (r === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
      return "";
    if (!s) return vp[r];
    let a = e.root();
    if (a.rawCache || (a.rawCache = {}), typeof a.rawCache[r] < "u")
      return a.rawCache[r];
    if (r === "before" || r === "after")
      return this.beforeAfter(e, r);
    {
      let o = "raw" + i5(r);
      this[o] ? i = this[o](a, e) : a.walk((u) => {
        if (i = u.raws[n], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = vp[r]), a.rawCache[r] = i, i;
  }
  rawBeforeClose(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u")
        return n = r.raws.after, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeComment(e, n) {
    let r;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return r = i.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(n, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeDecl(e, n) {
    let r;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return r = i.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(n, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeOpen(e) {
    let n;
    return e.walk((r) => {
      if (r.type !== "decl" && (n = r.raws.between, typeof n < "u"))
        return !1;
    }), n;
  }
  rawBeforeRule(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u")
        return n = r.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), n && (n = n.replace(/\S/g, "")), n;
  }
  rawColon(e) {
    let n;
    return e.walkDecls((r) => {
      if (typeof r.raws.between < "u")
        return n = r.raws.between.replace(/[^\s:]/g, ""), !1;
    }), n;
  }
  rawEmptyBody(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length === 0 && (n = r.raws.after, typeof n < "u"))
        return !1;
    }), n;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let n;
    return e.walk((r) => {
      let i = r.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof r.raws.before < "u") {
        let s = r.raws.before.split(`
`);
        return n = s[s.length - 1], n = n.replace(/\S/g, ""), !1;
      }
    }), n;
  }
  rawSemicolon(e) {
    let n;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length && r.last.type === "decl" && (n = r.raws.semicolon, typeof n < "u"))
        return !1;
    }), n;
  }
  rawValue(e, n) {
    let r = e[n], i = e.raws[n];
    return i && i.value === r ? i.raw : r;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, n) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, n);
  }
};
var TS = kd;
kd.default = kd;
let s5 = TS;
function Dd(t, e) {
  new s5(e).stringify(t);
}
var El = Dd;
Dd.default = Dd;
let { isClean: ho, my: a5 } = qa, o5 = Lh, u5 = TS, l5 = El;
function Pd(t, e) {
  let n = new t.constructor();
  for (let r in t) {
    if (!Object.prototype.hasOwnProperty.call(t, r) || r === "proxyCache") continue;
    let i = t[r], s = typeof i;
    r === "parent" && s === "object" ? e && (n[r] = e) : r === "source" ? n[r] = i : Array.isArray(i) ? n[r] = i.map((a) => Pd(a, n)) : (s === "object" && i !== null && (i = Pd(i)), n[r] = i);
  }
  return n;
}
let Od = class {
  constructor(e = {}) {
    this.raws = {}, this[ho] = !1, this[a5] = !0;
    for (let n in e)
      if (n === "nodes") {
        this.nodes = [];
        for (let r of e[n])
          typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
      } else
        this[n] = e[n];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let n = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${n.input.from}:${n.start.line}:${n.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let n in e)
      this[n] = e[n];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let n = Pd(this);
    for (let r in e)
      n[r] = e[r];
    return n;
  }
  cloneAfter(e = {}) {
    let n = this.clone(e);
    return this.parent.insertAfter(this, n), n;
  }
  cloneBefore(e = {}) {
    let n = this.clone(e);
    return this.parent.insertBefore(this, n), n;
  }
  error(e, n = {}) {
    if (this.source) {
      let { end: r, start: i } = this.rangeBy(n);
      return this.source.input.error(
        e,
        { column: i.column, line: i.line },
        { column: r.column, line: r.line },
        n
      );
    }
    return new o5(e);
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : n === "root" ? () => e.root().toProxy() : e[n];
      },
      set(e, n, r) {
        return e[n] === r || (e[n] = r, (n === "prop" || n === "value" || n === "name" || n === "params" || n === "important" || /* c8 ignore next */
        n === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[ho]) {
      this[ho] = !1;
      let e = this;
      for (; e = e.parent; )
        e[ho] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, n) {
    let r = this.source.start;
    if (e.index)
      r = this.positionInside(e.index, n);
    else if (e.word) {
      n = this.toString();
      let i = n.indexOf(e.word);
      i !== -1 && (r = this.positionInside(i, n));
    }
    return r;
  }
  positionInside(e, n) {
    let r = n || this.toString(), i = this.source.start.column, s = this.source.start.line;
    for (let a = 0; a < e; a++)
      r[a] === `
` ? (i = 1, s += 1) : i += 1;
    return { column: i, line: s };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let n = {
      column: this.source.start.column,
      line: this.source.start.line
    }, r = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: n.column + 1,
      line: n.line
    };
    if (e.word) {
      let i = this.toString(), s = i.indexOf(e.word);
      s !== -1 && (n = this.positionInside(s, i), r = this.positionInside(s + e.word.length, i));
    } else
      e.start ? n = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (n = this.positionInside(e.index)), e.end ? r = {
        column: e.end.column,
        line: e.end.line
      } : e.endIndex ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
    return (r.line < n.line || r.line === n.line && r.column <= n.column) && (r = { column: n.column + 1, line: n.line }), { end: r, start: n };
  }
  raw(e, n) {
    return new u5().raw(this, e, n);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let n = this, r = !1;
      for (let i of e)
        i === this ? r = !0 : r ? (this.parent.insertAfter(n, i), n = i) : this.parent.insertBefore(n, i);
      r || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, n) {
    let r = {}, i = n == null;
    n = n || /* @__PURE__ */ new Map();
    let s = 0;
    for (let a in this) {
      if (!Object.prototype.hasOwnProperty.call(this, a) || a === "parent" || a === "proxyCache") continue;
      let o = this[a];
      if (Array.isArray(o))
        r[a] = o.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, n) : u);
      else if (typeof o == "object" && o.toJSON)
        r[a] = o.toJSON(null, n);
      else if (a === "source") {
        let u = n.get(o.input);
        u == null && (u = s, n.set(o.input, s), s++), r[a] = {
          end: o.end,
          inputId: u,
          start: o.start
        };
      } else
        r[a] = o;
    }
    return i && (r.inputs = [...n.keys()].map((a) => a.toJSON())), r;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = l5) {
    e.stringify && (e = e.stringify);
    let n = "";
    return e(this, (r) => {
      n += r;
    }), n;
  }
  warn(e, n, r) {
    let i = { node: this };
    for (let s in r) i[s] = r[s];
    return e.warn(n, i);
  }
  get proxyOf() {
    return this;
  }
};
var yl = Od;
Od.default = Od;
let c5 = yl, Nd = class extends c5 {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var Tl = Nd;
Nd.default = Nd;
let d5 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", f5 = (t = 21) => {
  let e = "", n = t | 0;
  for (; n--; )
    e += d5[Math.random() * 64 | 0];
  return e;
};
var h5 = { nanoid: f5 };
let { SourceMapConsumer: Ap, SourceMapGenerator: Ip } = Rn, { existsSync: m5, readFileSync: p5 } = Rn, { dirname: dc, join: g5 } = Rn;
function b5(t) {
  return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
}
let Md = class {
  constructor(e, n) {
    if (n.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let r = n.map ? n.map.prev : void 0, i = this.loadMap(n.from, r);
    !this.mapFile && n.from && (this.mapFile = n.from), this.mapFile && (this.root = dc(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Ap(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let n = /^data:application\/json;charset=utf-?8;base64,/, r = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/;
    if (i.test(e) || s.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (n.test(e) || r.test(e))
      return b5(e.substr(RegExp.lastMatch.length));
    let a = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + a);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let n = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!n) return;
    let r = e.lastIndexOf(n.pop()), i = e.indexOf("*/", r);
    r > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(r, i)));
  }
  loadFile(e) {
    if (this.root = dc(e), m5(e))
      return this.mapFile = e, p5(e, "utf-8").toString().trim();
  }
  loadMap(e, n) {
    if (n === !1) return !1;
    if (n) {
      if (typeof n == "string")
        return n;
      if (typeof n == "function") {
        let r = n(e);
        if (r) {
          let i = this.loadFile(r);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + r.toString()
            );
          return i;
        }
      } else {
        if (n instanceof Ap)
          return Ip.fromSourceMap(n).toString();
        if (n instanceof Ip)
          return n.toString();
        if (this.isMap(n))
          return JSON.stringify(n);
        throw new Error(
          "Unsupported previous source map format: " + n.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let r = this.annotation;
        return e && (r = g5(dc(e), r)), this.loadFile(r);
      }
    }
  }
  startWith(e, n) {
    return e ? e.substr(0, n.length) === n : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var SS = Md;
Md.default = Md;
let { SourceMapConsumer: E5, SourceMapGenerator: y5 } = Rn, { fileURLToPath: Cp, pathToFileURL: mo } = Rn, { isAbsolute: Fd, resolve: Bd } = Rn, { nanoid: T5 } = h5, fc = Rn, Lp = Lh, S5 = SS, hc = Symbol("fromOffsetCache"), x5 = !!(E5 && y5), _p = !!(Bd && Fd), Lu = class {
  constructor(e, n = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, n.from && (!_p || /^\w+:\/\//.test(n.from) || Fd(n.from) ? this.file = n.from : this.file = Bd(n.from)), _p && x5) {
      let r = new S5(this.css, n);
      if (r.text) {
        this.map = r;
        let i = r.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + T5(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, n, r, i = {}) {
    let s, a, o;
    if (n && typeof n == "object") {
      let l = n, c = r;
      if (typeof l.offset == "number") {
        let d = this.fromOffset(l.offset);
        n = d.line, r = d.col;
      } else
        n = l.line, r = l.column;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        a = d.line, o = d.col;
      } else
        a = c.line, o = c.column;
    } else if (!r) {
      let l = this.fromOffset(n);
      n = l.line, r = l.col;
    }
    let u = this.origin(n, r, a, o);
    return u ? s = new Lp(
      e,
      u.endLine === void 0 ? u.line : { column: u.column, line: u.line },
      u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine },
      u.source,
      u.file,
      i.plugin
    ) : s = new Lp(
      e,
      a === void 0 ? n : { column: r, line: n },
      a === void 0 ? r : { column: o, line: a },
      this.css,
      this.file,
      i.plugin
    ), s.input = { column: r, endColumn: o, endLine: a, line: n, source: this.css }, this.file && (mo && (s.input.url = mo(this.file).toString()), s.input.file = this.file), s;
  }
  fromOffset(e) {
    let n, r;
    if (this[hc])
      r = this[hc];
    else {
      let s = this.css.split(`
`);
      r = new Array(s.length);
      let a = 0;
      for (let o = 0, u = s.length; o < u; o++)
        r[o] = a, a += s[o].length + 1;
      this[hc] = r;
    }
    n = r[r.length - 1];
    let i = 0;
    if (e >= n)
      i = r.length - 1;
    else {
      let s = r.length - 2, a;
      for (; i < s; )
        if (a = i + (s - i >> 1), e < r[a])
          s = a - 1;
        else if (e >= r[a + 1])
          i = a + 1;
        else {
          i = a;
          break;
        }
    }
    return {
      col: e - r[i] + 1,
      line: i + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Bd(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, n, r, i) {
    if (!this.map) return !1;
    let s = this.map.consumer(), a = s.originalPositionFor({ column: n, line: e });
    if (!a.source) return !1;
    let o;
    typeof r == "number" && (o = s.originalPositionFor({ column: i, line: r }));
    let u;
    Fd(a.source) ? u = mo(a.source) : u = new URL(
      a.source,
      this.map.consumer().sourceRoot || mo(this.map.mapFile)
    );
    let l = {
      column: a.column,
      endColumn: o && o.column,
      endLine: o && o.line,
      line: a.line,
      url: u.toString()
    };
    if (u.protocol === "file:")
      if (Cp)
        l.file = Cp(u);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = s.sourceContentFor(a.source);
    return c && (l.source = c), l;
  }
  toJSON() {
    let e = {};
    for (let n of ["hasBOM", "css", "file", "id"])
      this[n] != null && (e[n] = this[n]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var Sl = Lu;
Lu.default = Lu;
fc && fc.registerInput && fc.registerInput(Lu);
let { SourceMapConsumer: xS, SourceMapGenerator: Xo } = Rn, { dirname: Qo, relative: vS, resolve: AS, sep: IS } = Rn, { pathToFileURL: Rp } = Rn, v5 = Sl, A5 = !!(xS && Xo), I5 = !!(Qo && AS && vS && IS), C5 = class {
  constructor(e, n, r, i) {
    this.stringify = e, this.mapOpts = r.map || {}, this.root = n, this.opts = r, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let n = `
`;
    this.css.includes(`\r
`) && (n = `\r
`), this.css += n + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let n = this.toUrl(this.path(e.file)), r = e.root || Qo(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new xS(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, n, this.toUrl(this.path(r)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let n = this.root.nodes.length - 1; n >= 0; n--)
          e = this.root.nodes[n], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(n);
      } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), I5 && A5 && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (n) => {
        e += n;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Xo.fromSourceMap(e);
    } else
      this.map = new Xo({ file: this.outputFile() }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Xo({ file: this.outputFile() });
    let e = 1, n = 1, r = "<no source>", i = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, s, a;
    this.stringify(this.root, (o, u, l) => {
      if (this.css += o, u && l !== "end" && (i.generated.line = e, i.generated.column = n - 1, u.source && u.source.start ? (i.source = this.sourcePath(u), i.original.line = u.source.start.line, i.original.column = u.source.start.column - 1, this.map.addMapping(i)) : (i.source = r, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), s = o.match(/\n/g), s ? (e += s.length, a = o.lastIndexOf(`
`), n = o.length - a) : n += o.length, u && l !== "start") {
        let c = u.parent || { raws: {} };
        (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== c.last || c.raws.semicolon) && (u.source && u.source.end ? (i.source = this.sourcePath(u), i.original.line = u.source.end.line, i.original.column = u.source.end.column - 1, i.generated.line = e, i.generated.column = n - 2, this.map.addMapping(i)) : (i.source = r, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = n - 1, this.map.addMapping(i)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((n) => n.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let n = this.memoizedPaths.get(e);
    if (n) return n;
    let r = this.opts.to ? Qo(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (r = Qo(AS(r, this.mapOpts.annotation)));
    let i = vS(r, e);
    return this.memoizedPaths.set(e, i), i;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let n = e.source.input.map;
            this.previousMaps.includes(n) || this.previousMaps.push(n);
          }
        });
      else {
        let e = new v5(this.css, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((n) => {
        if (n.source) {
          let r = n.source.input.from;
          if (r && !e[r]) {
            e[r] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(r) : this.toUrl(this.path(r));
            this.map.setSourceContent(i, n.source.input.css);
          }
        }
      });
    else if (this.css) {
      let n = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(n, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let n = this.memoizedFileURLs.get(e);
    if (n) return n;
    if (Rp) {
      let r = Rp(e).toString();
      return this.memoizedFileURLs.set(e, r), r;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let n = this.memoizedURLs.get(e);
    if (n) return n;
    IS === "\\" && (e = e.replace(/\\/g, "/"));
    let r = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, r), r;
  }
};
var CS = C5;
let L5 = yl, $d = class extends L5 {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var xl = $d;
$d.default = $d;
let { isClean: LS, my: _S } = qa, RS = Tl, wS = xl, _5 = yl, kS, _h, Rh, DS;
function PS(t) {
  return t.map((e) => (e.nodes && (e.nodes = PS(e.nodes)), delete e.source, e));
}
function OS(t) {
  if (t[LS] = !1, t.proxyOf.nodes)
    for (let e of t.proxyOf.nodes)
      OS(e);
}
let fr = class NS extends _5 {
  append(...e) {
    for (let n of e) {
      let r = this.normalize(n, this.last);
      for (let i of r) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let n of this.nodes) n.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let n = this.getIterator(), r, i;
    for (; this.indexes[n] < this.proxyOf.nodes.length && (r = this.indexes[n], i = e(this.proxyOf.nodes[r], r), i !== !1); )
      this.indexes[n] += 1;
    return delete this.indexes[n], i;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, n) {
        return n === "proxyOf" ? e : e[n] ? n === "each" || typeof n == "string" && n.startsWith("walk") ? (...r) => e[n](
          ...r.map((i) => typeof i == "function" ? (s, a) => i(s.toProxy(), a) : i)
        ) : n === "every" || n === "some" ? (r) => e[n](
          (i, ...s) => r(i.toProxy(), ...s)
        ) : n === "root" ? () => e.root().toProxy() : n === "nodes" ? e.nodes.map((r) => r.toProxy()) : n === "first" || n === "last" ? e[n].toProxy() : e[n] : e[n];
      },
      set(e, n, r) {
        return e[n] === r || (e[n] = r, (n === "name" || n === "params" || n === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, n) {
    let r = this.index(e), i = this.normalize(n, this.proxyOf.nodes[r]).reverse();
    r = this.index(e);
    for (let a of i) this.proxyOf.nodes.splice(r + 1, 0, a);
    let s;
    for (let a in this.indexes)
      s = this.indexes[a], r < s && (this.indexes[a] = s + i.length);
    return this.markDirty(), this;
  }
  insertBefore(e, n) {
    let r = this.index(e), i = r === 0 ? "prepend" : !1, s = this.normalize(n, this.proxyOf.nodes[r], i).reverse();
    r = this.index(e);
    for (let o of s) this.proxyOf.nodes.splice(r, 0, o);
    let a;
    for (let o in this.indexes)
      a = this.indexes[o], r <= a && (this.indexes[o] = a + s.length);
    return this.markDirty(), this;
  }
  normalize(e, n) {
    if (typeof e == "string")
      e = PS(kS(e).nodes);
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new RS(e)];
    } else if (e.selector)
      e = [new _h(e)];
    else if (e.name)
      e = [new Rh(e)];
    else if (e.text)
      e = [new wS(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[_S] || NS.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[LS] && OS(i), typeof i.raws.before > "u" && n && typeof n.raws.before < "u" && (i.raws.before = n.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  prepend(...e) {
    e = e.reverse();
    for (let n of e) {
      let r = this.normalize(n, this.first, "prepend").reverse();
      for (let i of r) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + r.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let n;
    for (let r in this.indexes)
      n = this.indexes[r], n >= e && (this.indexes[r] = n - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, n, r) {
    return r || (r = n, n = {}), this.walkDecls((i) => {
      n.props && !n.props.includes(i.prop) || n.fast && !i.value.includes(n.fast) || (i.value = i.value.replace(e, r));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((n, r) => {
      let i;
      try {
        i = e(n, r);
      } catch (s) {
        throw n.addToError(s);
      }
      return i !== !1 && n.walk && (i = n.walk(e)), i;
    });
  }
  walkAtRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "atrule" && e.test(r.name))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "atrule" && r.name === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "atrule")
        return n(r, i);
    }));
  }
  walkComments(e) {
    return this.walk((n, r) => {
      if (n.type === "comment")
        return e(n, r);
    });
  }
  walkDecls(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "decl" && e.test(r.prop))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "decl" && r.prop === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "decl")
        return n(r, i);
    }));
  }
  walkRules(e, n) {
    return n ? e instanceof RegExp ? this.walk((r, i) => {
      if (r.type === "rule" && e.test(r.selector))
        return n(r, i);
    }) : this.walk((r, i) => {
      if (r.type === "rule" && r.selector === e)
        return n(r, i);
    }) : (n = e, this.walk((r, i) => {
      if (r.type === "rule")
        return n(r, i);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
fr.registerParse = (t) => {
  kS = t;
};
fr.registerRule = (t) => {
  _h = t;
};
fr.registerAtRule = (t) => {
  Rh = t;
};
fr.registerRoot = (t) => {
  DS = t;
};
var yi = fr;
fr.default = fr;
fr.rebuild = (t) => {
  t.type === "atrule" ? Object.setPrototypeOf(t, Rh.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, _h.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, RS.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, wS.prototype) : t.type === "root" && Object.setPrototypeOf(t, DS.prototype), t[_S] = !0, t.nodes && t.nodes.forEach((e) => {
    fr.rebuild(e);
  });
};
let R5 = yi, MS, FS, Ea = class extends R5 {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new MS(new FS(), this, e).stringify();
  }
};
Ea.registerLazyResult = (t) => {
  MS = t;
};
Ea.registerProcessor = (t) => {
  FS = t;
};
var wh = Ea;
Ea.default = Ea;
let Ud = class {
  constructor(e, n = {}) {
    if (this.type = "warning", this.text = e, n.node && n.node.source) {
      let r = n.node.rangeBy(n);
      this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
    }
    for (let r in n) this[r] = n[r];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var BS = Ud;
Ud.default = Ud;
let w5 = BS, Hd = class {
  constructor(e, n, r) {
    this.processor = e, this.messages = [], this.root = n, this.opts = r, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, n = {}) {
    n.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (n.plugin = this.lastPlugin.postcssPlugin);
    let r = new w5(e, n);
    return this.messages.push(r), r;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var kh = Hd;
Hd.default = Hd;
const mc = 39, wp = 34, po = 92, kp = 47, go = 10, Bs = 32, bo = 12, Eo = 9, yo = 13, k5 = 91, D5 = 93, P5 = 40, O5 = 41, N5 = 123, M5 = 125, F5 = 59, B5 = 42, $5 = 58, U5 = 64, To = /[\t\n\f\r "#'()/;[\\\]{}]/g, So = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, H5 = /.[\r\n"'(/\\]/, Dp = /[\da-f]/i;
var V5 = function(e, n = {}) {
  let r = e.css.valueOf(), i = n.ignoreErrors, s, a, o, u, l, c, d, f, h, m, p = r.length, g = 0, b = [], y = [];
  function T() {
    return g;
  }
  function S(R) {
    throw e.error("Unclosed " + R, g);
  }
  function I() {
    return y.length === 0 && g >= p;
  }
  function C(R) {
    if (y.length) return y.pop();
    if (g >= p) return;
    let k = R ? R.ignoreUnclosed : !1;
    switch (s = r.charCodeAt(g), s) {
      case go:
      case Bs:
      case Eo:
      case yo:
      case bo: {
        a = g;
        do
          a += 1, s = r.charCodeAt(a);
        while (s === Bs || s === go || s === Eo || s === yo || s === bo);
        m = ["space", r.slice(g, a)], g = a - 1;
        break;
      }
      case k5:
      case D5:
      case N5:
      case M5:
      case $5:
      case F5:
      case O5: {
        let A = String.fromCharCode(s);
        m = [A, A, g];
        break;
      }
      case P5: {
        if (f = b.length ? b.pop()[1] : "", h = r.charCodeAt(g + 1), f === "url" && h !== mc && h !== wp && h !== Bs && h !== go && h !== Eo && h !== bo && h !== yo) {
          a = g;
          do {
            if (c = !1, a = r.indexOf(")", a + 1), a === -1)
              if (i || k) {
                a = g;
                break;
              } else
                S("bracket");
            for (d = a; r.charCodeAt(d - 1) === po; )
              d -= 1, c = !c;
          } while (c);
          m = ["brackets", r.slice(g, a + 1), g, a], g = a;
        } else
          a = r.indexOf(")", g + 1), u = r.slice(g, a + 1), a === -1 || H5.test(u) ? m = ["(", "(", g] : (m = ["brackets", u, g, a], g = a);
        break;
      }
      case mc:
      case wp: {
        o = s === mc ? "'" : '"', a = g;
        do {
          if (c = !1, a = r.indexOf(o, a + 1), a === -1)
            if (i || k) {
              a = g + 1;
              break;
            } else
              S("string");
          for (d = a; r.charCodeAt(d - 1) === po; )
            d -= 1, c = !c;
        } while (c);
        m = ["string", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      case U5: {
        To.lastIndex = g + 1, To.test(r), To.lastIndex === 0 ? a = r.length - 1 : a = To.lastIndex - 2, m = ["at-word", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      case po: {
        for (a = g, l = !0; r.charCodeAt(a + 1) === po; )
          a += 1, l = !l;
        if (s = r.charCodeAt(a + 1), l && s !== kp && s !== Bs && s !== go && s !== Eo && s !== yo && s !== bo && (a += 1, Dp.test(r.charAt(a)))) {
          for (; Dp.test(r.charAt(a + 1)); )
            a += 1;
          r.charCodeAt(a + 1) === Bs && (a += 1);
        }
        m = ["word", r.slice(g, a + 1), g, a], g = a;
        break;
      }
      default: {
        s === kp && r.charCodeAt(g + 1) === B5 ? (a = r.indexOf("*/", g + 2) + 1, a === 0 && (i || k ? a = r.length : S("comment")), m = ["comment", r.slice(g, a + 1), g, a], g = a) : (So.lastIndex = g + 1, So.test(r), So.lastIndex === 0 ? a = r.length - 1 : a = So.lastIndex - 2, m = ["word", r.slice(g, a + 1), g, a], b.push(m), g = a);
        break;
      }
    }
    return g++, m;
  }
  function _(R) {
    y.push(R);
  }
  return {
    back: _,
    endOfFile: I,
    nextToken: C,
    position: T
  };
};
let $S = yi, _u = class extends $S {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var Dh = _u;
_u.default = _u;
$S.registerAtRule(_u);
let US = yi, HS, VS, os = class extends US {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, n, r) {
    let i = super.normalize(e);
    if (n) {
      if (r === "prepend")
        this.nodes.length > 1 ? n.raws.before = this.nodes[1].raws.before : delete n.raws.before;
      else if (this.first !== n)
        for (let s of i)
          s.raws.before = n.raws.before;
    }
    return i;
  }
  removeChild(e, n) {
    let r = this.index(e);
    return !n && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new HS(new VS(), this, e).stringify();
  }
};
os.registerLazyResult = (t) => {
  HS = t;
};
os.registerProcessor = (t) => {
  VS = t;
};
var Wa = os;
os.default = os;
US.registerRoot(os);
let ya = {
  comma(t) {
    return ya.split(t, [","], !0);
  },
  space(t) {
    let e = [" ", `
`, "	"];
    return ya.split(t, e);
  },
  split(t, e, n) {
    let r = [], i = "", s = !1, a = 0, o = !1, u = "", l = !1;
    for (let c of t)
      l ? l = !1 : c === "\\" ? l = !0 : o ? c === u && (o = !1) : c === '"' || c === "'" ? (o = !0, u = c) : c === "(" ? a += 1 : c === ")" ? a > 0 && (a -= 1) : a === 0 && e.includes(c) && (s = !0), s ? (i !== "" && r.push(i.trim()), i = "", s = !1) : i += c;
    return (n || i !== "") && r.push(i.trim()), r;
  }
};
var GS = ya;
ya.default = ya;
let zS = yi, G5 = GS, Ru = class extends zS {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return G5.comma(this.selector);
  }
  set selectors(e) {
    let n = this.selector ? this.selector.match(/,\s*/) : null, r = n ? n[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(r);
  }
};
var Ph = Ru;
Ru.default = Ru;
zS.registerRule(Ru);
let z5 = Tl, q5 = V5, W5 = xl, K5 = Dh, j5 = Wa, Pp = Ph;
const Op = {
  empty: !0,
  space: !0
};
function Y5(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let n = t[e], r = n[3] || n[2];
    if (r) return r;
  }
}
let X5 = class {
  constructor(e) {
    this.input = e, this.root = new j5(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let n = new K5();
    n.name = e[1].slice(1), n.name === "" && this.unnamedAtrule(n, e), this.init(n, e[2]);
    let r, i, s, a = !1, o = !1, u = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? l.push(r === "(" ? ")" : "]") : r === "{" && l.length > 0 ? l.push("}") : r === l[l.length - 1] && l.pop(), l.length === 0)
        if (r === ";") {
          n.source.end = this.getPosition(e[2]), n.source.end.offset++, this.semicolon = !0;
          break;
        } else if (r === "{") {
          o = !0;
          break;
        } else if (r === "}") {
          if (u.length > 0) {
            for (s = u.length - 1, i = u[s]; i && i[0] === "space"; )
              i = u[--s];
            i && (n.source.end = this.getPosition(i[3] || i[2]), n.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          u.push(e);
      else
        u.push(e);
      if (this.tokenizer.endOfFile()) {
        a = !0;
        break;
      }
    }
    n.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (n.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(n, "params", u), a && (e = u[u.length - 1], n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++, this.spaces = n.raws.between, n.raws.between = "")) : (n.raws.afterName = "", n.params = ""), o && (n.nodes = [], this.current = n);
  }
  checkMissedSemicolon(e) {
    let n = this.colon(e);
    if (n === !1) return;
    let r = 0, i;
    for (let s = n - 1; s >= 0 && (i = e[s], !(i[0] !== "space" && (r += 1, r === 2))); s--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
  colon(e) {
    let n = 0, r, i, s;
    for (let [a, o] of e.entries()) {
      if (r = o, i = r[0], i === "(" && (n += 1), i === ")" && (n -= 1), n === 0 && i === ":")
        if (!s)
          this.doubleColon(r);
        else {
          if (s[0] === "word" && s[1] === "progid")
            continue;
          return a;
        }
      s = r;
    }
    return !1;
  }
  comment(e) {
    let n = new W5();
    this.init(n, e[2]), n.source.end = this.getPosition(e[3] || e[2]), n.source.end.offset++;
    let r = e[1].slice(2, -2);
    if (/^\s*$/.test(r))
      n.text = "", n.raws.left = r, n.raws.right = "";
    else {
      let i = r.match(/^(\s*)([^]*\S)(\s*)$/);
      n.text = i[2], n.raws.left = i[1], n.raws.right = i[3];
    }
  }
  createTokenizer() {
    this.tokenizer = q5(this.input);
  }
  decl(e, n) {
    let r = new z5();
    this.init(r, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), r.source.end = this.getPosition(
      i[3] || i[2] || Y5(e)
    ), r.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
    for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      r.prop += e.shift()[1];
    }
    r.raws.between = "";
    let s;
    for (; e.length; )
      if (s = e.shift(), s[0] === ":") {
        r.raws.between += s[1];
        break;
      } else
        s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), r.raws.between += s[1];
    (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
    let a = [], o;
    for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
      a.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (s = e[l], s[1].toLowerCase() === "!important") {
        r.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (r.raws.important = c);
        break;
      } else if (s[1].toLowerCase() === "important") {
        let c = e.slice(0), d = "";
        for (let f = l; f > 0; f--) {
          let h = c[f][0];
          if (d.trim().indexOf("!") === 0 && h !== "space")
            break;
          d = c.pop()[1] + d;
        }
        d.trim().indexOf("!") === 0 && (r.important = !0, r.raws.important = d, e = c);
      }
      if (s[0] !== "space" && s[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (r.raws.between += a.map((l) => l[1]).join(""), a = []), this.raw(r, "value", a.concat(e), n), r.value.includes(":") && !n && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let n = new Pp();
    this.init(n, e[2]), n.selector = "", n.raws.between = "", this.current = n;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let n = this.current.nodes[this.current.nodes.length - 1];
      n && n.type === "rule" && !n.raws.ownSemicolon && (n.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let n = this.input.fromOffset(e);
    return {
      column: n.col,
      line: n.line,
      offset: e
    };
  }
  init(e, n) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(n)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let n = !1, r = null, i = !1, s = null, a = [], o = e[1].startsWith("--"), u = [], l = e;
    for (; l; ) {
      if (r = l[0], u.push(l), r === "(" || r === "[")
        s || (s = l), a.push(r === "(" ? ")" : "]");
      else if (o && i && r === "{")
        s || (s = l), a.push("}");
      else if (a.length === 0)
        if (r === ";")
          if (i) {
            this.decl(u, o);
            return;
          } else
            break;
        else if (r === "{") {
          this.rule(u);
          return;
        } else if (r === "}") {
          this.tokenizer.back(u.pop()), n = !0;
          break;
        } else r === ":" && (i = !0);
      else r === a[a.length - 1] && (a.pop(), a.length === 0 && (s = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (n = !0), a.length > 0 && this.unclosedBracket(s), n && i) {
      if (!o)
        for (; u.length && (l = u[u.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(u.pop());
      this.decl(u, o);
    } else
      this.unknownWord(u);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, n, r, i) {
    let s, a, o = r.length, u = "", l = !0, c, d;
    for (let f = 0; f < o; f += 1)
      s = r[f], a = s[0], a === "space" && f === o - 1 && !i ? l = !1 : a === "comment" ? (d = r[f - 1] ? r[f - 1][0] : "empty", c = r[f + 1] ? r[f + 1][0] : "empty", !Op[d] && !Op[c] ? u.slice(-1) === "," ? l = !1 : u += s[1] : l = !1) : u += s[1];
    if (!l) {
      let f = r.reduce((h, m) => h + m[1], "");
      e.raws[n] = { raw: f, value: u };
    }
    e[n] = u;
  }
  rule(e) {
    e.pop();
    let n = new Pp();
    this.init(n, e[0][2]), n.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(n, "selector", e), this.current = n;
  }
  spacesAndCommentsFromEnd(e) {
    let n, r = "";
    for (; e.length && (n = e[e.length - 1][0], !(n !== "space" && n !== "comment")); )
      r = e.pop()[1] + r;
    return r;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let n, r = "";
    for (; e.length && (n = e[0][0], !(n !== "space" && n !== "comment")); )
      r += e.shift()[1];
    return r;
  }
  spacesFromEnd(e) {
    let n, r = "";
    for (; e.length && (n = e[e.length - 1][0], n === "space"); )
      r = e.pop()[1] + r;
    return r;
  }
  stringFrom(e, n) {
    let r = "";
    for (let i = n; i < e.length; i++)
      r += e[i][1];
    return e.splice(n, e.length - n), r;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, n) {
    throw this.input.error(
      "At-rule without name",
      { offset: n[2] },
      { offset: n[2] + n[1].length }
    );
  }
};
var Q5 = X5;
let Z5 = yi, J5 = Q5, eF = Sl;
function wu(t, e) {
  let n = new eF(t, e), r = new J5(n);
  try {
    r.parse();
  } catch (i) {
    throw i;
  }
  return r.root;
}
var Oh = wu;
wu.default = wu;
Z5.registerParse(wu);
let { isClean: Dn, my: tF } = qa, nF = CS, rF = El, iF = yi, sF = wh, Np = kh, aF = Oh, oF = Wa;
const uF = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, lF = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, cF = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, us = 0;
function $s(t) {
  return typeof t == "object" && typeof t.then == "function";
}
function qS(t) {
  let e = !1, n = uF[t.type];
  return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
    n,
    n + "-" + e,
    us,
    n + "Exit",
    n + "Exit-" + e
  ] : e ? [n, n + "-" + e, n + "Exit", n + "Exit-" + e] : t.append ? [n, us, n + "Exit"] : [n, n + "Exit"];
}
function Mp(t) {
  let e;
  return t.type === "document" ? e = ["Document", us, "DocumentExit"] : t.type === "root" ? e = ["Root", us, "RootExit"] : e = qS(t), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: t,
    visitorIndex: 0,
    visitors: []
  };
}
function Vd(t) {
  return t[Dn] = !1, t.nodes && t.nodes.forEach((e) => Vd(e)), t;
}
let Gd = {}, ls = class WS {
  constructor(e, n, r) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof n == "object" && n !== null && (n.type === "root" || n.type === "document"))
      i = Vd(n);
    else if (n instanceof WS || n instanceof Np)
      i = Vd(n.root), n.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = !1), r.map.prev = n.map);
    else {
      let s = aF;
      r.syntax && (s = r.syntax.parse), r.parser && (s = r.parser), s.parse && (s = s.parse);
      try {
        i = s(n, r);
      } catch (a) {
        this.processed = !0, this.error = a;
      }
      i && !i[tF] && iF.rebuild(i);
    }
    this.result = new Np(e, i, r), this.helpers = { ...Gd, postcss: Gd, result: this.result }, this.plugins = this.processor.plugins.map((s) => typeof s == "object" && s.prepare ? { ...s, ...s.prepare(this.result) } : s);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, n) {
    let r = this.result.lastPlugin;
    try {
      n && n.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (n, r, i) => {
      this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([n, i]);
    };
    for (let n of this.plugins)
      if (typeof n == "object")
        for (let r in n) {
          if (!lF[r] && /^[A-Z]/.test(r))
            throw new Error(
              `Unknown event ${r} in ${n.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!cF[r])
            if (typeof n[r] == "object")
              for (let i in n[r])
                i === "*" ? e(n, r, n[r][i]) : e(
                  n,
                  r + "-" + i.toLowerCase(),
                  n[r][i]
                );
            else typeof n[r] == "function" && e(n, r, n[r]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let n = this.plugins[e], r = this.runOnRoot(n);
      if ($s(r))
        try {
          await r;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Dn]; ) {
        e[Dn] = !0;
        let n = [Mp(e)];
        for (; n.length > 0; ) {
          let r = this.visitTick(n);
          if ($s(r))
            try {
              await r;
            } catch (i) {
              let s = n[n.length - 1].node;
              throw this.handleError(i, s);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [n, r] of this.listeners.OnceExit) {
          this.result.lastPlugin = n;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (s) => r(s, this.helpers)
              );
              await Promise.all(i);
            } else
              await r(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let n = this.result.root.nodes.map(
            (r) => e.Once(r, this.helpers)
          );
          return $s(n[0]) ? Promise.all(n) : n;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (n) {
      throw this.handleError(n);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, n = rF;
    e.syntax && (n = e.syntax.stringify), e.stringifier && (n = e.stringifier), n.stringify && (n = n.stringify);
    let i = new nF(n, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let n = this.runOnRoot(e);
      if ($s(n))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Dn]; )
        e[Dn] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let n of e.nodes)
            this.visitSync(this.listeners.OnceExit, n);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, n) {
    return this.async().then(e, n);
  }
  toString() {
    return this.css;
  }
  visitSync(e, n) {
    for (let [r, i] of e) {
      this.result.lastPlugin = r;
      let s;
      try {
        s = i(n, this.helpers);
      } catch (a) {
        throw this.handleError(a, n.proxyOf);
      }
      if (n.type !== "root" && n.type !== "document" && !n.parent)
        return !0;
      if ($s(s))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let n = e[e.length - 1], { node: r, visitors: i } = n;
    if (r.type !== "root" && r.type !== "document" && !r.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && n.visitorIndex < i.length) {
      let [a, o] = i[n.visitorIndex];
      n.visitorIndex += 1, n.visitorIndex === i.length && (n.visitors = [], n.visitorIndex = 0), this.result.lastPlugin = a;
      try {
        return o(r.toProxy(), this.helpers);
      } catch (u) {
        throw this.handleError(u, r);
      }
    }
    if (n.iterator !== 0) {
      let a = n.iterator, o;
      for (; o = r.nodes[r.indexes[a]]; )
        if (r.indexes[a] += 1, !o[Dn]) {
          o[Dn] = !0, e.push(Mp(o));
          return;
        }
      n.iterator = 0, delete r.indexes[a];
    }
    let s = n.events;
    for (; n.eventIndex < s.length; ) {
      let a = s[n.eventIndex];
      if (n.eventIndex += 1, a === us) {
        r.nodes && r.nodes.length && (r[Dn] = !0, n.iterator = r.getIterator());
        return;
      } else if (this.listeners[a]) {
        n.visitors = this.listeners[a];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Dn] = !0;
    let n = qS(e);
    for (let r of n)
      if (r === us)
        e.nodes && e.each((i) => {
          i[Dn] || this.walkSync(i);
        });
      else {
        let i = this.listeners[r];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
ls.registerPostcss = (t) => {
  Gd = t;
};
var KS = ls;
ls.default = ls;
oF.registerLazyResult(ls);
sF.registerLazyResult(ls);
let dF = CS, fF = El, hF = Oh;
const mF = kh;
let zd = class {
  constructor(e, n, r) {
    n = n.toString(), this.stringified = !1, this._processor = e, this._css = n, this._opts = r, this._map = void 0;
    let i, s = fF;
    this.result = new mF(this._processor, i, this._opts), this.result.css = n;
    let a = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return a.root;
      }
    });
    let o = new dF(s, i, this._opts, n);
    if (o.isMap()) {
      let [u, l] = o.generate();
      u && (this.result.css = u), l && (this.result.map = l);
    }
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, n) {
    return this.async().then(e, n);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, n = hF;
    try {
      e = n(this._css, this._opts);
    } catch (r) {
      this.error = r;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var pF = zd;
zd.default = zd;
let gF = pF, bF = KS, EF = wh, yF = Wa, Ta = class {
  constructor(e = []) {
    this.version = "8.4.31", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let n = [];
    for (let r of e)
      if (r.postcss === !0 ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins))
        n = n.concat(r.plugins);
      else if (typeof r == "object" && r.postcssPlugin)
        n.push(r);
      else if (typeof r == "function")
        n.push(r);
      else if (!(typeof r == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
    return n;
  }
  process(e, n = {}) {
    return this.plugins.length === 0 && typeof n.parser > "u" && typeof n.stringifier > "u" && typeof n.syntax > "u" ? new gF(this, e, n) : new bF(this, e, n);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var TF = Ta;
Ta.default = Ta;
yF.registerProcessor(Ta);
EF.registerProcessor(Ta);
let SF = Tl, xF = SS, vF = xl, AF = Dh, IF = Sl, CF = Wa, LF = Ph;
function Sa(t, e) {
  if (Array.isArray(t)) return t.map((i) => Sa(i));
  let { inputs: n, ...r } = t;
  if (n) {
    e = [];
    for (let i of n) {
      let s = { ...i, __proto__: IF.prototype };
      s.map && (s.map = {
        ...s.map,
        __proto__: xF.prototype
      }), e.push(s);
    }
  }
  if (r.nodes && (r.nodes = t.nodes.map((i) => Sa(i, e))), r.source) {
    let { inputId: i, ...s } = r.source;
    r.source = s, i != null && (r.source.input = e[i]);
  }
  if (r.type === "root")
    return new CF(r);
  if (r.type === "decl")
    return new SF(r);
  if (r.type === "rule")
    return new LF(r);
  if (r.type === "comment")
    return new vF(r);
  if (r.type === "atrule")
    return new AF(r);
  throw new Error("Unknown node type: " + t.type);
}
var _F = Sa;
Sa.default = Sa;
let RF = Lh, jS = Tl, wF = KS, kF = yi, Nh = TF, DF = El, PF = _F, YS = wh, OF = BS, XS = xl, QS = Dh, NF = kh, MF = Sl, FF = Oh, BF = GS, ZS = Ph, JS = Wa, $F = yl;
function We(...t) {
  return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new Nh(t);
}
We.plugin = function(e, n) {
  let r = !1;
  function i(...a) {
    console && console.warn && !r && (r = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let o = n(...a);
    return o.postcssPlugin = e, o.postcssVersion = new Nh().version, o;
  }
  let s;
  return Object.defineProperty(i, "postcss", {
    get() {
      return s || (s = i()), s;
    }
  }), i.process = function(a, o, u) {
    return We([i(u)]).process(a, o);
  }, i;
};
We.stringify = DF;
We.parse = FF;
We.fromJSON = PF;
We.list = BF;
We.comment = (t) => new XS(t);
We.atRule = (t) => new QS(t);
We.decl = (t) => new jS(t);
We.rule = (t) => new ZS(t);
We.root = (t) => new JS(t);
We.document = (t) => new YS(t);
We.CssSyntaxError = RF;
We.Declaration = jS;
We.Container = kF;
We.Processor = Nh;
We.Document = YS;
We.Comment = XS;
We.Warning = OF;
We.AtRule = QS;
We.Result = NF;
We.Input = MF;
We.Rule = ZS;
We.Root = JS;
We.Node = $F;
wF.registerPostcss(We);
var UF = We;
We.default = We;
const HF = zT, Fp = BM, { isPlainObject: VF } = Ih, Bp = JM, GF = e5, { parse: zF } = UF, qF = [
  "img",
  "audio",
  "video",
  "picture",
  "svg",
  "object",
  "map",
  "iframe",
  "embed"
], WF = ["script", "style"];
function Mi(t, e) {
  t && Object.keys(t).forEach(function(n) {
    e(t[n], n);
  });
}
function ar(t, e) {
  return {}.hasOwnProperty.call(t, e);
}
function $p(t, e) {
  const n = [];
  return Mi(t, function(r) {
    e(r) && n.push(r);
  }), n;
}
function KF(t) {
  for (const e in t)
    if (ar(t, e))
      return !1;
  return !0;
}
function jF(t) {
  return t.map(function(e) {
    if (!e.url)
      throw new Error("URL missing");
    return e.url + (e.w ? ` ${e.w}w` : "") + (e.h ? ` ${e.h}h` : "") + (e.d ? ` ${e.d}x` : "");
  }).join(", ");
}
var YF = xa;
const XF = /^[^\0\t\n\f\r /<=>]+$/;
function xa(t, e, n) {
  if (t == null)
    return "";
  typeof t == "number" && (t = t.toString());
  let r = "", i = "";
  function s(N, U) {
    const B = this;
    this.tag = N, this.attribs = U || {}, this.tagPosition = r.length, this.text = "", this.openingTagLength = 0, this.mediaChildren = [], this.updateParentNodeText = function() {
      if (g.length) {
        const V = g[g.length - 1];
        V.text += B.text;
      }
    }, this.updateParentNodeMediaChildren = function() {
      g.length && qF.includes(this.tag) && g[g.length - 1].mediaChildren.push(this.tag);
    };
  }
  e = Object.assign({}, xa.defaults, e), e.parser = Object.assign({}, QF, e.parser);
  const a = function(N) {
    return e.allowedTags === !1 || (e.allowedTags || []).indexOf(N) > -1;
  };
  WF.forEach(function(N) {
    a(N) && !e.allowVulnerableTags && console.warn(`

 Your \`allowedTags\` option includes, \`${N}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
  });
  const o = e.nonTextTags || [
    "script",
    "style",
    "textarea",
    "option"
  ];
  let u, l;
  e.allowedAttributes && (u = {}, l = {}, Mi(e.allowedAttributes, function(N, U) {
    u[U] = [];
    const B = [];
    N.forEach(function(V) {
      typeof V == "string" && V.indexOf("*") >= 0 ? B.push(Fp(V).replace(/\\\*/g, ".*")) : u[U].push(V);
    }), B.length && (l[U] = new RegExp("^(" + B.join("|") + ")$"));
  }));
  const c = {}, d = {}, f = {};
  Mi(e.allowedClasses, function(N, U) {
    if (u && (ar(u, U) || (u[U] = []), u[U].push("class")), c[U] = N, Array.isArray(N)) {
      const B = [];
      c[U] = [], f[U] = [], N.forEach(function(V) {
        typeof V == "string" && V.indexOf("*") >= 0 ? B.push(Fp(V).replace(/\\\*/g, ".*")) : V instanceof RegExp ? f[U].push(V) : c[U].push(V);
      }), B.length && (d[U] = new RegExp("^(" + B.join("|") + ")$"));
    }
  });
  const h = {};
  let m;
  Mi(e.transformTags, function(N, U) {
    let B;
    typeof N == "function" ? B = N : typeof N == "string" && (B = xa.simpleTransform(N)), U === "*" ? m = B : h[U] = B;
  });
  let p, g, b, y, T, S, I = !1;
  _();
  const C = new HF.Parser({
    onopentag: function(N, U) {
      if (e.onOpenTag && e.onOpenTag(N, U), e.enforceHtmlBoundary && N === "html" && _(), T) {
        S++;
        return;
      }
      const B = new s(N, U);
      g.push(B);
      let V = !1;
      const K = !!B.text;
      let w;
      if (ar(h, N) && (w = h[N](N, U), B.attribs = U = w.attribs, w.text !== void 0 && (B.innerText = w.text), N !== w.tagName && (B.name = N = w.tagName, y[p] = w.tagName)), m && (w = m(N, U), B.attribs = U = w.attribs, N !== w.tagName && (B.name = N = w.tagName, y[p] = w.tagName)), (!a(N) || e.disallowedTagsMode === "recursiveEscape" && !KF(b) || e.nestingLimit != null && p >= e.nestingLimit) && (V = !0, b[p] = !0, (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && o.indexOf(N) !== -1 && (T = !0, S = 1)), p++, V) {
        if (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") {
          if (B.innerText && !K) {
            const D = R(B.innerText);
            e.textFilter ? r += e.textFilter(D, N) : r += D, I = !0;
          }
          return;
        }
        i = r, r = "";
      }
      r += "<" + N, N === "script" && (e.allowedScriptHostnames || e.allowedScriptDomains) && (B.innerText = ""), V && (e.disallowedTagsMode === "escape" || e.disallowedTagsMode === "recursiveEscape") && e.preserveEscapedAttributes ? Mi(U, function(D, te) {
        r += " " + te + '="' + R(D || "", !0) + '"';
      }) : (!u || ar(u, N) || u["*"]) && Mi(U, function(D, te) {
        if (!XF.test(te)) {
          delete B.attribs[te];
          return;
        }
        if (D === "" && !e.allowedEmptyAttributes.includes(te) && (e.nonBooleanAttributes.includes(te) || e.nonBooleanAttributes.includes("*"))) {
          delete B.attribs[te];
          return;
        }
        let he = !1;
        if (!u || ar(u, N) && u[N].indexOf(te) !== -1 || u["*"] && u["*"].indexOf(te) !== -1 || ar(l, N) && l[N].test(te) || l["*"] && l["*"].test(te))
          he = !0;
        else if (u && u[N]) {
          for (const ie of u[N])
            if (VF(ie) && ie.name && ie.name === te) {
              he = !0;
              let X = "";
              if (ie.multiple === !0) {
                const fe = D.split(" ");
                for (const Te of fe)
                  ie.values.indexOf(Te) !== -1 && (X === "" ? X = Te : X += " " + Te);
              } else ie.values.indexOf(D) >= 0 && (X = D);
              D = X;
            }
        }
        if (he) {
          if (e.allowedSchemesAppliedToAttributes.indexOf(te) !== -1 && k(N, D)) {
            delete B.attribs[te];
            return;
          }
          if (N === "script" && te === "src") {
            let ie = !0;
            try {
              const X = A(D);
              if (e.allowedScriptHostnames || e.allowedScriptDomains) {
                const fe = (e.allowedScriptHostnames || []).find(function(me) {
                  return me === X.url.hostname;
                }), Te = (e.allowedScriptDomains || []).find(function(me) {
                  return X.url.hostname === me || X.url.hostname.endsWith(`.${me}`);
                });
                ie = fe || Te;
              }
            } catch {
              ie = !1;
            }
            if (!ie) {
              delete B.attribs[te];
              return;
            }
          }
          if (N === "iframe" && te === "src") {
            let ie = !0;
            try {
              const X = A(D);
              if (X.isRelativeUrl)
                ie = ar(e, "allowIframeRelativeUrls") ? e.allowIframeRelativeUrls : !e.allowedIframeHostnames && !e.allowedIframeDomains;
              else if (e.allowedIframeHostnames || e.allowedIframeDomains) {
                const fe = (e.allowedIframeHostnames || []).find(function(me) {
                  return me === X.url.hostname;
                }), Te = (e.allowedIframeDomains || []).find(function(me) {
                  return X.url.hostname === me || X.url.hostname.endsWith(`.${me}`);
                });
                ie = fe || Te;
              }
            } catch {
              ie = !1;
            }
            if (!ie) {
              delete B.attribs[te];
              return;
            }
          }
          if (te === "srcset")
            try {
              let ie = GF(D);
              if (ie.forEach(function(X) {
                k("srcset", X.url) && (X.evil = !0);
              }), ie = $p(ie, function(X) {
                return !X.evil;
              }), ie.length)
                D = jF($p(ie, function(X) {
                  return !X.evil;
                })), B.attribs[te] = D;
              else {
                delete B.attribs[te];
                return;
              }
            } catch {
              delete B.attribs[te];
              return;
            }
          if (te === "class") {
            const ie = c[N], X = c["*"], fe = d[N], Te = f[N], me = f["*"], ye = d["*"], Ee = [
              fe,
              ye
            ].concat(Te, me).filter(function(He) {
              return He;
            });
            if (ie && X ? D = G(D, Bp(ie, X), Ee) : D = G(D, ie || X, Ee), !D.length) {
              delete B.attribs[te];
              return;
            }
          }
          if (te === "style") {
            if (e.parseStyleAttributes)
              try {
                const ie = zF(N + " {" + D + "}", { map: !1 }), X = L(ie, e.allowedStyles);
                if (D = P(X), D.length === 0) {
                  delete B.attribs[te];
                  return;
                }
              } catch {
                typeof window < "u" && console.warn('Failed to parse "' + N + " {" + D + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete B.attribs[te];
                return;
              }
            else if (e.allowedStyles)
              throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
          }
          r += " " + te, D && D.length ? r += '="' + R(D, !0) + '"' : e.allowedEmptyAttributes.includes(te) && (r += '=""');
        } else
          delete B.attribs[te];
      }), e.selfClosing.indexOf(N) !== -1 ? r += " />" : (r += ">", B.innerText && !K && !e.textFilter && (r += R(B.innerText), I = !0)), V && (r = i + R(r), i = ""), B.openingTagLength = r.length - B.tagPosition;
    },
    ontext: function(N) {
      if (T)
        return;
      const U = g[g.length - 1];
      let B;
      if (U && (B = U.tag, N = U.innerText !== void 0 ? U.innerText : N), e.disallowedTagsMode === "completelyDiscard" && !a(B))
        N = "";
      else if ((e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && (B === "script" || B === "style"))
        r += N;
      else if (!I) {
        const V = R(N, !1);
        e.textFilter ? r += e.textFilter(V, B) : r += V;
      }
      if (g.length) {
        const V = g[g.length - 1];
        V.text += N;
      }
    },
    onclosetag: function(N, U) {
      if (e.onCloseTag && e.onCloseTag(N, U), T)
        if (S--, !S)
          T = !1;
        else
          return;
      const B = g.pop();
      if (!B)
        return;
      if (B.tag !== N) {
        g.push(B);
        return;
      }
      T = e.enforceHtmlBoundary ? N === "html" : !1, p--;
      const V = b[p];
      if (V) {
        if (delete b[p], e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") {
          B.updateParentNodeText();
          return;
        }
        i = r, r = "";
      }
      if (y[p] && (N = y[p], delete y[p]), e.exclusiveFilter) {
        const K = e.exclusiveFilter(B);
        if (K === "excludeTag") {
          V && (r = i, i = ""), r = r.substring(0, B.tagPosition) + r.substring(B.tagPosition + B.openingTagLength);
          return;
        } else if (K) {
          r = r.substring(0, B.tagPosition);
          return;
        }
      }
      if (B.updateParentNodeMediaChildren(), B.updateParentNodeText(), // Already output />
      e.selfClosing.indexOf(N) !== -1 || // Escaped tag, closing tag is implied
      U && !a(N) && ["escape", "recursiveEscape"].indexOf(e.disallowedTagsMode) >= 0) {
        V && (r = i, i = "");
        return;
      }
      r += "</" + N + ">", V && (r = i + R(r), i = ""), I = !1;
    }
  }, e.parser);
  return C.write(t), C.end(), r;
  function _() {
    r = "", p = 0, g = [], b = {}, y = {}, T = !1, S = 0;
  }
  function R(N, U) {
    return typeof N != "string" && (N = N + ""), e.parser.decodeEntities && (N = N.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), U && (N = N.replace(/"/g, "&quot;"))), N = N.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), U && (N = N.replace(/"/g, "&quot;")), N;
  }
  function k(N, U) {
    for (U = U.replace(/[\x00-\x20]+/g, ""); ; ) {
      const K = U.indexOf("<!--");
      if (K === -1)
        break;
      const w = U.indexOf("-->", K + 4);
      if (w === -1)
        break;
      U = U.substring(0, K) + U.substring(w + 3);
    }
    const B = U.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!B)
      return U.match(/^[/\\]{2}/) ? !e.allowProtocolRelative : !1;
    const V = B[1].toLowerCase();
    return ar(e.allowedSchemesByTag, N) ? e.allowedSchemesByTag[N].indexOf(V) === -1 : !e.allowedSchemes || e.allowedSchemes.indexOf(V) === -1;
  }
  function A(N) {
    if (N = N.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), N.startsWith("relative:"))
      throw new Error("relative: exploit attempt");
    let U = "relative://relative-site";
    for (let K = 0; K < 100; K++)
      U += `/${K}`;
    const B = new URL(N, U);
    return {
      isRelativeUrl: B && B.hostname === "relative-site" && B.protocol === "relative:",
      url: B
    };
  }
  function L(N, U) {
    if (!U)
      return N;
    const B = N.nodes[0];
    let V;
    return U[B.selector] && U["*"] ? V = Bp(
      U[B.selector],
      U["*"]
    ) : V = U[B.selector] || U["*"], V && (N.nodes[0].nodes = B.nodes.reduce($(V), [])), N;
  }
  function P(N) {
    return N.nodes[0].nodes.reduce(function(U, B) {
      return U.push(
        `${B.prop}:${B.value}${B.important ? " !important" : ""}`
      ), U;
    }, []).join(";");
  }
  function $(N) {
    return function(U, B) {
      return ar(N, B.prop) && N[B.prop].some(function(K) {
        return K.test(B.value);
      }) && U.push(B), U;
    };
  }
  function G(N, U, B) {
    return U ? (N = N.split(/\s+/), N.filter(function(V) {
      return U.indexOf(V) !== -1 || B.some(function(K) {
        return K.test(V);
      });
    }).join(" ")) : N;
  }
}
const QF = {
  decodeEntities: !0
};
xa.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    "address",
    "article",
    "aside",
    "footer",
    "header",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hgroup",
    "main",
    "nav",
    "section",
    // Text content
    "blockquote",
    "dd",
    "div",
    "dl",
    "dt",
    "figcaption",
    "figure",
    "hr",
    "li",
    "menu",
    "ol",
    "p",
    "pre",
    "ul",
    // Inline text semantics
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "cite",
    "code",
    "data",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "time",
    "u",
    "var",
    "wbr",
    // Table content
    "caption",
    "col",
    "colgroup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    "abbr",
    "accept",
    "accept-charset",
    "accesskey",
    "action",
    "allow",
    "alt",
    "as",
    "autocapitalize",
    "autocomplete",
    "blocking",
    "charset",
    "cite",
    "class",
    "color",
    "cols",
    "colspan",
    "content",
    "contenteditable",
    "coords",
    "crossorigin",
    "data",
    "datetime",
    "decoding",
    "dir",
    "dirname",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "fetchpriority",
    "for",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formtarget",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "http-equiv",
    "id",
    "imagesizes",
    "imagesrcset",
    "inputmode",
    "integrity",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemtype",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "name",
    "nonce",
    "optimum",
    "pattern",
    "ping",
    "placeholder",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "referrerpolicy",
    "rel",
    "rows",
    "rowspan",
    "sandbox",
    "scope",
    "shape",
    "size",
    "sizes",
    "slot",
    "span",
    "spellcheck",
    "src",
    "srcdoc",
    "srclang",
    "srcset",
    "start",
    "step",
    "style",
    "tabindex",
    "target",
    "title",
    "translate",
    "type",
    "usemap",
    "value",
    "width",
    "wrap",
    // Event handlers
    "onauxclick",
    "onafterprint",
    "onbeforematch",
    "onbeforeprint",
    "onbeforeunload",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onpagehide",
    "onpageshow",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onrejectionhandled",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwheel"
  ],
  disallowedTagsMode: "discard",
  allowedAttributes: {
    a: ["href", "name", "target"],
    // We don't currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
  },
  allowedEmptyAttributes: [
    "alt"
  ],
  // Lots of these won't come up by default because we don't allow them
  selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
  // URL schemes we permit
  allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
  allowProtocolRelative: !0,
  enforceHtmlBoundary: !1,
  parseStyleAttributes: !0,
  preserveEscapedAttributes: !1
};
xa.simpleTransform = function(t, e, n) {
  return n = n === void 0 ? !0 : n, e = e || {}, function(r, i) {
    let s;
    if (n)
      for (s in e)
        i[s] = e[s];
    else
      i = e;
    return {
      tagName: t,
      attribs: i
    };
  };
};
const ZF = /* @__PURE__ */ yT(YF);
function JF(t) {
  return { __html: eB(t) };
}
function Qn(t, e) {
  const n = Object.keys(t).filter(
    (i) => e.includes(i) ? null : i
  ), r = new Object();
  return n.forEach((i) => {
    r[i] = t[i];
  }), r;
}
function eB(t) {
  return ZF(t, {
    allowedAttributes: {
      a: ["href"],
      img: ["alt", "src", "height", "width"]
    },
    allowedSchemes: ["http", "https", "mailto"],
    allowedTags: [
      "a",
      "b",
      "br",
      "i",
      "img",
      "p",
      "small",
      "span",
      "sub",
      "sup"
    ]
  });
}
const tB = le("span", {}), yr = (t) => {
  const { as: e, label: n } = t, i = Qn(t, ["as", "label"]);
  return /* @__PURE__ */ v.createElement(tB, { as: e, ...i }, fn(n, i.lang));
}, de = Number.isFinite || function(t) {
  return typeof t == "number" && isFinite(t);
}, nB = Number.isSafeInteger || function(t) {
  return typeof t == "number" && Math.abs(t) <= rB;
}, rB = Number.MAX_SAFE_INTEGER || 9007199254740991;
let be = /* @__PURE__ */ function(t) {
  return t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError", t;
}({}), q = /* @__PURE__ */ function(t) {
  return t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError", t.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError", t.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_PARSING_ERROR = "levelParsingError", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.FRAG_GAP = "fragGap", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.ASSET_LIST_LOAD_ERROR = "assetListLoadError", t.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout", t.ASSET_LIST_PARSING_ERROR = "assetListParsingError", t.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.ATTACH_MEDIA_ERROR = "attachMediaError", t.UNKNOWN = "unknown", t;
}({}), x = /* @__PURE__ */ function(t) {
  return t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.MEDIA_ENDED = "hlsMediaEnded", t.STALL_RESOLVED = "hlsStallResolved", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFERED_TO_END = "hlsBufferedToEnd", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached", t.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded", t.ASSET_LIST_LOADING = "hlsAssetListLoading", t.ASSET_LIST_LOADED = "hlsAssetListLoaded", t.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated", t.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary", t.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated", t.INTERSTITIAL_STARTED = "hlsInterstitialStarted", t.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted", t.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded", t.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError", t.INTERSTITIAL_ENDED = "hlsInterstitialEnded", t.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed", t.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached", t.EVENT_CUE_ENTER = "hlsEventCueEnter", t;
}({});
var Me = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
}, pe = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
class Li {
  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  constructor(e, n = 0, r = 0) {
    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = n, this.totalWeight_ = r;
  }
  sample(e, n) {
    const r = Math.pow(this.alpha_, e);
    this.estimate_ = n * (1 - r) + r * this.estimate_, this.totalWeight_ += e;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (e)
        return this.estimate_ / e;
    }
    return this.estimate_;
  }
}
class iB {
  constructor(e, n, r, i = 100) {
    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new Li(e), this.fast_ = new Li(n), this.defaultTTFB_ = i, this.ttfb_ = new Li(e);
  }
  update(e, n) {
    const {
      slow_: r,
      fast_: i,
      ttfb_: s
    } = this;
    r.halfLife !== e && (this.slow_ = new Li(e, r.getEstimate(), r.getTotalWeight())), i.halfLife !== n && (this.fast_ = new Li(n, i.getEstimate(), i.getTotalWeight())), s.halfLife !== e && (this.ttfb_ = new Li(e, s.getEstimate(), s.getTotalWeight()));
  }
  sample(e, n) {
    e = Math.max(e, this.minDelayMs_);
    const r = 8 * n, i = e / 1e3, s = r / i;
    this.fast_.sample(i, s), this.slow_.sample(i, s);
  }
  sampleTTFB(e) {
    const n = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(n, 2) / 2);
    this.ttfb_.sample(r, Math.max(e, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;
  }
  get defaultEstimate() {
    return this.defaultEstimate_;
  }
  destroy() {
  }
}
function sB(t, e, n) {
  return (e = oB(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Xe() {
  return Xe = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, Xe.apply(null, arguments);
}
function Up(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ze(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Up(Object(n), !0).forEach(function(r) {
      sB(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Up(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function aB(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function oB(t) {
  var e = aB(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
class En {
  constructor(e, n) {
    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;
    const r = `[${e}]:`;
    this.trace = Lr, this.debug = n.debug.bind(null, r), this.log = n.log.bind(null, r), this.warn = n.warn.bind(null, r), this.info = n.info.bind(null, r), this.error = n.error.bind(null, r);
  }
}
const Lr = function() {
}, uB = {
  trace: Lr,
  debug: Lr,
  log: Lr,
  warn: Lr,
  info: Lr,
  error: Lr
};
function qd() {
  return Xe({}, uB);
}
function lB(t, e) {
  const n = self.console[t];
  return n ? n.bind(self.console, `${e ? "[" + e + "] " : ""}[${t}] >`) : Lr;
}
function Hp(t, e, n) {
  return e[t] ? e[t].bind(e) : lB(t, n);
}
const Wd = qd();
function cB(t, e, n) {
  const r = qd();
  if (typeof console == "object" && t === !0 || typeof t == "object") {
    const i = [
      // Remove out from list here to hard-disable a log-level
      // 'trace',
      "debug",
      "log",
      "info",
      "warn",
      "error"
    ];
    i.forEach((s) => {
      r[s] = Hp(s, t, n);
    });
    try {
      r.log(`Debug logs enabled for "${e}" in hls.js version 1.6.13`);
    } catch {
      return qd();
    }
    i.forEach((s) => {
      Wd[s] = Hp(s, t);
    });
  } else
    Xe(Wd, r);
  return r;
}
const qe = Wd;
function Or(t = !0) {
  return typeof self > "u" ? void 0 : (t || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;
}
function dB(t) {
  return typeof self < "u" && t === self.ManagedMediaSource;
}
function ex(t, e) {
  const n = Object.keys(t), r = Object.keys(e), i = n.length, s = r.length;
  return !i || !s || i === s && !n.some((a) => r.indexOf(a) === -1);
}
function cn(t, e = !1) {
  if (typeof TextDecoder < "u") {
    const l = new TextDecoder("utf-8").decode(t);
    if (e) {
      const c = l.indexOf("\0");
      return c !== -1 ? l.substring(0, c) : l;
    }
    return l.replace(/\0/g, "");
  }
  const n = t.length;
  let r, i, s, a = "", o = 0;
  for (; o < n; ) {
    if (r = t[o++], r === 0 && e)
      return a;
    if (r === 0 || r === 3)
      continue;
    switch (r >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        a += String.fromCharCode(r);
        break;
      case 12:
      case 13:
        i = t[o++], a += String.fromCharCode((r & 31) << 6 | i & 63);
        break;
      case 14:
        i = t[o++], s = t[o++], a += String.fromCharCode((r & 15) << 12 | (i & 63) << 6 | (s & 63) << 0);
        break;
    }
  }
  return a;
}
function Ft(t) {
  let e = "";
  for (let n = 0; n < t.length; n++) {
    let r = t[n].toString(16);
    r.length < 2 && (r = "0" + r), e += r;
  }
  return e;
}
function tx(t) {
  return Uint8Array.from(t.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}
function fB(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var pc = { exports: {} }, Vp;
function hB() {
  return Vp || (Vp = 1, function(t, e) {
    (function(n) {
      var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\/?#]*))\1([^]*)$/, s = /(?:\/|^)\.(?=\/)/g, a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, o = {
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(u, l, c) {
          if (c = c || {}, u = u.trim(), l = l.trim(), !l) {
            if (!c.alwaysNormalize)
              return u;
            var d = o.parseURL(u);
            if (!d)
              throw new Error("Error trying to parse base URL.");
            return d.path = o.normalizePath(
              d.path
            ), o.buildURLFromParts(d);
          }
          var f = o.parseURL(l);
          if (!f)
            throw new Error("Error trying to parse relative URL.");
          if (f.scheme)
            return c.alwaysNormalize ? (f.path = o.normalizePath(f.path), o.buildURLFromParts(f)) : l;
          var h = o.parseURL(u);
          if (!h)
            throw new Error("Error trying to parse base URL.");
          if (!h.netLoc && h.path && h.path[0] !== "/") {
            var m = i.exec(h.path);
            h.netLoc = m[1], h.path = m[2];
          }
          h.netLoc && !h.path && (h.path = "/");
          var p = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: h.scheme,
            netLoc: f.netLoc,
            path: null,
            params: f.params,
            query: f.query,
            fragment: f.fragment
          };
          if (!f.netLoc && (p.netLoc = h.netLoc, f.path[0] !== "/"))
            if (!f.path)
              p.path = h.path, f.params || (p.params = h.params, f.query || (p.query = h.query));
            else {
              var g = h.path, b = g.substring(0, g.lastIndexOf("/") + 1) + f.path;
              p.path = o.normalizePath(b);
            }
          return p.path === null && (p.path = c.alwaysNormalize ? o.normalizePath(f.path) : f.path), o.buildURLFromParts(p);
        },
        parseURL: function(u) {
          var l = r.exec(u);
          return l ? {
            scheme: l[1] || "",
            netLoc: l[2] || "",
            path: l[3] || "",
            params: l[4] || "",
            query: l[5] || "",
            fragment: l[6] || ""
          } : null;
        },
        normalizePath: function(u) {
          for (u = u.split("").reverse().join("").replace(s, ""); u.length !== (u = u.replace(a, "")).length; )
            ;
          return u.split("").reverse().join("");
        },
        buildURLFromParts: function(u) {
          return u.scheme + u.netLoc + u.path + u.params + u.query + u.fragment;
        }
      };
      t.exports = o;
    })();
  }(pc)), pc.exports;
}
var Mh = hB();
class Fh {
  constructor() {
    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
      start: 0,
      first: 0,
      end: 0
    }, this.parsing = {
      start: 0,
      end: 0
    }, this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var Qe = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};
class nx {
  constructor(e) {
    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == "string" && (e = {
      url: e
    }), this.base = e, pB(this, "stats");
  }
  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array
  setByteRange(e, n) {
    const r = e.split("@", 2);
    let i;
    r.length === 1 ? i = (n == null ? void 0 : n.byteRangeEndOffset) || 0 : i = parseInt(r[1]), this._byteRange = [i, parseInt(r[0]) + i];
  }
  get baseurl() {
    return this.base.url;
  }
  get byteRange() {
    return this._byteRange === null ? [] : this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get elementaryStreams() {
    return this._streams === null && (this._streams = {
      [Qe.AUDIO]: null,
      [Qe.VIDEO]: null,
      [Qe.AUDIOVIDEO]: null
    }), this._streams;
  }
  set elementaryStreams(e) {
    this._streams = e;
  }
  get hasStats() {
    return this._stats !== null;
  }
  get hasStreams() {
    return this._streams !== null;
  }
  get stats() {
    return this._stats === null && (this._stats = new Fh()), this._stats;
  }
  set stats(e) {
    this._stats = e;
  }
  get url() {
    return !this._url && this.baseurl && this.relurl && (this._url = Mh.buildAbsoluteURL(this.baseurl, this.relurl, {
      alwaysNormalize: !0
    })), this._url || "";
  }
  set url(e) {
    this._url = e;
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams: e
    } = this;
    e[Qe.AUDIO] = null, e[Qe.VIDEO] = null, e[Qe.AUDIOVIDEO] = null;
  }
}
function gt(t) {
  return t.sn !== "initSegment";
}
class gc extends nx {
  constructor(e, n) {
    super(n), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;
  }
  get byteLength() {
    if (this.hasStats) {
      const e = this.stats.total;
      if (e)
        return e;
    }
    if (this.byteRange.length) {
      const e = this.byteRange[0], n = this.byteRange[1];
      if (de(e) && de(n))
        return n - e;
    }
    return null;
  }
  get bitrate() {
    return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;
  }
  set bitrate(e) {
    this._bitrate = e;
  }
  get decryptdata() {
    var e;
    const {
      levelkeys: n
    } = this;
    if (!n || n.NONE)
      return null;
    if (n.identity)
      this._decryptdata || (this._decryptdata = n.identity.getDecryptData(this.sn));
    else if (!((e = this._decryptdata) != null && e.keyId)) {
      const r = Object.keys(n);
      if (r.length === 1) {
        const i = this._decryptdata = n[r[0]] || null;
        i && (this._decryptdata = i.getDecryptData(this.sn, n));
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null)
      return null;
    const e = de(this.duration) ? this.duration : 0;
    return this.programDateTime + e * 1e3;
  }
  get encrypted() {
    var e;
    if ((e = this._decryptdata) != null && e.encrypted)
      return !0;
    if (this.levelkeys) {
      var n;
      const r = Object.keys(this.levelkeys), i = r.length;
      if (i > 1 || i === 1 && (n = this.levelkeys[r[0]]) != null && n.encrypted)
        return !0;
    }
    return !1;
  }
  get programDateTime() {
    return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;
  }
  set programDateTime(e) {
    if (!de(e)) {
      this._programDateTime = this.rawProgramDateTime = null;
      return;
    }
    this._programDateTime = e;
  }
  get ref() {
    return gt(this) ? (this._ref || (this._ref = {
      base: this.base,
      start: this.start,
      duration: this.duration,
      sn: this.sn,
      programDateTime: this.programDateTime
    }), this._ref) : null;
  }
  addStart(e) {
    this.setStart(this.start + e);
  }
  setStart(e) {
    this.start = e, this._ref && (this._ref.start = e);
  }
  setDuration(e) {
    this.duration = e, this._ref && (this._ref.duration = e);
  }
  setKeyFormat(e) {
    const n = this.levelkeys;
    if (n) {
      var r;
      const i = n[e];
      i && !((r = this._decryptdata) != null && r.keyId) && (this._decryptdata = i.getDecryptData(this.sn, n));
    }
  }
  abortRequests() {
    var e, n;
    (e = this.loader) == null || e.abort(), (n = this.keyLoader) == null || n.abort();
  }
  setElementaryStreamInfo(e, n, r, i, s, a = !1) {
    const {
      elementaryStreams: o
    } = this, u = o[e];
    if (!u) {
      o[e] = {
        startPTS: n,
        endPTS: r,
        startDTS: i,
        endDTS: s,
        partial: a
      };
      return;
    }
    u.startPTS = Math.min(u.startPTS, n), u.endPTS = Math.max(u.endPTS, r), u.startDTS = Math.min(u.startDTS, i), u.endDTS = Math.max(u.endDTS, s);
  }
}
class mB extends nx {
  constructor(e, n, r, i, s) {
    super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = n, this.index = i;
    const a = e.enumeratedString("BYTERANGE");
    a && this.setByteRange(a, s), s && (this.fragOffset = s.fragOffset + s.duration);
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams: e
    } = this;
    return !!(e.audio || e.video || e.audiovideo);
  }
}
function rx(t, e) {
  const n = Object.getPrototypeOf(t);
  if (n) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    return r || rx(n, e);
  }
}
function pB(t, e) {
  const n = rx(t, e);
  n && (n.enumerable = !0, Object.defineProperty(t, e, n));
}
const Gp = Math.pow(2, 32) - 1, gB = [].push, ix = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function Et(t) {
  return String.fromCharCode.apply(null, t);
}
function sx(t, e) {
  const n = t[e] << 8 | t[e + 1];
  return n < 0 ? 65536 + n : n;
}
function xe(t, e) {
  const n = ax(t, e);
  return n < 0 ? 4294967296 + n : n;
}
function zp(t, e) {
  let n = xe(t, e);
  return n *= Math.pow(2, 32), n += xe(t, e + 4), n;
}
function ax(t, e) {
  return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
function bB(t) {
  const e = t.byteLength;
  for (let n = 0; n < e; ) {
    const r = xe(t, n);
    if (r > 8 && t[n + 4] === 109 && t[n + 5] === 111 && t[n + 6] === 111 && t[n + 7] === 102)
      return !0;
    n = r > 1 ? n + r : e;
  }
  return !1;
}
function Pe(t, e) {
  const n = [];
  if (!e.length)
    return n;
  const r = t.byteLength;
  for (let i = 0; i < r; ) {
    const s = xe(t, i), a = Et(t.subarray(i + 4, i + 8)), o = s > 1 ? i + s : r;
    if (a === e[0])
      if (e.length === 1)
        n.push(t.subarray(i + 8, o));
      else {
        const u = Pe(t.subarray(i + 8, o), e.slice(1));
        u.length && gB.apply(n, u);
      }
    i = o;
  }
  return n;
}
function EB(t) {
  const e = [], n = t[0];
  let r = 8;
  const i = xe(t, r);
  r += 4;
  let s = 0, a = 0;
  n === 0 ? (s = xe(t, r), a = xe(t, r + 4), r += 8) : (s = zp(t, r), a = zp(t, r + 8), r += 16), r += 2;
  let o = t.length + a;
  const u = sx(t, r);
  r += 2;
  for (let l = 0; l < u; l++) {
    let c = r;
    const d = xe(t, c);
    c += 4;
    const f = d & 2147483647;
    if ((d & 2147483648) >>> 31 === 1)
      return qe.warn("SIDX has hierarchical references (not supported)"), null;
    const m = xe(t, c);
    c += 4, e.push({
      referenceSize: f,
      subsegmentDuration: m,
      // unscaled
      info: {
        duration: m / i,
        start: o,
        end: o + f - 1
      }
    }), o += f, c += 4, r = c;
  }
  return {
    earliestPresentationTime: s,
    timescale: i,
    version: n,
    referencesCount: u,
    references: e
  };
}
function ox(t) {
  const e = [], n = Pe(t, ["moov", "trak"]);
  for (let i = 0; i < n.length; i++) {
    const s = n[i], a = Pe(s, ["tkhd"])[0];
    if (a) {
      let o = a[0];
      const u = xe(a, o === 0 ? 12 : 20), l = Pe(s, ["mdia", "mdhd"])[0];
      if (l) {
        o = l[0];
        const c = xe(l, o === 0 ? 12 : 20), d = Pe(s, ["mdia", "hdlr"])[0];
        if (d) {
          const f = Et(d.subarray(8, 12)), h = {
            soun: Qe.AUDIO,
            vide: Qe.VIDEO
          }[f], m = Pe(s, ["mdia", "minf", "stbl", "stsd"])[0], p = yB(m);
          h ? (e[u] = {
            timescale: c,
            type: h,
            stsd: p
          }, e[h] = ze({
            timescale: c,
            id: u
          }, p)) : e[u] = {
            timescale: c,
            type: f,
            stsd: p
          };
        }
      }
    }
  }
  return Pe(t, ["moov", "mvex", "trex"]).forEach((i) => {
    const s = xe(i, 4), a = e[s];
    a && (a.default = {
      duration: xe(i, 12),
      flags: xe(i, 20)
    });
  }), e;
}
function yB(t) {
  const e = t.subarray(8), n = e.subarray(86), r = Et(e.subarray(4, 8));
  let i = r, s;
  const a = r === "enca" || r === "encv";
  if (a) {
    const l = Pe(e, [r])[0].subarray(r === "enca" ? 28 : 78);
    Pe(l, ["sinf"]).forEach((d) => {
      const f = Pe(d, ["schm"])[0];
      if (f) {
        const h = Et(f.subarray(4, 8));
        if (h === "cbcs" || h === "cenc") {
          const m = Pe(d, ["frma"])[0];
          m && (i = Et(m));
        }
      }
    });
  }
  const o = i;
  switch (i) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const u = Pe(n, ["avcC"])[0];
      u && u.length > 3 && (i += "." + vo(u[1]) + vo(u[2]) + vo(u[3]), s = xo(o === "avc1" ? "dva1" : "dvav", n));
      break;
    }
    case "mp4a": {
      const u = Pe(e, [r])[0], l = Pe(u.subarray(28), ["esds"])[0];
      if (l && l.length > 7) {
        let c = 4;
        if (l[c++] !== 3)
          break;
        c = bc(l, c), c += 2;
        const d = l[c++];
        if (d & 128 && (c += 2), d & 64 && (c += l[c++]), l[c++] !== 4)
          break;
        c = bc(l, c);
        const f = l[c++];
        if (f === 64)
          i += "." + vo(f);
        else
          break;
        if (c += 12, l[c++] !== 5)
          break;
        c = bc(l, c);
        const h = l[c++];
        let m = (h & 248) >> 3;
        m === 31 && (m += 1 + ((h & 7) << 3) + ((l[c] & 224) >> 5)), i += "." + m;
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const u = Pe(n, ["hvcC"])[0];
      if (u && u.length > 12) {
        const l = u[1], c = ["", "A", "B", "C"][l >> 6], d = l & 31, f = xe(u, 2), h = (l & 32) >> 5 ? "H" : "L", m = u[12], p = u.subarray(6, 12);
        i += "." + c + d, i += "." + TB(f).toString(16).toUpperCase(), i += "." + h + m;
        let g = "";
        for (let b = p.length; b--; ) {
          const y = p[b];
          (y || g) && (g = "." + y.toString(16).toUpperCase() + g);
        }
        i += g;
      }
      s = xo(o == "hev1" ? "dvhe" : "dvh1", n);
      break;
    }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1": {
      i = xo(i, n) || i;
      break;
    }
    case "vp09": {
      const u = Pe(n, ["vpcC"])[0];
      if (u && u.length > 6) {
        const l = u[4], c = u[5], d = u[6] >> 4 & 15;
        i += "." + On(l) + "." + On(c) + "." + On(d);
      }
      break;
    }
    case "av01": {
      const u = Pe(n, ["av1C"])[0];
      if (u && u.length > 2) {
        const l = u[1] >>> 5, c = u[1] & 31, d = u[2] >>> 7 ? "H" : "M", f = (u[2] & 64) >> 6, h = (u[2] & 32) >> 5, m = l === 2 && f ? h ? 12 : 10 : f ? 10 : 8, p = (u[2] & 16) >> 4, g = (u[2] & 8) >> 3, b = (u[2] & 4) >> 2, y = u[2] & 3;
        i += "." + l + "." + On(c) + d + "." + On(m) + "." + p + "." + g + b + y + "." + On(1) + "." + On(1) + "." + On(1) + "." + 0, s = xo("dav1", n);
      }
      break;
    }
  }
  return {
    codec: i,
    encrypted: a,
    supplemental: s
  };
}
function xo(t, e) {
  const n = Pe(e, ["dvvC"]), r = n.length ? n[0] : Pe(e, ["dvcC"])[0];
  if (r) {
    const i = r[2] >> 1 & 127, s = r[2] << 5 & 32 | r[3] >> 3 & 31;
    return t + "." + On(i) + "." + On(s);
  }
}
function TB(t) {
  let e = 0;
  for (let n = 0; n < 32; n++)
    e |= (t >> n & 1) << 31 - n;
  return e >>> 0;
}
function bc(t, e) {
  const n = e + 5;
  for (; t[e++] & 128 && e < n; )
    ;
  return e;
}
function vo(t) {
  return ("0" + t.toString(16).toUpperCase()).slice(-2);
}
function On(t) {
  return (t < 10 ? "0" : "") + t;
}
function SB(t, e) {
  if (!t || !e)
    return;
  const n = e.keyId;
  n && e.isCommonEncryption && ux(t, (r, i) => {
    const s = r.subarray(8, 24);
    s.some((a) => a !== 0) || (qe.log(`[eme] Patching keyId in 'enc${i ? "a" : "v"}>sinf>>tenc' box: ${Ft(s)} -> ${Ft(n)}`), r.set(n, 8));
  });
}
function xB(t) {
  const e = [];
  return ux(t, (n) => e.push(n.subarray(8, 24))), e;
}
function ux(t, e) {
  Pe(t, ["moov", "trak"]).forEach((r) => {
    const i = Pe(r, ["mdia", "minf", "stbl", "stsd"])[0];
    if (!i) return;
    const s = i.subarray(8);
    let a = Pe(s, ["enca"]);
    const o = a.length > 0;
    o || (a = Pe(s, ["encv"])), a.forEach((u) => {
      const l = o ? u.subarray(28) : u.subarray(78);
      Pe(l, ["sinf"]).forEach((d) => {
        const f = lx(d);
        f && e(f, o);
      });
    });
  });
}
function lx(t) {
  const e = Pe(t, ["schm"])[0];
  if (e) {
    const n = Et(e.subarray(4, 8));
    if (n === "cbcs" || n === "cenc") {
      const r = Pe(t, ["schi", "tenc"])[0];
      if (r)
        return r;
    }
  }
}
function vB(t, e, n) {
  const r = {}, i = Pe(t, ["moof", "traf"]);
  for (let s = 0; s < i.length; s++) {
    const a = i[s], o = Pe(a, ["tfhd"])[0], u = xe(o, 4), l = e[u];
    if (!l)
      continue;
    r[u] || (r[u] = {
      start: NaN,
      duration: 0,
      sampleCount: 0,
      timescale: l.timescale,
      type: l.type
    });
    const c = r[u], d = Pe(a, ["tfdt"])[0];
    if (d) {
      const T = d[0];
      let S = xe(d, 4);
      T === 1 && (S === Gp ? n.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (S *= Gp + 1, S += xe(d, 8))), de(S) && (!de(c.start) || S < c.start) && (c.start = S);
    }
    const f = l.default, h = xe(o, 0) | (f == null ? void 0 : f.flags);
    let m = (f == null ? void 0 : f.duration) || 0;
    h & 8 && (h & 2 ? m = xe(o, 12) : m = xe(o, 8));
    const p = Pe(a, ["trun"]);
    let g = c.start || 0, b = 0, y = m;
    for (let T = 0; T < p.length; T++) {
      const S = p[T], I = xe(S, 4), C = c.sampleCount;
      c.sampleCount += I;
      const _ = S[3] & 1, R = S[3] & 4, k = S[2] & 1, A = S[2] & 2, L = S[2] & 4, P = S[2] & 8;
      let $ = 8, G = I;
      for (_ && ($ += 4), R && I && (!(S[$ + 1] & 1) && c.keyFrameIndex === void 0 && (c.keyFrameIndex = C), $ += 4, k ? (y = xe(S, $), $ += 4) : y = m, A && ($ += 4), P && ($ += 4), g += y, b += y, G--); G--; )
        k ? (y = xe(S, $), $ += 4) : y = m, A && ($ += 4), L && (S[$ + 1] & 1 || c.keyFrameIndex === void 0 && (c.keyFrameIndex = c.sampleCount - (G + 1), c.keyFrameStart = g), $ += 4), P && ($ += 4), g += y, b += y;
      !b && m && (b += m * I);
    }
    c.duration += b;
  }
  if (!Object.keys(r).some((s) => r[s].duration)) {
    let s = 1 / 0, a = 0;
    const o = Pe(t, ["sidx"]);
    for (let u = 0; u < o.length; u++) {
      const l = EB(o[u]);
      if (l != null && l.references) {
        s = Math.min(s, l.earliestPresentationTime / l.timescale);
        const c = l.references.reduce((d, f) => d + f.info.duration || 0, 0);
        a = Math.max(a, c + l.earliestPresentationTime / l.timescale);
      }
    }
    a && de(a) && Object.keys(r).forEach((u) => {
      r[u].duration || (r[u].duration = a * r[u].timescale - r[u].start);
    });
  }
  return r;
}
function AB(t) {
  const e = {
    valid: null,
    remainder: null
  }, n = Pe(t, ["moof"]);
  if (n.length < 2)
    return e.remainder = t, e;
  const r = n[n.length - 1];
  return e.valid = t.slice(0, r.byteOffset - 8), e.remainder = t.slice(r.byteOffset - 8), e;
}
function gn(t, e) {
  const n = new Uint8Array(t.length + e.length);
  return n.set(t), n.set(e, t.length), n;
}
function qp(t, e) {
  const n = [], r = e.samples, i = e.timescale, s = e.id;
  let a = !1;
  return Pe(r, ["moof"]).map((u) => {
    const l = u.byteOffset - 8;
    Pe(u, ["traf"]).map((d) => {
      const f = Pe(d, ["tfdt"]).map((h) => {
        const m = h[0];
        let p = xe(h, 4);
        return m === 1 && (p *= Math.pow(2, 32), p += xe(h, 8)), p / i;
      })[0];
      return f !== void 0 && (t = f), Pe(d, ["tfhd"]).map((h) => {
        const m = xe(h, 4), p = xe(h, 0) & 16777215, g = (p & 1) !== 0, b = (p & 2) !== 0, y = (p & 8) !== 0;
        let T = 0;
        const S = (p & 16) !== 0;
        let I = 0;
        const C = (p & 32) !== 0;
        let _ = 8;
        m === s && (g && (_ += 8), b && (_ += 4), y && (T = xe(h, _), _ += 4), S && (I = xe(h, _), _ += 4), C && (_ += 4), e.type === "video" && (a = vl(e.codec)), Pe(d, ["trun"]).map((R) => {
          const k = R[0], A = xe(R, 0) & 16777215, L = (A & 1) !== 0;
          let P = 0;
          const $ = (A & 4) !== 0, G = (A & 256) !== 0;
          let N = 0;
          const U = (A & 512) !== 0;
          let B = 0;
          const V = (A & 1024) !== 0, K = (A & 2048) !== 0;
          let w = 0;
          const Y = xe(R, 4);
          let J = 8;
          L && (P = xe(R, J), J += 4), $ && (J += 4);
          let D = P + l;
          for (let te = 0; te < Y; te++) {
            if (G ? (N = xe(R, J), J += 4) : N = T, U ? (B = xe(R, J), J += 4) : B = I, V && (J += 4), K && (k === 0 ? w = xe(R, J) : w = ax(R, J), J += 4), e.type === Qe.VIDEO) {
              let he = 0;
              for (; he < B; ) {
                const ie = xe(r, D);
                if (D += 4, IB(a, r[D])) {
                  const X = r.subarray(D, D + ie);
                  Bh(X, a ? 2 : 1, t + w / i, n);
                }
                D += ie, he += ie + 4;
              }
            }
            t += N / i;
          }
        }));
      });
    });
  }), n;
}
function vl(t) {
  if (!t)
    return !1;
  const e = t.substring(0, 4);
  return e === "hvc1" || e === "hev1" || // Dolby Vision
  e === "dvh1" || e === "dvhe";
}
function IB(t, e) {
  if (t) {
    const n = e >> 1 & 63;
    return n === 39 || n === 40;
  } else
    return (e & 31) === 6;
}
function Bh(t, e, n, r) {
  const i = cx(t);
  let s = 0;
  s += e;
  let a = 0, o = 0, u = 0;
  for (; s < i.length; ) {
    a = 0;
    do {
      if (s >= i.length)
        break;
      u = i[s++], a += u;
    } while (u === 255);
    o = 0;
    do {
      if (s >= i.length)
        break;
      u = i[s++], o += u;
    } while (u === 255);
    const l = i.length - s;
    let c = s;
    if (o < l)
      s += o;
    else if (o > l) {
      qe.error(`Malformed SEI payload. ${o} is too small, only ${l} bytes left to parse.`);
      break;
    }
    if (a === 4) {
      if (i[c++] === 181) {
        const f = sx(i, c);
        if (c += 2, f === 49) {
          const h = xe(i, c);
          if (c += 4, h === 1195456820) {
            const m = i[c++];
            if (m === 3) {
              const p = i[c++], g = 31 & p, b = 64 & p, y = b ? 2 + g * 3 : 0, T = new Uint8Array(y);
              if (b) {
                T[0] = p;
                for (let S = 1; S < y; S++)
                  T[S] = i[c++];
              }
              r.push({
                type: m,
                payloadType: a,
                pts: n,
                bytes: T
              });
            }
          }
        }
      }
    } else if (a === 5 && o > 16) {
      const d = [];
      for (let m = 0; m < 16; m++) {
        const p = i[c++].toString(16);
        d.push(p.length == 1 ? "0" + p : p), (m === 3 || m === 5 || m === 7 || m === 9) && d.push("-");
      }
      const f = o - 16, h = new Uint8Array(f);
      for (let m = 0; m < f; m++)
        h[m] = i[c++];
      r.push({
        payloadType: a,
        pts: n,
        uuid: d.join(""),
        userData: cn(h),
        userDataBytes: h
      });
    }
  }
}
function cx(t) {
  const e = t.byteLength, n = [];
  let r = 1;
  for (; r < e - 2; )
    t[r] === 0 && t[r + 1] === 0 && t[r + 2] === 3 ? (n.push(r + 2), r += 2) : r++;
  if (n.length === 0)
    return t;
  const i = e - n.length, s = new Uint8Array(i);
  let a = 0;
  for (r = 0; r < i; a++, r++)
    a === n[0] && (a++, n.shift()), s[r] = t[a];
  return s;
}
function CB(t) {
  const e = t[0];
  let n = "", r = "", i = 0, s = 0, a = 0, o = 0, u = 0, l = 0;
  if (e === 0) {
    for (; Et(t.subarray(l, l + 1)) !== "\0"; )
      n += Et(t.subarray(l, l + 1)), l += 1;
    for (n += Et(t.subarray(l, l + 1)), l += 1; Et(t.subarray(l, l + 1)) !== "\0"; )
      r += Et(t.subarray(l, l + 1)), l += 1;
    r += Et(t.subarray(l, l + 1)), l += 1, i = xe(t, 12), s = xe(t, 16), o = xe(t, 20), u = xe(t, 24), l = 28;
  } else if (e === 1) {
    l += 4, i = xe(t, l), l += 4;
    const d = xe(t, l);
    l += 4;
    const f = xe(t, l);
    for (l += 4, a = 2 ** 32 * d + f, nB(a) || (a = Number.MAX_SAFE_INTEGER, qe.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = xe(t, l), l += 4, u = xe(t, l), l += 4; Et(t.subarray(l, l + 1)) !== "\0"; )
      n += Et(t.subarray(l, l + 1)), l += 1;
    for (n += Et(t.subarray(l, l + 1)), l += 1; Et(t.subarray(l, l + 1)) !== "\0"; )
      r += Et(t.subarray(l, l + 1)), l += 1;
    r += Et(t.subarray(l, l + 1)), l += 1;
  }
  const c = t.subarray(l, t.byteLength);
  return {
    schemeIdUri: n,
    value: r,
    timeScale: i,
    presentationTime: a,
    presentationTimeDelta: s,
    eventDuration: o,
    id: u,
    payload: c
  };
}
function LB(t, ...e) {
  const n = e.length;
  let r = 8, i = n;
  for (; i--; )
    r += e[i].byteLength;
  const s = new Uint8Array(r);
  for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = r & 255, s.set(t, 4), i = 0, r = 8; i < n; i++)
    s.set(e[i], r), r += e[i].byteLength;
  return s;
}
function _B(t, e, n) {
  if (t.byteLength !== 16)
    throw new RangeError("Invalid system id");
  let r, i;
  r = 0, i = new Uint8Array();
  let s;
  r > 0 ? (s = new Uint8Array(4), e.length > 0 && new DataView(s.buffer).setUint32(0, e.length, !1)) : s = new Uint8Array();
  const a = new Uint8Array(4);
  return n.byteLength > 0 && new DataView(a.buffer).setUint32(0, n.byteLength, !1), LB(
    [112, 115, 115, 104],
    new Uint8Array([
      r,
      0,
      0,
      0
      // Flags
    ]),
    t,
    // 16 bytes
    s,
    i,
    a,
    n
  );
}
function RB(t) {
  const e = [];
  if (t instanceof ArrayBuffer) {
    const n = t.byteLength;
    let r = 0;
    for (; r + 32 < n; ) {
      const i = new DataView(t, r), s = wB(i);
      e.push(s), r += s.size;
    }
  }
  return e;
}
function wB(t) {
  const e = t.getUint32(0), n = t.byteOffset, r = t.byteLength;
  if (r < e)
    return {
      offset: n,
      size: r
    };
  if (t.getUint32(4) !== 1886614376)
    return {
      offset: n,
      size: e
    };
  const s = t.getUint32(8) >>> 24;
  if (s !== 0 && s !== 1)
    return {
      offset: n,
      size: e
    };
  const a = t.buffer, o = Ft(new Uint8Array(a, n + 12, 16));
  let u = null, l = null, c = 0;
  if (s === 0)
    c = 28;
  else {
    const f = t.getUint32(28);
    if (!f || r < 32 + f * 16)
      return {
        offset: n,
        size: e
      };
    u = [];
    for (let h = 0; h < f; h++)
      u.push(new Uint8Array(a, n + 32 + h * 16, 16));
    c = 32 + f * 16;
  }
  if (!c)
    return {
      offset: n,
      size: e
    };
  const d = t.getUint32(c);
  return e - 32 < d ? {
    offset: n,
    size: e
  } : (l = new Uint8Array(a, n + c + 4, d), {
    version: s,
    systemId: o,
    kids: u,
    data: l,
    offset: n,
    size: e
  });
}
const dx = () => /\(Windows.+Firefox\//i.test(navigator.userAgent), cs = {
  audio: {
    a3ds: 1,
    "ac-3": 0.95,
    "ac-4": 1,
    alac: 0.9,
    alaw: 1,
    dra1: 1,
    "dts+": 1,
    "dts-": 1,
    dtsc: 1,
    dtse: 1,
    dtsh: 1,
    "ec-3": 0.9,
    enca: 1,
    fLaC: 0.9,
    // MP4-RA listed codec entry for FLAC
    flac: 0.9,
    // legacy browser codec name for FLAC
    FLAC: 0.9,
    // some manifests may list "FLAC" with Apple's tools
    g719: 1,
    g726: 1,
    m4ae: 1,
    mha1: 1,
    mha2: 1,
    mhm1: 1,
    mhm2: 1,
    mlpa: 1,
    mp4a: 1,
    "raw ": 1,
    Opus: 1,
    opus: 1,
    // browsers expect this to be lowercase despite MP4RA says 'Opus'
    samr: 1,
    sawb: 1,
    sawp: 1,
    sevc: 1,
    sqcp: 1,
    ssmv: 1,
    twos: 1,
    ulaw: 1
  },
  video: {
    avc1: 1,
    avc2: 1,
    avc3: 1,
    avc4: 1,
    avcp: 1,
    av01: 0.8,
    dav1: 0.8,
    drac: 1,
    dva1: 1,
    dvav: 1,
    dvh1: 0.7,
    dvhe: 0.7,
    encv: 1,
    hev1: 0.75,
    hvc1: 0.75,
    mjp2: 1,
    mp4v: 1,
    mvc1: 1,
    mvc2: 1,
    mvc3: 1,
    mvc4: 1,
    resv: 1,
    rv60: 1,
    s263: 1,
    svc1: 1,
    svc2: 1,
    "vc-1": 1,
    vp08: 1,
    vp09: 0.9
  },
  text: {
    stpp: 1,
    wvtt: 1
  }
};
function $h(t, e) {
  const n = cs[e];
  return !!n && !!n[t.slice(0, 4)];
}
function va(t, e, n = !0) {
  return !t.split(",").some((r) => !Uh(r, e, n));
}
function Uh(t, e, n = !0) {
  var r;
  const i = Or(n);
  return (r = i == null ? void 0 : i.isTypeSupported(Aa(t, e))) != null ? r : !1;
}
function Aa(t, e) {
  return `${e}/mp4;codecs=${t}`;
}
function Wp(t) {
  if (t) {
    const e = t.substring(0, 4);
    return cs.video[e];
  }
  return 2;
}
function ku(t) {
  const e = dx();
  return t.split(",").reduce((n, r) => {
    const s = e && vl(r) ? 9 : cs.video[r];
    return s ? (s * 2 + n) / (n ? 3 : 2) : (cs.audio[r] + n) / (n ? 2 : 1);
  }, 0);
}
const Ec = {};
function kB(t, e = !0) {
  if (Ec[t])
    return Ec[t];
  const n = {
    // Idealy fLaC and Opus would be first (spec-compliant) but
    // some browsers will report that fLaC is supported then fail.
    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"],
    // Replace audio codec info if browser does not support mp4a.40.34,
    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs="mp3"'
    "mp4a.40.34": ["mp3"]
  }[t];
  for (let i = 0; i < n.length; i++) {
    var r;
    if (Uh(n[i], "audio", e))
      return Ec[t] = n[i], n[i];
    if (n[i] === "mp3" && (r = Or(e)) != null && r.isTypeSupported("audio/mpeg"))
      return "";
  }
  return t;
}
const DB = /flac|opus|mp4a\.40\.34/i;
function Du(t, e = !0) {
  return t.replace(DB, (n) => kB(n.toLowerCase(), e));
}
function PB(t, e) {
  const n = [];
  if (t) {
    const r = t.split(",");
    for (let i = 0; i < r.length; i++)
      $h(r[i], "video") || n.push(r[i]);
  }
  return e && n.push(e), n.join(",");
}
function Zo(t, e) {
  if (t && (t.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(t) !== -1) && (Kp(t, "audio") || Kp(t, "video")))
    return t;
  if (e) {
    const n = e.split(",");
    if (n.length > 1) {
      if (t) {
        for (let r = n.length; r--; )
          if (n[r].substring(0, 4) === t.substring(0, 4))
            return n[r];
      }
      return n[0];
    }
  }
  return e || t;
}
function Kp(t, e) {
  return $h(t, e) && Uh(t, e);
}
function OB(t) {
  const e = t.split(",");
  for (let n = 0; n < e.length; n++) {
    const r = e[n].split(".");
    r.length > 2 && r[0] === "avc1" && (e[n] = `avc1.${parseInt(r[1]).toString(16)}${("000" + parseInt(r[2]).toString(16)).slice(-4)}`);
  }
  return e.join(",");
}
function NB(t) {
  if (t.startsWith("av01.")) {
    const e = t.split("."), n = ["0", "111", "01", "01", "01", "0"];
    for (let r = e.length; r > 4 && r < 10; r++)
      e[r] = n[r - 4];
    return e.join(".");
  }
  return t;
}
function jp(t) {
  const e = Or(t) || {
    isTypeSupported: () => !1
  };
  return {
    mpeg: e.isTypeSupported("audio/mpeg"),
    mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
    ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
  };
}
function Kd(t) {
  return t.replace(/^.+codecs=["']?([^"']+).*$/, "$1");
}
const MB = {
  supported: !0,
  powerEfficient: !0,
  smooth: !0
  // keySystemAccess: null,
}, FB = {
  supported: !1,
  smooth: !1,
  powerEfficient: !1
  // keySystemAccess: null,
}, fx = {
  supported: !0,
  configurations: [],
  decodingInfoResults: [MB]
};
function hx(t, e) {
  return {
    supported: !1,
    configurations: e,
    decodingInfoResults: [FB],
    error: t
  };
}
function BB(t, e, n, r, i, s) {
  const a = t.videoCodec, o = t.audioCodec ? t.audioGroups : null, u = s == null ? void 0 : s.audioCodec, l = s == null ? void 0 : s.channels, c = l ? parseInt(l) : u ? 1 / 0 : 2;
  let d = null;
  if (o != null && o.length)
    try {
      o.length === 1 && o[0] ? d = e.groups[o[0]].channels : d = o.reduce((f, h) => {
        if (h) {
          const m = e.groups[h];
          if (!m)
            throw new Error(`Audio track group ${h} not found`);
          Object.keys(m.channels).forEach((p) => {
            f[p] = (f[p] || 0) + m.channels[p];
          });
        }
        return f;
      }, {
        2: 0
      });
    } catch {
      return !0;
    }
  return a !== void 0 && // Force media capabilities check for HEVC to avoid failure on Windows
  (a.split(",").some((f) => vl(f)) || t.width > 1920 && t.height > 1088 || t.height > 1920 && t.width > 1088 || t.frameRate > Math.max(r, 30) || t.videoRange !== "SDR" && t.videoRange !== n || t.bitrate > Math.max(i, 8e6)) || !!d && de(c) && Object.keys(d).some((f) => parseInt(f) > c);
}
function mx(t, e, n, r = {}) {
  const i = t.videoCodec;
  if (!i && !t.audioCodec || !n)
    return Promise.resolve(fx);
  const s = [], a = $B(t), o = a.length, u = UB(t, e, o > 0), l = u.length;
  for (let c = o || 1 * l || 1; c--; ) {
    const d = {
      type: "media-source"
    };
    if (o && (d.video = a[c % o]), l) {
      d.audio = u[c % l];
      const f = d.audio.bitrate;
      d.video && f && (d.video.bitrate -= f);
    }
    s.push(d);
  }
  if (i) {
    const c = navigator.userAgent;
    if (i.split(",").some((d) => vl(d)) && dx())
      return Promise.resolve(hx(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${c})`), s));
  }
  return Promise.all(s.map((c) => {
    const d = VB(c);
    return r[d] || (r[d] = n.decodingInfo(c));
  })).then((c) => ({
    supported: !c.some((d) => !d.supported),
    configurations: s,
    decodingInfoResults: c
  })).catch((c) => ({
    supported: !1,
    configurations: s,
    decodingInfoResults: [],
    error: c
  }));
}
function $B(t) {
  var e;
  const n = (e = t.videoCodec) == null ? void 0 : e.split(","), r = px(t), i = t.width || 640, s = t.height || 480, a = t.frameRate || 30, o = t.videoRange.toLowerCase();
  return n ? n.map((u) => {
    const l = {
      contentType: Aa(NB(u), "video"),
      width: i,
      height: s,
      bitrate: r,
      framerate: a
    };
    return o !== "sdr" && (l.transferFunction = o), l;
  }) : [];
}
function UB(t, e, n) {
  var r;
  const i = (r = t.audioCodec) == null ? void 0 : r.split(","), s = px(t);
  return i && t.audioGroups ? t.audioGroups.reduce((a, o) => {
    var u;
    const l = o ? (u = e.groups[o]) == null ? void 0 : u.tracks : null;
    return l ? l.reduce((c, d) => {
      if (d.groupId === o) {
        const f = parseFloat(d.channels || "");
        i.forEach((h) => {
          const m = {
            contentType: Aa(h, "audio"),
            bitrate: n ? HB(h, s) : s
          };
          f && (m.channels = "" + f), c.push(m);
        });
      }
      return c;
    }, a) : a;
  }, []) : [];
}
function HB(t, e) {
  if (e <= 1)
    return 1;
  let n = 128e3;
  return t === "ec-3" ? n = 768e3 : t === "ac-3" && (n = 64e4), Math.min(e / 2, n);
}
function px(t) {
  return Math.ceil(Math.max(t.bitrate * 0.9, t.averageBitrate) / 1e3) * 1e3 || 1;
}
function VB(t) {
  let e = "";
  const {
    audio: n,
    video: r
  } = t;
  if (r) {
    const i = Kd(r.contentType);
    e += `${i}_r${r.height}x${r.width}f${Math.ceil(r.framerate)}${r.transferFunction || "sd"}_${Math.ceil(r.bitrate / 1e5)}`;
  }
  if (n) {
    const i = Kd(n.contentType);
    e += `${r ? "_" : ""}${i}_c${n.channels}`;
  }
  return e;
}
const jd = ["NONE", "TYPE-0", "TYPE-1", null];
function GB(t) {
  return jd.indexOf(t) > -1;
}
const Pu = ["SDR", "PQ", "HLG"];
function zB(t) {
  return !!t && Pu.indexOf(t) > -1;
}
var Jo = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function Yp(t) {
  const {
    canSkipUntil: e,
    canSkipDateRanges: n,
    age: r
  } = t, i = r < e / 2;
  return e && i ? n ? Jo.v2 : Jo.Yes : Jo.No;
}
class Xp {
  constructor(e, n, r) {
    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = n, this.skip = r;
  }
  addDirectives(e) {
    const n = new self.URL(e);
    return this.msn !== void 0 && n.searchParams.set("_HLS_msn", this.msn.toString()), this.part !== void 0 && n.searchParams.set("_HLS_part", this.part.toString()), this.skip && n.searchParams.set("_HLS_skip", this.skip), n.href;
  }
}
class Ia {
  constructor(e) {
    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0), this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((r) => !!r).map((r) => r.substring(0, 4)).join(","), "supplemental" in e) {
      var n;
      this.supplemental = e.supplemental;
      const r = (n = e.supplemental) == null ? void 0 : n.videoCodec;
      r && r !== e.videoCodec && (this.codecSet += `,${r.substring(0, 4)}`);
    }
    this.addGroupId("audio", e.attrs.AUDIO), this.addGroupId("text", e.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(e) {
    return Qp(this._audioGroups, e);
  }
  hasSubtitleGroup(e) {
    return Qp(this._subtitleGroups, e);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(e, n) {
    if (n) {
      if (e === "audio") {
        let r = this._audioGroups;
        r || (r = this._audioGroups = []), r.indexOf(n) === -1 && r.push(n);
      } else if (e === "text") {
        let r = this._subtitleGroups;
        r || (r = this._subtitleGroups = []), r.indexOf(n) === -1 && r.push(n);
      }
    }
  }
  // Deprecated methods (retained for backwards compatibility)
  get urlId() {
    return 0;
  }
  set urlId(e) {
  }
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : void 0;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : void 0;
  }
  get audioGroupId() {
    var e;
    return (e = this.audioGroups) == null ? void 0 : e[0];
  }
  get textGroupId() {
    var e;
    return (e = this.subtitleGroups) == null ? void 0 : e[0];
  }
  addFallback() {
  }
}
function Qp(t, e) {
  return !e || !t ? !1 : t.indexOf(e) !== -1;
}
function qB() {
  if (typeof matchMedia == "function") {
    const t = matchMedia("(dynamic-range: high)"), e = matchMedia("bad query");
    if (t.media !== e.media)
      return t.matches === !0;
  }
  return !1;
}
function WB(t, e) {
  let n = !1, r = [];
  if (t && (n = t !== "SDR", r = [t]), e) {
    r = e.allowedVideoRanges || Pu.slice(0);
    const i = r.join("") !== "SDR" && !e.videoCodec;
    n = e.preferHDR !== void 0 ? e.preferHDR : i && qB(), n || (r = ["SDR"]);
  }
  return {
    preferHDR: n,
    allowedVideoRanges: r
  };
}
const KB = (t) => {
  const e = /* @__PURE__ */ new WeakSet();
  return (n, r) => {
    if (t && (r = t(n, r)), typeof r == "object" && r !== null) {
      if (e.has(r))
        return;
      e.add(r);
    }
    return r;
  };
}, Ze = (t, e) => JSON.stringify(t, KB(e));
function jB(t, e, n, r, i) {
  const s = Object.keys(t), a = r == null ? void 0 : r.channels, o = r == null ? void 0 : r.audioCodec, u = i == null ? void 0 : i.videoCodec, l = a && parseInt(a) === 2;
  let c = !1, d = !1, f = 1 / 0, h = 1 / 0, m = 1 / 0, p = 1 / 0, g = 0, b = [];
  const {
    preferHDR: y,
    allowedVideoRanges: T
  } = WB(e, i);
  for (let R = s.length; R--; ) {
    const k = t[s[R]];
    c || (c = k.channels[2] > 0), f = Math.min(f, k.minHeight), h = Math.min(h, k.minFramerate), m = Math.min(m, k.minBitrate), T.filter((L) => k.videoRanges[L] > 0).length > 0 && (d = !0);
  }
  f = de(f) ? f : 0, h = de(h) ? h : 0;
  const S = Math.max(1080, f), I = Math.max(30, h);
  m = de(m) ? m : n, n = Math.max(m, n), d || (e = void 0);
  const C = s.length > 1;
  return {
    codecSet: s.reduce((R, k) => {
      const A = t[k];
      if (k === R)
        return R;
      if (b = d ? T.filter((L) => A.videoRanges[L] > 0) : [], C) {
        if (A.minBitrate > n)
          return wn(k, `min bitrate of ${A.minBitrate} > current estimate of ${n}`), R;
        if (!A.hasDefaultAudio)
          return wn(k, "no renditions with default or auto-select sound found"), R;
        if (o && k.indexOf(o.substring(0, 4)) % 5 !== 0)
          return wn(k, `audio codec preference "${o}" not found`), R;
        if (a && !l) {
          if (!A.channels[a])
            return wn(k, `no renditions with ${a} channel sound found (channels options: ${Object.keys(A.channels)})`), R;
        } else if ((!o || l) && c && A.channels[2] === 0)
          return wn(k, "no renditions with stereo sound found"), R;
        if (A.minHeight > S)
          return wn(k, `min resolution of ${A.minHeight} > maximum of ${S}`), R;
        if (A.minFramerate > I)
          return wn(k, `min framerate of ${A.minFramerate} > maximum of ${I}`), R;
        if (!b.some((L) => A.videoRanges[L] > 0))
          return wn(k, `no variants with VIDEO-RANGE of ${Ze(b)} found`), R;
        if (u && k.indexOf(u.substring(0, 4)) % 5 !== 0)
          return wn(k, `video codec preference "${u}" not found`), R;
        if (A.maxScore < g)
          return wn(k, `max score of ${A.maxScore} < selected max of ${g}`), R;
      }
      return R && (ku(k) >= ku(R) || A.fragmentError > t[R].fragmentError) ? R : (p = A.minIndex, g = A.maxScore, k);
    }, void 0),
    videoRanges: b,
    preferHDR: y,
    minFramerate: h,
    minBitrate: m,
    minIndex: p
  };
}
function wn(t, e) {
  qe.log(`[abr] start candidates with "${t}" ignored because ${e}`);
}
function gx(t) {
  return t.reduce((e, n) => {
    let r = e.groups[n.groupId];
    r || (r = e.groups[n.groupId] = {
      tracks: [],
      channels: {
        2: 0
      },
      hasDefault: !1,
      hasAutoSelect: !1
    }), r.tracks.push(n);
    const i = n.channels || "2";
    return r.channels[i] = (r.channels[i] || 0) + 1, r.hasDefault = r.hasDefault || n.default, r.hasAutoSelect = r.hasAutoSelect || n.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;
  }, {
    hasDefaultAudio: !1,
    hasAutoSelectAudio: !1,
    groups: {}
  });
}
function YB(t, e, n, r) {
  return t.slice(n, r + 1).reduce((i, s, a) => {
    if (!s.codecSet)
      return i;
    const o = s.audioGroups;
    let u = i[s.codecSet];
    u || (i[s.codecSet] = u = {
      minBitrate: 1 / 0,
      minHeight: 1 / 0,
      minFramerate: 1 / 0,
      minIndex: a,
      maxScore: 0,
      videoRanges: {
        SDR: 0
      },
      channels: {
        2: 0
      },
      hasDefaultAudio: !o,
      fragmentError: 0
    }), u.minBitrate = Math.min(u.minBitrate, s.bitrate);
    const l = Math.min(s.height, s.width);
    return u.minHeight = Math.min(u.minHeight, l), u.minFramerate = Math.min(u.minFramerate, s.frameRate), u.minIndex = Math.min(u.minIndex, a), u.maxScore = Math.max(u.maxScore, s.score), u.fragmentError += s.fragmentError, u.videoRanges[s.videoRange] = (u.videoRanges[s.videoRange] || 0) + 1, o && o.forEach((c) => {
      if (!c)
        return;
      const d = e.groups[c];
      d && (u.hasDefaultAudio = u.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio, Object.keys(d.channels).forEach((f) => {
        u.channels[f] = (u.channels[f] || 0) + d.channels[f];
      }));
    }), i;
  }, {});
}
function Zp(t) {
  if (!t)
    return t;
  const {
    lang: e,
    assocLang: n,
    characteristics: r,
    channels: i,
    audioCodec: s
  } = t;
  return {
    lang: e,
    assocLang: n,
    characteristics: r,
    channels: i,
    audioCodec: s
  };
}
function $n(t, e, n) {
  if ("attrs" in t) {
    const r = e.indexOf(t);
    if (r !== -1)
      return r;
  }
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    if (ti(t, i, n))
      return r;
  }
  return -1;
}
function ti(t, e, n) {
  const {
    groupId: r,
    name: i,
    lang: s,
    assocLang: a,
    default: o
  } = t, u = t.forced;
  return (r === void 0 || e.groupId === r) && (i === void 0 || e.name === i) && (s === void 0 || XB(s, e.lang)) && (s === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (u === void 0 || e.forced === u) && (!("characteristics" in t) || QB(t.characteristics || "", e.characteristics)) && (n === void 0 || n(t, e));
}
function XB(t, e = "--") {
  return t.length === e.length ? t === e : t.startsWith(e) || e.startsWith(t);
}
function QB(t, e = "") {
  const n = t.split(","), r = e.split(",");
  return n.length === r.length && !n.some((i) => r.indexOf(i) === -1);
}
function jr(t, e) {
  const {
    audioCodec: n,
    channels: r
  } = t;
  return (n === void 0 || (e.audioCodec || "").substring(0, 4) === n.substring(0, 4)) && (r === void 0 || r === (e.channels || "2"));
}
function ZB(t, e, n, r, i) {
  const s = e[r], o = e.reduce((f, h, m) => {
    const p = h.uri;
    return (f[p] || (f[p] = [])).push(m), f;
  }, {})[s.uri];
  o.length > 1 && (r = Math.max.apply(Math, o));
  const u = s.videoRange, l = s.frameRate, c = s.codecSet.substring(0, 4), d = Jp(e, r, (f) => {
    if (f.videoRange !== u || f.frameRate !== l || f.codecSet.substring(0, 4) !== c)
      return !1;
    const h = f.audioGroups, m = n.filter((p) => !h || h.indexOf(p.groupId) !== -1);
    return $n(t, m, i) > -1;
  });
  return d > -1 ? d : Jp(e, r, (f) => {
    const h = f.audioGroups, m = n.filter((p) => !h || h.indexOf(p.groupId) !== -1);
    return $n(t, m, i) > -1;
  });
}
function Jp(t, e, n) {
  for (let r = e; r > -1; r--)
    if (n(t[r]))
      return r;
  for (let r = e + 1; r < t.length; r++)
    if (n(t[r]))
      return r;
  return -1;
}
function Ou(t, e) {
  var n;
  return !!t && t !== ((n = e.loadLevelObj) == null ? void 0 : n.uri);
}
class JB extends En {
  constructor(e) {
    super("abr", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = "", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (n) => {
      var r;
      const {
        fragCurrent: i,
        partCurrent: s,
        hls: a
      } = this, {
        autoLevelEnabled: o,
        media: u
      } = a;
      if (!i || !u)
        return;
      const l = performance.now(), c = s ? s.stats : i.stats, d = s ? s.duration : i.duration, f = l - c.loading.start, h = a.minAutoLevel, m = i.level, p = this._nextAutoLevel;
      if (c.aborted || c.loaded && c.loaded === c.total || m <= h) {
        this.clearTimer(), this._nextAutoLevel = -1;
        return;
      }
      if (!o)
        return;
      const g = p > -1 && p !== m, b = !!n || g;
      if (!b && (u.paused || !u.playbackRate || !u.readyState))
        return;
      const y = a.mainForwardBufferInfo;
      if (!b && y === null)
        return;
      const T = this.bwEstimator.getEstimateTTFB(), S = Math.abs(u.playbackRate);
      if (f <= Math.max(T, 1e3 * (d / (S * 2))))
        return;
      const I = y ? y.len / S : 0, C = c.loading.first ? c.loading.first - c.loading.start : -1, _ = c.loaded && C > -1, R = this.getBwEstimate(), k = a.levels, A = k[m], L = Math.max(c.loaded, Math.round(d * (i.bitrate || A.averageBitrate) / 8));
      let P = _ ? f - C : f;
      P < 1 && _ && (P = Math.min(f, c.loaded * 8 / R));
      const $ = _ ? c.loaded * 1e3 / P : 0, G = T / 1e3, N = $ ? (L - c.loaded) / $ : L * 8 / R + G;
      if (N <= I)
        return;
      const U = $ ? $ * 8 : R, B = ((r = (n == null ? void 0 : n.details) || this.hls.latestLevelDetails) == null ? void 0 : r.live) === !0, V = this.hls.config.abrBandWidthUpFactor;
      let K = Number.POSITIVE_INFINITY, w;
      for (w = m - 1; w > h; w--) {
        const te = k[w].maxBitrate, he = !k[w].details || B;
        if (K = this.getTimeToLoadFrag(G, U, d * te, he), K < Math.min(I, d + G))
          break;
      }
      if (K >= N || K > d * 10)
        return;
      _ ? this.bwEstimator.sample(f - Math.min(T, C), c.loaded) : this.bwEstimator.sampleTTFB(f);
      const Y = k[w].maxBitrate;
      this.getBwEstimate() * V > Y && this.resetEstimator(Y);
      const J = this.findBestLevel(Y, h, w, 0, I, 1, 1);
      J > -1 && (w = J), this.warn(`Fragment ${i.sn}${s ? " part " + s.index : ""} of level ${m} is loading too slowly;
      Fragment duration: ${i.duration.toFixed(3)}
      Time to underbuffer: ${I.toFixed(3)} s
      Estimated load time for current fragment: ${N.toFixed(3)} s
      Estimated load time for down switch fragment: ${K.toFixed(3)} s
      TTFB estimate: ${C | 0} ms
      Current BW estimate: ${de(R) ? R | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${w} @ ${Y | 0} bps`), a.nextLoadLevel = a.nextAutoLevel = w, this.clearTimer();
      const D = () => {
        if (this.clearTimer(), this.fragCurrent === i && this.hls.loadLevel === w && w > 0) {
          const te = this.getStarvationDelay();
          if (this.warn(`Aborting inflight request ${w > 0 ? "and switching down" : ""}
      Fragment duration: ${i.duration.toFixed(3)} s
      Time to underbuffer: ${te.toFixed(3)} s`), i.abortRequests(), this.fragCurrent = this.partCurrent = null, w > h) {
            let he = this.findBestLevel(this.hls.levels[h].bitrate, h, w, 0, te, 1, 1);
            he === -1 && (he = h), this.hls.nextLoadLevel = this.hls.nextAutoLevel = he, this.resetEstimator(this.hls.levels[he].bitrate);
          }
        }
      };
      g || N > K * 2 ? D() : this.timer = self.setInterval(D, K * 1e3), a.trigger(x.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag: i,
        part: s,
        stats: c
      });
    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();
  }
  resetEstimator(e) {
    e && (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();
  }
  initEstimator() {
    const e = this.hls.config;
    return new iB(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  destroy() {
    this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;
  }
  onManifestLoading(e, n) {
    this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();
  }
  onLevelsUpdated() {
    this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;
  }
  onMaxAutoLevelUpdated() {
    this.firstSelection = -1, this.nextAutoLevelKey = "";
  }
  onFragLoading(e, n) {
    const r = n.frag;
    if (!this.ignoreFragment(r)) {
      if (!r.bitrateTest) {
        var i;
        this.fragCurrent = r, this.partCurrent = (i = n.part) != null ? i : null;
      }
      this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);
    }
  }
  onLevelSwitching(e, n) {
    this.clearTimer();
  }
  onError(e, n) {
    if (!n.fatal)
      switch (n.details) {
        case q.BUFFER_ADD_CODEC_ERROR:
        case q.BUFFER_APPEND_ERROR:
          this.lastLoadedFragLevel = -1, this.firstSelection = -1;
          break;
        case q.FRAG_LOAD_TIMEOUT: {
          const r = n.frag, {
            fragCurrent: i,
            partCurrent: s
          } = this;
          if (r && i && r.sn === i.sn && r.level === i.level) {
            const a = performance.now(), o = s ? s.stats : r.stats, u = a - o.loading.start, l = o.loading.first ? o.loading.first - o.loading.start : -1;
            if (o.loaded && l > -1) {
              const d = this.bwEstimator.getEstimateTTFB();
              this.bwEstimator.sample(u - Math.min(d, l), o.loaded);
            } else
              this.bwEstimator.sampleTTFB(u);
          }
          break;
        }
      }
  }
  getTimeToLoadFrag(e, n, r, i) {
    const s = e + r / n, a = i ? e + this.lastLevelLoadSec : 0;
    return s + a;
  }
  onLevelLoaded(e, n) {
    const r = this.hls.config, {
      loading: i
    } = n.stats, s = i.end - i.first;
    de(s) && (this.lastLevelLoadSec = s / 1e3), n.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), this.timer > -1 && this._abandonRulesCheck(n.levelInfo);
  }
  onFragLoaded(e, {
    frag: n,
    part: r
  }) {
    const i = r ? r.stats : n.stats;
    if (n.type === pe.MAIN && this.bwEstimator.sampleTTFB(i.loading.first - i.loading.start), !this.ignoreFragment(n)) {
      if (this.clearTimer(), n.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {
        const s = r ? r.duration : n.duration, a = this.hls.levels[n.level], o = (a.loaded ? a.loaded.bytes : 0) + i.loaded, u = (a.loaded ? a.loaded.duration : 0) + s;
        a.loaded = {
          bytes: o,
          duration: u
        }, a.realBitrate = Math.round(8 * o / u);
      }
      if (n.bitrateTest) {
        const s = {
          stats: i,
          frag: n,
          part: r,
          id: n.type
        };
        this.onFragBuffered(x.FRAG_BUFFERED, s), n.bitrateTest = !1;
      } else
        this.lastLoadedFragLevel = n.level;
    }
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = i != null && i.stats.loaded ? i.stats : r.stats;
    if (s.aborted || this.ignoreFragment(r))
      return;
    const a = s.parsing.end - s.loading.start - Math.min(s.loading.first - s.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(a, s.loaded), s.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0;
  }
  ignoreFragment(e) {
    return e.type !== pe.MAIN || e.sn === "initSegment";
  }
  clearTimer() {
    this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);
  }
  get firstAutoLevel() {
    const {
      maxAutoLevel: e,
      minAutoLevel: n
    } = this.hls, r = this.getBwEstimate(), i = this.hls.config.maxStarvationDelay, s = this.findBestLevel(r, n, e, 0, i, 1, 1);
    if (s > -1)
      return s;
    const a = this.hls.firstLevel, o = Math.min(Math.max(a, n), e);
    return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`), o;
  }
  get forcedAutoLevel() {
    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;
  }
  // return next auto level
  get nextAutoLevel() {
    const e = this.forcedAutoLevel, r = this.bwEstimator.canEstimate(), i = this.lastLoadedFragLevel > -1;
    if (e !== -1 && (!r || !i || this.nextAutoLevelKey === this.getAutoLevelKey()))
      return e;
    const s = r && i ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (e !== -1) {
      const a = this.hls.levels;
      if (a.length > Math.max(e, s) && a[e].loadError <= a[s].loadError)
        return e;
    }
    return this._nextAutoLevel = s, this.nextAutoLevelKey = this.getAutoLevelKey(), s;
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent: e,
      partCurrent: n,
      hls: r
    } = this;
    if (r.levels.length <= 1)
      return r.loadLevel;
    const {
      maxAutoLevel: i,
      config: s,
      minAutoLevel: a
    } = r, o = n ? n.duration : e ? e.duration : 0, u = this.getBwEstimate(), l = this.getStarvationDelay();
    let c = s.abrBandWidthFactor, d = s.abrBandWidthUpFactor;
    if (l) {
      const g = this.findBestLevel(u, a, i, l, 0, c, d);
      if (g >= 0)
        return this.rebufferNotice = -1, g;
    }
    let f = o ? Math.min(o, s.maxStarvationDelay) : s.maxStarvationDelay;
    if (!l) {
      const g = this.bitrateTestDelay;
      g && (f = (o ? Math.min(o, s.maxLoadingDelay) : s.maxLoadingDelay) - g, this.info(`bitrate test took ${Math.round(1e3 * g)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * f)} ms`), c = d = 1);
    }
    const h = this.findBestLevel(u, a, i, l, f, c, d);
    if (this.rebufferNotice !== h && (this.rebufferNotice = h, this.info(`${l ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${h}`)), h > -1)
      return h;
    const m = r.levels[a], p = r.loadLevelObj;
    return p && (m == null ? void 0 : m.bitrate) < p.bitrate ? a : r.loadLevel;
  }
  getStarvationDelay() {
    const e = this.hls, n = e.media;
    if (!n)
      return 1 / 0;
    const r = n && n.playbackRate !== 0 ? Math.abs(n.playbackRate) : 1, i = e.mainForwardBufferInfo;
    return (i ? i.len : 0) / r;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(e, n, r, i, s, a, o) {
    var u;
    const l = i + s, c = this.lastLoadedFragLevel, d = c === -1 ? this.hls.firstLevel : c, {
      fragCurrent: f,
      partCurrent: h
    } = this, {
      levels: m,
      allAudioTracks: p,
      loadLevel: g,
      config: b
    } = this.hls;
    if (m.length === 1)
      return 0;
    const y = m[d], T = !!((u = this.hls.latestLevelDetails) != null && u.live), S = g === -1 || c === -1;
    let I, C = "SDR", _ = (y == null ? void 0 : y.frameRate) || 0;
    const {
      audioPreference: R,
      videoPreference: k
    } = b, A = this.audioTracksByGroup || (this.audioTracksByGroup = gx(p));
    let L = -1;
    if (S) {
      if (this.firstSelection !== -1)
        return this.firstSelection;
      const U = this.codecTiers || (this.codecTiers = YB(m, A, n, r)), B = jB(U, C, e, R, k), {
        codecSet: V,
        videoRanges: K,
        minFramerate: w,
        minBitrate: Y,
        minIndex: J,
        preferHDR: D
      } = B;
      L = J, I = V, C = D ? K[K.length - 1] : K[0], _ = w, e = Math.max(e, Y), this.log(`picked start tier ${Ze(B)}`);
    } else
      I = y == null ? void 0 : y.codecSet, C = y == null ? void 0 : y.videoRange;
    const P = h ? h.duration : f ? f.duration : 0, $ = this.bwEstimator.getEstimateTTFB() / 1e3, G = [];
    for (let U = r; U >= n; U--) {
      var N;
      const B = m[U], V = U > d;
      if (!B)
        continue;
      if (b.useMediaCapabilities && !B.supportedResult && !B.supportedPromise) {
        const he = navigator.mediaCapabilities;
        typeof (he == null ? void 0 : he.decodingInfo) == "function" && BB(B, A, C, _, e, R) ? (B.supportedPromise = mx(B, A, he, this.supportedCache), B.supportedPromise.then((ie) => {
          if (!this.hls)
            return;
          B.supportedResult = ie;
          const X = this.hls.levels, fe = X.indexOf(B);
          ie.error ? this.warn(`MediaCapabilities decodingInfo error: "${ie.error}" for level ${fe} ${Ze(ie)}`) : ie.supported ? ie.decodingInfoResults.some((Te) => Te.smooth === !1 || Te.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${fe} not smooth or powerEfficient: ${Ze(ie)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${fe} ${Ze(ie)}`), fe > -1 && X.length > 1 && (this.log(`Removing unsupported level ${fe}`), this.hls.removeLevel(fe), this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)));
        }).catch((ie) => {
          this.warn(`Error handling MediaCapabilities decodingInfo: ${ie}`);
        })) : B.supportedResult = fx;
      }
      if ((I && B.codecSet !== I || C && B.videoRange !== C || V && _ > B.frameRate || !V && _ > 0 && _ < B.frameRate || (N = B.supportedResult) != null && (N = N.decodingInfoResults) != null && N.some((he) => he.smooth === !1)) && (!S || U !== L)) {
        G.push(U);
        continue;
      }
      const K = B.details, w = (h ? K == null ? void 0 : K.partTarget : K == null ? void 0 : K.averagetargetduration) || P;
      let Y;
      V ? Y = o * e : Y = a * e;
      const J = P && i >= P * 2 && s === 0 ? B.averageBitrate : B.maxBitrate, D = this.getTimeToLoadFrag($, Y, J * w, K === void 0);
      if (
        // if adjusted bw is greater than level bitrate AND
        Y >= J && // no level change, or new level has no error history
        (U === c || B.loadError === 0 && B.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1
        (D <= $ || !de(D) || T && !this.bitrateTestDelay || D < l)
      ) {
        const he = this.forcedAutoLevel;
        return U !== g && (he === -1 || he !== g) && (G.length && this.trace(`Skipped level(s) ${G.join(",")} of ${r} max with CODECS and VIDEO-RANGE:"${m[G[0]].codecs}" ${m[G[0]].videoRange}; not compatible with "${I}" ${C}`), this.info(`switch candidate:${d}->${U} adjustedbw(${Math.round(Y)})-bitrate=${Math.round(Y - J)} ttfb:${$.toFixed(1)} avgDuration:${w.toFixed(1)} maxFetchDuration:${l.toFixed(1)} fetchDuration:${D.toFixed(1)} firstSelection:${S} codecSet:${B.codecSet} videoRange:${B.videoRange} hls.loadLevel:${g}`)), S && (this.firstSelection = U), U;
      }
    }
    return -1;
  }
  set nextAutoLevel(e) {
    const n = this.deriveNextAutoLevel(e);
    this._nextAutoLevel !== n && (this.nextAutoLevelKey = "", this._nextAutoLevel = n);
  }
  deriveNextAutoLevel(e) {
    const {
      maxAutoLevel: n,
      minAutoLevel: r
    } = this.hls;
    return Math.min(Math.max(e, r), n);
  }
}
const bx = {
  /**
   * Searches for an item in an array which matches a certain condition.
   * This requires the condition to only match one item in the array,
   * and for the array to be ordered.
   *
   * @param list The array to search.
   * @param comparisonFn
   *      Called and provided a candidate item as the first argument.
   *      Should return:
   *          > -1 if the item should be located at a lower index than the provided item.
   *          > 1 if the item should be located at a higher index than the provided item.
   *          > 0 if the item is the item you're looking for.
   *
   * @returns the object if found, otherwise returns null
   */
  search: function(t, e) {
    let n = 0, r = t.length - 1, i = null, s = null;
    for (; n <= r; ) {
      i = (n + r) / 2 | 0, s = t[i];
      const a = e(s);
      if (a > 0)
        n = i + 1;
      else if (a < 0)
        r = i - 1;
      else
        return s;
    }
    return null;
  }
};
function e9(t, e, n) {
  if (e === null || !Array.isArray(t) || !t.length || !de(e))
    return null;
  const r = t[0].programDateTime;
  if (e < (r || 0))
    return null;
  const i = t[t.length - 1].endProgramDateTime;
  if (e >= (i || 0))
    return null;
  for (let s = 0; s < t.length; ++s) {
    const a = t[s];
    if (n9(e, n, a))
      return a;
  }
  return null;
}
function ai(t, e, n = 0, r = 0, i = 5e-3) {
  let s = null;
  if (t) {
    s = e[1 + t.sn - e[0].sn] || null;
    const o = t.endDTS - n;
    o > 0 && o < 15e-7 && (n += 15e-7), s && t.level !== s.level && s.end <= t.end && (s = e[2 + t.sn - e[0].sn] || null);
  } else n === 0 && e[0].start === 0 && (s = e[0]);
  if (s && ((!t || t.level === s.level) && eg(n, r, s) === 0 || t9(s, t, Math.min(i, r))))
    return s;
  const a = bx.search(e, eg.bind(null, n, r));
  return a && (a !== t || !s) ? a : s;
}
function t9(t, e, n) {
  if (e && e.start === 0 && e.level < t.level && (e.endPTS || 0) > 0) {
    const r = e.tagList.reduce((i, s) => (s[0] === "INF" && (i += parseFloat(s[1])), i), n);
    return t.start <= r;
  }
  return !1;
}
function eg(t = 0, e = 0, n) {
  if (n.start <= t && n.start + n.duration > t)
    return 0;
  const r = Math.min(e, n.duration + (n.deltaPTS ? n.deltaPTS : 0));
  return n.start + n.duration - r <= t ? 1 : n.start - r > t && n.start ? -1 : 0;
}
function n9(t, e, n) {
  const r = Math.min(e, n.duration + (n.deltaPTS ? n.deltaPTS : 0)) * 1e3;
  return (n.endProgramDateTime || 0) - r > t;
}
function Ex(t, e, n) {
  if (t && t.startCC <= e && t.endCC >= e) {
    let r = t.fragments;
    const {
      fragmentHint: i
    } = t;
    i && (r = r.concat(i));
    let s;
    return bx.search(r, (a) => a.cc < e ? 1 : a.cc > e ? -1 : (s = a, a.end <= n ? 1 : a.start > n ? -1 : 0)), s || null;
  }
  return null;
}
function Nu(t) {
  switch (t.details) {
    case q.FRAG_LOAD_TIMEOUT:
    case q.KEY_LOAD_TIMEOUT:
    case q.LEVEL_LOAD_TIMEOUT:
    case q.MANIFEST_LOAD_TIMEOUT:
      return !0;
  }
  return !1;
}
function yx(t) {
  return t.details.startsWith("key");
}
function Tx(t) {
  return yx(t) && !!t.frag && !t.frag.decryptdata;
}
function tg(t, e) {
  const n = Nu(e);
  return t.default[`${n ? "timeout" : "error"}Retry`];
}
function Hh(t, e) {
  const n = t.backoff === "linear" ? 1 : Math.pow(2, e);
  return Math.min(n * t.retryDelayMs, t.maxRetryDelayMs);
}
function ng(t) {
  return ze(ze({}, t), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function Mu(t, e, n, r) {
  if (!t)
    return !1;
  const i = r == null ? void 0 : r.code, s = e < t.maxNumRetry && (r9(i) || !!n);
  return t.shouldRetry ? t.shouldRetry(t, e, n, r, s) : s;
}
function r9(t) {
  return Yd(t) || !!t && (t < 400 || t > 499);
}
function Yd(t) {
  return t === 0 && navigator.onLine === !1;
}
var Lt = {
  DoNothing: 0,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  RetryRequest: 5
}, an = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  MoveAllAlternatesMatchingKey: 4
};
class i9 extends En {
  constructor(e) {
    super("error-controller", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.ERROR, this.onError, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.ERROR, this.onError, this), e.off(x.ERROR, this.onErrorOut, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this));
  }
  destroy() {
    this.unregisterListeners(), this.hls = null;
  }
  startLoad(e) {
  }
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === pe.MAIN ? e.level : this.getVariantIndex();
  }
  getVariantIndex() {
    var e;
    const n = this.hls, r = n.currentLevel;
    return (e = n.loadLevelObj) != null && e.details || r === -1 ? n.loadLevel : r;
  }
  variantHasKey(e, n) {
    if (e) {
      var r;
      if ((r = e.details) != null && r.hasKey(n))
        return !0;
      const i = e.audioGroups;
      if (i)
        return this.hls.allAudioTracks.filter((a) => i.indexOf(a.groupId) >= 0).some((a) => {
          var o;
          return (o = a.details) == null ? void 0 : o.hasKey(n);
        });
    }
    return !1;
  }
  onManifestLoading() {
    this.playlistError = 0;
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(e, n) {
    var r;
    if (n.fatal)
      return;
    const i = this.hls, s = n.context;
    switch (n.details) {
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        n.errorAction = this.getFragRetryOrSwitchAction(n);
        return;
      case q.FRAG_PARSING_ERROR:
        if ((r = n.frag) != null && r.gap) {
          n.errorAction = ji();
          return;
        }
      case q.FRAG_GAP:
      case q.FRAG_DECRYPT_ERROR: {
        n.errorAction = this.getFragRetryOrSwitchAction(n), n.errorAction.action = Lt.SendAlternateToPenaltyBox;
        return;
      }
      case q.LEVEL_EMPTY_ERROR:
      case q.LEVEL_PARSING_ERROR:
        {
          var a;
          const u = n.parent === pe.MAIN ? n.level : i.loadLevel;
          n.details === q.LEVEL_EMPTY_ERROR && ((a = n.context) != null && (a = a.levelDetails) != null && a.live) ? n.errorAction = this.getPlaylistRetryOrSwitchAction(n, u) : (n.levelRetry = !1, n.errorAction = this.getLevelSwitchAction(n, u));
        }
        return;
      case q.LEVEL_LOAD_ERROR:
      case q.LEVEL_LOAD_TIMEOUT:
        typeof (s == null ? void 0 : s.level) == "number" && (n.errorAction = this.getPlaylistRetryOrSwitchAction(n, s.level));
        return;
      case q.AUDIO_TRACK_LOAD_ERROR:
      case q.AUDIO_TRACK_LOAD_TIMEOUT:
      case q.SUBTITLE_LOAD_ERROR:
      case q.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (s) {
          const u = i.loadLevelObj;
          if (u && (s.type === Me.AUDIO_TRACK && u.hasAudioGroup(s.groupId) || s.type === Me.SUBTITLE_TRACK && u.hasSubtitleGroup(s.groupId))) {
            n.errorAction = this.getPlaylistRetryOrSwitchAction(n, i.loadLevel), n.errorAction.action = Lt.SendAlternateToPenaltyBox, n.errorAction.flags = an.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        n.errorAction = {
          action: Lt.SendAlternateToPenaltyBox,
          flags: an.MoveAllAlternatesMatchingHDCP
        };
        return;
      case q.KEY_SYSTEM_SESSION_UPDATE_FAILED:
      case q.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
      case q.KEY_SYSTEM_NO_SESSION:
        n.errorAction = {
          action: Lt.SendAlternateToPenaltyBox,
          flags: an.MoveAllAlternatesMatchingKey
        };
        return;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.REMUX_ALLOC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (!n.errorAction) {
          var o;
          n.errorAction = this.getLevelSwitchAction(n, (o = n.level) != null ? o : i.loadLevel);
        }
        return;
      case q.INTERNAL_EXCEPTION:
      case q.BUFFER_APPENDING_ERROR:
      case q.BUFFER_FULL_ERROR:
      case q.LEVEL_SWITCH_ERROR:
      case q.BUFFER_STALLED_ERROR:
      case q.BUFFER_SEEK_OVER_HOLE:
      case q.BUFFER_NUDGE_ON_STALL:
        n.errorAction = ji();
        return;
    }
    n.type === be.KEY_SYSTEM_ERROR && (n.levelRetry = !1, n.errorAction = ji());
  }
  getPlaylistRetryOrSwitchAction(e, n) {
    const r = this.hls, i = tg(r.config.playlistLoadPolicy, e), s = this.playlistError++;
    if (Mu(i, s, Nu(e), e.response))
      return {
        action: Lt.RetryRequest,
        flags: an.None,
        retryConfig: i,
        retryCount: s
      };
    const o = this.getLevelSwitchAction(e, n);
    return i && (o.retryConfig = i, o.retryCount = s), o;
  }
  getFragRetryOrSwitchAction(e) {
    const n = this.hls, r = this.getVariantLevelIndex(e.frag), i = n.levels[r], {
      fragLoadPolicy: s,
      keyLoadPolicy: a
    } = n.config, o = tg(yx(e) ? a : s, e), u = n.levels.reduce((c, d) => c + d.fragmentError, 0);
    if (i && (e.details !== q.FRAG_GAP && i.fragmentError++, !Tx(e) && Mu(o, u, Nu(e), e.response)))
      return {
        action: Lt.RetryRequest,
        flags: an.None,
        retryConfig: o,
        retryCount: u
      };
    const l = this.getLevelSwitchAction(e, r);
    return o && (l.retryConfig = o, l.retryCount = u), l;
  }
  getLevelSwitchAction(e, n) {
    const r = this.hls;
    n == null && (n = r.loadLevel);
    const i = this.hls.levels[n];
    if (i) {
      var s, a;
      const l = e.details;
      i.loadError++, l === q.BUFFER_APPEND_ERROR && i.fragmentError++;
      let c = -1;
      const {
        levels: d,
        loadLevel: f,
        minAutoLevel: h,
        maxAutoLevel: m
      } = r;
      !r.autoLevelEnabled && !r.config.preserveManualLevelOnError && (r.loadLevel = -1);
      const p = (s = e.frag) == null ? void 0 : s.type, b = (p === pe.AUDIO && l === q.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (l === q.BUFFER_ADD_CODEC_ERROR || l === q.BUFFER_APPEND_ERROR)) && d.some(({
        audioCodec: C
      }) => i.audioCodec !== C), T = e.sourceBufferName === "video" && (l === q.BUFFER_ADD_CODEC_ERROR || l === q.BUFFER_APPEND_ERROR) && d.some(({
        codecSet: C,
        audioCodec: _
      }) => i.codecSet !== C && i.audioCodec === _), {
        type: S,
        groupId: I
      } = (a = e.context) != null ? a : {};
      for (let C = d.length; C--; ) {
        const _ = (C + f) % d.length;
        if (_ !== f && _ >= h && _ <= m && d[_].loadError === 0) {
          var o, u;
          const R = d[_];
          if (l === q.FRAG_GAP && p === pe.MAIN && e.frag) {
            const k = d[_].details;
            if (k) {
              const A = ai(e.frag, k.fragments, e.frag.start);
              if (A != null && A.gap)
                continue;
            }
          } else {
            if (S === Me.AUDIO_TRACK && R.hasAudioGroup(I) || S === Me.SUBTITLE_TRACK && R.hasSubtitleGroup(I))
              continue;
            if (p === pe.AUDIO && (o = i.audioGroups) != null && o.some((k) => R.hasAudioGroup(k)) || p === pe.SUBTITLE && (u = i.subtitleGroups) != null && u.some((k) => R.hasSubtitleGroup(k)) || b && i.audioCodec === R.audioCodec || T && i.codecSet === R.codecSet || !b && i.codecSet !== R.codecSet)
              continue;
          }
          c = _;
          break;
        }
      }
      if (c > -1 && r.loadLevel !== c)
        return e.levelRetry = !0, this.playlistError = 0, {
          action: Lt.SendAlternateToPenaltyBox,
          flags: an.None,
          nextAutoLevel: c
        };
    }
    return {
      action: Lt.SendAlternateToPenaltyBox,
      flags: an.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(e, n) {
    var r;
    switch ((r = n.errorAction) == null ? void 0 : r.action) {
      case Lt.DoNothing:
        break;
      case Lt.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(n), !n.errorAction.resolved && n.details !== q.FRAG_GAP ? n.fatal = !0 : /MediaSource readyState: ended/.test(n.error.message) && (this.warn(`MediaSource ended after "${n.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());
        break;
    }
    if (n.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(e) {
    const n = this.hls, r = e.errorAction;
    if (!r)
      return;
    const {
      flags: i
    } = r, s = r.nextAutoLevel;
    switch (i) {
      case an.None:
        this.switchLevel(e, s);
        break;
      case an.MoveAllAlternatesMatchingHDCP: {
        const u = this.getVariantLevelIndex(e.frag), l = n.levels[u], c = l == null ? void 0 : l.attrs["HDCP-LEVEL"];
        if (r.hdcpLevel = c, c === "NONE")
          this.warn("HDCP policy resticted output with HDCP-LEVEL=NONE");
        else if (c) {
          n.maxHdcpLevel = jd[jd.indexOf(c) - 1], r.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of "${n.maxHdcpLevel}" or lower`);
          break;
        }
      }
      case an.MoveAllAlternatesMatchingKey: {
        const u = e.decryptdata;
        if (u) {
          const l = this.hls.levels, c = l.length;
          for (let f = c; f--; )
            if (this.variantHasKey(l[f], u)) {
              var a, o;
              this.log(`Banned key found in level ${f} (${l[f].bitrate}bps) or audio group "${(a = l[f].audioGroups) == null ? void 0 : a.join(",")}" (${(o = e.frag) == null ? void 0 : o.type} fragment) ${Ft(u.keyId || [])}`), l[f].fragmentError++, l[f].loadError++, this.log(`Removing level ${f} with key error (${e.error})`), this.hls.removeLevel(f);
            }
          const d = e.frag;
          if (this.hls.levels.length < c)
            r.resolved = !0;
          else if (d && d.type !== pe.MAIN) {
            const f = d.decryptdata;
            f && !u.matches(f) && (r.resolved = !0);
          }
        }
        break;
      }
    }
    r.resolved || this.switchLevel(e, s);
  }
  switchLevel(e, n) {
    if (n !== void 0 && e.errorAction && (this.warn(`switching to level ${n} after ${e.details}`), this.hls.nextAutoLevel = n, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === q.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
      const r = Kd(e.mimeType), i = this.hls.levels;
      for (let s = i.length; s--; )
        i[s][`${e.sourceBufferName}Codec`] === r && (this.log(`Removing level ${s} for ${e.details} ("${r}" not supported)`), this.hls.removeLevel(s));
    }
  }
}
function ji(t) {
  const e = {
    action: Lt.DoNothing,
    flags: an.None
  };
  return t && (e.resolved = !0), e;
}
var Tt = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};
class s9 {
  constructor(e) {
    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this));
  }
  destroy() {
    this._unregisterListeners(), this.hls = // @ts-ignore
    this.fragments = // @ts-ignore
    this.activePartLists = // @ts-ignore
    this.endListFragments = this.timeRanges = null;
  }
  /**
   * Return a Fragment or Part with an appended range that matches the position and levelType
   * Otherwise, return null
   */
  getAppendedFrag(e, n) {
    const r = this.activePartLists[n];
    if (r)
      for (let i = r.length; i--; ) {
        const s = r[i];
        if (!s)
          break;
        if (s.start <= e && e <= s.end && s.loaded)
          return s;
      }
    return this.getBufferedFrag(e, n);
  }
  /**
   * Return a buffered Fragment that matches the position and levelType.
   * A buffered Fragment is one whose loading, parsing and appending is done (completed or "partial" meaning aborted).
   * If not found any Fragment, return null
   */
  getBufferedFrag(e, n) {
    return this.getFragAtPos(e, n, !0);
  }
  getFragAtPos(e, n, r) {
    const {
      fragments: i
    } = this, s = Object.keys(i);
    for (let a = s.length; a--; ) {
      const o = i[s[a]];
      if ((o == null ? void 0 : o.body.type) === n && (!r || o.buffered)) {
        const u = o.body;
        if (u.start <= e && e <= u.end)
          return u;
      }
    }
    return null;
  }
  /**
   * Partial fragments effected by coded frame eviction will be removed
   * The browser will unload parts of the buffer to free up memory for new buffer data
   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)
   */
  detectEvictedFragments(e, n, r, i, s) {
    this.timeRanges && (this.timeRanges[e] = n);
    const a = (i == null ? void 0 : i.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((o) => {
      const u = this.fragments[o];
      if (!u || a >= u.body.sn)
        return;
      if (!u.buffered && (!u.loaded || s)) {
        u.body.type === r && this.removeFragment(u.body);
        return;
      }
      const l = u.range[e];
      if (l) {
        if (l.time.length === 0) {
          this.removeFragment(u.body);
          return;
        }
        l.time.some((c) => {
          const d = !this.isTimeBuffered(c.startPTS, c.endPTS, n);
          return d && this.removeFragment(u.body), d;
        });
      }
    });
  }
  /**
   * Checks if the fragment passed in is loaded in the buffer properly
   * Partially loaded fragments will be registered as a partial fragment
   */
  detectPartialFragments(e) {
    const n = this.timeRanges;
    if (!n || e.frag.sn === "initSegment")
      return;
    const r = e.frag, i = _i(r), s = this.fragments[i];
    if (!s || s.buffered && r.gap)
      return;
    const a = !r.relurl;
    Object.keys(n).forEach((o) => {
      const u = r.elementaryStreams[o];
      if (!u)
        return;
      const l = n[o], c = a || u.partial === !0;
      s.range[o] = this.getBufferedTimes(r, e.part, c, l);
    }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, (s.body.endList = r.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), Ao(s) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(s.body);
  }
  removeParts(e, n) {
    const r = this.activePartLists[n];
    r && (this.activePartLists[n] = rg(r, (i) => i.fragment.sn >= e));
  }
  fragBuffered(e, n) {
    const r = _i(e);
    let i = this.fragments[r];
    !i && n && (i = this.fragments[r] = {
      body: e,
      appendedPTS: null,
      loaded: null,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0);
  }
  getBufferedTimes(e, n, r, i) {
    const s = {
      time: [],
      partial: r
    }, a = e.start, o = e.end, u = e.minEndPTS || o, l = e.maxStartPTS || a;
    for (let c = 0; c < i.length; c++) {
      const d = i.start(c) - this.bufferPadding, f = i.end(c) + this.bufferPadding;
      if (l >= d && u <= f) {
        s.time.push({
          startPTS: Math.max(a, i.start(c)),
          endPTS: Math.min(o, i.end(c))
        });
        break;
      } else if (a < f && o > d) {
        const h = Math.max(a, i.start(c)), m = Math.min(o, i.end(c));
        m > h && (s.partial = !0, s.time.push({
          startPTS: h,
          endPTS: m
        }));
      } else if (o <= d)
        break;
    }
    return s;
  }
  /**
   * Gets the partial fragment for a certain time
   */
  getPartialFragment(e) {
    let n = null, r, i, s, a = 0;
    const {
      bufferPadding: o,
      fragments: u
    } = this;
    return Object.keys(u).forEach((l) => {
      const c = u[l];
      c && Ao(c) && (i = c.body.start - o, s = c.body.end + o, e >= i && e <= s && (r = Math.min(e - i, s - e), a <= r && (n = c.body, a = r)));
    }), n;
  }
  isEndListAppended(e) {
    const n = this.endListFragments[e];
    return n !== void 0 && (n.buffered || Ao(n));
  }
  getState(e) {
    const n = _i(e), r = this.fragments[n];
    return r ? r.buffered ? Ao(r) ? Tt.PARTIAL : Tt.OK : Tt.APPENDING : Tt.NOT_LOADED;
  }
  isTimeBuffered(e, n, r) {
    let i, s;
    for (let a = 0; a < r.length; a++) {
      if (i = r.start(a) - this.bufferPadding, s = r.end(a) + this.bufferPadding, e >= i && n <= s)
        return !0;
      if (n <= i)
        return !1;
    }
    return !1;
  }
  onManifestLoading() {
    this.removeAllFragments();
  }
  onFragLoaded(e, n) {
    if (n.frag.sn === "initSegment" || n.frag.bitrateTest)
      return;
    const r = n.frag, i = n.part ? null : n, s = _i(r);
    this.fragments[s] = {
      body: r,
      appendedPTS: null,
      loaded: i,
      buffered: !1,
      range: /* @__PURE__ */ Object.create(null)
    };
  }
  onBufferAppended(e, n) {
    const {
      frag: r,
      part: i,
      timeRanges: s,
      type: a
    } = n;
    if (r.sn === "initSegment")
      return;
    const o = r.type;
    if (i) {
      let l = this.activePartLists[o];
      l || (this.activePartLists[o] = l = []), l.push(i);
    }
    this.timeRanges = s;
    const u = s[a];
    this.detectEvictedFragments(a, u, o, i);
  }
  onFragBuffered(e, n) {
    this.detectPartialFragments(n);
  }
  hasFragment(e) {
    const n = _i(e);
    return !!this.fragments[n];
  }
  hasFragments(e) {
    const {
      fragments: n
    } = this, r = Object.keys(n);
    if (!e)
      return r.length > 0;
    for (let i = r.length; i--; ) {
      const s = n[r[i]];
      if ((s == null ? void 0 : s.body.type) === e)
        return !0;
    }
    return !1;
  }
  hasParts(e) {
    var n;
    return !!((n = this.activePartLists[e]) != null && n.length);
  }
  removeFragmentsInRange(e, n, r, i, s) {
    i && !this.hasGaps || Object.keys(this.fragments).forEach((a) => {
      const o = this.fragments[a];
      if (!o)
        return;
      const u = o.body;
      u.type !== r || i && !u.gap || u.start < n && u.end > e && (o.buffered || s) && this.removeFragment(u);
    });
  }
  removeFragment(e) {
    const n = _i(e);
    e.clearElementaryStreamInfo();
    const r = this.activePartLists[e.type];
    if (r) {
      const i = e.sn;
      this.activePartLists[e.type] = rg(r, (s) => s.fragment.sn !== i);
    }
    delete this.fragments[n], e.endList && delete this.endListFragments[e.type];
  }
  removeAllFragments() {
    var e;
    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;
    const n = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;
    n && n.forEach((r) => r.clearElementaryStreamInfo());
  }
}
function Ao(t) {
  var e, n, r;
  return t.buffered && !!(t.body.gap || (e = t.range.video) != null && e.partial || (n = t.range.audio) != null && n.partial || (r = t.range.audiovideo) != null && r.partial);
}
function _i(t) {
  return `${t.type}_${t.level}_${t.sn}`;
}
function rg(t, e) {
  return t.filter((n) => {
    const r = e(n);
    return r || n.clearElementaryStreamInfo(), r;
  });
}
var Nr = {
  cbc: 0,
  ctr: 1
};
class a9 {
  constructor(e, n, r) {
    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = n, this.aesMode = r;
  }
  decrypt(e, n) {
    switch (this.aesMode) {
      case Nr.cbc:
        return this.subtle.decrypt({
          name: "AES-CBC",
          iv: this.aesIV
        }, n, e);
      case Nr.ctr:
        return this.subtle.decrypt(
          {
            name: "AES-CTR",
            counter: this.aesIV,
            length: 64
          },
          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block
          n,
          e
        );
      default:
        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);
    }
  }
}
function o9(t) {
  const e = t.byteLength, n = e && new DataView(t.buffer).getUint8(e - 1);
  return n ? t.slice(0, e - n) : t;
}
class u9 {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();
  }
  // Using view.getUint32() also swaps the byte order.
  uint8ArrayToUint32Array_(e) {
    const n = new DataView(e), r = new Uint32Array(4);
    for (let i = 0; i < 4; i++)
      r[i] = n.getUint32(i * 4);
    return r;
  }
  initTable() {
    const e = this.sBox, n = this.invSBox, r = this.subMix, i = r[0], s = r[1], a = r[2], o = r[3], u = this.invSubMix, l = u[0], c = u[1], d = u[2], f = u[3], h = new Uint32Array(256);
    let m = 0, p = 0, g = 0;
    for (g = 0; g < 256; g++)
      g < 128 ? h[g] = g << 1 : h[g] = g << 1 ^ 283;
    for (g = 0; g < 256; g++) {
      let b = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
      b = b >>> 8 ^ b & 255 ^ 99, e[m] = b, n[b] = m;
      const y = h[m], T = h[y], S = h[T];
      let I = h[b] * 257 ^ b * 16843008;
      i[m] = I << 24 | I >>> 8, s[m] = I << 16 | I >>> 16, a[m] = I << 8 | I >>> 24, o[m] = I, I = S * 16843009 ^ T * 65537 ^ y * 257 ^ m * 16843008, l[b] = I << 24 | I >>> 8, c[b] = I << 16 | I >>> 16, d[b] = I << 8 | I >>> 24, f[b] = I, m ? (m = y ^ h[h[h[S ^ y]]], p ^= h[h[p]]) : m = p = 1;
    }
  }
  expandKey(e) {
    const n = this.uint8ArrayToUint32Array_(e);
    let r = !0, i = 0;
    for (; i < n.length && r; )
      r = n[i] === this.key[i], i++;
    if (r)
      return;
    this.key = n;
    const s = this.keySize = n.length;
    if (s !== 4 && s !== 6 && s !== 8)
      throw new Error("Invalid aes key size=" + s);
    const a = this.ksRows = (s + 6 + 1) * 4;
    let o, u;
    const l = this.keySchedule = new Uint32Array(a), c = this.invKeySchedule = new Uint32Array(a), d = this.sBox, f = this.rcon, h = this.invSubMix, m = h[0], p = h[1], g = h[2], b = h[3];
    let y, T;
    for (o = 0; o < a; o++) {
      if (o < s) {
        y = l[o] = n[o];
        continue;
      }
      T = y, o % s === 0 ? (T = T << 8 | T >>> 24, T = d[T >>> 24] << 24 | d[T >>> 16 & 255] << 16 | d[T >>> 8 & 255] << 8 | d[T & 255], T ^= f[o / s | 0] << 24) : s > 6 && o % s === 4 && (T = d[T >>> 24] << 24 | d[T >>> 16 & 255] << 16 | d[T >>> 8 & 255] << 8 | d[T & 255]), l[o] = y = (l[o - s] ^ T) >>> 0;
    }
    for (u = 0; u < a; u++)
      o = a - u, u & 3 ? T = l[o] : T = l[o - 4], u < 4 || o <= 4 ? c[u] = T : c[u] = m[d[T >>> 24]] ^ p[d[T >>> 16 & 255]] ^ g[d[T >>> 8 & 255]] ^ b[d[T & 255]], c[u] = c[u] >>> 0;
  }
  // Adding this as a method greatly improves performance.
  networkToHostOrderSwap(e) {
    return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24;
  }
  decrypt(e, n, r) {
    const i = this.keySize + 6, s = this.invKeySchedule, a = this.invSBox, o = this.invSubMix, u = o[0], l = o[1], c = o[2], d = o[3], f = this.uint8ArrayToUint32Array_(r);
    let h = f[0], m = f[1], p = f[2], g = f[3];
    const b = new Int32Array(e), y = new Int32Array(b.length);
    let T, S, I, C, _, R, k, A, L, P, $, G, N, U;
    const B = this.networkToHostOrderSwap;
    for (; n < b.length; ) {
      for (L = B(b[n]), P = B(b[n + 1]), $ = B(b[n + 2]), G = B(b[n + 3]), _ = L ^ s[0], R = G ^ s[1], k = $ ^ s[2], A = P ^ s[3], N = 4, U = 1; U < i; U++)
        T = u[_ >>> 24] ^ l[R >> 16 & 255] ^ c[k >> 8 & 255] ^ d[A & 255] ^ s[N], S = u[R >>> 24] ^ l[k >> 16 & 255] ^ c[A >> 8 & 255] ^ d[_ & 255] ^ s[N + 1], I = u[k >>> 24] ^ l[A >> 16 & 255] ^ c[_ >> 8 & 255] ^ d[R & 255] ^ s[N + 2], C = u[A >>> 24] ^ l[_ >> 16 & 255] ^ c[R >> 8 & 255] ^ d[k & 255] ^ s[N + 3], _ = T, R = S, k = I, A = C, N = N + 4;
      T = a[_ >>> 24] << 24 ^ a[R >> 16 & 255] << 16 ^ a[k >> 8 & 255] << 8 ^ a[A & 255] ^ s[N], S = a[R >>> 24] << 24 ^ a[k >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[_ & 255] ^ s[N + 1], I = a[k >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[_ >> 8 & 255] << 8 ^ a[R & 255] ^ s[N + 2], C = a[A >>> 24] << 24 ^ a[_ >> 16 & 255] << 16 ^ a[R >> 8 & 255] << 8 ^ a[k & 255] ^ s[N + 3], y[n] = B(T ^ h), y[n + 1] = B(C ^ m), y[n + 2] = B(I ^ p), y[n + 3] = B(S ^ g), h = L, m = P, p = $, g = G, n = n + 4;
    }
    return y.buffer;
  }
}
class l9 {
  constructor(e, n, r) {
    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = n, this.aesMode = r;
  }
  expandKey() {
    const e = c9(this.aesMode);
    return this.subtle.importKey("raw", this.key, {
      name: e
    }, !1, ["encrypt", "decrypt"]);
  }
}
function c9(t) {
  switch (t) {
    case Nr.cbc:
      return "AES-CBC";
    case Nr.ctr:
      return "AES-CTR";
    default:
      throw new Error(`[FastAESKey] invalid aes mode ${t}`);
  }
}
const d9 = 16;
class Vh {
  constructor(e, {
    removePKCS7Padding: n = !0
  } = {}) {
    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = n, n)
      try {
        const r = self.crypto;
        r && (this.subtle = r.subtle || r.webkitSubtle);
      } catch {
      }
    this.useSoftware = !this.subtle;
  }
  destroy() {
    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult: e,
      remainderData: n
    } = this;
    if (!e || n)
      return this.reset(), null;
    const r = new Uint8Array(e);
    return this.reset(), this.removePKCS7Padding ? o9(r) : r;
  }
  reset() {
    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);
  }
  decrypt(e, n, r, i) {
    return this.useSoftware ? new Promise((s, a) => {
      const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
      this.softwareDecrypt(o, n, r, i);
      const u = this.flush();
      u ? s(u.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"));
    }) : this.webCryptoDecrypt(new Uint8Array(e), n, r, i);
  }
  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached
  // data is handled in the flush() call
  softwareDecrypt(e, n, r, i) {
    const {
      currentIV: s,
      currentResult: a,
      remainderData: o
    } = this;
    if (i !== Nr.cbc || n.byteLength !== 16)
      return qe.warn("SoftwareDecrypt: can only handle AES-128-CBC"), null;
    this.logOnce("JS AES decrypt"), o && (e = gn(o, e), this.remainderData = null);
    const u = this.getValidChunk(e);
    if (!u.length)
      return null;
    s && (r = s);
    let l = this.softwareDecrypter;
    l || (l = this.softwareDecrypter = new u9()), l.expandKey(n);
    const c = a;
    return this.currentResult = l.decrypt(u.buffer, 0, r), this.currentIV = u.slice(-16).buffer, c || null;
  }
  webCryptoDecrypt(e, n, r, i) {
    if (this.key !== n || !this.fastAesKey) {
      if (!this.subtle)
        return Promise.resolve(this.onWebCryptoError(e, n, r, i));
      this.key = n, this.fastAesKey = new l9(this.subtle, n, i);
    }
    return this.fastAesKey.expandKey().then((s) => this.subtle ? (this.logOnce("WebCrypto AES decrypt"), new a9(this.subtle, new Uint8Array(r), i).decrypt(e.buffer, s)) : Promise.reject(new Error("web crypto not initialized"))).catch((s) => (qe.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${s.name}: ${s.message}`), this.onWebCryptoError(e, n, r, i)));
  }
  onWebCryptoError(e, n, r, i) {
    const s = this.enableSoftwareAES;
    if (s) {
      this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, n, r, i);
      const a = this.flush();
      if (a)
        return a.buffer;
    }
    throw new Error("WebCrypto" + (s ? " and softwareDecrypt" : "") + ": failed to decrypt data");
  }
  getValidChunk(e) {
    let n = e;
    const r = e.length - e.length % d9;
    return r !== e.length && (n = e.slice(0, r), this.remainderData = e.slice(r)), n;
  }
  logOnce(e) {
    this.logEnabled && (qe.log(`[decrypter]: ${e}`), this.logEnabled = !1);
  }
}
const ig = Math.pow(2, 17);
class f9 {
  constructor(e) {
    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;
  }
  destroy() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }
  abort() {
    this.loader && this.loader.abort();
  }
  load(e, n) {
    const r = e.url;
    if (!r)
      return Promise.reject(new or({
        type: be.NETWORK_ERROR,
        details: q.FRAG_LOAD_ERROR,
        fatal: !1,
        frag: e,
        error: new Error(`Fragment does not have a ${r ? "part list" : "url"}`),
        networkDetails: null
      }));
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, u) => {
      if (this.loader && this.loader.destroy(), e.gap)
        if (e.tagList.some((m) => m[0] === "GAP")) {
          u(ag(e));
          return;
        } else
          e.gap = !1;
      const l = this.loader = s ? new s(i) : new a(i), c = sg(e);
      e.loader = l;
      const d = ng(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: e.sn === "initSegment" ? 1 / 0 : ig
      };
      e.stats = l.stats;
      const h = {
        onSuccess: (m, p, g, b) => {
          this.resetLoader(e, l);
          let y = m.data;
          g.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(y.slice(0, 16)), y = y.slice(16)), o({
            frag: e,
            part: null,
            payload: y,
            networkDetails: b
          });
        },
        onError: (m, p, g, b) => {
          this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            response: ze({
              url: r,
              data: void 0
            }, m),
            error: new Error(`HTTP Error ${m.code} ${m.text}`),
            networkDetails: g,
            stats: b
          }));
        },
        onAbort: (m, p, g) => {
          this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            error: new Error("Aborted"),
            networkDetails: g,
            stats: m
          }));
        },
        onTimeout: (m, p, g) => {
          this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: g,
            stats: m
          }));
        }
      };
      n && (h.onProgress = (m, p, g, b) => n({
        frag: e,
        part: null,
        payload: g,
        networkDetails: b
      })), l.load(c, f, h);
    });
  }
  loadPart(e, n, r) {
    this.abort();
    const i = this.config, s = i.fLoader, a = i.loader;
    return new Promise((o, u) => {
      if (this.loader && this.loader.destroy(), e.gap || n.gap) {
        u(ag(e, n));
        return;
      }
      const l = this.loader = s ? new s(i) : new a(i), c = sg(e, n);
      e.loader = l;
      const d = ng(i.fragLoadPolicy.default), f = {
        loadPolicy: d,
        timeout: d.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: ig
      };
      n.stats = l.stats, l.load(c, f, {
        onSuccess: (h, m, p, g) => {
          this.resetLoader(e, l), this.updateStatsFromPart(e, n);
          const b = {
            frag: e,
            part: n,
            payload: h.data,
            networkDetails: g
          };
          r(b), o(b);
        },
        onError: (h, m, p, g) => {
          this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.FRAG_LOAD_ERROR,
            fatal: !1,
            frag: e,
            part: n,
            response: ze({
              url: c.url,
              data: void 0
            }, h),
            error: new Error(`HTTP Error ${h.code} ${h.text}`),
            networkDetails: p,
            stats: g
          }));
        },
        onAbort: (h, m, p) => {
          e.stats.aborted = n.stats.aborted, this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.INTERNAL_ABORTED,
            fatal: !1,
            frag: e,
            part: n,
            error: new Error("Aborted"),
            networkDetails: p,
            stats: h
          }));
        },
        onTimeout: (h, m, p) => {
          this.resetLoader(e, l), u(new or({
            type: be.NETWORK_ERROR,
            details: q.FRAG_LOAD_TIMEOUT,
            fatal: !1,
            frag: e,
            part: n,
            error: new Error(`Timeout after ${f.timeout}ms`),
            networkDetails: p,
            stats: h
          }));
        }
      });
    });
  }
  updateStatsFromPart(e, n) {
    const r = e.stats, i = n.stats, s = i.total;
    if (r.loaded += i.loaded, s) {
      const u = Math.round(e.duration / n.duration), l = Math.min(Math.round(r.loaded / s), u), d = (u - l) * Math.round(r.loaded / l);
      r.total = r.loaded + d;
    } else
      r.total = Math.max(r.loaded, r.total);
    const a = r.loading, o = i.loading;
    a.start ? a.first += o.first - o.start : (a.start = o.start, a.first = o.first), a.end = o.end;
  }
  resetLoader(e, n) {
    e.loader = null, this.loader === n && (self.clearTimeout(this.partLoadTimeout), this.loader = null), n.destroy();
  }
}
function sg(t, e = null) {
  const n = e || t, r = {
    frag: t,
    part: e,
    responseType: "arraybuffer",
    url: n.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  }, i = n.byteRangeStartOffset, s = n.byteRangeEndOffset;
  if (de(i) && de(s)) {
    var a;
    let o = i, u = s;
    if (t.sn === "initSegment" && h9((a = t.decryptdata) == null ? void 0 : a.method)) {
      const l = s - i;
      l % 16 && (u = s + (16 - l % 16)), i !== 0 && (r.resetIV = !0, o = i - 16);
    }
    r.rangeStart = o, r.rangeEnd = u;
  }
  return r;
}
function ag(t, e) {
  const n = new Error(`GAP ${t.gap ? "tag" : "attribute"} found`), r = {
    type: be.MEDIA_ERROR,
    details: q.FRAG_GAP,
    fatal: !1,
    frag: t,
    error: n,
    networkDetails: null
  };
  return e && (r.part = e), (e || t).stats.aborted = !0, new or(r);
}
function h9(t) {
  return t === "AES-128" || t === "AES-256";
}
class or extends Error {
  constructor(e) {
    super(e.error.message), this.data = void 0, this.data = e;
  }
}
class Sx extends En {
  constructor(e, n) {
    super(e, n), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  /**
   * @param millis - Interval time (ms)
   * @eturns True when interval has been scheduled, false when already scheduled (no effect)
   */
  setInterval(e) {
    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);
  }
  /**
   * @returns True when interval was cleared, false when none was set (no effect)
   */
  clearInterval() {
    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;
  }
  /**
   * @returns True when timeout was cleared, false when none was set (no effect)
   */
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;
  }
  /**
   * Will call the subclass doTick implementation in this main loop tick
   * or in the next one (via setTimeout(,0)) in case it has already been called
   * in this tick (in case this is a re-entrant call).
   */
  tick() {
    this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);
  }
  tickImmediate() {
    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  /**
   * For subclass to implement task logic
   * @abstract
   */
  doTick() {
  }
}
class Gh {
  constructor(e, n, r, i = 0, s = -1, a = !1) {
    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = Io(), this.buffering = {
      audio: Io(),
      video: Io(),
      audiovideo: Io()
    }, this.level = e, this.sn = n, this.id = r, this.size = i, this.part = s, this.partial = a;
  }
}
function Io() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
const og = {
  length: 0,
  start: () => 0,
  end: () => 0
};
class Ce {
  /**
   * Return true if `media`'s buffered include `position`
   */
  static isBuffered(e, n) {
    if (e) {
      const r = Ce.getBuffered(e);
      for (let i = r.length; i--; )
        if (n >= r.start(i) && n <= r.end(i))
          return !0;
    }
    return !1;
  }
  static bufferedRanges(e) {
    if (e) {
      const n = Ce.getBuffered(e);
      return Ce.timeRangesToArray(n);
    }
    return [];
  }
  static timeRangesToArray(e) {
    const n = [];
    for (let r = 0; r < e.length; r++)
      n.push({
        start: e.start(r),
        end: e.end(r)
      });
    return n;
  }
  static bufferInfo(e, n, r) {
    if (e) {
      const i = Ce.bufferedRanges(e);
      if (i.length)
        return Ce.bufferedInfo(i, n, r);
    }
    return {
      len: 0,
      start: n,
      end: n,
      bufferedIndex: -1
    };
  }
  static bufferedInfo(e, n, r) {
    n = Math.max(0, n), e.length > 1 && e.sort((c, d) => c.start - d.start || d.end - c.end);
    let i = -1, s = [];
    if (r)
      for (let c = 0; c < e.length; c++) {
        n >= e[c].start && n <= e[c].end && (i = c);
        const d = s.length;
        if (d) {
          const f = s[d - 1].end;
          e[c].start - f < r ? e[c].end > f && (s[d - 1].end = e[c].end) : s.push(e[c]);
        } else
          s.push(e[c]);
      }
    else
      s = e;
    let a = 0, o, u = n, l = n;
    for (let c = 0; c < s.length; c++) {
      const d = s[c].start, f = s[c].end;
      if (i === -1 && n >= d && n <= f && (i = c), n + r >= d && n < f)
        u = d, l = f, a = l - n;
      else if (n + r < d) {
        o = d;
        break;
      }
    }
    return {
      len: a,
      start: u || 0,
      end: l || 0,
      nextStart: o,
      buffered: e,
      bufferedIndex: i
    };
  }
  /**
   * Safe method to get buffered property.
   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource
   */
  static getBuffered(e) {
    try {
      return e.buffered || og;
    } catch (n) {
      return qe.log("failed to get media.buffered", n), og;
    }
  }
}
const xx = /\{\$([a-zA-Z0-9-_]+)\}/g;
function ug(t) {
  return xx.test(t);
}
function Xd(t, e) {
  if (t.variableList !== null || t.hasVariableRefs) {
    const n = t.variableList;
    return e.replace(xx, (r) => {
      const i = r.substring(2, r.length - 1), s = n == null ? void 0 : n[i];
      return s === void 0 ? (t.playlistParsingError || (t.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${i}"`)), r) : s;
    });
  }
  return e;
}
function lg(t, e, n) {
  let r = t.variableList;
  r || (t.variableList = r = {});
  let i, s;
  if ("QUERYPARAM" in e) {
    i = e.QUERYPARAM;
    try {
      const a = new self.URL(n).searchParams;
      if (a.has(i))
        s = a.get(i);
      else
        throw new Error(`"${i}" does not match any query parameter in URI: "${n}"`);
    } catch (a) {
      t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`));
    }
  } else
    i = e.NAME, s = e.VALUE;
  i in r ? t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${i}"`)) : r[i] = s || "";
}
function m9(t, e, n) {
  const r = e.IMPORT;
  if (n && r in n) {
    let i = t.variableList;
    i || (t.variableList = i = {}), i[r] = n[r];
  } else
    t.playlistParsingError || (t.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`));
}
const p9 = /^(\d+)x(\d+)$/, cg = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class ut {
  constructor(e, n) {
    typeof e == "string" && (e = ut.parseAttrList(e, n)), Xe(this, e);
  }
  get clientAttrs() {
    return Object.keys(this).filter((e) => e.substring(0, 2) === "X-");
  }
  decimalInteger(e) {
    const n = parseInt(this[e], 10);
    return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let n = (this[e] || "0x").slice(2);
      n = (n.length & 1 ? "0" : "") + n;
      const r = new Uint8Array(n.length / 2);
      for (let i = 0; i < n.length / 2; i++)
        r[i] = parseInt(n.slice(i * 2, i * 2 + 2), 16);
      return r;
    }
    return null;
  }
  hexadecimalIntegerAsNumber(e) {
    const n = parseInt(this[e], 16);
    return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e]);
  }
  optionalFloat(e, n) {
    const r = this[e];
    return r ? parseFloat(r) : n;
  }
  enumeratedString(e) {
    return this[e];
  }
  enumeratedStringList(e, n) {
    const r = this[e];
    return (r ? r.split(/[ ,]+/) : []).reduce((i, s) => (i[s.toLowerCase()] = !0, i), n);
  }
  bool(e) {
    return this[e] === "YES";
  }
  decimalResolution(e) {
    const n = p9.exec(this[e]);
    if (n !== null)
      return {
        width: parseInt(n[1], 10),
        height: parseInt(n[2], 10)
      };
  }
  static parseAttrList(e, n) {
    let r;
    const i = {}, s = '"';
    for (cg.lastIndex = 0; (r = cg.exec(e)) !== null; ) {
      const a = r[1].trim();
      let o = r[2];
      const u = o.indexOf(s) === 0 && o.lastIndexOf(s) === o.length - 1;
      let l = !1;
      if (u)
        o = o.slice(1, -1);
      else
        switch (a) {
          case "IV":
          case "SCTE35-CMD":
          case "SCTE35-IN":
          case "SCTE35-OUT":
            l = !0;
        }
      if (n && (u || l))
        o = Xd(n, o);
      else if (!l && !u)
        switch (a) {
          case "CLOSED-CAPTIONS":
            if (o === "NONE")
              break;
          case "ALLOWED-CPC":
          case "CLASS":
          case "ASSOC-LANGUAGE":
          case "AUDIO":
          case "BYTERANGE":
          case "CHANNELS":
          case "CHARACTERISTICS":
          case "CODECS":
          case "DATA-ID":
          case "END-DATE":
          case "GROUP-ID":
          case "ID":
          case "IMPORT":
          case "INSTREAM-ID":
          case "KEYFORMAT":
          case "KEYFORMATVERSIONS":
          case "LANGUAGE":
          case "NAME":
          case "PATHWAY-ID":
          case "QUERYPARAM":
          case "RECENTLY-REMOVED-DATERANGES":
          case "SERVER-URI":
          case "STABLE-RENDITION-ID":
          case "STABLE-VARIANT-ID":
          case "START-DATE":
          case "SUBTITLES":
          case "SUPPLEMENTAL-CODECS":
          case "URI":
          case "VALUE":
          case "VIDEO":
          case "X-ASSET-LIST":
          case "X-ASSET-URI":
            qe.warn(`${e}: attribute ${a} is missing quotes`);
        }
      i[a] = o;
    }
    return i;
  }
}
const g9 = "com.apple.hls.interstitial";
function b9(t) {
  return t !== "ID" && t !== "CLASS" && t !== "CUE" && t !== "START-DATE" && t !== "DURATION" && t !== "END-DATE" && t !== "END-ON-NEXT";
}
function E9(t) {
  return t === "SCTE35-OUT" || t === "SCTE35-IN" || t === "SCTE35-CMD";
}
class vx {
  constructor(e, n, r = 0) {
    var i;
    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (n == null ? void 0 : n.tagAnchor) || null, this.tagOrder = (i = n == null ? void 0 : n.tagOrder) != null ? i : r, n) {
      const s = n.attr;
      for (const a in s)
        if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== s[a]) {
          qe.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = a;
          break;
        }
      e = Xe(new ut({}), s, e);
    }
    if (this.attr = e, n ? (this._startDate = n._startDate, this._cue = n._cue, this._endDate = n._endDate, this._dateAtEnd = n._dateAtEnd) : this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
      const s = (n == null ? void 0 : n.endDate) || new Date(this.attr["END-DATE"]);
      de(s.getTime()) && (this._endDate = s);
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get cue() {
    const e = this._cue;
    return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
      pre: !1,
      post: !1,
      once: !1
    }) : e;
  }
  get startTime() {
    const {
      tagAnchor: e
    } = this;
    return e === null || e.programDateTime === null ? (qe.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    const e = this._endDate || this._dateAtEnd;
    if (e)
      return e;
    const n = this.duration;
    return n !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + n * 1e3) : null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const e = this.attr.decimalFloatingPoint("DURATION");
      if (de(e))
        return e;
    } else if (this._endDate)
      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
    return null;
  }
  get plannedDuration() {
    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isInterstitial() {
    return this.class === g9;
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && de(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI" in this.attr || "X-ASSET-LIST" in this.attr);
  }
}
const y9 = 10;
class T9 {
  constructor(e) {
    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;
  }
  reloaded(e) {
    if (!e) {
      this.advanced = !0, this.updated = !0;
      return;
    }
    const n = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex;
    this.updated = this.endSN !== e.endSN || !!r || !!n || !this.live, this.advanced = this.endSN > e.endSN || n > 0 || n === 0 && r > 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;
  }
  hasKey(e) {
    return this.encryptedFragments.some((n) => {
      let r = n.decryptdata;
      return r || (n.setKeyFormat(e.keyFormat), r = n.decryptdata), !!r && e.matches(r);
    });
  }
  get hasProgramDateTime() {
    return this.fragments.length ? de(this.fragments[this.fragments.length - 1].programDateTime) : !1;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || y9;
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime;
    return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;
  }
  get fragmentEnd() {
    return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0;
  }
  get fragmentStart() {
    return this.fragments.length ? this.fragments[0].start : 0;
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;
  }
  get lastPartIndex() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1;
  }
  get maxPartIndex() {
    const e = this.partList;
    if (e) {
      const n = this.lastPartIndex;
      if (n !== -1) {
        for (let r = e.length; r--; )
          if (e[r].index > n)
            return e[r].index;
        return n;
      }
    }
    return 0;
  }
  get lastPartSn() {
    var e;
    return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;
  }
  get expired() {
    if (this.live && this.age && this.misses < 3) {
      const e = this.partEnd - this.fragmentStart;
      return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration;
    }
    return !1;
  }
}
function Fu(t, e) {
  return t.length === e.length ? !t.some((n, r) => n !== e[r]) : !1;
}
function dg(t, e) {
  return !t && !e ? !0 : !t || !e ? !1 : Fu(t, e);
}
function Yi(t) {
  return t === "AES-128" || t === "AES-256" || t === "AES-256-CTR";
}
function zh(t) {
  switch (t) {
    case "AES-128":
    case "AES-256":
      return Nr.cbc;
    case "AES-256-CTR":
      return Nr.ctr;
    default:
      throw new Error(`invalid full segment method ${t}`);
  }
}
function qh(t) {
  return Uint8Array.from(atob(t), (e) => e.charCodeAt(0));
}
function Qd(t) {
  return Uint8Array.from(unescape(encodeURIComponent(t)), (e) => e.charCodeAt(0));
}
function S9(t) {
  const e = Qd(t).subarray(0, 16), n = new Uint8Array(16);
  return n.set(e, 16 - e.length), n;
}
function Ax(t) {
  const e = function(r, i, s) {
    const a = r[i];
    r[i] = r[s], r[s] = a;
  };
  e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7);
}
function Ix(t) {
  const e = t.split(":");
  let n = null;
  if (e[0] === "data" && e.length === 2) {
    const r = e[1].split(";"), i = r[r.length - 1].split(",");
    if (i.length === 2) {
      const s = i[0] === "base64", a = i[1];
      s ? (r.splice(-1, 1), n = qh(a)) : n = S9(a);
    }
  }
  return n;
}
const Bu = typeof self < "u" ? self : void 0;
var lt = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
}, _t = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function eu(t) {
  switch (t) {
    case _t.FAIRPLAY:
      return lt.FAIRPLAY;
    case _t.PLAYREADY:
      return lt.PLAYREADY;
    case _t.WIDEVINE:
      return lt.WIDEVINE;
    case _t.CLEARKEY:
      return lt.CLEARKEY;
  }
}
function yc(t) {
  switch (t) {
    case lt.FAIRPLAY:
      return _t.FAIRPLAY;
    case lt.PLAYREADY:
      return _t.PLAYREADY;
    case lt.WIDEVINE:
      return _t.WIDEVINE;
    case lt.CLEARKEY:
      return _t.CLEARKEY;
  }
}
function Ks(t) {
  const {
    drmSystems: e,
    widevineLicenseUrl: n
  } = t, r = e ? [lt.FAIRPLAY, lt.WIDEVINE, lt.PLAYREADY, lt.CLEARKEY].filter((i) => !!e[i]) : [];
  return !r[lt.WIDEVINE] && n && r.push(lt.WIDEVINE), r;
}
const Cx = function(t) {
  return Bu != null && (t = Bu.navigator) != null && t.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;
}();
function x9(t, e, n, r) {
  let i;
  switch (t) {
    case lt.FAIRPLAY:
      i = ["cenc", "sinf"];
      break;
    case lt.WIDEVINE:
    case lt.PLAYREADY:
      i = ["cenc"];
      break;
    case lt.CLEARKEY:
      i = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${t}`);
  }
  return v9(i, e, n, r);
}
function v9(t, e, n, r) {
  return [{
    initDataTypes: t,
    persistentState: r.persistentState || "optional",
    distinctiveIdentifier: r.distinctiveIdentifier || "optional",
    sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
    audioCapabilities: e.map((s) => ({
      contentType: `audio/mp4; codecs=${s}`,
      robustness: r.audioRobustness || "",
      encryptionScheme: r.audioEncryptionScheme || null
    })),
    videoCapabilities: n.map((s) => ({
      contentType: `video/mp4; codecs=${s}`,
      robustness: r.videoRobustness || "",
      encryptionScheme: r.videoEncryptionScheme || null
    }))
  }];
}
function A9(t) {
  var e;
  return !!t && (t.sessionType === "persistent-license" || !!((e = t.sessionTypes) != null && e.some((n) => n === "persistent-license")));
}
function Lx(t) {
  const e = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2), n = String.fromCharCode.apply(null, Array.from(e)), r = n.substring(n.indexOf("<"), n.length), a = new DOMParser().parseFromString(r, "text/xml").getElementsByTagName("KID")[0];
  if (a) {
    const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
    if (o) {
      const u = qh(o).subarray(0, 16);
      return Ax(u), u;
    }
  }
  return null;
}
let Co = {};
class ni {
  static clearKeyUriToKeyIdMap() {
    Co = {};
  }
  static setKeyIdForUri(e, n) {
    Co[e] = n;
  }
  constructor(e, n, r, i = [1], s = null, a) {
    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = n, this.keyFormat = r, this.keyFormatVersions = i, this.iv = s, this.encrypted = e ? e !== "NONE" : !1, this.isCommonEncryption = this.encrypted && !Yi(e), a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(tx(a)));
  }
  matches(e) {
    return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && Fu(e.keyFormatVersions, this.keyFormatVersions) && dg(e.iv, this.iv) && dg(e.keyId, this.keyId);
  }
  isSupported() {
    if (this.method) {
      if (Yi(this.method) || this.method === "NONE")
        return !0;
      if (this.keyFormat === "identity")
        return this.method === "SAMPLE-AES";
      switch (this.keyFormat) {
        case _t.FAIRPLAY:
        case _t.WIDEVINE:
        case _t.PLAYREADY:
        case _t.CLEARKEY:
          return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
      }
    }
    return !1;
  }
  getDecryptData(e, n) {
    if (!this.encrypted || !this.uri)
      return null;
    if (Yi(this.method)) {
      let s = this.iv;
      return s || (typeof e != "number" && (qe.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0), s = C9(e)), new ni(this.method, this.uri, "identity", this.keyFormatVersions, s);
    }
    if (this.keyId) {
      const s = Co[this.uri];
      if (s && !Fu(this.keyId, s) && ni.setKeyIdForUri(this.uri, this.keyId), this.pssh)
        return this;
    }
    const r = Ix(this.uri);
    if (r)
      switch (this.keyFormat) {
        case _t.WIDEVINE:
          if (this.pssh = r, !this.keyId) {
            const s = RB(r.buffer);
            if (s.length) {
              var i;
              const a = s[0];
              this.keyId = (i = a.kids) != null && i.length ? a.kids[0] : null;
            }
          }
          this.keyId || (this.keyId = fg(n));
          break;
        case _t.PLAYREADY: {
          const s = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = _B(s, null, r), this.keyId = Lx(r);
          break;
        }
        default: {
          let s = r.subarray(0, 16);
          if (s.length !== 16) {
            const a = new Uint8Array(16);
            a.set(s, 16 - s.length), s = a;
          }
          this.keyId = s;
          break;
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let s;
      s = I9(n), s || (s = fg(n), s || (s = Co[this.uri])), s && (this.keyId = s, ni.setKeyIdForUri(this.uri, s));
    }
    return this;
  }
}
function I9(t) {
  const e = t == null ? void 0 : t[_t.WIDEVINE];
  return e ? e.keyId : null;
}
function fg(t) {
  const e = t == null ? void 0 : t[_t.PLAYREADY];
  if (e) {
    const n = Ix(e.uri);
    if (n)
      return Lx(n);
  }
  return null;
}
function C9(t) {
  const e = new Uint8Array(16);
  for (let n = 12; n < 16; n++)
    e[n] = t >> 8 * (15 - n) & 255;
  return e;
}
const hg = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g, mg = /#EXT-X-MEDIA:(.*)/g, L9 = /^#EXT(?:INF|-X-TARGETDURATION):/m, Tc = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
  /(?!#) *(\S[^\r\n]*)/.source,
  // segment URI, group 3 => the URI (note newline is not eaten)
  /#.*/.source
  // All other non-segment oriented tags will match with all groups empty
].join("|"), "g"), _9 = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class Un {
  static findGroup(e, n) {
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if (i.id === n)
        return i;
    }
  }
  static resolve(e, n) {
    return Mh.buildAbsoluteURL(n, e, {
      alwaysNormalize: !0
    });
  }
  static isMediaPlaylist(e) {
    return L9.test(e);
  }
  static parseMasterPlaylist(e, n) {
    const r = ug(e), i = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs: r
    }, s = [];
    if (hg.lastIndex = 0, !e.startsWith("#EXTM3U"))
      return i.playlistParsingError = new Error("no EXTM3U delimiter"), i;
    let a;
    for (; (a = hg.exec(e)) != null; )
      if (a[1]) {
        var o;
        const l = new ut(a[1], i), c = Xd(i, a[2]), d = {
          attrs: l,
          bitrate: l.decimalInteger("BANDWIDTH") || l.decimalInteger("AVERAGE-BANDWIDTH"),
          name: l.NAME,
          url: Un.resolve(c, n)
        }, f = l.decimalResolution("RESOLUTION");
        f && (d.width = f.width, d.height = f.height), bg(l.CODECS, d);
        const h = l["SUPPLEMENTAL-CODECS"];
        h && (d.supplemental = {}, bg(h, d.supplemental)), (o = d.unknownCodecs) != null && o.length || s.push(d), i.levels.push(d);
      } else if (a[3]) {
        const l = a[3], c = a[4];
        switch (l) {
          case "SESSION-DATA": {
            const d = new ut(c, i), f = d["DATA-ID"];
            f && (i.sessionData === null && (i.sessionData = {}), i.sessionData[f] = d);
            break;
          }
          case "SESSION-KEY": {
            const d = pg(c, n, i);
            d.encrypted && d.isSupported() ? (i.sessionKeys === null && (i.sessionKeys = []), i.sessionKeys.push(d)) : qe.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${c}"`);
            break;
          }
          case "DEFINE": {
            {
              const d = new ut(c, i);
              lg(i, d, n);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const d = new ut(c, i);
            i.contentSteering = {
              uri: Un.resolve(d["SERVER-URI"], n),
              pathwayId: d["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            i.startTimeOffset = gg(c);
            break;
          }
        }
      }
    const u = s.length > 0 && s.length < i.levels.length;
    return i.levels = u ? s : i.levels, i.levels.length === 0 && (i.playlistParsingError = new Error("no levels found in manifest")), i;
  }
  static parseMasterPlaylistMedia(e, n, r) {
    let i;
    const s = {}, a = r.levels, o = {
      AUDIO: a.map((l) => ({
        id: l.attrs.AUDIO,
        audioCodec: l.audioCodec
      })),
      SUBTITLES: a.map((l) => ({
        id: l.attrs.SUBTITLES,
        textCodec: l.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let u = 0;
    for (mg.lastIndex = 0; (i = mg.exec(e)) !== null; ) {
      const l = new ut(i[1], r), c = l.TYPE;
      if (c) {
        const d = o[c], f = s[c] || [];
        s[c] = f;
        const h = l.LANGUAGE, m = l["ASSOC-LANGUAGE"], p = l.CHANNELS, g = l.CHARACTERISTICS, b = l["INSTREAM-ID"], y = {
          attrs: l,
          bitrate: 0,
          id: u++,
          groupId: l["GROUP-ID"] || "",
          name: l.NAME || h || "",
          type: c,
          default: l.bool("DEFAULT"),
          autoselect: l.bool("AUTOSELECT"),
          forced: l.bool("FORCED"),
          lang: h,
          url: l.URI ? Un.resolve(l.URI, n) : ""
        };
        if (m && (y.assocLang = m), p && (y.channels = p), g && (y.characteristics = g), b && (y.instreamId = b), d != null && d.length) {
          const T = Un.findGroup(d, y.groupId) || d[0];
          Eg(y, T, "audioCodec"), Eg(y, T, "textCodec");
        }
        f.push(y);
      }
    }
    return s;
  }
  static parseLevelPlaylist(e, n, r, i, s, a) {
    var o;
    const u = {
      url: n
    }, l = new T9(n), c = l.fragments, d = [];
    let f = null, h = 0, m = 0, p = 0, g = 0, b = 0, y = null, T = new gc(i, u), S, I, C, _ = -1, R = !1, k = null, A;
    if (Tc.lastIndex = 0, l.m3u8 = e, l.hasVariableRefs = ug(e), ((o = Tc.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
      return l.playlistParsingError = new Error("Missing format identifier #EXTM3U"), l;
    for (; (S = Tc.exec(e)) !== null; ) {
      R && (R = !1, T = new gc(i, u), T.playlistOffset = p, T.setStart(p), T.sn = h, T.cc = g, b && (T.bitrate = b), T.level = r, f && (T.initSegment = f, f.rawProgramDateTime && (T.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null), k && (T.setByteRange(k), k = null)));
      const G = S[1];
      if (G) {
        T.duration = parseFloat(G);
        const N = (" " + S[2]).slice(1);
        T.title = N || null, T.tagList.push(N ? ["INF", G, N] : ["INF", G]);
      } else if (S[3]) {
        if (de(T.duration)) {
          T.playlistOffset = p, T.setStart(p), C && Tg(T, C, l), T.sn = h, T.level = r, T.cc = g, c.push(T);
          const N = (" " + S[3]).slice(1);
          T.relurl = Xd(l, N), Zd(T, y, d), y = T, p += T.duration, h++, m = 0, R = !0;
        }
      } else {
        if (S = S[0].match(_9), !S) {
          qe.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (I = 1; I < S.length && S[I] === void 0; I++)
          ;
        const N = (" " + S[I]).slice(1), U = (" " + S[I + 1]).slice(1), B = S[I + 2] ? (" " + S[I + 2]).slice(1) : null;
        switch (N) {
          case "BYTERANGE":
            y ? T.setByteRange(U, y) : T.setByteRange(U);
            break;
          case "PROGRAM-DATE-TIME":
            T.rawProgramDateTime = U, T.tagList.push(["PROGRAM-DATE-TIME", U]), _ === -1 && (_ = c.length);
            break;
          case "PLAYLIST-TYPE":
            l.type && ir(l, N, S), l.type = U.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            l.startSN !== 0 ? ir(l, N, S) : c.length > 0 && Sg(l, N, S), h = l.startSN = parseInt(U);
            break;
          case "SKIP": {
            l.skippedSegments && ir(l, N, S);
            const V = new ut(U, l), K = V.decimalInteger("SKIPPED-SEGMENTS");
            if (de(K)) {
              l.skippedSegments += K;
              for (let Y = K; Y--; )
                c.push(null);
              h += K;
            }
            const w = V.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            w && (l.recentlyRemovedDateranges = (l.recentlyRemovedDateranges || []).concat(w.split("	")));
            break;
          }
          case "TARGETDURATION":
            l.targetduration !== 0 && ir(l, N, S), l.targetduration = Math.max(parseInt(U), 1);
            break;
          case "VERSION":
            l.version !== null && ir(l, N, S), l.version = parseInt(U);
            break;
          case "INDEPENDENT-SEGMENTS":
            break;
          case "ENDLIST":
            l.live || ir(l, N, S), l.live = !1;
            break;
          case "#":
            (U || B) && T.tagList.push(B ? [U, B] : [U]);
            break;
          case "DISCONTINUITY":
            g++, T.tagList.push(["DIS"]);
            break;
          case "GAP":
            T.gap = !0, T.tagList.push([N]);
            break;
          case "BITRATE":
            T.tagList.push([N, U]), b = parseInt(U) * 1e3, de(b) ? T.bitrate = b : b = 0;
            break;
          case "DATERANGE": {
            const V = new ut(U, l), K = new vx(V, l.dateRanges[V.ID], l.dateRangeTagCount);
            l.dateRangeTagCount++, K.isValid || l.skippedSegments ? l.dateRanges[K.id] = K : qe.warn(`Ignoring invalid DATERANGE tag: "${U}"`), T.tagList.push(["EXT-X-DATERANGE", U]);
            break;
          }
          case "DEFINE": {
            {
              const V = new ut(U, l);
              "IMPORT" in V ? m9(l, V, a) : lg(l, V, n);
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            l.startCC !== 0 ? ir(l, N, S) : c.length > 0 && Sg(l, N, S), l.startCC = g = parseInt(U);
            break;
          case "KEY": {
            const V = pg(U, n, l);
            if (V.isSupported()) {
              if (V.method === "NONE") {
                C = void 0;
                break;
              }
              C || (C = {});
              const K = C[V.keyFormat];
              K != null && K.matches(V) || (K && (C = Xe({}, C)), C[V.keyFormat] = V);
            } else
              qe.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: "${U}"`);
            break;
          }
          case "START":
            l.startTimeOffset = gg(U);
            break;
          case "MAP": {
            const V = new ut(U, l);
            if (T.duration) {
              const K = new gc(i, u);
              yg(K, V, r, C), f = K, T.initSegment = f, f.rawProgramDateTime && !T.rawProgramDateTime && (T.rawProgramDateTime = f.rawProgramDateTime);
            } else {
              const K = T.byteRangeEndOffset;
              if (K) {
                const w = T.byteRangeStartOffset;
                k = `${K - w}@${w}`;
              } else
                k = null;
              yg(T, V, r, C), f = T, R = !0;
            }
            f.cc = g;
            break;
          }
          case "SERVER-CONTROL": {
            A && ir(l, N, S), A = new ut(U), l.canBlockReload = A.bool("CAN-BLOCK-RELOAD"), l.canSkipUntil = A.optionalFloat("CAN-SKIP-UNTIL", 0), l.canSkipDateRanges = l.canSkipUntil > 0 && A.bool("CAN-SKIP-DATERANGES"), l.partHoldBack = A.optionalFloat("PART-HOLD-BACK", 0), l.holdBack = A.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            l.partTarget && ir(l, N, S);
            const V = new ut(U);
            l.partTarget = V.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let V = l.partList;
            V || (V = l.partList = []);
            const K = m > 0 ? V[V.length - 1] : void 0, w = m++, Y = new ut(U, l), J = new mB(Y, T, u, w, K);
            V.push(J), T.duration += J.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const V = new ut(U, l);
            l.preloadHint = V;
            break;
          }
          case "RENDITION-REPORT": {
            const V = new ut(U, l);
            l.renditionReports = l.renditionReports || [], l.renditionReports.push(V);
            break;
          }
          default:
            qe.warn(`line parsed but not handled: ${S}`);
            break;
        }
      }
    }
    y && !y.relurl ? (c.pop(), p -= y.duration, l.partList && (l.fragmentHint = y)) : l.partList && (Zd(T, y, d), T.cc = g, l.fragmentHint = T, C && Tg(T, C, l)), l.targetduration || (l.playlistParsingError = new Error("Missing Target Duration"));
    const L = c.length, P = c[0], $ = c[L - 1];
    if (p += l.skippedSegments * l.targetduration, p > 0 && L && $) {
      l.averagetargetduration = p / L;
      const G = $.sn;
      l.endSN = G !== "initSegment" ? G : 0, l.live || ($.endList = !0), _ > 0 && (w9(c, _), P && d.unshift(P));
    }
    return l.fragmentHint && (p += l.fragmentHint.duration), l.totalduration = p, d.length && l.dateRangeTagCount && P && _x(d, l), l.endCC = g, l;
  }
}
function _x(t, e) {
  let n = t.length;
  if (!n)
    if (e.hasProgramDateTime) {
      const o = e.fragments[e.fragments.length - 1];
      t.push(o), n++;
    } else
      return;
  const r = t[n - 1], i = e.live ? 1 / 0 : e.totalduration, s = Object.keys(e.dateRanges);
  for (let o = s.length; o--; ) {
    const u = e.dateRanges[s[o]], l = u.startDate.getTime();
    u.tagAnchor = r.ref;
    for (let c = n; c--; ) {
      var a;
      if (((a = t[c]) == null ? void 0 : a.sn) < e.startSN)
        break;
      const d = R9(e, l, t, c, i);
      if (d !== -1) {
        u.tagAnchor = e.fragments[d].ref;
        break;
      }
    }
  }
}
function R9(t, e, n, r, i) {
  const s = n[r];
  if (s) {
    const o = s.programDateTime;
    if (e >= o || r === 0) {
      var a;
      const u = (((a = n[r + 1]) == null ? void 0 : a.start) || i) - s.start;
      if (e <= o + u * 1e3) {
        const l = n[r].sn - t.startSN;
        if (l < 0)
          return -1;
        const c = t.fragments;
        if (c.length > n.length) {
          const f = (n[r + 1] || c[c.length - 1]).sn - t.startSN;
          for (let h = f; h > l; h--) {
            const m = c[h].programDateTime;
            if (e >= m && e < m + c[h].duration * 1e3)
              return h;
          }
        }
        return l;
      }
    }
  }
  return -1;
}
function pg(t, e, n) {
  var r, i;
  const s = new ut(t, n), a = (r = s.METHOD) != null ? r : "", o = s.URI, u = s.hexadecimalInteger("IV"), l = s.KEYFORMATVERSIONS, c = (i = s.KEYFORMAT) != null ? i : "identity";
  o && s.IV && !u && qe.error(`Invalid IV: ${s.IV}`);
  const d = o ? Un.resolve(o, e) : "", f = (l || "1").split("/").map(Number).filter(Number.isFinite);
  return new ni(a, d, c, f, u, s.KEYID);
}
function gg(t) {
  const n = new ut(t).decimalFloatingPoint("TIME-OFFSET");
  return de(n) ? n : null;
}
function bg(t, e) {
  let n = (t || "").split(/[ ,]+/).filter((r) => r);
  ["video", "audio", "text"].forEach((r) => {
    const i = n.filter((s) => $h(s, r));
    i.length && (e[`${r}Codec`] = i.map((s) => s.split("/")[0]).join(","), n = n.filter((s) => i.indexOf(s) === -1));
  }), e.unknownCodecs = n;
}
function Eg(t, e, n) {
  const r = e[n];
  r && (t[n] = r);
}
function w9(t, e) {
  let n = t[e];
  for (let r = e; r--; ) {
    const i = t[r];
    if (!i)
      return;
    i.programDateTime = n.programDateTime - i.duration * 1e3, n = i;
  }
}
function Zd(t, e, n) {
  t.rawProgramDateTime ? n.push(t) : e != null && e.programDateTime && (t.programDateTime = e.endProgramDateTime);
}
function yg(t, e, n, r) {
  t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = n, t.sn = "initSegment", r && (t.levelkeys = r), t.initSegment = null;
}
function Tg(t, e, n) {
  t.levelkeys = e;
  const {
    encryptedFragments: r
  } = n;
  (!r.length || r[r.length - 1].levelkeys !== e) && Object.keys(e).some((i) => e[i].isCommonEncryption) && r.push(t);
}
function ir(t, e, n) {
  t.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${n[0]})`);
}
function Sg(t, e, n) {
  t.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${n[0]})`);
}
function Sc(t, e) {
  const n = e.startPTS;
  if (de(n)) {
    let r = 0, i;
    e.sn > t.sn ? (r = n - t.start, i = t) : (r = t.start - n, i = e), i.duration !== r && i.setDuration(r);
  } else e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.setStart(t.start + (t.minEndPTS - t.start)) : e.setStart(t.start + t.duration) : e.setStart(Math.max(t.start - e.duration, 0));
}
function Rx(t, e, n, r, i, s, a) {
  r - n <= 0 && (a.warn("Fragment should have a positive duration", e), r = n + e.duration, s = i + e.duration);
  let u = n, l = r;
  const c = e.startPTS, d = e.endPTS;
  if (de(c)) {
    const b = Math.abs(c - n);
    t && b > t.totalduration ? a.warn(`media timestamps and playlist times differ by ${b}s for level ${e.level} ${t.url}`) : de(e.deltaPTS) ? e.deltaPTS = Math.max(b, e.deltaPTS) : e.deltaPTS = b, u = Math.max(n, c), n = Math.min(n, c), i = e.startDTS !== void 0 ? Math.min(i, e.startDTS) : i, l = Math.min(r, d), r = Math.max(r, d), s = e.endDTS !== void 0 ? Math.max(s, e.endDTS) : s;
  }
  const f = n - e.start;
  e.start !== 0 && e.setStart(n), e.setDuration(r - e.start), e.startPTS = n, e.maxStartPTS = u, e.startDTS = i, e.endPTS = r, e.minEndPTS = l, e.endDTS = s;
  const h = e.sn;
  if (!t || h < t.startSN || h > t.endSN)
    return 0;
  let m;
  const p = h - t.startSN, g = t.fragments;
  for (g[p] = e, m = p; m > 0; m--)
    Sc(g[m], g[m - 1]);
  for (m = p; m < g.length - 1; m++)
    Sc(g[m], g[m + 1]);
  return t.fragmentHint && Sc(g[g.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, f;
}
function k9(t, e, n) {
  if (t === e)
    return;
  let r = null;
  const i = t.fragments;
  for (let c = i.length - 1; c >= 0; c--) {
    const d = i[c].initSegment;
    if (d) {
      r = d;
      break;
    }
  }
  t.fragmentHint && delete t.fragmentHint.endPTS;
  let s;
  O9(t, e, (c, d, f, h) => {
    if ((!e.startCC || e.skippedSegments) && d.cc !== c.cc) {
      const m = c.cc - d.cc;
      for (let p = f; p < h.length; p++)
        h[p].cc += m;
      e.endCC = h[h.length - 1].cc;
    }
    de(c.startPTS) && de(c.endPTS) && (d.setStart(d.startPTS = c.startPTS), d.startDTS = c.startDTS, d.maxStartPTS = c.maxStartPTS, d.endPTS = c.endPTS, d.endDTS = c.endDTS, d.minEndPTS = c.minEndPTS, d.setDuration(c.endPTS - c.startPTS), d.duration && (s = d), e.PTSKnown = e.alignedSliding = !0), c.hasStreams && (d.elementaryStreams = c.elementaryStreams), d.loader = c.loader, c.hasStats && (d.stats = c.stats), c.initSegment && (d.initSegment = c.initSegment, r = c.initSegment);
  });
  const a = e.fragments, o = e.fragmentHint ? a.concat(e.fragmentHint) : a;
  if (r && o.forEach((c) => {
    var d;
    c && (!c.initSegment || c.initSegment.relurl === ((d = r) == null ? void 0 : d.relurl)) && (c.initSegment = r);
  }), e.skippedSegments) {
    if (e.deltaUpdateFailed = a.some((c) => !c), e.deltaUpdateFailed) {
      n.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let c = e.skippedSegments; c--; )
        a.shift();
      e.startSN = a[0].sn;
    } else {
      e.canSkipDateRanges && (e.dateRanges = D9(t.dateRanges, e, n));
      const c = t.fragments.filter((d) => d.rawProgramDateTime);
      if (t.hasProgramDateTime && !e.hasProgramDateTime)
        for (let d = 1; d < o.length; d++)
          o[d].programDateTime === null && Zd(o[d], o[d - 1], c);
      _x(c, e);
    }
    e.endCC = a[a.length - 1].cc;
  }
  if (!e.startCC) {
    var u;
    const c = Dx(t, e.startSN - 1);
    e.startCC = (u = c == null ? void 0 : c.cc) != null ? u : a[0].cc;
  }
  P9(t.partList, e.partList, (c, d) => {
    d.elementaryStreams = c.elementaryStreams, d.stats = c.stats;
  }), s ? Rx(e, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS, n) : wx(t, e), a.length && (e.totalduration = e.edge - a[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
  const l = e.advancedDateTime;
  if (e.advanced && l) {
    const c = e.edge;
    e.driftStart || (e.driftStartTime = l, e.driftStart = c), e.driftEndTime = l, e.driftEnd = c;
  } else
    e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime;
  e.requestScheduled === -1 && (e.requestScheduled = t.requestScheduled);
}
function D9(t, e, n) {
  const {
    dateRanges: r,
    recentlyRemovedDateranges: i
  } = e, s = Xe({}, t);
  i && i.forEach((u) => {
    delete s[u];
  });
  const o = Object.keys(s).length;
  return o ? (Object.keys(r).forEach((u) => {
    const l = s[u], c = new vx(r[u].attr, l);
    c.isValid ? (s[u] = c, l || (c.tagOrder += o)) : n.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${Ze(r[u].attr)}"`);
  }), s) : r;
}
function P9(t, e, n) {
  if (t && e) {
    let r = 0;
    for (let i = 0, s = t.length; i <= s; i++) {
      const a = t[i], o = e[i + r];
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? n(a, o) : r--;
    }
  }
}
function O9(t, e, n) {
  const r = e.skippedSegments, i = Math.max(t.startSN, e.startSN) - e.startSN, s = (t.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, a = e.startSN - t.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, u = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments;
  for (let l = i; l <= s; l++) {
    const c = u[a + l];
    let d = o[l];
    if (r && !d && c && (d = e.fragments[l] = c), c && d) {
      n(c, d, l, o);
      const f = c.relurl, h = d.relurl;
      if (f && N9(f, h)) {
        e.playlistParsingError = xg(`media sequence mismatch ${d.sn}:`, t, e, c, d);
        return;
      } else if (c.cc !== d.cc) {
        e.playlistParsingError = xg(`discontinuity sequence mismatch (${c.cc}!=${d.cc})`, t, e, c, d);
        return;
      }
    }
  }
}
function xg(t, e, n, r, i) {
  return new Error(`${t} ${i.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${n.startSN}
${n.m3u8}`);
}
function wx(t, e, n = !0) {
  const r = e.startSN + e.skippedSegments - t.startSN, i = t.fragments, s = r >= 0;
  let a = 0;
  if (s && r < i.length)
    a = i[r].start;
  else if (s && e.startSN === t.endSN + 1)
    a = t.fragmentEnd;
  else if (s && n)
    a = t.fragmentStart + r * e.levelTargetDuration;
  else if (!e.skippedSegments && e.fragmentStart === 0)
    a = t.fragmentStart;
  else
    return;
  Jd(e, a);
}
function Jd(t, e) {
  if (e) {
    const n = t.fragments;
    for (let r = t.skippedSegments; r < n.length; r++)
      n[r].addStart(e);
    t.fragmentHint && t.fragmentHint.addStart(e);
  }
}
function kx(t, e = 1 / 0) {
  let n = 1e3 * t.targetduration;
  if (t.updated) {
    const r = t.fragments;
    if (r.length && n * 4 > e) {
      const s = r[r.length - 1].duration * 1e3;
      s < n && (n = s);
    }
  } else
    n /= 2;
  return Math.round(n);
}
function Dx(t, e, n) {
  if (!t)
    return null;
  let r = t.fragments[e - t.startSN];
  return r || (r = t.fragmentHint, r && r.sn === e) ? r : e < t.startSN && n && n.sn === e ? n : null;
}
function vg(t, e, n) {
  return t ? Px(t.partList, e, n) : null;
}
function Px(t, e, n) {
  if (t)
    for (let r = t.length; r--; ) {
      const i = t[r];
      if (i.index === n && i.fragment.sn === e)
        return i;
    }
  return null;
}
function Ox(t) {
  t.forEach((e, n) => {
    var r;
    (r = e.details) == null || r.fragments.forEach((i) => {
      i.level = n, i.initSegment && (i.initSegment.level = n);
    });
  });
}
function N9(t, e) {
  return t !== e && e ? Ag(t) !== Ag(e) : !1;
}
function Ag(t) {
  return t.replace(/\?[^?]*$/, "");
}
function ia(t, e) {
  for (let r = 0, i = t.length; r < i; r++) {
    var n;
    if (((n = t[r]) == null ? void 0 : n.cc) === e)
      return t[r];
  }
  return null;
}
function M9(t, e) {
  return !!(t && e.startCC < t.endCC && e.endCC > t.startCC);
}
function Ig(t, e) {
  const n = t.start + e;
  t.startPTS = n, t.setStart(n), t.endPTS = n + t.duration;
}
function Nx(t, e) {
  const n = e.fragments;
  for (let r = 0, i = n.length; r < i; r++)
    Ig(n[r], t);
  e.fragmentHint && Ig(e.fragmentHint, t), e.alignedSliding = !0;
}
function F9(t, e) {
  t && (Mx(e, t), e.alignedSliding || $u(e, t), !e.alignedSliding && !e.skippedSegments && wx(t, e, !1));
}
function Mx(t, e) {
  if (!M9(e, t))
    return;
  const n = Math.min(e.endCC, t.endCC), r = ia(e.fragments, n), i = ia(t.fragments, n);
  if (!r || !i)
    return;
  qe.log(`Aligning playlist at start of dicontinuity sequence ${n}`);
  const s = r.start - i.start;
  Nx(s, t);
}
function $u(t, e) {
  if (!t.hasProgramDateTime || !e.hasProgramDateTime)
    return;
  const n = t.fragments, r = e.fragments;
  if (!n.length || !r.length)
    return;
  let i, s;
  const a = Math.min(e.endCC, t.endCC);
  e.startCC < a && t.startCC < a && (i = ia(r, a), s = ia(n, a)), (!i || !s) && (i = r[Math.floor(r.length / 2)], s = ia(n, i.cc) || n[Math.floor(n.length / 2)]);
  const o = i.programDateTime, u = s.programDateTime;
  if (!o || !u)
    return;
  const l = (u - o) / 1e3 - (s.start - i.start);
  Nx(l, t);
}
function Bt(t, e, n) {
  zt(t, e, n), t.addEventListener(e, n);
}
function zt(t, e, n) {
  t.removeEventListener(e, n);
}
const B9 = {
  toString: function(t) {
    let e = "";
    const n = t.length;
    for (let r = 0; r < n; r++)
      e += `[${t.start(r).toFixed(3)}-${t.end(r).toFixed(3)}]`;
    return e;
  }
}, Z = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};
class Wh extends Sx {
  constructor(e, n, r, i, s) {
    super(i, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = Z.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () => {
      const {
        config: a,
        fragCurrent: o,
        media: u,
        mediaBuffer: l,
        state: c
      } = this, d = u ? u.currentTime : 0, f = Ce.bufferInfo(l || u, d, a.maxBufferHole), h = !f.len;
      if (this.log(`Media seeking to ${de(d) ? d.toFixed(3) : d}, state: ${c}, ${h ? "out of" : "in"} buffer`), this.state === Z.ENDED)
        this.resetLoadingState();
      else if (o) {
        const m = a.maxFragLookUpTolerance, p = o.start - m, g = o.start + o.duration + m;
        if (h || g < f.start || p > f.end) {
          const b = d > g;
          (d < p || b) && (b && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`), o.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);
        }
      }
      if (u) {
        this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);
        const m = this.lastCurrentTime;
        if (d > m && (this.lastCurrentTime = d), !this.loadingParts) {
          const p = Math.max(f.end, d), g = this.shouldLoadParts(this.getLevelDetails(), p);
          g && (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${p.toFixed(2)}`), this.loadingParts = g);
        }
      }
      this.hls.hasEnoughToStart || (this.log(`Setting ${h ? "startPosition" : "nextLoadPosition"} to ${d} for seek without enough to start`), this.nextLoadPosition = d, h && (this.startPosition = d)), h && this.state === Z.IDLE && this.tickImmediate();
    }, this.onMediaEnded = () => {
      this.log("setting startPosition to 0 because media ended"), this.startPosition = this.lastCurrentTime = 0;
    }, this.playlistType = s, this.hls = e, this.fragmentLoader = new f9(e.config), this.keyLoader = r, this.fragmentTracker = n, this.config = e.config, this.decrypter = new Vh(e.config);
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  startLoad(e) {
  }
  stopLoad() {
    if (this.state === Z.STOPPED)
      return;
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
    const e = this.fragCurrent;
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Z.STOPPED;
  }
  get startPositionValue() {
    const {
      nextLoadPosition: e,
      startPosition: n
    } = this;
    return n === -1 && e ? e : n;
  }
  get bufferingEnabled() {
    return this.buffering;
  }
  pauseBuffering() {
    this.buffering = !1;
  }
  resumeBuffering() {
    this.buffering = !0;
  }
  get inFlightFrag() {
    return {
      frag: this.fragCurrent,
      state: this.state
    };
  }
  _streamEnded(e, n) {
    if (n.live || !this.media)
      return !1;
    const r = e.end || 0, i = this.config.timelineOffset || 0;
    if (r <= i)
      return !1;
    const s = e.buffered;
    this.config.maxBufferHole && s && s.length > 1 && (e = Ce.bufferedInfo(s, e.start, 0));
    const a = e.nextStart;
    if (a && a > i && a < n.edge || this.media.currentTime < e.start)
      return !1;
    const u = n.partList;
    if (u != null && u.length) {
      const c = u[u.length - 1];
      return Ce.isBuffered(this.media, c.start + c.duration / 2);
    }
    const l = n.fragments[n.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(l);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null)
      return this.levelLastLoaded.details;
  }
  get timelineOffset() {
    const e = this.config.timelineOffset;
    if (e) {
      var n;
      return ((n = this.getLevelDetails()) == null ? void 0 : n.appliedTimelineOffset) || e;
    }
    return 0;
  }
  onMediaAttached(e, n) {
    const r = this.media = this.mediaBuffer = n.media;
    Bt(r, "seeking", this.onMediaSeeking), Bt(r, "ended", this.onMediaEnded);
    const i = this.config;
    this.levels && i.autoStartLoad && this.state === Z.STOPPED && this.startLoad(i.startPosition);
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia, i = this.media;
    if (i !== null) {
      if (i.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), zt(i, "seeking", this.onMediaSeeking), zt(i, "ended", this.onMediaEnded), this.keyLoader && !r && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, r) {
        this.resetLoadingState(), this.resetTransmuxer();
        return;
      }
      this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();
    }
  }
  onManifestLoading() {
    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;
  }
  onError(e, n) {
  }
  onManifestLoaded(e, n) {
    this.startTimeOffset = n.startTimeOffset;
  }
  onHandlerDestroying() {
    this.stopLoad(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;
  }
  onHandlerDestroyed() {
    this.state = Z.STOPPED, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();
  }
  loadFragment(e, n, r) {
    this.startFragRequested = !0, this._loadFragForPlayback(e, n, r);
  }
  _loadFragForPlayback(e, n, r) {
    const i = (s) => {
      const a = s.frag;
      if (this.fragContextChanged(a)) {
        this.warn(`${a.type} sn: ${a.sn}${s.part ? " part: " + s.part.index : ""} of ${this.fragInfo(a, !1, s.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(a);
        return;
      }
      a.stats.chunkCount++, this._handleFragmentLoadProgress(s);
    };
    this._doFragLoad(e, n, r, i).then((s) => {
      if (!s)
        return;
      const a = this.state, o = s.frag;
      if (this.fragContextChanged(o)) {
        (a === Z.FRAG_LOADING || !this.fragCurrent && a === Z.PARSING) && (this.fragmentTracker.removeFragment(o), this.state = Z.IDLE);
        return;
      }
      "payload" in s && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`), this.hls.trigger(x.FRAG_LOADED, s)), this._handleFragmentLoadComplete(s);
    }).catch((s) => {
      this.state === Z.STOPPED || this.state === Z.ERROR || (this.warn(`Frag error: ${(s == null ? void 0 : s.message) || s}`), this.resetFragmentLoading(e));
    });
  }
  clearTrackerIfNeeded(e) {
    var n;
    const {
      fragmentTracker: r
    } = this;
    if (r.getState(e) === Tt.APPENDING) {
      const s = e.type, a = this.getFwdBufferInfo(this.mediaBuffer, s), o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength), u = this.backtrackFragment;
      ((u ? e.sn - u.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && r.removeFragment(e);
    } else ((n = this.mediaBuffer) == null ? void 0 : n.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({
      frag: e,
      part: null,
      stats: e.stats,
      id: e.type
    }), r.getState(e) === Tt.PARTIAL && r.removeFragment(e));
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const n = e.fragments[e.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: n,
        part: null,
        stats: n.stats,
        id: n.type
      });
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0);
  }
  waitForLive(e) {
    const n = e.details;
    return (n == null ? void 0 : n.live) && n.type !== "EVENT" && (this.levelLastLoaded !== e || n.expired);
  }
  flushMainBuffer(e, n, r = null) {
    if (!(e - n))
      return;
    const i = {
      startOffset: e,
      endOffset: n,
      type: r
    };
    this.hls.trigger(x.BUFFER_FLUSHING, i);
  }
  _loadInitSegment(e, n) {
    this._doFragLoad(e, n).then((r) => {
      const i = r == null ? void 0 : r.frag;
      if (!i || this.fragContextChanged(i) || !this.levels)
        throw new Error("init load aborted");
      return r;
    }).then((r) => {
      const {
        hls: i
      } = this, {
        frag: s,
        payload: a
      } = r, o = s.decryptdata;
      if (a && a.byteLength > 0 && o != null && o.key && o.iv && Yi(o.method)) {
        const u = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, zh(o.method)).catch((l) => {
          throw i.trigger(x.ERROR, {
            type: be.MEDIA_ERROR,
            details: q.FRAG_DECRYPT_ERROR,
            fatal: !1,
            error: l,
            reason: l.message,
            frag: s
          }), l;
        }).then((l) => {
          const c = self.performance.now();
          return i.trigger(x.FRAG_DECRYPTED, {
            frag: s,
            payload: l,
            stats: {
              tstart: u,
              tdecrypt: c
            }
          }), r.payload = l, this.completeInitSegmentLoad(r);
        });
      }
      return this.completeInitSegmentLoad(r);
    }).catch((r) => {
      this.state === Z.STOPPED || this.state === Z.ERROR || (this.warn(r), this.resetFragmentLoading(e));
    });
  }
  completeInitSegmentLoad(e) {
    const {
      levels: n
    } = this;
    if (!n)
      throw new Error("init load aborted, missing levels");
    const r = e.frag.stats;
    this.state !== Z.STOPPED && (this.state = Z.IDLE), e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick();
  }
  unhandledEncryptionError(e, n) {
    var r, i;
    const s = e.tracks;
    if (s && !n.encrypted && ((r = s.audio) != null && r.encrypted || (i = s.video) != null && i.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
      const a = this.media, o = new Error(`Encrypted track with no key in ${this.fragInfo(n)} (media ${a ? "attached mediaKeys: " + a.mediaKeys : "detached"})`);
      return this.warn(o.message), !a || a.mediaKeys ? !1 : (this.hls.trigger(x.ERROR, {
        type: be.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_KEYS,
        fatal: !1,
        error: o,
        frag: n
      }), this.resetTransmuxer(), !0);
    }
    return !1;
  }
  fragContextChanged(e) {
    const {
      fragCurrent: n
    } = this;
    return !e || !n || e.sn !== n.sn || e.level !== n.level;
  }
  fragBufferedComplete(e, n) {
    const r = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.log(`Buffered ${e.type} sn: ${e.sn}${n ? " part: " + n.index : ""} of ${this.fragInfo(e, !1, n)} > buffer:${r ? B9.toString(Ce.getBuffered(r)) : "(detached)"})`), gt(e)) {
      var i;
      if (e.type !== pe.SUBTITLE) {
        const a = e.elementaryStreams;
        if (!Object.keys(a).some((o) => !!a[o])) {
          this.state = Z.IDLE;
          return;
        }
      }
      const s = (i = this.levels) == null ? void 0 : i[e.level];
      s != null && s.fragmentError && (this.log(`Resetting level fragment error count of ${s.fragmentError} on frag buffered`), s.fragmentError = 0);
    }
    this.state = Z.IDLE;
  }
  _handleFragmentLoadComplete(e) {
    const {
      transmuxer: n
    } = this;
    if (!n)
      return;
    const {
      frag: r,
      part: i,
      partsLoaded: s
    } = e, a = !s || s.length === 0 || s.some((u) => !u), o = new Gh(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !a);
    n.flush(o);
  }
  _handleFragmentLoadProgress(e) {
  }
  _doFragLoad(e, n, r = null, i) {
    var s;
    this.fragCurrent = e;
    const a = n.details;
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
    let o = null;
    if (e.encrypted && !((s = e.decryptdata) != null && s.key)) {
      if (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = Z.KEY_LOADING, this.fragCurrent = e, o = this.keyLoader.load(e).then((f) => {
        if (!this.fragContextChanged(f.frag))
          return this.hls.trigger(x.KEY_LOADED, f), this.state === Z.KEY_LOADING && (this.state = Z.IDLE), f;
      }), this.hls.trigger(x.KEY_LOADING, {
        frag: e
      }), this.fragCurrent === null)
        return this.log("context changed in KEY_LOADING"), Promise.resolve(null);
    } else e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested), o && this.log("[eme] blocking frag load until media-keys acquired"));
    const u = this.fragPrevious;
    if (gt(e) && (!u || e.sn !== u.sn)) {
      const f = this.shouldLoadParts(n.details, e.end);
      f !== this.loadingParts && (this.log(`LL-Part loading ${f ? "ON" : "OFF"} loading sn ${u == null ? void 0 : u.sn}->${e.sn}`), this.loadingParts = f);
    }
    if (r = Math.max(e.start, r || 0), this.loadingParts && gt(e)) {
      const f = a.partList;
      if (f && i) {
        r > a.fragmentEnd && a.fragmentHint && (e = a.fragmentHint);
        const h = this.getNextPart(f, e, r);
        if (h > -1) {
          const m = f[h];
          e = this.fragCurrent = m.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${m.index} (${h}/${f.length - 1}) of ${this.fragInfo(e, !1, m)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = m.start + m.duration, this.state = Z.FRAG_LOADING;
          let p;
          return o ? p = o.then((g) => !g || this.fragContextChanged(g.frag) ? null : this.doFragPartsLoad(e, m, n, i)).catch((g) => this.handleFragLoadError(g)) : p = this.doFragPartsLoad(e, m, n, i).catch((g) => this.handleFragLoadError(g)), this.hls.trigger(x.FRAG_LOADING, {
            frag: e,
            part: m,
            targetBufferTime: r
          }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : p;
        } else if (!e.url || this.loadedEndOfParts(f, r))
          return Promise.resolve(null);
      }
    }
    if (gt(e) && this.loadingParts) {
      var l;
      this.log(`LL-Part loading OFF after next part miss @${r.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(l = a.partList) == null ? void 0 : l.filter((f) => f.loaded).map((f) => `[${f.start}-${f.end}]`)}`), this.loadingParts = !1;
    } else if (!e.url)
      return Promise.resolve(null);
    this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + a.startSN + "-" + a.endSN + "]"}, target: ${parseFloat(r.toFixed(3))}`), de(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = Z.FRAG_LOADING;
    const c = this.config.progressive;
    let d;
    return c && o ? d = o.then((f) => !f || this.fragContextChanged(f.frag) ? null : this.fragmentLoader.load(e, i)).catch((f) => this.handleFragLoadError(f)) : d = Promise.all([this.fragmentLoader.load(e, c ? i : void 0), o]).then(([f]) => (!c && i && i(f), f)).catch((f) => this.handleFragLoadError(f)), this.hls.trigger(x.FRAG_LOADING, {
      frag: e,
      targetBufferTime: r
    }), this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d;
  }
  doFragPartsLoad(e, n, r, i) {
    return new Promise((s, a) => {
      var o;
      const u = [], l = (o = r.details) == null ? void 0 : o.partList, c = (d) => {
        this.fragmentLoader.loadPart(e, d, i).then((f) => {
          u[d.index] = f;
          const h = f.part;
          this.hls.trigger(x.FRAG_LOADED, f);
          const m = vg(r.details, e.sn, d.index + 1) || Px(l, e.sn, d.index + 1);
          if (m)
            c(m);
          else
            return s({
              frag: e,
              part: h,
              partsLoaded: u
            });
        }).catch(a);
      };
      c(n);
    });
  }
  handleFragLoadError(e) {
    if ("data" in e) {
      const n = e.data;
      n.frag && n.details === q.INTERNAL_ABORTED ? this.handleFragLoadAborted(n.frag, n.part) : n.frag && n.type === be.KEY_SYSTEM_ERROR ? (n.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(n.frag)) : this.hls.trigger(x.ERROR, n);
    } else
      this.hls.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      });
    return null;
  }
  _handleTransmuxerFlush(e) {
    const n = this.getCurrentContext(e);
    if (!n || this.state !== Z.PARSING) {
      !this.fragCurrent && this.state !== Z.STOPPED && this.state !== Z.ERROR && (this.state = Z.IDLE);
      return;
    }
    const {
      frag: r,
      part: i,
      level: s
    } = n, a = self.performance.now();
    r.stats.parsing.end = a, i && (i.stats.parsing.end = a);
    const o = this.getLevelDetails(), l = o && r.sn > o.endSN || this.shouldLoadParts(o, r.end);
    l !== this.loadingParts && (this.log(`LL-Part loading ${l ? "ON" : "OFF"} after parsing segment ending @${r.end.toFixed(2)}`), this.loadingParts = l), this.updateLevelTiming(r, i, s, e.partial);
  }
  shouldLoadParts(e, n) {
    if (this.config.lowLatencyMode) {
      if (!e)
        return this.loadingParts;
      if (e.partList) {
        var r;
        const s = e.partList[0];
        if (s.fragment.type === pe.SUBTITLE)
          return !1;
        const a = s.end + (((r = e.fragmentHint) == null ? void 0 : r.duration) || 0);
        if (n >= a) {
          var i;
          if ((this.hls.hasEnoughToStart ? ((i = this.media) == null ? void 0 : i.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > s.start - s.fragment.duration)
            return !0;
        }
      }
    }
    return !1;
  }
  getCurrentContext(e) {
    const {
      levels: n,
      fragCurrent: r
    } = this, {
      level: i,
      sn: s,
      part: a
    } = e;
    if (!(n != null && n[i]))
      return this.warn(`Levels object was unset while buffering fragment ${s} of ${this.playlistLabel()} ${i}. The current chunk will not be buffered.`), null;
    const o = n[i], u = o.details, l = a > -1 ? vg(u, s, a) : null, c = l ? l.fragment : Dx(u, s, r);
    return c ? (r && r !== c && (c.stats = r.stats), {
      frag: c,
      part: l,
      level: o
    }) : null;
  }
  bufferFragmentData(e, n, r, i, s) {
    if (this.state !== Z.PARSING)
      return;
    const {
      data1: a,
      data2: o
    } = e;
    let u = a;
    if (o && (u = gn(a, o)), !u.length)
      return;
    const l = this.initPTS[n.cc], c = l ? -l.baseTime / l.timescale : void 0, d = {
      type: e.type,
      frag: n,
      part: r,
      chunkMeta: i,
      offset: c,
      parent: n.type,
      data: u
    };
    if (this.hls.trigger(x.BUFFER_APPENDING, d), e.dropped && e.independent && !r) {
      if (s)
        return;
      this.flushBufferGap(n);
    }
  }
  flushBufferGap(e) {
    const n = this.media;
    if (!n)
      return;
    if (!Ce.isBuffered(n, n.currentTime)) {
      this.flushMainBuffer(0, e.start);
      return;
    }
    const r = n.currentTime, i = Ce.bufferInfo(n, r, 0), s = e.duration, a = Math.min(this.config.maxFragLookUpTolerance * 2, s * 0.25), o = Math.max(Math.min(e.start - a, i.end - a), r + a);
    e.start - o > a && this.flushMainBuffer(o, e.start);
  }
  getFwdBufferInfo(e, n) {
    var r;
    const i = this.getLoadPosition();
    if (!de(i))
      return null;
    const a = this.lastCurrentTime > i || (r = this.media) != null && r.paused ? 0 : this.config.maxBufferHole;
    return this.getFwdBufferInfoAtPos(e, i, n, a);
  }
  getFwdBufferInfoAtPos(e, n, r, i) {
    const s = Ce.bufferInfo(e, n, i);
    if (s.len === 0 && s.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(n, r);
      if (a && (s.nextStart <= a.end || a.gap)) {
        const o = Math.max(Math.min(s.nextStart, a.end) - n, i);
        return Ce.bufferInfo(e, n, o);
      }
    }
    return s;
  }
  getMaxBufferLength(e) {
    const {
      config: n
    } = this;
    let r;
    return e ? r = Math.max(8 * n.maxBufferSize / e, n.maxBufferLength) : r = n.maxBufferLength, Math.min(r, n.maxMaxBufferLength);
  }
  reduceMaxBufferLength(e, n) {
    const r = this.config, i = Math.max(Math.min(e - n, r.maxBufferLength), n), s = Math.max(e - n * 3, r.maxMaxBufferLength / 2, i);
    return s >= i ? (r.maxMaxBufferLength = s, this.warn(`Reduce max buffer length to ${s}s`), !0) : !1;
  }
  getAppendedFrag(e, n = pe.MAIN) {
    const r = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, n) : null;
    return r && "fragment" in r ? r.fragment : r;
  }
  getNextFragment(e, n) {
    const r = n.fragments, i = r.length;
    if (!i)
      return null;
    const {
      config: s
    } = this, a = r[0].start, o = s.lowLatencyMode && !!n.partList;
    let u = null;
    if (n.live) {
      const d = s.initialLiveManifestSize;
      if (i < d)
        return this.warn(`Not enough fragments to start playback (have: ${i}, need: ${d})`), null;
      if (!n.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) {
        var l;
        o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"), this.loadingParts = !0), u = this.getInitialLiveFragment(n);
        const f = this.hls.startPosition, h = this.hls.liveSyncPosition, m = u ? (f !== -1 && f >= a ? f : h) || u.start : e;
        this.log(`Setting startPosition to ${m} to match start frag at live edge. mainStart: ${f} liveSyncPosition: ${h} frag.start: ${(l = u) == null ? void 0 : l.start}`), this.startPosition = this.nextLoadPosition = m;
      }
    } else e <= a && (u = r[0]);
    if (!u) {
      const d = this.loadingParts ? n.partEnd : n.fragmentEnd;
      u = this.getFragmentAtPosition(e, d, n);
    }
    let c = this.filterReplacedPrimary(u, n);
    if (!c && u) {
      const d = u.sn - n.startSN;
      c = this.filterReplacedPrimary(r[d + 1] || null, n);
    }
    return this.mapToInitFragWhenRequired(c);
  }
  isLoopLoading(e, n) {
    const r = this.fragmentTracker.getState(e);
    return (r === Tt.OK || r === Tt.PARTIAL && !!e.gap) && this.nextLoadPosition > n;
  }
  getNextFragmentLoopLoading(e, n, r, i, s) {
    let a = null;
    if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, n), a && !a.gap && r.nextStart)) {
      const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, i, 0);
      if (o !== null && r.len + o.len >= s) {
        const u = a.sn;
        return this.loopSn !== u && (this.log(`buffer full after gaps in "${i}" playlist starting at sn: ${u}`), this.loopSn = u), null;
      }
    }
    return this.loopSn = void 0, a;
  }
  get primaryPrefetch() {
    if (Cg(this.config)) {
      var e;
      if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event)
        return !0;
    }
    return !1;
  }
  filterReplacedPrimary(e, n) {
    if (!e)
      return e;
    if (Cg(this.config) && e.type !== pe.SUBTITLE) {
      const r = this.hls.interstitialsManager, i = r == null ? void 0 : r.bufferingItem;
      if (i) {
        const a = i.event;
        if (a) {
          if (a.appendInPlace || Math.abs(e.start - i.start) > 1 || i.start === 0)
            return null;
        } else if (e.end <= i.start && (n == null ? void 0 : n.live) === !1 || e.start > i.end && i.nextEvent && (i.nextEvent.appendInPlace || e.start - i.end > 1))
          return null;
      }
      const s = r == null ? void 0 : r.playerQueue;
      if (s)
        for (let a = s.length; a--; ) {
          const o = s[a].interstitial;
          if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime)
            return null;
        }
    }
    return e;
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e;
  }
  getNextPart(e, n, r) {
    let i = -1, s = !1, a = !0;
    for (let o = 0, u = e.length; o < u; o++) {
      const l = e[o];
      if (a = a && !l.independent, i > -1 && r < l.start)
        break;
      const c = l.loaded;
      c ? i = -1 : (s || (l.independent || a) && l.fragment === n) && (l.fragment !== n && this.warn(`Need buffer at ${r} but next unloaded part starts at ${l.start}`), i = o), s = c;
    }
    return i;
  }
  loadedEndOfParts(e, n) {
    let r;
    for (let i = e.length; i--; ) {
      if (r = e[i], !r.loaded)
        return !1;
      if (n > r.start)
        return !0;
    }
    return !1;
  }
  /*
   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the
   "sliding" of the playlist, which is its offset from the start of playback. After sliding we can compute the real
   start and end times for each fragment in the playlist (after which this method will not need to be called).
  */
  getInitialLiveFragment(e) {
    const n = e.fragments, r = this.fragPrevious;
    let i = null;
    if (r) {
      if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), i = e9(n, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {
        const s = r.sn + 1;
        if (s >= e.startSN && s <= e.endSN) {
          const a = n[s - e.startSN];
          r.cc === a.cc && (i = a, this.log(`Live playlist, switching playlist, load frag with next SN: ${i.sn}`));
        }
        i || (i = Ex(e, r.cc, r.end), i && this.log(`Live playlist, switching playlist, load frag with same CC: ${i.sn}`));
      }
    } else {
      const s = this.hls.liveSyncPosition;
      s !== null && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e));
    }
    return i;
  }
  /*
  This method finds the best matching fragment given the provided position.
   */
  getFragmentAtPosition(e, n, r) {
    const {
      config: i
    } = this;
    let {
      fragPrevious: s
    } = this, {
      fragments: a,
      endSN: o
    } = r;
    const {
      fragmentHint: u
    } = r, {
      maxFragLookUpTolerance: l
    } = i, c = r.partList, d = !!(this.loadingParts && c != null && c.length && u);
    d && !this.bitrateTest && c[c.length - 1].fragment.sn === u.sn && (a = a.concat(u), o = u.sn);
    let f;
    if (e < n) {
      var h;
      const p = e < this.lastCurrentTime || e > n - l || (h = this.media) != null && h.paused || !this.startFragRequested ? 0 : l;
      f = ai(s, a, e, p);
    } else
      f = a[a.length - 1];
    if (f) {
      const m = f.sn - r.startSN, p = this.fragmentTracker.getState(f);
      if ((p === Tt.OK || p === Tt.PARTIAL && f.gap) && (s = f), s && f.sn === s.sn && (!d || c[0].fragment.sn > f.sn || !r.live) && f.level === s.level) {
        const b = a[m + 1];
        f.sn < o && this.fragmentTracker.getState(b) !== Tt.OK ? f = b : f = null;
      }
    }
    return f;
  }
  alignPlaylists(e, n, r) {
    const i = e.fragments.length;
    if (!i)
      return this.warn("No fragments in live playlist"), 0;
    const s = e.fragmentStart, a = !n, o = e.alignedSliding && de(s);
    if (a || !o && !s) {
      F9(r, e);
      const u = e.fragmentStart;
      return this.log(`Live playlist sliding: ${u.toFixed(2)} start-sn: ${n ? n.startSN : "na"}->${e.startSN} fragments: ${i}`), u;
    }
    return s;
  }
  waitForCdnTuneIn(e) {
    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3);
  }
  setStartPosition(e, n) {
    let r = this.startPosition;
    r < n && (r = -1);
    const i = this.timelineOffset;
    if (r === -1) {
      const s = this.startTimeOffset !== null, a = s ? this.startTimeOffset : e.startTimeOffset;
      a !== null && de(a) ? (r = n + a, a < 0 && (r += e.edge), r = Math.min(Math.max(n, r), n + e.totalduration), this.log(`Setting startPosition to ${r} for start time offset ${a} found in ${s ? "multivariant" : "media"} playlist`), this.startPosition = r) : e.live ? (r = this.hls.liveSyncPosition || n, this.log(`Setting startPosition to -1 to start at live edge ${r}`), this.startPosition = -1) : (this.log("setting startPosition to 0 by default"), this.startPosition = r = 0), this.lastCurrentTime = r + i;
    }
    this.nextLoadPosition = r + i;
  }
  getLoadPosition() {
    var e;
    const {
      media: n
    } = this;
    let r = 0;
    return (e = this.hls) != null && e.hasEnoughToStart && n ? r = n.currentTime : this.nextLoadPosition >= 0 && (r = this.nextLoadPosition), r;
  }
  handleFragLoadAborted(e, n) {
    this.transmuxer && e.type === this.playlistType && gt(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${n ? " part " + n.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));
  }
  resetFragmentLoading(e) {
    (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== Z.FRAG_LOADING_WAITING_RETRY) && (this.state = Z.IDLE);
  }
  onFragmentOrKeyLoadError(e, n) {
    var r;
    if (n.chunkMeta && !n.frag) {
      const b = this.getCurrentContext(n.chunkMeta);
      b && (n.frag = b.frag);
    }
    const i = n.frag;
    if (!i || i.type !== e || !this.levels)
      return;
    if (this.fragContextChanged(i)) {
      var s;
      this.warn(`Frag load error must match current frag to retry ${i.url} > ${(s = this.fragCurrent) == null ? void 0 : s.url}`);
      return;
    }
    const a = n.details === q.FRAG_GAP;
    a && this.fragmentTracker.fragBuffered(i, !0);
    const o = n.errorAction;
    if (!o) {
      this.state = Z.ERROR;
      return;
    }
    const {
      action: u,
      flags: l,
      retryCount: c = 0,
      retryConfig: d
    } = o, f = !!d, h = f && u === Lt.RetryRequest, m = f && !o.resolved && l === an.MoveAllAlternatesMatchingHost, p = (r = this.hls.latestLevelDetails) == null ? void 0 : r.live;
    if (!h && m && gt(i) && !i.endList && p && !Tx(n))
      this.resetFragmentErrors(e), this.treatAsGap(i), o.resolved = !0;
    else if ((h || m) && c < d.maxNumRetry) {
      var g;
      const b = Yd((g = n.response) == null ? void 0 : g.code), y = Hh(d, c);
      if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + y, this.state = Z.FRAG_LOADING_WAITING_RETRY, o.resolved = !0, b) {
        this.log("Waiting for connection (offline)"), this.retryDate = 1 / 0, n.reason = "offline";
        return;
      }
      this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${n.details}, retrying loading ${c + 1}/${d.maxNumRetry} in ${y}ms`);
    } else if (d)
      if (this.resetFragmentErrors(e), c < d.maxNumRetry)
        !a && u !== Lt.RemoveAlternatePermanently && (o.resolved = !0);
      else {
        this.warn(`${n.details} reached or exceeded max retry (${c})`);
        return;
      }
    else u === Lt.SendAlternateToPenaltyBox ? this.state = Z.WAITING_LEVEL : this.state = Z.ERROR;
    this.tickImmediate();
  }
  checkRetryDate() {
    const e = self.performance.now(), n = this.retryDate, r = n === 1 / 0;
    (!n || e >= n || r && !Yd(0)) && (r && this.log("Connection restored (online)"), this.resetStartWhenNotLoaded(), this.state = Z.IDLE);
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === Z.PARSING || this.state === Z.PARSED) {
      const n = e.frag, r = e.parent, i = this.getFwdBufferInfo(this.mediaBuffer, r), s = i && i.len > 0.5;
      s && this.reduceMaxBufferLength(i.len, (n == null ? void 0 : n.duration) || 10);
      const a = !s;
      return a && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${r} buffer`), n && (this.fragmentTracker.removeFragment(n), this.nextLoadPosition = n.start), this.resetLoadingState(), a;
    }
    return !1;
  }
  resetFragmentErrors(e) {
    e === pe.AUDIO && (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== Z.STOPPED && (this.state = Z.IDLE);
  }
  afterBufferFlushed(e, n, r) {
    if (!e)
      return;
    const i = Ce.getBuffered(e);
    this.fragmentTracker.detectEvictedFragments(n, i, r), this.state === Z.ENDED && this.resetLoadingState();
  }
  resetLoadingState() {
    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state !== Z.STOPPED && (this.state = Z.IDLE);
  }
  resetStartWhenNotLoaded() {
    if (!this.hls.hasEnoughToStart) {
      this.startFragRequested = !1;
      const e = this.levelLastLoaded, n = e ? e.details : null;
      n != null && n.live ? (this.log("resetting startPosition for live start"), this.startPosition = -1, this.setStartPosition(n, n.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;
    }
  }
  resetWhenMissingContext(e) {
    this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState();
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);
  }
  updateLevelTiming(e, n, r, i) {
    const s = r.details;
    if (!s) {
      this.warn("level.details undefined");
      return;
    }
    if (!Object.keys(e.elementaryStreams).reduce((u, l) => {
      const c = e.elementaryStreams[l];
      if (c) {
        const d = c.endPTS - c.startPTS;
        if (d <= 0)
          return this.warn(`Could not parse fragment ${e.sn} ${l} duration reliably (${d})`), u || !1;
        const f = i ? 0 : Rx(s, e, c.startPTS, c.endPTS, c.startDTS, c.endDTS, this);
        return this.hls.trigger(x.LEVEL_PTS_UPDATED, {
          details: s,
          level: r,
          drift: f,
          type: l,
          frag: e,
          start: c.startPTS,
          end: c.endPTS
        }), !0;
      }
      return u;
    }, !1)) {
      var o;
      if (r.fragmentError === 0 && this.treatAsGap(e, r), ((o = this.transmuxer) == null ? void 0 : o.error) === null) {
        const u = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
        if (this.warn(u.message), this.hls.trigger(x.ERROR, {
          type: be.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          error: u,
          frag: e,
          reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${r.url}"`
        }), !this.hls)
          return;
        this.resetTransmuxer();
      }
    }
    this.state = Z.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${n ? " part: " + n.index : ""} of ${this.fragInfo(e, !1, n)})`), this.hls.trigger(x.FRAG_PARSED, {
      frag: e,
      part: n
    });
  }
  playlistLabel() {
    return this.playlistType === pe.MAIN ? "level" : "track";
  }
  fragInfo(e, n = !0, r) {
    var i, s;
    return `${this.playlistLabel()} ${e.level} (${r ? "part" : "frag"}:[${((i = n && !r ? e.startPTS : (r || e).start) != null ? i : NaN).toFixed(3)}-${((s = n && !r ? e.endPTS : (r || e).end) != null ? s : NaN).toFixed(3)}]${r && e.type === "main" ? "INDEPENDENT=" + (r.independent ? "YES" : "NO") : ""}`;
  }
  treatAsGap(e, n) {
    n && n.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);
  }
  resetTransmuxer() {
    var e;
    (e = this.transmuxer) == null || e.reset();
  }
  recoverWorkerError(e) {
    e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState());
  }
  set state(e) {
    const n = this._state;
    n !== e && (this._state = e, this.log(`${n}->${e}`));
  }
  get state() {
    return this._state;
  }
}
function Cg(t) {
  return !!t.interstitialsController && t.enableInterstitialPlayback !== !1;
}
class Fx {
  constructor() {
    this.chunks = [], this.dataLength = 0;
  }
  push(e) {
    this.chunks.push(e), this.dataLength += e.length;
  }
  flush() {
    const {
      chunks: e,
      dataLength: n
    } = this;
    let r;
    if (e.length)
      e.length === 1 ? r = e[0] : r = $9(e, n);
    else return new Uint8Array(0);
    return this.reset(), r;
  }
  reset() {
    this.chunks.length = 0, this.dataLength = 0;
  }
}
function $9(t, e) {
  const n = new Uint8Array(e);
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    n.set(s, r), r += s.length;
  }
  return n;
}
var xc = { exports: {} }, Lg;
function U9() {
  return Lg || (Lg = 1, function(t) {
    var e = Object.prototype.hasOwnProperty, n = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
    function i(u, l, c) {
      this.fn = u, this.context = l, this.once = c || !1;
    }
    function s(u, l, c, d, f) {
      if (typeof c != "function")
        throw new TypeError("The listener must be a function");
      var h = new i(c, d || u, f), m = n ? n + l : l;
      return u._events[m] ? u._events[m].fn ? u._events[m] = [u._events[m], h] : u._events[m].push(h) : (u._events[m] = h, u._eventsCount++), u;
    }
    function a(u, l) {
      --u._eventsCount === 0 ? u._events = new r() : delete u._events[l];
    }
    function o() {
      this._events = new r(), this._eventsCount = 0;
    }
    o.prototype.eventNames = function() {
      var l = [], c, d;
      if (this._eventsCount === 0) return l;
      for (d in c = this._events)
        e.call(c, d) && l.push(n ? d.slice(1) : d);
      return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l;
    }, o.prototype.listeners = function(l) {
      var c = n ? n + l : l, d = this._events[c];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, h = d.length, m = new Array(h); f < h; f++)
        m[f] = d[f].fn;
      return m;
    }, o.prototype.listenerCount = function(l) {
      var c = n ? n + l : l, d = this._events[c];
      return d ? d.fn ? 1 : d.length : 0;
    }, o.prototype.emit = function(l, c, d, f, h, m) {
      var p = n ? n + l : l;
      if (!this._events[p]) return !1;
      var g = this._events[p], b = arguments.length, y, T;
      if (g.fn) {
        switch (g.once && this.removeListener(l, g.fn, void 0, !0), b) {
          case 1:
            return g.fn.call(g.context), !0;
          case 2:
            return g.fn.call(g.context, c), !0;
          case 3:
            return g.fn.call(g.context, c, d), !0;
          case 4:
            return g.fn.call(g.context, c, d, f), !0;
          case 5:
            return g.fn.call(g.context, c, d, f, h), !0;
          case 6:
            return g.fn.call(g.context, c, d, f, h, m), !0;
        }
        for (T = 1, y = new Array(b - 1); T < b; T++)
          y[T - 1] = arguments[T];
        g.fn.apply(g.context, y);
      } else {
        var S = g.length, I;
        for (T = 0; T < S; T++)
          switch (g[T].once && this.removeListener(l, g[T].fn, void 0, !0), b) {
            case 1:
              g[T].fn.call(g[T].context);
              break;
            case 2:
              g[T].fn.call(g[T].context, c);
              break;
            case 3:
              g[T].fn.call(g[T].context, c, d);
              break;
            case 4:
              g[T].fn.call(g[T].context, c, d, f);
              break;
            default:
              if (!y) for (I = 1, y = new Array(b - 1); I < b; I++)
                y[I - 1] = arguments[I];
              g[T].fn.apply(g[T].context, y);
          }
      }
      return !0;
    }, o.prototype.on = function(l, c, d) {
      return s(this, l, c, d, !1);
    }, o.prototype.once = function(l, c, d) {
      return s(this, l, c, d, !0);
    }, o.prototype.removeListener = function(l, c, d, f) {
      var h = n ? n + l : l;
      if (!this._events[h]) return this;
      if (!c)
        return a(this, h), this;
      var m = this._events[h];
      if (m.fn)
        m.fn === c && (!f || m.once) && (!d || m.context === d) && a(this, h);
      else {
        for (var p = 0, g = [], b = m.length; p < b; p++)
          (m[p].fn !== c || f && !m[p].once || d && m[p].context !== d) && g.push(m[p]);
        g.length ? this._events[h] = g.length === 1 ? g[0] : g : a(this, h);
      }
      return this;
    }, o.prototype.removeAllListeners = function(l) {
      var c;
      return l ? (c = n ? n + l : l, this._events[c] && a(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = n, o.EventEmitter = o, t.exports = o;
  }(xc)), xc.exports;
}
var H9 = U9(), Kh = /* @__PURE__ */ fB(H9);
const Ca = "1.6.13", ds = {};
function V9() {
  return typeof __HLS_WORKER_BUNDLE__ == "function";
}
function G9() {
  const t = ds[Ca];
  if (t)
    return t.clientCount++, t;
  const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  }), n = self.URL.createObjectURL(e), i = {
    worker: new self.Worker(n),
    objectURL: n,
    clientCount: 1
  };
  return ds[Ca] = i, i;
}
function z9(t) {
  const e = ds[t];
  if (e)
    return e.clientCount++, e;
  const n = new self.URL(t, self.location.href).href, i = {
    worker: new self.Worker(n),
    scriptURL: n,
    clientCount: 1
  };
  return ds[t] = i, i;
}
function q9(t) {
  const e = ds[t || Ca];
  if (e && e.clientCount-- === 1) {
    const {
      worker: r,
      objectURL: i
    } = e;
    delete ds[t || Ca], i && self.URL.revokeObjectURL(i), r.terminate();
  }
}
function Bx(t, e) {
  return e + 10 <= t.length && t[e] === 51 && t[e + 1] === 68 && t[e + 2] === 73 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;
}
function jh(t, e) {
  return e + 10 <= t.length && t[e] === 73 && t[e + 1] === 68 && t[e + 2] === 51 && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;
}
function Al(t, e) {
  let n = 0;
  return n = (t[e] & 127) << 21, n |= (t[e + 1] & 127) << 14, n |= (t[e + 2] & 127) << 7, n |= t[e + 3] & 127, n;
}
function La(t, e) {
  const n = e;
  let r = 0;
  for (; jh(t, e); ) {
    r += 10;
    const i = Al(t, e + 6);
    r += i, Bx(t, e + 10) && (r += 10), e += r;
  }
  if (r > 0)
    return t.subarray(n, n + r);
}
function W9(t, e, n, r) {
  const i = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], s = e[n + 2], a = s >> 2 & 15;
  if (a > 12) {
    const h = new Error(`invalid ADTS sampling index:${a}`);
    t.emit(x.ERROR, x.ERROR, {
      type: be.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      fatal: !0,
      error: h,
      reason: h.message
    });
    return;
  }
  const o = (s >> 6 & 3) + 1, u = e[n + 3] >> 6 & 3 | (s & 1) << 2, l = "mp4a.40." + o, c = i[a];
  let d = a;
  (o === 5 || o === 29) && (d -= 3);
  const f = [o << 3 | (d & 14) >> 1, (d & 1) << 7 | u << 3];
  return qe.log(`manifest codec:${r}, parsed codec:${l}, channels:${u}, rate:${c} (ADTS object type:${o} sampling index:${a})`), {
    config: f,
    samplerate: c,
    channelCount: u,
    codec: l,
    parsedCodec: l,
    manifestCodec: r
  };
}
function $x(t, e) {
  return t[e] === 255 && (t[e + 1] & 246) === 240;
}
function Ux(t, e) {
  return t[e + 1] & 1 ? 7 : 9;
}
function Yh(t, e) {
  return (t[e + 3] & 3) << 11 | t[e + 4] << 3 | (t[e + 5] & 224) >>> 5;
}
function K9(t, e) {
  return e + 5 < t.length;
}
function Uu(t, e) {
  return e + 1 < t.length && $x(t, e);
}
function j9(t, e) {
  return K9(t, e) && $x(t, e) && Yh(t, e) <= t.length - e;
}
function Y9(t, e) {
  if (Uu(t, e)) {
    const n = Ux(t, e);
    if (e + n >= t.length)
      return !1;
    const r = Yh(t, e);
    if (r <= n)
      return !1;
    const i = e + r;
    return i === t.length || Uu(t, i);
  }
  return !1;
}
function Hx(t, e, n, r, i) {
  if (!t.samplerate) {
    const s = W9(e, n, r, i);
    if (!s)
      return;
    Xe(t, s);
  }
}
function Vx(t) {
  return 1024 * 9e4 / t;
}
function X9(t, e) {
  const n = Ux(t, e);
  if (e + n <= t.length) {
    const r = Yh(t, e) - n;
    if (r > 0)
      return {
        headerLength: n,
        frameLength: r
      };
  }
}
function Gx(t, e, n, r, i) {
  const s = Vx(t.samplerate), a = r + i * s, o = X9(e, n);
  let u;
  if (o) {
    const {
      frameLength: d,
      headerLength: f
    } = o, h = f + d, m = Math.max(0, n + h - e.length);
    m ? (u = new Uint8Array(h - f), u.set(e.subarray(n + f, e.length), 0)) : u = e.subarray(n + f, n + h);
    const p = {
      unit: u,
      pts: a
    };
    return m || t.samples.push(p), {
      sample: p,
      length: h,
      missing: m
    };
  }
  const l = e.length - n;
  return u = new Uint8Array(l), u.set(e.subarray(n, e.length), 0), {
    sample: {
      unit: u,
      pts: a
    },
    length: l,
    missing: -1
  };
}
function Q9(t, e) {
  return jh(t, e) && Al(t, e + 6) + 10 <= t.length - e;
}
function Z9(t) {
  return t instanceof ArrayBuffer ? t : t.byteOffset == 0 && t.byteLength == t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
}
function vc(t, e = 0, n = 1 / 0) {
  return J9(t, e, n, Uint8Array);
}
function J9(t, e, n, r) {
  const i = e$(t);
  let s = 1;
  "BYTES_PER_ELEMENT" in r && (s = r.BYTES_PER_ELEMENT);
  const a = t$(t) ? t.byteOffset : 0, o = (a + t.byteLength) / s, u = (a + e) / s, l = Math.floor(Math.max(0, Math.min(u, o))), c = Math.floor(Math.min(l + Math.max(n, 0), o));
  return new r(i, l, c - l);
}
function e$(t) {
  return t instanceof ArrayBuffer ? t : t.buffer;
}
function t$(t) {
  return t && t.buffer instanceof ArrayBuffer && t.byteLength !== void 0 && t.byteOffset !== void 0;
}
function n$(t) {
  const e = {
    key: t.type,
    description: "",
    data: "",
    mimeType: null,
    pictureType: null
  }, n = 3;
  if (t.size < 2)
    return;
  if (t.data[0] !== n) {
    console.log("Ignore frame with unrecognized character encoding");
    return;
  }
  const r = t.data.subarray(1).indexOf(0);
  if (r === -1)
    return;
  const i = cn(vc(t.data, 1, r)), s = t.data[2 + r], a = t.data.subarray(3 + r).indexOf(0);
  if (a === -1)
    return;
  const o = cn(vc(t.data, 3 + r, a));
  let u;
  return i === "-->" ? u = cn(vc(t.data, 4 + r + a)) : u = Z9(t.data.subarray(4 + r + a)), e.mimeType = i, e.pictureType = s, e.description = o, e.data = u, e;
}
function r$(t) {
  if (t.size < 2)
    return;
  const e = cn(t.data, !0), n = new Uint8Array(t.data.subarray(e.length + 1));
  return {
    key: t.type,
    info: e,
    data: n.buffer
  };
}
function i$(t) {
  if (t.size < 2)
    return;
  if (t.type === "TXXX") {
    let n = 1;
    const r = cn(t.data.subarray(n), !0);
    n += r.length + 1;
    const i = cn(t.data.subarray(n));
    return {
      key: t.type,
      info: r,
      data: i
    };
  }
  const e = cn(t.data.subarray(1));
  return {
    key: t.type,
    info: "",
    data: e
  };
}
function s$(t) {
  if (t.type === "WXXX") {
    if (t.size < 2)
      return;
    let n = 1;
    const r = cn(t.data.subarray(n), !0);
    n += r.length + 1;
    const i = cn(t.data.subarray(n));
    return {
      key: t.type,
      info: r,
      data: i
    };
  }
  const e = cn(t.data);
  return {
    key: t.type,
    info: "",
    data: e
  };
}
function a$(t) {
  return t.type === "PRIV" ? r$(t) : t.type[0] === "W" ? s$(t) : t.type === "APIC" ? n$(t) : i$(t);
}
function o$(t) {
  const e = String.fromCharCode(t[0], t[1], t[2], t[3]), n = Al(t, 4), r = 10;
  return {
    type: e,
    size: n,
    data: t.subarray(r, r + n)
  };
}
const Lo = 10, u$ = 10;
function zx(t) {
  let e = 0;
  const n = [];
  for (; jh(t, e); ) {
    const r = Al(t, e + 6);
    t[e + 5] >> 6 & 1 && (e += Lo), e += Lo;
    const i = e + r;
    for (; e + u$ < i; ) {
      const s = o$(t.subarray(e)), a = a$(s);
      a && n.push(a), e += s.size + Lo;
    }
    Bx(t, e) && (e += Lo);
  }
  return n;
}
function qx(t) {
  return t && t.key === "PRIV" && t.info === "com.apple.streaming.transportStreamTimestamp";
}
function l$(t) {
  if (t.data.byteLength === 8) {
    const e = new Uint8Array(t.data), n = e[3] & 1;
    let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
    return r /= 45, n && (r += 4772185884e-2), Math.round(r);
  }
}
function Xh(t) {
  const e = zx(t);
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (qx(r))
      return l$(r);
  }
}
let un = /* @__PURE__ */ function(t) {
  return t.audioId3 = "org.id3", t.dateRange = "com.apple.quicktime.HLS", t.emsg = "https://aomedia.org/emsg/ID3", t.misbklv = "urn:misb:KLV:bin:1910.1", t;
}({});
function Mn(t = "", e = 9e4) {
  return {
    type: t,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}
class Qh {
  constructor() {
    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;
  }
  resetInitSegment(e, n, r, i) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(e) {
    this.initPTS = e, this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;
  }
  canParse(e, n) {
    return !1;
  }
  appendFrame(e, n, r) {
  }
  // feed incoming data to the front of the parsing pipeline
  demux(e, n) {
    this.cachedData && (e = gn(this.cachedData, e), this.cachedData = null);
    let r = La(e, 0), i = r ? r.length : 0, s;
    const a = this._audioTrack, o = this._id3Track, u = r ? Xh(r) : void 0, l = e.length;
    for ((this.basePTS === null || this.frameIndex === 0 && de(u)) && (this.basePTS = c$(u, n, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null && (this.lastPTS = this.basePTS), r && r.length > 0 && o.samples.push({
      pts: this.lastPTS,
      dts: this.lastPTS,
      data: r,
      type: un.audioId3,
      duration: Number.POSITIVE_INFINITY
    }); i < l; ) {
      if (this.canParse(e, i)) {
        const c = this.appendFrame(a, e, i);
        c ? (this.frameIndex++, this.lastPTS = c.sample.pts, i += c.length, s = i) : i = l;
      } else Q9(e, i) ? (r = La(e, i), o.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: r,
        type: un.audioId3,
        duration: Number.POSITIVE_INFINITY
      }), i += r.length, s = i) : i++;
      if (i === l && s !== l) {
        const c = e.slice(s);
        this.cachedData ? this.cachedData = gn(this.cachedData, c) : this.cachedData = c;
      }
    }
    return {
      audioTrack: a,
      videoTrack: Mn(),
      id3Track: o,
      textTrack: Mn()
    };
  }
  demuxSampleAes(e, n, r) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(e) {
    const n = this.cachedData;
    return n && (this.cachedData = null, this.demux(n, 0)), {
      audioTrack: this._audioTrack,
      videoTrack: Mn(),
      id3Track: this._id3Track,
      textTrack: Mn()
    };
  }
  destroy() {
    this.cachedData = null, this._audioTrack = this._id3Track = void 0;
  }
}
const c$ = (t, e, n) => {
  if (de(t))
    return t * 90;
  const r = n ? n.baseTime * 9e4 / n.timescale : 0;
  return e * 9e4 + r;
};
let _o = null;
const d$ = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], f$ = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], h$ = [
  // MPEG 2.5
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // Reserved
  [
    0,
    // Reserved
    0,
    // Layer3
    0,
    // Layer2
    0
    // Layer1
  ],
  // MPEG 2
  [
    0,
    // Reserved
    72,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ],
  // MPEG 1
  [
    0,
    // Reserved
    144,
    // Layer3
    144,
    // Layer2
    12
    // Layer1
  ]
], m$ = [
  0,
  // Reserved
  1,
  // Layer3
  1,
  // Layer2
  4
  // Layer1
];
function Wx(t, e, n, r, i) {
  if (n + 24 > e.length)
    return;
  const s = Kx(e, n);
  if (s && n + s.frameLength <= e.length) {
    const a = s.samplesPerFrame * 9e4 / s.sampleRate, o = r + i * a, u = {
      unit: e.subarray(n, n + s.frameLength),
      pts: o,
      dts: o
    };
    return t.config = [], t.channelCount = s.channelCount, t.samplerate = s.sampleRate, t.samples.push(u), {
      sample: u,
      length: s.frameLength,
      missing: 0
    };
  }
}
function Kx(t, e) {
  const n = t[e + 1] >> 3 & 3, r = t[e + 1] >> 1 & 3, i = t[e + 2] >> 4 & 15, s = t[e + 2] >> 2 & 3;
  if (n !== 1 && i !== 0 && i !== 15 && s !== 3) {
    const a = t[e + 2] >> 1 & 1, o = t[e + 3] >> 6, u = n === 3 ? 3 - r : r === 3 ? 3 : 4, l = d$[u * 14 + i - 1] * 1e3, d = f$[(n === 3 ? 0 : n === 2 ? 1 : 2) * 3 + s], f = o === 3 ? 1 : 2, h = h$[n][r], m = m$[r], p = h * 8 * m, g = Math.floor(h * l / d + a) * m;
    if (_o === null) {
      const T = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      _o = T ? parseInt(T[1]) : 0;
    }
    return !!_o && _o <= 87 && r === 2 && l >= 224e3 && o === 0 && (t[e + 3] = t[e + 3] | 128), {
      sampleRate: d,
      channelCount: f,
      frameLength: g,
      samplesPerFrame: p
    };
  }
}
function Zh(t, e) {
  return t[e] === 255 && (t[e + 1] & 224) === 224 && (t[e + 1] & 6) !== 0;
}
function jx(t, e) {
  return e + 1 < t.length && Zh(t, e);
}
function p$(t, e) {
  return Zh(t, e) && 4 <= t.length - e;
}
function Yx(t, e) {
  if (e + 1 < t.length && Zh(t, e)) {
    const r = Kx(t, e);
    let i = 4;
    r != null && r.frameLength && (i = r.frameLength);
    const s = e + i;
    return s === t.length || jx(t, s);
  }
  return !1;
}
class g$ extends Qh {
  constructor(e, n) {
    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = n;
  }
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS
  static probe(e, n) {
    if (!e)
      return !1;
    const r = La(e, 0);
    let i = (r == null ? void 0 : r.length) || 0;
    if (Yx(e, i))
      return !1;
    for (let s = e.length; i < s; i++)
      if (Y9(e, i))
        return n.log("ADTS sync word found !"), !0;
    return !1;
  }
  canParse(e, n) {
    return j9(e, n);
  }
  appendFrame(e, n, r) {
    Hx(e, this.observer, n, r, e.manifestCodec);
    const i = Gx(e, n, r, this.basePTS, this.frameIndex);
    if (i && i.missing === 0)
      return i;
  }
}
const Xx = (t, e) => {
  let n = 0, r = 5;
  e += r;
  const i = new Uint32Array(1), s = new Uint32Array(1), a = new Uint8Array(1);
  for (; r > 0; ) {
    a[0] = t[e];
    const o = Math.min(r, 8), u = 8 - o;
    s[0] = 4278190080 >>> 24 + u << u, i[0] = (a[0] & s[0]) >> u, n = n ? n << o | i[0] : i[0], e += 1, r -= o;
  }
  return n;
};
class b$ extends Qh {
  constructor(e) {
    super(), this.observer = void 0, this.observer = e;
  }
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/ac-3",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "ac3",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  canParse(e, n) {
    return n + 64 < e.length;
  }
  appendFrame(e, n, r) {
    const i = Qx(e, n, r, this.basePTS, this.frameIndex);
    if (i !== -1)
      return {
        sample: e.samples[e.samples.length - 1],
        length: i,
        missing: 0
      };
  }
  static probe(e) {
    if (!e)
      return !1;
    const n = La(e, 0);
    if (!n)
      return !1;
    const r = n.length;
    return e[r] === 11 && e[r + 1] === 119 && Xh(n) !== void 0 && // check the bsid to confirm ac-3
    Xx(e, r) < 16;
  }
}
function Qx(t, e, n, r, i) {
  if (n + 8 > e.length || e[n] !== 11 || e[n + 1] !== 119)
    return -1;
  const s = e[n + 4] >> 6;
  if (s >= 3)
    return -1;
  const o = [48e3, 44100, 32e3][s], u = e[n + 4] & 63, c = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][u * 3 + s] * 2;
  if (n + c > e.length)
    return -1;
  const d = e[n + 6] >> 5;
  let f = 0;
  d === 2 ? f += 2 : (d & 1 && d !== 1 && (f += 2), d & 4 && (f += 2));
  const h = (e[n + 6] << 8 | e[n + 7]) >> 12 - f & 1, p = [2, 1, 2, 3, 3, 4, 4, 5][d] + h, g = e[n + 5] >> 3, b = e[n + 5] & 7, y = new Uint8Array([s << 6 | g << 1 | b >> 2, (b & 3) << 6 | d << 3 | h << 2 | u >> 4, u << 4 & 224]), T = 1536 / o * 9e4, S = r + i * T, I = e.subarray(n, n + c);
  return t.config = y, t.channelCount = p, t.samplerate = o, t.samples.push({
    unit: I,
    pts: S
  }), c;
}
class E$ extends Qh {
  resetInitSegment(e, n, r, i) {
    super.resetInitSegment(e, n, r, i), this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: n,
      duration: i,
      inputTimeScale: 9e4,
      dropped: 0
    };
  }
  static probe(e) {
    if (!e)
      return !1;
    const n = La(e, 0);
    let r = (n == null ? void 0 : n.length) || 0;
    if (n && e[r] === 11 && e[r + 1] === 119 && Xh(n) !== void 0 && // check the bsid to confirm ac-3 or ec-3 (not mp3)
    Xx(e, r) <= 16)
      return !1;
    for (let i = e.length; r < i; r++)
      if (Yx(e, r))
        return qe.log("MPEG Audio sync word found !"), !0;
    return !1;
  }
  canParse(e, n) {
    return p$(e, n);
  }
  appendFrame(e, n, r) {
    if (this.basePTS !== null)
      return Wx(e, n, r, this.basePTS, this.frameIndex);
  }
}
const y$ = /\/emsg[-/]ID3/i;
class T$ {
  constructor(e, n) {
    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = n;
  }
  resetTimeStamp() {
  }
  resetInitSegment(e, n, r, i) {
    const s = this.videoTrack = Mn("video", 1), a = this.audioTrack = Mn("audio", 1), o = this.txtTrack = Mn("text", 1);
    if (this.id3Track = Mn("id3", 1), this.timeOffset = 0, !(e != null && e.byteLength))
      return;
    const u = ox(e);
    if (u.video) {
      const {
        id: l,
        timescale: c,
        codec: d,
        supplemental: f
      } = u.video;
      s.id = l, s.timescale = o.timescale = c, s.codec = d, s.supplemental = f;
    }
    if (u.audio) {
      const {
        id: l,
        timescale: c,
        codec: d
      } = u.audio;
      a.id = l, a.timescale = c, a.codec = d;
    }
    o.id = ix.text, s.sampleDuration = 0, s.duration = a.duration = i;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(e) {
    return bB(e);
  }
  demux(e, n) {
    this.timeOffset = n;
    let r = e;
    const i = this.videoTrack, s = this.txtTrack;
    if (this.config.progressive) {
      this.remainderData && (r = gn(this.remainderData, e));
      const o = AB(r);
      this.remainderData = o.remainder, i.samples = o.valid || new Uint8Array();
    } else
      i.samples = r;
    const a = this.extractID3Track(i, n);
    return s.samples = qp(n, i), {
      videoTrack: i,
      audioTrack: this.audioTrack,
      id3Track: a,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const e = this.timeOffset, n = this.videoTrack, r = this.txtTrack;
    n.samples = this.remainderData || new Uint8Array(), this.remainderData = null;
    const i = this.extractID3Track(n, this.timeOffset);
    return r.samples = qp(e, n), {
      videoTrack: n,
      audioTrack: Mn(),
      id3Track: i,
      textTrack: Mn()
    };
  }
  extractID3Track(e, n) {
    const r = this.id3Track;
    if (e.samples.length) {
      const i = Pe(e.samples, ["emsg"]);
      i && i.forEach((s) => {
        const a = CB(s);
        if (y$.test(a.schemeIdUri)) {
          const o = _g(a, n);
          let u = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
          u <= 1e-3 && (u = Number.POSITIVE_INFINITY);
          const l = a.payload;
          r.samples.push({
            data: l,
            len: l.byteLength,
            dts: o,
            pts: o,
            type: un.emsg,
            duration: u
          });
        } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
          const o = _g(a, n);
          r.samples.push({
            data: a.payload,
            len: a.payload.byteLength,
            dts: o,
            pts: o,
            type: un.misbklv,
            duration: Number.POSITIVE_INFINITY
          });
        }
      });
    }
    return r;
  }
  demuxSampleAes(e, n, r) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
    this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;
  }
}
function _g(t, e) {
  return de(t.presentationTime) ? t.presentationTime / t.timeScale : e + t.presentationTimeDelta / t.timeScale;
}
class S$ {
  constructor(e, n, r) {
    this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new Vh(n, {
      removePKCS7Padding: !1
    });
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Nr.cbc);
  }
  // AAC - encrypt all full 16 bytes blocks starting from offset 16
  decryptAacSample(e, n, r) {
    const i = e[n].unit;
    if (i.length <= 16)
      return;
    const s = i.subarray(16, i.length - i.length % 16), a = s.buffer.slice(s.byteOffset, s.byteOffset + s.length);
    this.decryptBuffer(a).then((o) => {
      const u = new Uint8Array(o);
      i.set(u, 16), this.decrypter.isSync() || this.decryptAacSamples(e, n + 1, r);
    }).catch(r);
  }
  decryptAacSamples(e, n, r) {
    for (; ; n++) {
      if (n >= e.length) {
        r();
        return;
      }
      if (!(e[n].unit.length < 32) && (this.decryptAacSample(e, n, r), !this.decrypter.isSync()))
        return;
    }
  }
  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
  getAvcEncryptedData(e) {
    const n = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(n);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      r.set(e.subarray(s, s + 16), i);
    return r;
  }
  getAvcDecryptedUnit(e, n) {
    const r = new Uint8Array(n);
    let i = 0;
    for (let s = 32; s < e.length - 16; s += 160, i += 16)
      e.set(r.subarray(i, i + 16), s);
    return e;
  }
  decryptAvcSample(e, n, r, i, s) {
    const a = cx(s.data), o = this.getAvcEncryptedData(a);
    this.decryptBuffer(o.buffer).then((u) => {
      s.data = this.getAvcDecryptedUnit(a, u), this.decrypter.isSync() || this.decryptAvcSamples(e, n, r + 1, i);
    }).catch(i);
  }
  decryptAvcSamples(e, n, r, i) {
    if (e instanceof Uint8Array)
      throw new Error("Cannot decrypt samples of type Uint8Array");
    for (; ; n++, r = 0) {
      if (n >= e.length) {
        i();
        return;
      }
      const s = e[n].units;
      for (; !(r >= s.length); r++) {
        const a = s[r];
        if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, n, r, i, a), !this.decrypter.isSync()))
          return;
      }
    }
  }
}
class Zx {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(e, n, r) {
    return {
      key: e,
      frame: !1,
      pts: n,
      dts: r,
      units: [],
      length: 0
    };
  }
  getLastNalUnit(e) {
    var n;
    let r = this.VideoSample, i;
    if ((!r || r.units.length === 0) && (r = e[e.length - 1]), (n = r) != null && n.units) {
      const s = r.units;
      i = s[s.length - 1];
    }
    return i;
  }
  pushAccessUnit(e, n) {
    if (e.units.length && e.frame) {
      if (e.pts === void 0) {
        const r = n.samples, i = r.length;
        if (i) {
          const s = r[i - 1];
          e.pts = s.pts, e.dts = s.dts;
        } else {
          n.dropped++;
          return;
        }
      }
      n.samples.push(e);
    }
  }
  parseNALu(e, n, r) {
    const i = n.byteLength;
    let s = e.naluState || 0;
    const a = s, o = [];
    let u = 0, l, c, d, f = -1, h = 0;
    for (s === -1 && (f = 0, h = this.getNALuType(n, 0), s = 0, u = 1); u < i; ) {
      if (l = n[u++], !s) {
        s = l ? 0 : 1;
        continue;
      }
      if (s === 1) {
        s = l ? 0 : 2;
        continue;
      }
      if (!l)
        s = 3;
      else if (l === 1) {
        if (c = u - s - 1, f >= 0) {
          const m = {
            data: n.subarray(f, c),
            type: h
          };
          o.push(m);
        } else {
          const m = this.getLastNalUnit(e.samples);
          m && (a && u <= 4 - a && m.state && (m.data = m.data.subarray(0, m.data.byteLength - a)), c > 0 && (m.data = gn(m.data, n.subarray(0, c)), m.state = 0));
        }
        u < i ? (d = this.getNALuType(n, u), f = u, h = d, s = 0) : s = -1;
      } else
        s = 0;
    }
    if (f >= 0 && s >= 0) {
      const m = {
        data: n.subarray(f, i),
        type: h,
        state: s
      };
      o.push(m);
    }
    if (o.length === 0) {
      const m = this.getLastNalUnit(e.samples);
      m && (m.data = gn(m.data, n));
    }
    return e.naluState = s, o;
  }
}
class sa {
  constructor(e) {
    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;
  }
  // ():void
  loadWord() {
    const e = this.data, n = this.bytesAvailable, r = e.byteLength - n, i = new Uint8Array(4), s = Math.min(4, n);
    if (s === 0)
      throw new Error("no bytes available");
    i.set(e.subarray(r, r + s)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = s * 8, this.bytesAvailable -= s;
  }
  // (count:int):void
  skipBits(e) {
    let n;
    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, n = e >> 3, e -= n << 3, this.bytesAvailable -= n, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);
  }
  // (size:int):uint
  readBits(e) {
    let n = Math.min(this.bitsAvailable, e);
    const r = this.word >>> 32 - n;
    if (e > 32 && qe.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= n, this.bitsAvailable > 0)
      this.word <<= n;
    else if (this.bytesAvailable > 0)
      this.loadWord();
    else
      throw new Error("no bits available");
    return n = e - n, n > 0 && this.bitsAvailable ? r << n | this.readBits(n) : r;
  }
  // ():uint
  skipLZ() {
    let e;
    for (e = 0; e < this.bitsAvailable; ++e)
      if (this.word & 2147483648 >>> e)
        return this.word <<= e, this.bitsAvailable -= e, e;
    return this.loadWord(), e + this.skipLZ();
  }
  // ():void
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():void
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  // ():uint
  readUEG() {
    const e = this.skipLZ();
    return this.readBits(e + 1) - 1;
  }
  // ():int
  readEG() {
    const e = this.readUEG();
    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);
  }
  // Some convenience functions
  // :Boolean
  readBoolean() {
    return this.readBits(1) === 1;
  }
  // ():int
  readUByte() {
    return this.readBits(8);
  }
  // ():int
  readUShort() {
    return this.readBits(16);
  }
  // ():int
  readUInt() {
    return this.readBits(32);
  }
}
class x$ extends Zx {
  parsePES(e, n, r, i) {
    const s = this.parseNALu(e, r.data, i);
    let a = this.VideoSample, o, u = !1;
    r.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), s.forEach((l) => {
      var c, d;
      switch (l.type) {
        case 1: {
          let p = !1;
          o = !0;
          const g = l.data;
          if (u && g.length > 4) {
            const b = this.readSliceType(g);
            (b === 2 || b === 4 || b === 7 || b === 9) && (p = !0);
          }
          if (p) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.frame = !0, a.key = p;
          break;
        }
        case 5:
          o = !0, (c = a) != null && c.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 6: {
          o = !0, Bh(l.data, 1, r.pts, n.samples);
          break;
        }
        case 7: {
          var h, m;
          o = !0, u = !0;
          const p = l.data, g = this.readSPS(p);
          if (!e.sps || e.width !== g.width || e.height !== g.height || ((h = e.pixelRatio) == null ? void 0 : h[0]) !== g.pixelRatio[0] || ((m = e.pixelRatio) == null ? void 0 : m[1]) !== g.pixelRatio[1]) {
            e.width = g.width, e.height = g.height, e.pixelRatio = g.pixelRatio, e.sps = [p];
            const b = p.subarray(1, 4);
            let y = "avc1.";
            for (let T = 0; T < 3; T++) {
              let S = b[T].toString(16);
              S.length < 2 && (S = "0" + S), y += S;
            }
            e.codec = y;
          }
          break;
        }
        case 8:
          o = !0, e.pps = [l.data];
          break;
        case 9:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
          break;
        case 12:
          o = !0;
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  getNALuType(e, n) {
    return e[n] & 31;
  }
  readSliceType(e) {
    const n = new sa(e);
    return n.readUByte(), n.readUEG(), n.readUEG();
  }
  /**
   * The scaling list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */
  skipScalingList(e, n) {
    let r = 8, i = 8, s;
    for (let a = 0; a < e; a++)
      i !== 0 && (s = n.readEG(), i = (r + s + 256) % 256), r = i === 0 ? r : i;
  }
  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @returns an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */
  readSPS(e) {
    const n = new sa(e);
    let r = 0, i = 0, s = 0, a = 0, o, u, l;
    const c = n.readUByte.bind(n), d = n.readBits.bind(n), f = n.readUEG.bind(n), h = n.readBoolean.bind(n), m = n.skipBits.bind(n), p = n.skipEG.bind(n), g = n.skipUEG.bind(n), b = this.skipScalingList.bind(this);
    c();
    const y = c();
    if (d(5), m(3), c(), g(), y === 100 || y === 110 || y === 122 || y === 244 || y === 44 || y === 83 || y === 86 || y === 118 || y === 128) {
      const R = f();
      if (R === 3 && m(1), g(), g(), m(1), h())
        for (u = R !== 3 ? 8 : 12, l = 0; l < u; l++)
          h() && (l < 6 ? b(16, n) : b(64, n));
    }
    g();
    const T = f();
    if (T === 0)
      f();
    else if (T === 1)
      for (m(1), p(), p(), o = f(), l = 0; l < o; l++)
        p();
    g(), m(1);
    const S = f(), I = f(), C = d(1);
    C === 0 && m(1), m(1), h() && (r = f(), i = f(), s = f(), a = f());
    let _ = [1, 1];
    if (h() && h())
      switch (c()) {
        case 1:
          _ = [1, 1];
          break;
        case 2:
          _ = [12, 11];
          break;
        case 3:
          _ = [10, 11];
          break;
        case 4:
          _ = [16, 11];
          break;
        case 5:
          _ = [40, 33];
          break;
        case 6:
          _ = [24, 11];
          break;
        case 7:
          _ = [20, 11];
          break;
        case 8:
          _ = [32, 11];
          break;
        case 9:
          _ = [80, 33];
          break;
        case 10:
          _ = [18, 11];
          break;
        case 11:
          _ = [15, 11];
          break;
        case 12:
          _ = [64, 33];
          break;
        case 13:
          _ = [160, 99];
          break;
        case 14:
          _ = [4, 3];
          break;
        case 15:
          _ = [3, 2];
          break;
        case 16:
          _ = [2, 1];
          break;
        case 255: {
          _ = [c() << 8 | c(), c() << 8 | c()];
          break;
        }
      }
    return {
      width: Math.ceil((S + 1) * 16 - r * 2 - i * 2),
      height: (2 - C) * (I + 1) * 16 - (C ? 2 : 4) * (s + a),
      pixelRatio: _
    };
  }
}
class v$ extends Zx {
  constructor(...e) {
    super(...e), this.initVPS = null;
  }
  parsePES(e, n, r, i) {
    const s = this.parseNALu(e, r.data, i);
    let a = this.VideoSample, o, u = !1;
    r.data = null, a && s.length && !e.audFound && (this.pushAccessUnit(a, e), a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), s.forEach((l) => {
      var c, d;
      switch (l.type) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), a.frame = !0, o = !0;
          break;
        case 16:
        case 17:
        case 18:
        case 21:
          if (o = !0, u) {
            var f;
            (f = a) != null && f.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null);
          }
          a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 19:
        case 20:
          o = !0, (c = a) != null && c.frame && !a.key && (this.pushAccessUnit(a, e), a = this.VideoSample = null), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0, a.frame = !0;
          break;
        case 39:
          o = !0, Bh(
            l.data,
            2,
            // NALu header size
            r.pts,
            n.samples
          );
          break;
        case 32:
          o = !0, e.vps || (typeof e.params != "object" && (e.params = {}), e.params = Xe(e.params, this.readVPS(l.data)), this.initVPS = l.data), e.vps = [l.data];
          break;
        case 33:
          if (o = !0, u = !0, e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], l.data) && (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {
            const h = this.readSPS(l.data);
            e.width = h.width, e.height = h.height, e.pixelRatio = h.pixelRatio, e.codec = h.codecString, e.sps = [], typeof e.params != "object" && (e.params = {});
            for (const m in h.params)
              e.params[m] = h.params[m];
          }
          this.pushParameterSet(e.sps, l.data, e.vps), a || (a = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), a.key = !0;
          break;
        case 34:
          if (o = !0, typeof e.params == "object") {
            if (!e.pps) {
              e.pps = [];
              const h = this.readPPS(l.data);
              for (const m in h)
                e.params[m] = h[m];
            }
            this.pushParameterSet(e.pps, l.data, e.vps);
          }
          break;
        case 35:
          o = !0, e.audFound = !0, (d = a) != null && d.frame && (this.pushAccessUnit(a, e), a = null), a || (a = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));
          break;
        default:
          o = !1;
          break;
      }
      a && o && a.units.push(l);
    }), i && a && (this.pushAccessUnit(a, e), this.VideoSample = null);
  }
  pushParameterSet(e, n, r) {
    (r && r[0] === this.initVPS || !r && !e.length) && e.push(n);
  }
  getNALuType(e, n) {
    return (e[n] & 126) >>> 1;
  }
  ebsp2rbsp(e) {
    const n = new Uint8Array(e.byteLength);
    let r = 0;
    for (let i = 0; i < e.byteLength; i++)
      i >= 2 && e[i] === 3 && e[i - 1] === 0 && e[i - 2] === 0 || (n[r] = e[i], r++);
    return new Uint8Array(n.buffer, 0, r);
  }
  pushAccessUnit(e, n) {
    super.pushAccessUnit(e, n), this.initVPS && (this.initVPS = null);
  }
  readVPS(e) {
    const n = new sa(e);
    n.readUByte(), n.readUByte(), n.readBits(4), n.skipBits(2), n.readBits(6);
    const r = n.readBits(3), i = n.readBoolean();
    return {
      numTemporalLayers: r + 1,
      temporalIdNested: i
    };
  }
  readSPS(e) {
    const n = new sa(this.ebsp2rbsp(e));
    n.readUByte(), n.readUByte(), n.readBits(4);
    const r = n.readBits(3);
    n.readBoolean();
    const i = n.readBits(2), s = n.readBoolean(), a = n.readBits(5), o = n.readUByte(), u = n.readUByte(), l = n.readUByte(), c = n.readUByte(), d = n.readUByte(), f = n.readUByte(), h = n.readUByte(), m = n.readUByte(), p = n.readUByte(), g = n.readUByte(), b = n.readUByte(), y = [], T = [];
    for (let Le = 0; Le < r; Le++)
      y.push(n.readBoolean()), T.push(n.readBoolean());
    if (r > 0)
      for (let Le = r; Le < 8; Le++)
        n.readBits(2);
    for (let Le = 0; Le < r; Le++)
      y[Le] && (n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte(), n.readUByte()), T[Le] && n.readUByte();
    n.readUEG();
    const S = n.readUEG();
    S == 3 && n.skipBits(1);
    const I = n.readUEG(), C = n.readUEG(), _ = n.readBoolean();
    let R = 0, k = 0, A = 0, L = 0;
    _ && (R += n.readUEG(), k += n.readUEG(), A += n.readUEG(), L += n.readUEG());
    const P = n.readUEG(), $ = n.readUEG(), G = n.readUEG(), N = n.readBoolean();
    for (let Le = N ? 0 : r; Le <= r; Le++)
      n.skipUEG(), n.skipUEG(), n.skipUEG();
    if (n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG(), n.readBoolean() && n.readBoolean())
      for (let Ke = 0; Ke < 4; Ke++)
        for (let kt = 0; kt < (Ke === 3 ? 2 : 6); kt++)
          if (!n.readBoolean())
            n.readUEG();
          else {
            const $t = Math.min(64, 1 << 4 + (Ke << 1));
            Ke > 1 && n.readEG();
            for (let Tr = 0; Tr < $t; Tr++)
              n.readEG();
          }
    n.readBoolean(), n.readBoolean(), n.readBoolean() && (n.readUByte(), n.skipUEG(), n.skipUEG(), n.readBoolean());
    const V = n.readUEG();
    let K = 0;
    for (let Le = 0; Le < V; Le++) {
      let Ke = !1;
      if (Le !== 0 && (Ke = n.readBoolean()), Ke) {
        Le === V && n.readUEG(), n.readBoolean(), n.readUEG();
        let kt = 0;
        for (let Ot = 0; Ot <= K; Ot++) {
          const $t = n.readBoolean();
          let Tr = !1;
          $t || (Tr = n.readBoolean()), ($t || Tr) && kt++;
        }
        K = kt;
      } else {
        const kt = n.readUEG(), Ot = n.readUEG();
        K = kt + Ot;
        for (let $t = 0; $t < kt; $t++)
          n.readUEG(), n.readBoolean();
        for (let $t = 0; $t < Ot; $t++)
          n.readUEG(), n.readBoolean();
      }
    }
    if (n.readBoolean()) {
      const Le = n.readUEG();
      for (let Ke = 0; Ke < Le; Ke++) {
        for (let kt = 0; kt < G + 4; kt++)
          n.readBits(1);
        n.readBits(1);
      }
    }
    let Y = 0, J = 1, D = 1, te = !0, he = 1, ie = 0;
    n.readBoolean(), n.readBoolean();
    let X = !1;
    if (n.readBoolean()) {
      if (n.readBoolean()) {
        const er = n.readUByte(), Ya = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], xi = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
        er > 0 && er < 16 ? (J = Ya[er - 1], D = xi[er - 1]) : er === 255 && (J = n.readBits(16), D = n.readBits(16));
      }
      if (n.readBoolean() && n.readBoolean(), n.readBoolean() && (n.readBits(3), n.readBoolean(), n.readBoolean() && (n.readUByte(), n.readUByte(), n.readUByte())), n.readBoolean() && (n.readUEG(), n.readUEG()), n.readBoolean(), n.readBoolean(), n.readBoolean(), X = n.readBoolean(), X && (n.skipUEG(), n.skipUEG(), n.skipUEG(), n.skipUEG()), n.readBoolean() && (he = n.readBits(32), ie = n.readBits(32), n.readBoolean() && n.readUEG(), n.readBoolean())) {
        const xi = n.readBoolean(), Xa = n.readBoolean();
        let Q = !1;
        (xi || Xa) && (Q = n.readBoolean(), Q && (n.readUByte(), n.readBits(5), n.readBoolean(), n.readBits(5)), n.readBits(4), n.readBits(4), Q && n.readBits(4), n.readBits(5), n.readBits(5), n.readBits(5));
        for (let ce = 0; ce <= r; ce++) {
          te = n.readBoolean();
          const Ie = te || n.readBoolean();
          let Ne = !1;
          Ie ? n.readEG() : Ne = n.readBoolean();
          const Ge = Ne ? 1 : n.readUEG() + 1;
          if (xi)
            for (let It = 0; It < Ge; It++)
              n.readUEG(), n.readUEG(), Q && (n.readUEG(), n.readUEG()), n.skipBits(1);
          if (Xa)
            for (let It = 0; It < Ge; It++)
              n.readUEG(), n.readUEG(), Q && (n.readUEG(), n.readUEG()), n.skipBits(1);
        }
      }
      n.readBoolean() && (n.readBoolean(), n.readBoolean(), n.readBoolean(), Y = n.readUEG());
    }
    let Te = I, me = C;
    if (_) {
      let Le = 1, Ke = 1;
      S === 1 ? Le = Ke = 2 : S == 2 && (Le = 2), Te = I - Le * k - Le * R, me = C - Ke * L - Ke * A;
    }
    const ye = i ? ["A", "B", "C"][i] : "", Ee = o << 24 | u << 16 | l << 8 | c;
    let He = 0;
    for (let Le = 0; Le < 32; Le++)
      He = (He | (Ee >> Le & 1) << 31 - Le) >>> 0;
    let at = He.toString(16);
    return a === 1 && at === "2" && (at = "6"), {
      codecString: `hvc1.${ye}${a}.${at}.${s ? "H" : "L"}${b}.B0`,
      params: {
        general_tier_flag: s,
        general_profile_idc: a,
        general_profile_space: i,
        general_profile_compatibility_flags: [o, u, l, c],
        general_constraint_indicator_flags: [d, f, h, m, p, g],
        general_level_idc: b,
        bit_depth: P + 8,
        bit_depth_luma_minus8: P,
        bit_depth_chroma_minus8: $,
        min_spatial_segmentation_idc: Y,
        chroma_format_idc: S,
        frame_rate: {
          fixed: te,
          fps: ie / he
        }
      },
      width: Te,
      height: me,
      pixelRatio: [J, D]
    };
  }
  readPPS(e) {
    const n = new sa(this.ebsp2rbsp(e));
    n.readUByte(), n.readUByte(), n.skipUEG(), n.skipUEG(), n.skipBits(2), n.skipBits(3), n.skipBits(2), n.skipUEG(), n.skipUEG(), n.skipEG(), n.skipBits(2), n.readBoolean() && n.skipUEG(), n.skipEG(), n.skipEG(), n.skipBits(4);
    const i = n.readBoolean(), s = n.readBoolean();
    let a = 1;
    return s && i ? a = 0 : s ? a = 3 : i && (a = 2), {
      parallelismType: a
    };
  }
  matchSPS(e, n) {
    return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, n).substr(3);
  }
}
const xt = 188;
class _r {
  constructor(e, n, r, i) {
    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = n, this.typeSupported = r, this.logger = i, this.videoParser = null;
  }
  static probe(e, n) {
    const r = _r.syncOffset(e);
    return r > 0 && n.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1;
  }
  static syncOffset(e) {
    const n = e.length;
    let r = Math.min(xt * 5, n - xt) + 1, i = 0;
    for (; i < r; ) {
      let s = !1, a = -1, o = 0;
      for (let u = i; u < n; u += xt)
        if (e[u] === 71 && (n - u === xt || e[u + xt] === 71)) {
          if (o++, a === -1 && (a = u, a !== 0 && (r = Math.min(a + xt * 99, e.length - xt) + 1)), s || (s = ef(e, u) === 0), s && o > 1 && (a === 0 && o > 2 || u + xt > r))
            return a;
        } else {
          if (o)
            return -1;
          break;
        }
      i++;
    }
    return -1;
  }
  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   */
  static createTrack(e, n) {
    return {
      container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
      type: e,
      id: ix[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === "audio" ? n : void 0
    };
  }
  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   */
  resetInitSegment(e, n, r, i) {
    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = _r.createTrack("video"), this._videoTrack.duration = i, this._audioTrack = _r.createTrack("audio", i), this._id3Track = _r.createTrack("id3"), this._txtTrack = _r.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = n, this.videoCodec = r;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack: e,
      _videoTrack: n,
      _id3Track: r
    } = this;
    e && (e.pesData = null), n && (n.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null;
  }
  demux(e, n, r = !1, i = !1) {
    r || (this.sampleAes = null);
    let s;
    const a = this._videoTrack, o = this._audioTrack, u = this._id3Track, l = this._txtTrack;
    let c = a.pid, d = a.pesData, f = o.pid, h = u.pid, m = o.pesData, p = u.pesData, g = null, b = this.pmtParsed, y = this._pmtId, T = e.length;
    if (this.remainderData && (e = gn(this.remainderData, e), T = e.length, this.remainderData = null), T < xt && !i)
      return this.remainderData = e, {
        audioTrack: o,
        videoTrack: a,
        id3Track: u,
        textTrack: l
      };
    const S = Math.max(0, _r.syncOffset(e));
    T -= (T - S) % xt, T < e.byteLength && !i && (this.remainderData = new Uint8Array(e.buffer, T, e.buffer.byteLength - T));
    let I = 0;
    for (let _ = S; _ < T; _ += xt)
      if (e[_] === 71) {
        const R = !!(e[_ + 1] & 64), k = ef(e, _), A = (e[_ + 3] & 48) >> 4;
        let L;
        if (A > 1) {
          if (L = _ + 5 + e[_ + 4], L === _ + xt)
            continue;
        } else
          L = _ + 4;
        switch (k) {
          case c:
            R && (d && (s = Ri(d, this.logger)) && (this.readyVideoParser(a.segmentCodec), this.videoParser !== null && this.videoParser.parsePES(a, l, s, !1)), d = {
              data: [],
              size: 0
            }), d && (d.data.push(e.subarray(L, _ + xt)), d.size += _ + xt - L);
            break;
          case f:
            if (R) {
              if (m && (s = Ri(m, this.logger)))
                switch (o.segmentCodec) {
                  case "aac":
                    this.parseAACPES(o, s);
                    break;
                  case "mp3":
                    this.parseMPEGPES(o, s);
                    break;
                  case "ac3":
                    this.parseAC3PES(o, s);
                    break;
                }
              m = {
                data: [],
                size: 0
              };
            }
            m && (m.data.push(e.subarray(L, _ + xt)), m.size += _ + xt - L);
            break;
          case h:
            R && (p && (s = Ri(p, this.logger)) && this.parseID3PES(u, s), p = {
              data: [],
              size: 0
            }), p && (p.data.push(e.subarray(L, _ + xt)), p.size += _ + xt - L);
            break;
          case 0:
            R && (L += e[L] + 1), y = this._pmtId = A$(e, L);
            break;
          case y: {
            R && (L += e[L] + 1);
            const P = I$(e, L, this.typeSupported, r, this.observer, this.logger);
            c = P.videoPid, c > 0 && (a.pid = c, a.segmentCodec = P.segmentVideoCodec), f = P.audioPid, f > 0 && (o.pid = f, o.segmentCodec = P.segmentAudioCodec), h = P.id3Pid, h > 0 && (u.pid = h), g !== null && !b && (this.logger.warn(`MPEG-TS PMT found at ${_} after unknown PID '${g}'. Backtracking to sync byte @${S} to parse all TS packets.`), g = null, _ = S - 188), b = this.pmtParsed = !0;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            g = k;
            break;
        }
      } else
        I++;
    I > 0 && tf(this.observer, new Error(`Found ${I} TS packet/s that do not start with 0x47`), void 0, this.logger), a.pesData = d, o.pesData = m, u.pesData = p;
    const C = {
      audioTrack: o,
      videoTrack: a,
      id3Track: u,
      textTrack: l
    };
    return i && this.extractRemainingSamples(C), C;
  }
  flush() {
    const {
      remainderData: e
    } = this;
    this.remainderData = null;
    let n;
    return e ? n = this.demux(e, -1, !1, !0) : n = {
      videoTrack: this._videoTrack,
      audioTrack: this._audioTrack,
      id3Track: this._id3Track,
      textTrack: this._txtTrack
    }, this.extractRemainingSamples(n), this.sampleAes ? this.decrypt(n, this.sampleAes) : n;
  }
  extractRemainingSamples(e) {
    const {
      audioTrack: n,
      videoTrack: r,
      id3Track: i,
      textTrack: s
    } = e, a = r.pesData, o = n.pesData, u = i.pesData;
    let l;
    if (a && (l = Ri(a, this.logger)) ? (this.readyVideoParser(r.segmentCodec), this.videoParser !== null && (this.videoParser.parsePES(r, s, l, !0), r.pesData = null)) : r.pesData = a, o && (l = Ri(o, this.logger))) {
      switch (n.segmentCodec) {
        case "aac":
          this.parseAACPES(n, l);
          break;
        case "mp3":
          this.parseMPEGPES(n, l);
          break;
        case "ac3":
          this.parseAC3PES(n, l);
          break;
      }
      n.pesData = null;
    } else
      o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"), n.pesData = o;
    u && (l = Ri(u, this.logger)) ? (this.parseID3PES(i, l), i.pesData = null) : i.pesData = u;
  }
  demuxSampleAes(e, n, r) {
    const i = this.demux(e, r, !0, !this.config.progressive), s = this.sampleAes = new S$(this.observer, this.config, n);
    return this.decrypt(i, s);
  }
  readyVideoParser(e) {
    this.videoParser === null && (e === "avc" ? this.videoParser = new x$() : e === "hevc" && (this.videoParser = new v$()));
  }
  decrypt(e, n) {
    return new Promise((r) => {
      const {
        audioTrack: i,
        videoTrack: s
      } = e;
      i.samples && i.segmentCodec === "aac" ? n.decryptAacSamples(i.samples, 0, () => {
        s.samples ? n.decryptAvcSamples(s.samples, 0, 0, () => {
          r(e);
        }) : r(e);
      }) : s.samples && n.decryptAvcSamples(s.samples, 0, 0, () => {
        r(e);
      });
    });
  }
  destroy() {
    this.observer && this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;
  }
  parseAACPES(e, n) {
    let r = 0;
    const i = this.aacOverFlow;
    let s = n.data;
    if (i) {
      this.aacOverFlow = null;
      const d = i.missing, f = i.sample.unit.byteLength;
      if (d === -1)
        s = gn(i.sample.unit, s);
      else {
        const h = f - d;
        i.sample.unit.set(s.subarray(0, d), h), e.samples.push(i.sample), r = i.missing;
      }
    }
    let a, o;
    for (a = r, o = s.length; a < o - 1 && !Uu(s, a); a++)
      ;
    if (a !== r) {
      let d;
      const f = a < o - 1;
      if (f ? d = `AAC PES did not start with ADTS header,offset:${a}` : d = "No ADTS header found in AAC PES", tf(this.observer, new Error(d), f, this.logger), !f)
        return;
    }
    Hx(e, this.observer, s, a, this.audioCodec);
    let u;
    if (n.pts !== void 0)
      u = n.pts;
    else if (i) {
      const d = Vx(e.samplerate);
      u = i.sample.pts + d;
    } else {
      this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let l = 0, c;
    for (; a < o; )
      if (c = Gx(e, s, a, u, l), a += c.length, c.missing) {
        this.aacOverFlow = c;
        break;
      } else
        for (l++; a < o - 1 && !Uu(s, a); a++)
          ;
  }
  parseMPEGPES(e, n) {
    const r = n.data, i = r.length;
    let s = 0, a = 0;
    const o = n.pts;
    if (o === void 0) {
      this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    for (; a < i; )
      if (jx(r, a)) {
        const u = Wx(e, r, a, o, s);
        if (u)
          a += u.length, s++;
        else
          break;
      } else
        a++;
  }
  parseAC3PES(e, n) {
    {
      const r = n.data, i = n.pts;
      if (i === void 0) {
        this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const s = r.length;
      let a = 0, o = 0, u;
      for (; o < s && (u = Qx(e, r, o, i, a++)) > 0; )
        o += u;
    }
  }
  parseID3PES(e, n) {
    if (n.pts === void 0) {
      this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const r = Xe({}, n, {
      type: this._videoTrack ? un.emsg : un.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    e.samples.push(r);
  }
}
function ef(t, e) {
  return ((t[e + 1] & 31) << 8) + t[e + 2];
}
function A$(t, e) {
  return (t[e + 10] & 31) << 8 | t[e + 11];
}
function I$(t, e, n, r, i, s) {
  const a = {
    audioPid: -1,
    videoPid: -1,
    id3Pid: -1,
    segmentVideoCodec: "avc",
    segmentAudioCodec: "aac"
  }, o = (t[e + 1] & 15) << 8 | t[e + 2], u = e + 3 + o - 4, l = (t[e + 10] & 15) << 8 | t[e + 11];
  for (e += 12 + l; e < u; ) {
    const c = ef(t, e), d = (t[e + 3] & 15) << 8 | t[e + 4];
    switch (t[e]) {
      case 207:
        if (!r) {
          Ac("ADTS AAC", s);
          break;
        }
      case 15:
        a.audioPid === -1 && (a.audioPid = c);
        break;
      case 21:
        a.id3Pid === -1 && (a.id3Pid = c);
        break;
      case 219:
        if (!r) {
          Ac("H.264", s);
          break;
        }
      case 27:
        a.videoPid === -1 && (a.videoPid = c);
        break;
      case 3:
      case 4:
        !n.mpeg && !n.mp3 ? s.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = c, a.segmentAudioCodec = "mp3");
        break;
      case 193:
        if (!r) {
          Ac("AC-3", s);
          break;
        }
      case 129:
        n.ac3 ? a.audioPid === -1 && (a.audioPid = c, a.segmentAudioCodec = "ac3") : s.log("AC-3 audio found, not supported in this browser");
        break;
      case 6:
        if (a.audioPid === -1 && d > 0) {
          let f = e + 5, h = d;
          for (; h > 2; ) {
            switch (t[f]) {
              case 106:
                n.ac3 !== !0 ? s.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = c, a.segmentAudioCodec = "ac3");
                break;
            }
            const p = t[f + 1] + 2;
            f += p, h -= p;
          }
        }
        break;
      case 194:
      case 135:
        return tf(i, new Error("Unsupported EC-3 in M2TS found"), void 0, s), a;
      case 36:
        a.videoPid === -1 && (a.videoPid = c, a.segmentVideoCodec = "hevc", s.log("HEVC in M2TS found"));
        break;
    }
    e += d + 5;
  }
  return a;
}
function tf(t, e, n, r) {
  r.warn(`parsing error: ${e.message}`), t.emit(x.ERROR, x.ERROR, {
    type: be.MEDIA_ERROR,
    details: q.FRAG_PARSING_ERROR,
    fatal: !1,
    levelRetry: n,
    error: e,
    reason: e.message
  });
}
function Ac(t, e) {
  e.log(`${t} with AES-128-CBC encryption found in unencrypted stream`);
}
function Ri(t, e) {
  let n = 0, r, i, s, a, o;
  const u = t.data;
  if (!t || t.size === 0)
    return null;
  for (; u[0].length < 19 && u.length > 1; )
    u[0] = gn(u[0], u[1]), u.splice(1, 1);
  if (r = u[0], (r[0] << 16) + (r[1] << 8) + r[2] === 1) {
    if (i = (r[4] << 8) + r[5], i && i > t.size - 6)
      return null;
    const c = r[7];
    c & 192 && (a = (r[9] & 14) * 536870912 + // 1 << 29
    (r[10] & 255) * 4194304 + // 1 << 22
    (r[11] & 254) * 16384 + // 1 << 14
    (r[12] & 255) * 128 + // 1 << 7
    (r[13] & 254) / 2, c & 64 ? (o = (r[14] & 14) * 536870912 + // 1 << 29
    (r[15] & 255) * 4194304 + // 1 << 22
    (r[16] & 254) * 16384 + // 1 << 14
    (r[17] & 255) * 128 + // 1 << 7
    (r[18] & 254) / 2, a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`), a = o)) : o = a), s = r[8];
    let d = s + 9;
    if (t.size <= d)
      return null;
    t.size -= d;
    const f = new Uint8Array(t.size);
    for (let h = 0, m = u.length; h < m; h++) {
      r = u[h];
      let p = r.byteLength;
      if (d)
        if (d > p) {
          d -= p;
          continue;
        } else
          r = r.subarray(d), p -= d, d = 0;
      f.set(r, n), n += p;
    }
    return i && (i -= s + 3), {
      data: f,
      pts: a,
      dts: o,
      len: i
    };
  }
  return null;
}
class C$ {
  static getSilentFrame(e, n) {
    switch (e) {
      case "mp4a.40.2":
        if (n === 1)
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        if (n === 2)
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        if (n === 3)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        if (n === 4)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        if (n === 5)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        if (n === 6)
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        break;
      default:
        if (n === 1)
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (n === 2)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        if (n === 3)
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        break;
    }
  }
}
const xr = Math.pow(2, 32) - 1;
class z {
  static init() {
    z.types = {
      avc1: [],
      // codingname
      avcC: [],
      hvc1: [],
      hvcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let e;
    for (e in z.types)
      z.types.hasOwnProperty(e) && (z.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
    const n = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]), r = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    z.HDLR_TYPES = {
      video: n,
      audio: r
    };
    const i = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]), s = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    z.STTS = z.STSC = z.STCO = s, z.STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]), z.VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]), z.SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance
      0,
      0
      // reserved
    ]), z.STSD = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1
    ]);
    const a = new Uint8Array([105, 115, 111, 109]), o = new Uint8Array([97, 118, 99, 49]), u = new Uint8Array([0, 0, 0, 1]);
    z.FTYP = z.box(z.types.ftyp, a, u, a, o), z.DINF = z.box(z.types.dinf, z.box(z.types.dref, i));
  }
  static box(e, ...n) {
    let r = 8, i = n.length;
    const s = i;
    for (; i--; )
      r += n[i].byteLength;
    const a = new Uint8Array(r);
    for (a[0] = r >> 24 & 255, a[1] = r >> 16 & 255, a[2] = r >> 8 & 255, a[3] = r & 255, a.set(e, 4), i = 0, r = 8; i < s; i++)
      a.set(n[i], r), r += n[i].byteLength;
    return a;
  }
  static hdlr(e) {
    return z.box(z.types.hdlr, z.HDLR_TYPES[e]);
  }
  static mdat(e) {
    return z.box(z.types.mdat, e);
  }
  static mdhd(e, n) {
    n *= e;
    const r = Math.floor(n / (xr + 1)), i = Math.floor(n % (xr + 1));
    return z.box(z.types.mdhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]));
  }
  static mdia(e) {
    return z.box(z.types.mdia, z.mdhd(e.timescale || 0, e.duration || 0), z.hdlr(e.type), z.minf(e));
  }
  static mfhd(e) {
    return z.box(z.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      e >> 24,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
      // sequence_number
    ]));
  }
  static minf(e) {
    return e.type === "audio" ? z.box(z.types.minf, z.box(z.types.smhd, z.SMHD), z.DINF, z.stbl(e)) : z.box(z.types.minf, z.box(z.types.vmhd, z.VMHD), z.DINF, z.stbl(e));
  }
  static moof(e, n, r) {
    return z.box(z.types.moof, z.mfhd(e), z.traf(r, n));
  }
  static moov(e) {
    let n = e.length;
    const r = [];
    for (; n--; )
      r[n] = z.trak(e[n]);
    return z.box.apply(null, [z.types.moov, z.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(r).concat(z.mvex(e)));
  }
  static mvex(e) {
    let n = e.length;
    const r = [];
    for (; n--; )
      r[n] = z.trex(e[n]);
    return z.box.apply(null, [z.types.mvex, ...r]);
  }
  static mvhd(e, n) {
    n *= e;
    const r = Math.floor(n / (xr + 1)), i = Math.floor(n % (xr + 1)), s = new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      e >> 24 & 255,
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255,
      // timescale
      r >> 24,
      r >> 16 & 255,
      r >> 8 & 255,
      r & 255,
      i >> 24,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255,
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return z.box(z.types.mvhd, s);
  }
  static sdtp(e) {
    const n = e.samples || [], r = new Uint8Array(4 + n.length);
    let i, s;
    for (i = 0; i < n.length; i++)
      s = n[i].flags, r[i + 4] = s.dependsOn << 4 | s.isDependedOn << 2 | s.hasRedundancy;
    return z.box(z.types.sdtp, r);
  }
  static stbl(e) {
    return z.box(z.types.stbl, z.stsd(e), z.box(z.types.stts, z.STTS), z.box(z.types.stsc, z.STSC), z.box(z.types.stsz, z.STSZ), z.box(z.types.stco, z.STCO));
  }
  static avc1(e) {
    let n = [], r = [], i, s, a;
    for (i = 0; i < e.sps.length; i++)
      s = e.sps[i], a = s.byteLength, n.push(a >>> 8 & 255), n.push(a & 255), n = n.concat(Array.prototype.slice.call(s));
    for (i = 0; i < e.pps.length; i++)
      s = e.pps[i], a = s.byteLength, r.push(a >>> 8 & 255), r.push(a & 255), r = r.concat(Array.prototype.slice.call(s));
    const o = z.box(z.types.avcC, new Uint8Array([
      1,
      // version
      n[3],
      // profile
      n[4],
      // profile compat
      n[5],
      // level
      255,
      // lengthSizeMinusOne, hard-coded to 4 bytes
      224 | e.sps.length
      // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(n).concat([
      e.pps.length
      // numOfPictureParameterSets
    ]).concat(r))), u = e.width, l = e.height, c = e.pixelRatio[0], d = e.pixelRatio[1];
    return z.box(
      z.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        u >> 8 & 255,
        u & 255,
        // width
        l >> 8 & 255,
        l & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      o,
      z.box(z.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      z.box(z.types.pasp, new Uint8Array([
        c >> 24,
        // hSpacing
        c >> 16 & 255,
        c >> 8 & 255,
        c & 255,
        d >> 24,
        // vSpacing
        d >> 16 & 255,
        d >> 8 & 255,
        d & 255
      ]))
    );
  }
  static esds(e) {
    const n = e.config;
    return new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      3,
      // descriptor_type
      25,
      // length
      0,
      1,
      // es_id
      0,
      // stream_priority
      4,
      // descriptor_type
      17,
      // length
      64,
      // codec : mpeg4_audio
      21,
      // stream_type
      0,
      0,
      0,
      // buffer_size
      0,
      0,
      0,
      0,
      // maxBitrate
      0,
      0,
      0,
      0,
      // avgBitrate
      5,
      // descriptor_type
      2,
      // length
      ...n,
      6,
      1,
      2
      // GASpecificConfig)); // length + audio config descriptor
    ]);
  }
  static audioStsd(e) {
    const n = e.samplerate || 0;
    return new Uint8Array([
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      // reserved
      0,
      1,
      // data_reference_index
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      e.channelCount || 0,
      // channelcount
      0,
      16,
      // sampleSize:16bits
      0,
      0,
      0,
      0,
      // reserved2
      n >> 8 & 255,
      n & 255,
      //
      0,
      0
    ]);
  }
  static mp4a(e) {
    return z.box(z.types.mp4a, z.audioStsd(e), z.box(z.types.esds, z.esds(e)));
  }
  static mp3(e) {
    return z.box(z.types[".mp3"], z.audioStsd(e));
  }
  static ac3(e) {
    return z.box(z.types["ac-3"], z.audioStsd(e), z.box(z.types.dac3, e.config));
  }
  static stsd(e) {
    const {
      segmentCodec: n
    } = e;
    if (e.type === "audio") {
      if (n === "aac")
        return z.box(z.types.stsd, z.STSD, z.mp4a(e));
      if (n === "ac3" && e.config)
        return z.box(z.types.stsd, z.STSD, z.ac3(e));
      if (n === "mp3" && e.codec === "mp3")
        return z.box(z.types.stsd, z.STSD, z.mp3(e));
    } else if (e.pps && e.sps) {
      if (n === "avc")
        return z.box(z.types.stsd, z.STSD, z.avc1(e));
      if (n === "hevc" && e.vps)
        return z.box(z.types.stsd, z.STSD, z.hvc1(e));
    } else
      throw new Error("video track missing pps or sps");
    throw new Error(`unsupported ${e.type} segment codec (${n}/${e.codec})`);
  }
  static tkhd(e) {
    const n = e.id, r = (e.duration || 0) * (e.timescale || 0), i = e.width || 0, s = e.height || 0, a = Math.floor(r / (xr + 1)), o = Math.floor(r % (xr + 1));
    return z.box(z.types.tkhd, new Uint8Array([
      1,
      // version 1
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      // modification_time
      n >> 24 & 255,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      a >> 24,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255,
      o >> 24,
      o >> 16 & 255,
      o >> 8 & 255,
      o & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      0,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      i >> 8 & 255,
      i & 255,
      0,
      0,
      // width
      s >> 8 & 255,
      s & 255,
      0,
      0
      // height
    ]));
  }
  static traf(e, n) {
    const r = z.sdtp(e), i = e.id, s = Math.floor(n / (xr + 1)), a = Math.floor(n % (xr + 1));
    return z.box(
      z.types.traf,
      z.box(z.types.tfhd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        i >> 24,
        i >> 16 & 255,
        i >> 8 & 255,
        i & 255
        // track_ID
      ])),
      z.box(z.types.tfdt, new Uint8Array([
        1,
        // version 1
        0,
        0,
        0,
        // flags
        s >> 24,
        s >> 16 & 255,
        s >> 8 & 255,
        s & 255,
        a >> 24,
        a >> 16 & 255,
        a >> 8 & 255,
        a & 255
      ])),
      z.trun(e, r.length + 16 + // tfhd
      20 + // tfdt
      8 + // traf header
      16 + // mfhd
      8 + // moof header
      8),
      // mdat header
      r
    );
  }
  /**
   * Generate a track box.
   * @param track a track definition
   */
  static trak(e) {
    return e.duration = e.duration || 4294967295, z.box(z.types.trak, z.tkhd(e), z.mdia(e));
  }
  static trex(e) {
    const n = e.id;
    return z.box(z.types.trex, new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      n >> 24,
      n >> 16 & 255,
      n >> 8 & 255,
      n & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]));
  }
  static trun(e, n) {
    const r = e.samples || [], i = r.length, s = 12 + 16 * i, a = new Uint8Array(s);
    let o, u, l, c, d, f;
    for (n += 8 + s, a.set([
      e.type === "video" ? 1 : 0,
      // version 1 for video with signed-int sample_composition_time_offset
      0,
      15,
      1,
      // flags
      i >>> 24 & 255,
      i >>> 16 & 255,
      i >>> 8 & 255,
      i & 255,
      // sample_count
      n >>> 24 & 255,
      n >>> 16 & 255,
      n >>> 8 & 255,
      n & 255
      // data_offset
    ], 0), o = 0; o < i; o++)
      u = r[o], l = u.duration, c = u.size, d = u.flags, f = u.cts, a.set([
        l >>> 24 & 255,
        l >>> 16 & 255,
        l >>> 8 & 255,
        l & 255,
        // sample_duration
        c >>> 24 & 255,
        c >>> 16 & 255,
        c >>> 8 & 255,
        c & 255,
        // sample_size
        d.isLeading << 2 | d.dependsOn,
        d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync,
        d.degradPrio & 61440,
        d.degradPrio & 15,
        // sample_flags
        f >>> 24 & 255,
        f >>> 16 & 255,
        f >>> 8 & 255,
        f & 255
        // sample_composition_time_offset
      ], 12 + 16 * o);
    return z.box(z.types.trun, a);
  }
  static initSegment(e) {
    z.types || z.init();
    const n = z.moov(e);
    return gn(z.FTYP, n);
  }
  static hvc1(e) {
    const n = e.params, r = [e.vps, e.sps, e.pps], i = 4, s = new Uint8Array([1, n.general_profile_space << 6 | (n.general_tier_flag ? 32 : 0) | n.general_profile_idc, n.general_profile_compatibility_flags[0], n.general_profile_compatibility_flags[1], n.general_profile_compatibility_flags[2], n.general_profile_compatibility_flags[3], n.general_constraint_indicator_flags[0], n.general_constraint_indicator_flags[1], n.general_constraint_indicator_flags[2], n.general_constraint_indicator_flags[3], n.general_constraint_indicator_flags[4], n.general_constraint_indicator_flags[5], n.general_level_idc, 240 | n.min_spatial_segmentation_idc >> 8, 255 & n.min_spatial_segmentation_idc, 252 | n.parallelismType, 252 | n.chroma_format_idc, 248 | n.bit_depth_luma_minus8, 248 | n.bit_depth_chroma_minus8, 0, parseInt(n.frame_rate.fps), i - 1 | n.temporal_id_nested << 2 | n.num_temporal_layers << 3 | (n.frame_rate.fixed ? 64 : 0), r.length]);
    let a = s.length;
    for (let m = 0; m < r.length; m += 1) {
      a += 3;
      for (let p = 0; p < r[m].length; p += 1)
        a += 2 + r[m][p].length;
    }
    const o = new Uint8Array(a);
    o.set(s, 0), a = s.length;
    const u = r.length - 1;
    for (let m = 0; m < r.length; m += 1) {
      o.set(new Uint8Array([32 + m | (m === u ? 128 : 0), 0, r[m].length]), a), a += 3;
      for (let p = 0; p < r[m].length; p += 1)
        o.set(new Uint8Array([r[m][p].length >> 8, r[m][p].length & 255]), a), a += 2, o.set(r[m][p], a), a += r[m][p].length;
    }
    const l = z.box(z.types.hvcC, o), c = e.width, d = e.height, f = e.pixelRatio[0], h = e.pixelRatio[1];
    return z.box(
      z.types.hvc1,
      new Uint8Array([
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        c >> 8 & 255,
        c & 255,
        // width
        d >> 8 & 255,
        d & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        18,
        100,
        97,
        105,
        108,
        // dailymotion/hls.js
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
      ]),
      // pre_defined = -1
      l,
      z.box(z.types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
      ])),
      // avgBitrate
      z.box(z.types.pasp, new Uint8Array([
        f >> 24,
        // hSpacing
        f >> 16 & 255,
        f >> 8 & 255,
        f & 255,
        h >> 24,
        // vSpacing
        h >> 16 & 255,
        h >> 8 & 255,
        h & 255
      ]))
    );
  }
}
z.types = void 0;
z.HDLR_TYPES = void 0;
z.STTS = void 0;
z.STSC = void 0;
z.STCO = void 0;
z.STSZ = void 0;
z.VMHD = void 0;
z.SMHD = void 0;
z.STSD = void 0;
z.FTYP = void 0;
z.DINF = void 0;
const Jx = 9e4;
function Jh(t, e, n = 1, r = !1) {
  const i = t * e * n;
  return r ? Math.round(i) : i;
}
function L$(t, e, n = 1, r = !1) {
  return Jh(t, e, 1 / n, r);
}
function Us(t, e = !1) {
  return Jh(t, 1e3, 1 / Jx, e);
}
function _$(t, e = 1) {
  return Jh(t, Jx, 1 / e);
}
function Rg(t) {
  const {
    baseTime: e,
    timescale: n,
    trackId: r
  } = t;
  return `${e / n} (${e}/${n}) trackId: ${r}`;
}
const R$ = 10 * 1e3, w$ = 1024, k$ = 1152, D$ = 1536;
let wi = null, Ic = null;
function wg(t, e, n, r) {
  return {
    duration: e,
    size: n,
    cts: r,
    flags: {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: t ? 2 : 1,
      isNonSync: t ? 0 : 1
    }
  };
}
class tu extends En {
  constructor(e, n, r, i) {
    if (super("mp4-remuxer", i), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = n, this.typeSupported = r, this.ISGenerated = !1, wi === null) {
      const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
      wi = a ? parseInt(a[1]) : 0;
    }
    if (Ic === null) {
      const s = navigator.userAgent.match(/Safari\/(\d+)/i);
      Ic = s ? parseInt(s[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(e) {
    const n = this._initPTS;
    (!n || !e || e.trackId !== n.trackId || e.baseTime !== n.baseTime || e.timescale !== n.timescale) && this.log(`Reset initPTS: ${n && Rg(n)} > ${e && Rg(e)}`), this._initPTS = this._initDTS = e;
  }
  resetNextTimestamp() {
    this.log("reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;
  }
  resetInitSegment() {
    this.log("ISGenerated flag reset"), this.ISGenerated = !1, this.videoTrackConfig = void 0;
  }
  getVideoStartPts(e) {
    let n = !1;
    const r = e[0].pts, i = e.reduce((s, a) => {
      let o = a.pts, u = o - s;
      return u < -4294967296 && (n = !0, o = on(o, r), u = o - s), u > 0 ? s : o;
    }, r);
    return n && this.debug("PTS rollover detected"), i;
  }
  remux(e, n, r, i, s, a, o, u) {
    let l, c, d, f, h, m, p = s, g = s;
    const b = e.pid > -1, y = n.pid > -1, T = n.samples.length, S = e.samples.length > 0, I = o && T > 0 || T > 1;
    if ((!b || S) && (!y || I) || this.ISGenerated || o) {
      if (this.ISGenerated) {
        var _, R, k, A;
        const G = this.videoTrackConfig;
        (G && (n.width !== G.width || n.height !== G.height || ((_ = n.pixelRatio) == null ? void 0 : _[0]) !== ((R = G.pixelRatio) == null ? void 0 : R[0]) || ((k = n.pixelRatio) == null ? void 0 : k[1]) !== ((A = G.pixelRatio) == null ? void 0 : A[1])) || !G && I || this.nextAudioTs === null && S) && this.resetInitSegment();
      }
      this.ISGenerated || (d = this.generateIS(e, n, s, a));
      const L = this.isVideoContiguous;
      let P = -1, $;
      if (I && (P = P$(n.samples), !L && this.config.forceKeyFrameOnDiscontinuity))
        if (m = !0, P > 0) {
          this.warn(`Dropped ${P} out of ${T} video samples due to a missing keyframe`);
          const G = this.getVideoStartPts(n.samples);
          n.samples = n.samples.slice(P), n.dropped += P, g += (n.samples[0].pts - G) / n.inputTimeScale, $ = g;
        } else P === -1 && (this.warn(`No keyframe found out of ${T} video samples`), m = !1);
      if (this.ISGenerated) {
        if (S && I) {
          const G = this.getVideoStartPts(n.samples), U = (on(e.samples[0].pts, G) - G) / n.inputTimeScale;
          p += Math.max(0, U), g += Math.max(0, -U);
        }
        if (S) {
          if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"), d = this.generateIS(e, n, s, a)), c = this.remuxAudio(e, p, this.isAudioContiguous, a, y || I || u === pe.AUDIO ? g : void 0), I) {
            const G = c ? c.endPTS - c.startPTS : 0;
            n.inputTimeScale || (this.warn("regenerate InitSegment as video detected"), d = this.generateIS(e, n, s, a)), l = this.remuxVideo(n, g, L, G);
          }
        } else I && (l = this.remuxVideo(n, g, L, 0));
        l && (l.firstKeyFrame = P, l.independent = P !== -1, l.firstKeyFramePTS = $);
      }
    }
    return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (h = ev(r, s, this._initPTS, this._initDTS)), i.samples.length && (f = tv(i, s, this._initPTS))), {
      audio: c,
      video: l,
      initSegment: d,
      independent: m,
      text: f,
      id3: h
    };
  }
  computeInitPts(e, n, r, i) {
    const s = Math.round(r * n);
    let a = on(e, s);
    if (a < s + n)
      for (this.log(`Adjusting PTS for rollover in timeline near ${(s - a) / n} ${i}`); a < s + n; )
        a += 8589934592;
    return a - s;
  }
  generateIS(e, n, r, i) {
    const s = e.samples, a = n.samples, o = this.typeSupported, u = {}, l = this._initPTS;
    let c = !l || i, d = "audio/mp4", f, h, m, p = -1;
    if (c && (f = h = 1 / 0), e.config && s.length) {
      switch (e.timescale = e.samplerate, e.segmentCodec) {
        case "mp3":
          o.mpeg ? (d = "audio/mpeg", e.codec = "") : o.mp3 && (e.codec = "mp3");
          break;
        case "ac3":
          e.codec = "ac-3";
          break;
      }
      u.audio = {
        id: "audio",
        container: d,
        codec: e.codec,
        initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : z.initSegment([e]),
        metadata: {
          channelCount: e.channelCount
        }
      }, c && (p = e.id, m = e.inputTimeScale, !l || m !== l.timescale ? f = h = this.computeInitPts(s[0].pts, m, r, "audio") : c = !1);
    }
    if (n.sps && n.pps && a.length) {
      if (n.timescale = n.inputTimeScale, u.video = {
        id: "main",
        container: "video/mp4",
        codec: n.codec,
        initSegment: z.initSegment([n]),
        metadata: {
          width: n.width,
          height: n.height
        }
      }, c)
        if (p = n.id, m = n.inputTimeScale, !l || m !== l.timescale) {
          const g = this.getVideoStartPts(a), b = on(a[0].dts, g), y = this.computeInitPts(b, m, r, "video"), T = this.computeInitPts(g, m, r, "video");
          h = Math.min(h, y), f = Math.min(f, T);
        } else
          c = !1;
      this.videoTrackConfig = {
        width: n.width,
        height: n.height,
        pixelRatio: n.pixelRatio
      };
    }
    if (Object.keys(u).length)
      return this.ISGenerated = !0, c ? (l && this.warn(`Timestamps at playlist time: ${i ? "" : "~"}${r} ${f / m} != initPTS: ${l.baseTime / l.timescale} (${l.baseTime}/${l.timescale}) trackId: ${l.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${f / m} (${f}/${m}) trackId: ${p}`), this._initPTS = {
        baseTime: f,
        timescale: m,
        trackId: p
      }, this._initDTS = {
        baseTime: h,
        timescale: m,
        trackId: p
      }) : f = m = void 0, {
        tracks: u,
        initPTS: f,
        timescale: m,
        trackId: p
      };
  }
  remuxVideo(e, n, r, i) {
    const s = e.inputTimeScale, a = e.samples, o = [], u = a.length, l = this._initPTS, c = l.baseTime * s / l.timescale;
    let d = this.nextVideoTs, f = 8, h = this.videoSampleDuration, m, p, g = Number.POSITIVE_INFINITY, b = Number.NEGATIVE_INFINITY, y = !1;
    if (!r || d === null) {
      const Y = c + n * s, J = a[0].pts - on(a[0].dts, a[0].pts);
      wi && d !== null && Math.abs(Y - J - (d + c)) < 15e3 ? r = !0 : d = Y - J - c;
    }
    const T = d + c;
    for (let Y = 0; Y < u; Y++) {
      const J = a[Y];
      J.pts = on(J.pts, T), J.dts = on(J.dts, T), J.dts < a[Y > 0 ? Y - 1 : Y].dts && (y = !0);
    }
    y && a.sort(function(Y, J) {
      const D = Y.dts - J.dts, te = Y.pts - J.pts;
      return D || te;
    }), m = a[0].dts, p = a[a.length - 1].dts;
    const S = p - m, I = S ? Math.round(S / (u - 1)) : h || e.inputTimeScale / 30;
    if (r) {
      const Y = m - T, J = Y > I, D = Y < -1;
      if ((J || D) && (J ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Us(Y, !0)} ms (${Y}dts) hole between fragments detected at ${n.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Us(-Y, !0)} ms (${Y}dts) overlapping between fragments detected at ${n.toFixed(3)}`), !D || T >= a[0].pts || wi)) {
        m = T;
        const te = a[0].pts - Y;
        if (J)
          a[0].dts = m, a[0].pts = te;
        else {
          let he = !0;
          for (let ie = 0; ie < a.length && !(a[ie].dts > te && he); ie++) {
            const X = a[ie].pts;
            if (a[ie].dts -= Y, a[ie].pts -= Y, ie < a.length - 1) {
              const fe = a[ie + 1].pts, Te = a[ie].pts, me = fe <= Te, ye = fe <= X;
              he = me == ye;
            }
          }
        }
        this.log(`Video: Initial PTS/DTS adjusted: ${Us(te, !0)}/${Us(m, !0)}, delta: ${Us(Y, !0)} ms`);
      }
    }
    m = Math.max(0, m);
    let C = 0, _ = 0, R = m;
    for (let Y = 0; Y < u; Y++) {
      const J = a[Y], D = J.units, te = D.length;
      let he = 0;
      for (let ie = 0; ie < te; ie++)
        he += D[ie].data.length;
      _ += he, C += te, J.length = he, J.dts < R ? (J.dts = R, R += I / 4 | 0 || 1) : R = J.dts, g = Math.min(J.pts, g), b = Math.max(J.pts, b);
    }
    p = a[u - 1].dts;
    const k = _ + 4 * C + 8;
    let A;
    try {
      A = new Uint8Array(k);
    } catch (Y) {
      this.observer.emit(x.ERROR, x.ERROR, {
        type: be.MUX_ERROR,
        details: q.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: Y,
        bytes: k,
        reason: `fail allocating video mdat ${k}`
      });
      return;
    }
    const L = new DataView(A.buffer);
    L.setUint32(0, k), A.set(z.types.mdat, 4);
    let P = !1, $ = Number.POSITIVE_INFINITY, G = Number.POSITIVE_INFINITY, N = Number.NEGATIVE_INFINITY, U = Number.NEGATIVE_INFINITY;
    for (let Y = 0; Y < u; Y++) {
      const J = a[Y], D = J.units;
      let te = 0;
      for (let X = 0, fe = D.length; X < fe; X++) {
        const Te = D[X], me = Te.data, ye = Te.data.byteLength;
        L.setUint32(f, ye), f += 4, A.set(me, f), f += ye, te += 4 + ye;
      }
      let he;
      if (Y < u - 1)
        h = a[Y + 1].dts - J.dts, he = a[Y + 1].pts - J.pts;
      else {
        const X = this.config, fe = Y > 0 ? J.dts - a[Y - 1].dts : I;
        if (he = Y > 0 ? J.pts - a[Y - 1].pts : I, X.stretchShortVideoTrack && this.nextAudioTs !== null) {
          const Te = Math.floor(X.maxBufferHole * s), me = (i ? g + i * s : this.nextAudioTs + c) - J.pts;
          me > Te ? (h = me - fe, h < 0 ? h = fe : P = !0, this.log(`It is approximately ${me / 90} ms to the next segment; using duration ${h / 90} ms for the last video frame.`)) : h = fe;
        } else
          h = fe;
      }
      const ie = Math.round(J.pts - J.dts);
      $ = Math.min($, h), N = Math.max(N, h), G = Math.min(G, he), U = Math.max(U, he), o.push(wg(J.key, h, te, ie));
    }
    if (o.length) {
      if (wi) {
        if (wi < 70) {
          const Y = o[0].flags;
          Y.dependsOn = 2, Y.isNonSync = 0;
        }
      } else if (Ic && U - G < N - $ && I / N < 0.025 && o[0].cts === 0) {
        this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
        let Y = m;
        for (let J = 0, D = o.length; J < D; J++) {
          const te = Y + o[J].duration, he = Y + o[J].cts;
          if (J < D - 1) {
            const ie = te + o[J + 1].cts;
            o[J].duration = ie - he;
          } else
            o[J].duration = J ? o[J - 1].duration : I;
          o[J].cts = 0, Y = te;
        }
      }
    }
    h = P || !h ? I : h;
    const B = p + h;
    this.nextVideoTs = d = B - c, this.videoSampleDuration = h, this.isVideoContiguous = !0;
    const w = {
      data1: z.moof(e.sequenceNumber++, m, Xe(e, {
        samples: o
      })),
      data2: A,
      startPTS: (g - c) / s,
      endPTS: (b + h - c) / s,
      startDTS: (m - c) / s,
      endDTS: d / s,
      type: "video",
      hasAudio: !1,
      hasVideo: !0,
      nb: o.length,
      dropped: e.dropped
    };
    return e.samples = [], e.dropped = 0, w;
  }
  getSamplesPerFrame(e) {
    switch (e.segmentCodec) {
      case "mp3":
        return k$;
      case "ac3":
        return D$;
      default:
        return w$;
    }
  }
  remuxAudio(e, n, r, i, s) {
    const a = e.inputTimeScale, o = e.samplerate ? e.samplerate : a, u = a / o, l = this.getSamplesPerFrame(e), c = l * u, d = this._initPTS, f = e.segmentCodec === "mp3" && this.typeSupported.mpeg, h = [], m = s !== void 0;
    let p = e.samples, g = f ? 0 : 8, b = this.nextAudioTs || -1;
    const y = d.baseTime * a / d.timescale, T = y + n * a;
    if (this.isAudioContiguous = r = r || p.length && b > 0 && (i && Math.abs(T - (b + y)) < 9e3 || Math.abs(on(p[0].pts, T) - (b + y)) < 20 * c), p.forEach(function(U) {
      U.pts = on(U.pts, T);
    }), !r || b < 0) {
      const U = p.length;
      if (p = p.filter((B) => B.pts >= 0), U !== p.length && this.warn(`Removed ${p.length - U} of ${U} samples (initPTS ${y} / ${a})`), !p.length)
        return;
      s === 0 ? b = 0 : i && !m ? b = Math.max(0, T - y) : b = p[0].pts - y;
    }
    if (e.segmentCodec === "aac") {
      const U = this.config.maxAudioFramesDrift;
      for (let B = 0, V = b + y; B < p.length; B++) {
        const K = p[B], w = K.pts, Y = w - V, J = Math.abs(1e3 * Y / a);
        if (Y <= -U * c && m)
          B === 0 && (this.warn(`Audio frame @ ${(w / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * Y / a)} ms.`), this.nextAudioTs = b = w - y, V = w);
        else if (Y >= U * c && J < R$ && m) {
          let D = Math.round(Y / c);
          for (V = w - D * c; V < 0 && D && c; )
            D--, V += c;
          B === 0 && (this.nextAudioTs = b = V - y), this.warn(`Injecting ${D} audio frames @ ${((V - y) / a).toFixed(3)}s due to ${Math.round(1e3 * Y / a)} ms gap.`);
          for (let te = 0; te < D; te++) {
            let he = C$.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
            he || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), he = K.unit.subarray()), p.splice(B, 0, {
              unit: he,
              pts: V
            }), V += c, B++;
          }
        }
        K.pts = V, V += c;
      }
    }
    let S = null, I = null, C, _ = 0, R = p.length;
    for (; R--; )
      _ += p[R].unit.byteLength;
    for (let U = 0, B = p.length; U < B; U++) {
      const V = p[U], K = V.unit;
      let w = V.pts;
      if (I !== null) {
        const J = h[U - 1];
        J.duration = Math.round((w - I) / u);
      } else if (r && e.segmentCodec === "aac" && (w = b + y), S = w, _ > 0) {
        _ += g;
        try {
          C = new Uint8Array(_);
        } catch (J) {
          this.observer.emit(x.ERROR, x.ERROR, {
            type: be.MUX_ERROR,
            details: q.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: J,
            bytes: _,
            reason: `fail allocating audio mdat ${_}`
          });
          return;
        }
        f || (new DataView(C.buffer).setUint32(0, _), C.set(z.types.mdat, 4));
      } else
        return;
      C.set(K, g);
      const Y = K.byteLength;
      g += Y, h.push(wg(!0, l, Y, 0)), I = w;
    }
    const k = h.length;
    if (!k)
      return;
    const A = h[h.length - 1];
    b = I - y, this.nextAudioTs = b + u * A.duration;
    const L = f ? new Uint8Array(0) : z.moof(e.sequenceNumber++, S / u, Xe({}, e, {
      samples: h
    }));
    e.samples = [];
    const P = (S - y) / a, $ = b / a, N = {
      data1: L,
      data2: C,
      startPTS: P,
      endPTS: $,
      startDTS: P,
      endDTS: $,
      type: "audio",
      hasAudio: !0,
      hasVideo: !1,
      nb: k
    };
    return this.isAudioContiguous = !0, N;
  }
}
function on(t, e) {
  let n;
  if (e === null)
    return t;
  for (e < t ? n = -8589934592 : n = 8589934592; Math.abs(t - e) > 4294967296; )
    t += n;
  return t;
}
function P$(t) {
  for (let e = 0; e < t.length; e++)
    if (t[e].key)
      return e;
  return -1;
}
function ev(t, e, n, r) {
  const i = t.samples.length;
  if (!i)
    return;
  const s = t.inputTimeScale;
  for (let o = 0; o < i; o++) {
    const u = t.samples[o];
    u.pts = on(u.pts - n.baseTime * s / n.timescale, e * s) / s, u.dts = on(u.dts - r.baseTime * s / r.timescale, e * s) / s;
  }
  const a = t.samples;
  return t.samples = [], {
    samples: a
  };
}
function tv(t, e, n) {
  const r = t.samples.length;
  if (!r)
    return;
  const i = t.inputTimeScale;
  for (let a = 0; a < r; a++) {
    const o = t.samples[a];
    o.pts = on(o.pts - n.baseTime * i / n.timescale, e * i) / i;
  }
  t.samples.sort((a, o) => a.pts - o.pts);
  const s = t.samples;
  return t.samples = [], {
    samples: s
  };
}
class O$ extends En {
  constructor(e, n, r, i) {
    super("passthrough-remuxer", i), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;
  }
  destroy() {
  }
  resetTimeStamp(e) {
    this.lastEndTime = null;
    const n = this.initPTS;
    n && e && n.baseTime === e.baseTime && n.timescale === e.timescale || (this.initPTS = e);
  }
  resetNextTimestamp() {
    this.isVideoContiguous = !1, this.lastEndTime = null;
  }
  resetInitSegment(e, n, r, i) {
    this.audioCodec = n, this.videoCodec = r, this.generateInitSegment(e, i), this.emitInitSegment = !0;
  }
  generateInitSegment(e, n) {
    let {
      audioCodec: r,
      videoCodec: i
    } = this;
    if (!(e != null && e.byteLength)) {
      this.initTracks = void 0, this.initData = void 0;
      return;
    }
    const {
      audio: s,
      video: a
    } = this.initData = ox(e);
    if (n)
      SB(e, n);
    else {
      const u = s || a;
      u != null && u.encrypted && this.warn(`Init segment with encrypted track with has no key ("${u.codec}")!`);
    }
    s && (r = kg(s, Qe.AUDIO, this)), a && (i = kg(a, Qe.VIDEO, this));
    const o = {};
    s && a ? o.audiovideo = {
      container: "video/mp4",
      codec: r + "," + i,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : s ? o.audio = {
      container: "audio/mp4",
      codec: r,
      encrypted: s.encrypted,
      initSegment: e,
      id: "audio"
    } : a ? o.video = {
      container: "video/mp4",
      codec: i,
      supplemental: a.supplemental,
      encrypted: a.encrypted,
      initSegment: e,
      id: "main"
    } : this.warn("initSegment does not contain moov or trak boxes."), this.initTracks = o;
  }
  remux(e, n, r, i, s, a) {
    var o, u;
    let {
      initPTS: l,
      lastEndTime: c
    } = this;
    const d = {
      audio: void 0,
      video: void 0,
      text: i,
      id3: r,
      initSegment: void 0
    };
    de(c) || (c = this.lastEndTime = s || 0);
    const f = n.samples;
    if (!f.length)
      return d;
    const h = {
      initPTS: void 0,
      timescale: void 0,
      trackId: void 0
    };
    let m = this.initData;
    if ((o = m) != null && o.length || (this.generateInitSegment(f), m = this.initData), !((u = m) != null && u.length))
      return this.warn("Failed to generate initSegment."), d;
    this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
    const p = vB(f, m, this), g = m.audio ? p[m.audio.id] : null, b = m.video ? p[m.video.id] : null, y = Ro(b, 1 / 0), T = Ro(g, 1 / 0), S = Ro(b, 0, !0), I = Ro(g, 0, !0);
    let C = s, _ = 0;
    const R = g && (!b || !l && T < y || l && l.trackId === m.audio.id), k = R ? g : b;
    if (k) {
      const V = k.timescale, K = k.start - s * V, w = R ? m.audio.id : m.video.id;
      C = k.start / V, _ = R ? I - T : S - y, (a || !l) && (N$(l, C, s, _) || V !== l.timescale) && (l && this.warn(`Timestamps at playlist time: ${a ? "" : "~"}${s} ${K / V} != initPTS: ${l.baseTime / l.timescale} (${l.baseTime}/${l.timescale}) trackId: ${l.trackId}`), this.log(`Found initPTS at playlist time: ${s} offset: ${C - s} (${K}/${V}) trackId: ${w}`), l = null, h.initPTS = K, h.timescale = V, h.trackId = w);
    } else
      this.warn(`No audio or video samples found for initPTS at playlist time: ${s}`);
    l ? (h.initPTS = l.baseTime, h.timescale = l.timescale, h.trackId = l.trackId) : ((!h.timescale || h.trackId === void 0 || h.initPTS === void 0) && (this.warn("Could not set initPTS"), h.initPTS = C, h.timescale = 1, h.trackId = -1), this.initPTS = l = {
      baseTime: h.initPTS,
      timescale: h.timescale,
      trackId: h.trackId
    });
    const A = C - l.baseTime / l.timescale, L = A + _;
    _ > 0 ? this.lastEndTime = L : (this.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
    const P = !!m.audio, $ = !!m.video;
    let G = "";
    P && (G += "audio"), $ && (G += "video");
    const N = (m.audio ? m.audio.encrypted : !1) || (m.video ? m.video.encrypted : !1), U = {
      data1: f,
      startPTS: A,
      startDTS: A,
      endPTS: L,
      endDTS: L,
      type: G,
      hasAudio: P,
      hasVideo: $,
      nb: 1,
      dropped: 0,
      encrypted: N
    };
    d.audio = P && !$ ? U : void 0, d.video = $ ? U : void 0;
    const B = b == null ? void 0 : b.sampleCount;
    if (B) {
      const V = b.keyFrameIndex, K = V !== -1;
      U.nb = B, U.dropped = V === 0 || this.isVideoContiguous ? 0 : K ? V : B, U.independent = K, U.firstKeyFrame = V, K && b.keyFrameStart && (U.firstKeyFramePTS = (b.keyFrameStart - l.baseTime) / l.timescale), this.isVideoContiguous || (d.independent = K), this.isVideoContiguous || (this.isVideoContiguous = K), U.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${V}/${B} dropped: ${U.dropped} start: ${U.firstKeyFramePTS || "NA"}`);
    }
    return d.initSegment = h, d.id3 = ev(r, s, l, l), i.samples.length && (d.text = tv(i, s, l)), d;
  }
}
function Ro(t, e, n = !1) {
  return (t == null ? void 0 : t.start) !== void 0 ? (t.start + (n ? t.duration : 0)) / t.timescale : e;
}
function N$(t, e, n, r) {
  if (t === null)
    return !0;
  const i = Math.max(r, 1), s = e - t.baseTime / t.timescale;
  return Math.abs(s - n) > i;
}
function kg(t, e, n) {
  const r = t.codec;
  return r && r.length > 4 ? r : e === Qe.AUDIO ? r === "ec-3" || r === "ac-3" || r === "alac" ? r : r === "fLaC" || r === "Opus" ? Du(r, !1) : (n.warn(`Unhandled audio codec "${r}" in mp4 MAP`), r || "mp4a") : (n.warn(`Unhandled video codec "${r}" in mp4 MAP`), r || "avc1");
}
let ur;
try {
  ur = self.performance.now.bind(self.performance);
} catch {
  ur = Date.now;
}
const nu = [{
  demux: T$,
  remux: O$
}, {
  demux: _r,
  remux: tu
}, {
  demux: g$,
  remux: tu
}, {
  demux: E$,
  remux: tu
}];
nu.splice(2, 0, {
  demux: b$,
  remux: tu
});
class Dg {
  constructor(e, n, r, i, s, a) {
    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = n, this.config = r, this.id = s, this.logger = a;
  }
  configure(e) {
    this.transmuxConfig = e, this.decrypter && this.decrypter.reset();
  }
  push(e, n, r, i) {
    const s = r.transmuxing;
    s.executeStart = ur();
    let a = new Uint8Array(e);
    const {
      currentTransmuxState: o,
      transmuxConfig: u
    } = this;
    i && (this.currentTransmuxState = i);
    const {
      contiguous: l,
      discontinuity: c,
      trackSwitch: d,
      accurateTimeOffset: f,
      timeOffset: h,
      initSegmentChange: m
    } = i || o, {
      audioCodec: p,
      videoCodec: g,
      defaultInitPts: b,
      duration: y,
      initSegmentData: T
    } = u, S = M$(a, n);
    if (S && Yi(S.method)) {
      const R = this.getDecrypter(), k = zh(S.method);
      if (R.isSync()) {
        let A = R.softwareDecrypt(a, S.key.buffer, S.iv.buffer, k);
        if (r.part > -1) {
          const P = R.flush();
          A = P && P.buffer;
        }
        if (!A)
          return s.executeEnd = ur(), Cc(r);
        a = new Uint8Array(A);
      } else
        return this.asyncResult = !0, this.decryptionPromise = R.webCryptoDecrypt(a, S.key.buffer, S.iv.buffer, k).then((A) => {
          const L = this.push(A, null, r);
          return this.decryptionPromise = null, L;
        }), this.decryptionPromise;
    }
    const I = this.needsProbing(c, d);
    if (I) {
      const R = this.configureTransmuxer(a);
      if (R)
        return this.logger.warn(`[transmuxer] ${R.message}`), this.observer.emit(x.ERROR, x.ERROR, {
          type: be.MEDIA_ERROR,
          details: q.FRAG_PARSING_ERROR,
          fatal: !1,
          error: R,
          reason: R.message
        }), s.executeEnd = ur(), Cc(r);
    }
    (c || d || m || I) && this.resetInitSegment(T, p, g, y, n), (c || m || I) && this.resetInitialTimestamp(b), l || this.resetContiguity();
    const C = this.transmux(a, S, h, f, r);
    this.asyncResult = _a(C);
    const _ = this.currentTransmuxState;
    return _.contiguous = !0, _.discontinuity = !1, _.trackSwitch = !1, s.executeEnd = ur(), C;
  }
  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)
  flush(e) {
    const n = e.transmuxing;
    n.executeStart = ur();
    const {
      decrypter: r,
      currentTransmuxState: i,
      decryptionPromise: s
    } = this;
    if (s)
      return this.asyncResult = !0, s.then(() => this.flush(e));
    const a = [], {
      timeOffset: o
    } = i;
    if (r) {
      const d = r.flush();
      d && a.push(this.push(d.buffer, null, e));
    }
    const {
      demuxer: u,
      remuxer: l
    } = this;
    if (!u || !l) {
      n.executeEnd = ur();
      const d = [Cc(e)];
      return this.asyncResult ? Promise.resolve(d) : d;
    }
    const c = u.flush(o);
    return _a(c) ? (this.asyncResult = !0, c.then((d) => (this.flushRemux(a, d, e), a))) : (this.flushRemux(a, c, e), this.asyncResult ? Promise.resolve(a) : a);
  }
  flushRemux(e, n, r) {
    const {
      audioTrack: i,
      videoTrack: s,
      id3Track: a,
      textTrack: o
    } = n, {
      accurateTimeOffset: u,
      timeOffset: l
    } = this.currentTransmuxState;
    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${r.sn}${r.part > -1 ? " part: " + r.part : ""} of ${this.id === pe.MAIN ? "level" : "track"} ${r.level}`);
    const c = this.remuxer.remux(i, s, a, o, l, u, !0, this.id);
    e.push({
      remuxResult: c,
      chunkMeta: r
    }), r.transmuxing.executeEnd = ur();
  }
  resetInitialTimestamp(e) {
    const {
      demuxer: n,
      remuxer: r
    } = this;
    !n || !r || (n.resetTimeStamp(e), r.resetTimeStamp(e));
  }
  resetContiguity() {
    const {
      demuxer: e,
      remuxer: n
    } = this;
    !e || !n || (e.resetContiguity(), n.resetNextTimestamp());
  }
  resetInitSegment(e, n, r, i, s) {
    const {
      demuxer: a,
      remuxer: o
    } = this;
    !a || !o || (a.resetInitSegment(e, n, r, i), o.resetInitSegment(e, n, r, s));
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);
  }
  transmux(e, n, r, i, s) {
    let a;
    return n && n.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, n, r, i, s) : a = this.transmuxUnencrypted(e, r, i, s), a;
  }
  transmuxUnencrypted(e, n, r, i) {
    const {
      audioTrack: s,
      videoTrack: a,
      id3Track: o,
      textTrack: u
    } = this.demuxer.demux(e, n, !1, !this.config.progressive);
    return {
      remuxResult: this.remuxer.remux(s, a, o, u, n, r, !1, this.id),
      chunkMeta: i
    };
  }
  transmuxSampleAes(e, n, r, i, s) {
    return this.demuxer.demuxSampleAes(e, n, r).then((a) => ({
      remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, r, i, !1, this.id),
      chunkMeta: s
    }));
  }
  configureTransmuxer(e) {
    const {
      config: n,
      observer: r,
      typeSupported: i
    } = this;
    let s;
    for (let d = 0, f = nu.length; d < f; d++) {
      var a;
      if ((a = nu[d].demux) != null && a.probe(e, this.logger)) {
        s = nu[d];
        break;
      }
    }
    if (!s)
      return new Error("Failed to find demuxer by probing fragment data");
    const o = this.demuxer, u = this.remuxer, l = s.remux, c = s.demux;
    (!u || !(u instanceof l)) && (this.remuxer = new l(r, n, i, this.logger)), (!o || !(o instanceof c)) && (this.demuxer = new c(r, n, i, this.logger), this.probe = c.probe);
  }
  needsProbing(e, n) {
    return !this.demuxer || !this.remuxer || e || n;
  }
  getDecrypter() {
    let e = this.decrypter;
    return e || (e = this.decrypter = new Vh(this.config)), e;
  }
}
function M$(t, e) {
  let n = null;
  return t.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (n = e), n;
}
const Cc = (t) => ({
  remuxResult: {},
  chunkMeta: t
});
function _a(t) {
  return "then" in t && t.then instanceof Function;
}
class F$ {
  constructor(e, n, r, i, s) {
    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = n, this.initSegmentData = r, this.duration = i, this.defaultInitPts = s || null;
  }
}
class B$ {
  constructor(e, n, r, i, s, a) {
    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = n, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = s, this.initSegmentChange = a;
  }
}
let Pg = 0;
class nv {
  constructor(e, n, r, i) {
    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Pg++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (u) => {
      const l = u.data, c = this.hls;
      if (!(!c || !(l != null && l.event) || l.instanceNo !== this.instanceNo))
        switch (l.event) {
          case "init": {
            var d;
            const f = (d = this.workerContext) == null ? void 0 : d.objectURL;
            f && self.URL.revokeObjectURL(f);
            break;
          }
          case "transmuxComplete": {
            this.handleTransmuxComplete(l.data);
            break;
          }
          case "flush": {
            this.onFlush(l.data);
            break;
          }
          case "workerLog": {
            c.logger[l.data.logType] && c.logger[l.data.logType](l.data.message);
            break;
          }
          default: {
            l.data = l.data || {}, l.data.frag = this.frag, l.data.part = this.part, l.data.id = this.id, c.trigger(l.event, l.data);
            break;
          }
        }
    }, this.onWorkerError = (u) => {
      if (!this.hls)
        return;
      const l = new Error(`${u.message}  (${u.filename}:${u.lineno})`);
      this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`), this.hls.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.INTERNAL_EXCEPTION,
        fatal: !1,
        event: "demuxerWorker",
        error: l
      });
    };
    const s = e.config;
    this.hls = e, this.id = n, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = r, this.onFlush = i;
    const a = (u, l) => {
      l = l || {}, l.frag = this.frag || void 0, u === x.ERROR && (l = l, l.parent = this.id, l.part = this.part, this.error = l.error), this.hls.trigger(u, l);
    };
    this.observer = new Kh(), this.observer.on(x.FRAG_DECRYPTED, a), this.observer.on(x.ERROR, a);
    const o = jp(s.preferManagedMediaSource);
    if (this.useWorker && typeof Worker < "u") {
      const u = this.hls.logger;
      if (s.workerPath || V9()) {
        try {
          s.workerPath ? (u.log(`loading Web Worker ${s.workerPath} for "${n}"`), this.workerContext = z9(s.workerPath)) : (u.log(`injecting Web Worker for "${n}"`), this.workerContext = G9());
          const {
            worker: c
          } = this.workerContext;
          c.addEventListener("message", this.onWorkerMessage), c.addEventListener("error", this.onWorkerError), c.postMessage({
            instanceNo: this.instanceNo,
            cmd: "init",
            typeSupported: o,
            id: n,
            config: Ze(s)
          });
        } catch (c) {
          u.warn(`Error setting up "${n}" Web Worker, fallback to inline`, c), this.terminateWorker(), this.error = null, this.transmuxer = new Dg(this.observer, o, s, "", n, e.logger);
        }
        return;
      }
    }
    this.transmuxer = new Dg(this.observer, o, s, "", n, e.logger);
  }
  reset() {
    if (this.frag = null, this.part = null, this.workerContext) {
      const e = this.instanceNo;
      this.instanceNo = Pg++;
      const n = this.hls.config, r = jp(n.preferManagedMediaSource);
      this.workerContext.worker.postMessage({
        instanceNo: this.instanceNo,
        cmd: "reset",
        resetNo: e,
        typeSupported: r,
        id: this.id,
        config: Ze(n)
      });
    }
  }
  terminateWorker() {
    if (this.workerContext) {
      const {
        worker: e
      } = this.workerContext;
      this.workerContext = null, e.removeEventListener("message", this.onWorkerMessage), e.removeEventListener("error", this.onWorkerError), q9(this.hls.config.workerPath);
    }
  }
  destroy() {
    if (this.workerContext)
      this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;
    else {
      const n = this.transmuxer;
      n && (n.destroy(), this.transmuxer = null);
    }
    const e = this.observer;
    e && e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;
  }
  push(e, n, r, i, s, a, o, u, l, c) {
    var d, f;
    l.transmuxing.start = self.performance.now();
    const {
      instanceNo: h,
      transmuxer: m
    } = this, p = a ? a.start : s.start, g = s.decryptdata, b = this.frag, y = !(b && s.cc === b.cc), T = !(b && l.level === b.level), S = b ? l.sn - b.sn : -1, I = this.part ? l.part - this.part.index : -1, C = S === 0 && l.id > 1 && l.id === (b == null ? void 0 : b.stats.chunkCount), _ = !T && (S === 1 || S === 0 && (I === 1 || C && I <= 0)), R = self.performance.now();
    (T || S || s.stats.parsing.start === 0) && (s.stats.parsing.start = R), a && (I || !_) && (a.stats.parsing.start = R);
    const k = !(b && ((d = s.initSegment) == null ? void 0 : d.url) === ((f = b.initSegment) == null ? void 0 : f.url)), A = new B$(y, _, u, T, p, k);
    if (!_ || y || k) {
      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${s.type} sn: ${l.sn}${l.part > -1 ? " part: " + l.part : ""} ${this.id === pe.MAIN ? "level" : "track"}: ${l.level} id: ${l.id}
        discontinuity: ${y}
        trackSwitch: ${T}
        contiguous: ${_}
        accurateTimeOffset: ${u}
        timeOffset: ${p}
        initSegmentChange: ${k}`);
      const L = new F$(r, i, n, o, c);
      this.configureTransmuxer(L);
    }
    if (this.frag = s, this.part = a, this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: h,
        cmd: "demux",
        data: e,
        decryptdata: g,
        chunkMeta: l,
        state: A
      }, e instanceof ArrayBuffer ? [e] : []);
    else if (m) {
      const L = m.push(e, g, l, A);
      _a(L) ? L.then((P) => {
        this.handleTransmuxComplete(P);
      }).catch((P) => {
        this.transmuxerError(P, l, "transmuxer-interface push error");
      }) : this.handleTransmuxComplete(L);
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now();
    const {
      instanceNo: n,
      transmuxer: r
    } = this;
    if (this.workerContext)
      this.workerContext.worker.postMessage({
        instanceNo: n,
        cmd: "flush",
        chunkMeta: e
      });
    else if (r) {
      const i = r.flush(e);
      _a(i) ? i.then((s) => {
        this.handleFlushResult(s, e);
      }).catch((s) => {
        this.transmuxerError(s, e, "transmuxer-interface flush error");
      }) : this.handleFlushResult(i, e);
    }
  }
  transmuxerError(e, n, r) {
    this.hls && (this.error = e, this.hls.trigger(x.ERROR, {
      type: be.MEDIA_ERROR,
      details: q.FRAG_PARSING_ERROR,
      chunkMeta: n,
      frag: this.frag || void 0,
      part: this.part || void 0,
      fatal: !1,
      error: e,
      err: e,
      reason: r
    }));
  }
  handleFlushResult(e, n) {
    e.forEach((r) => {
      this.handleTransmuxComplete(r);
    }), this.onFlush(n);
  }
  configureTransmuxer(e) {
    const {
      instanceNo: n,
      transmuxer: r
    } = this;
    this.workerContext ? this.workerContext.worker.postMessage({
      instanceNo: n,
      cmd: "configure",
      config: e
    }) : r && r.configure(e);
  }
  handleTransmuxComplete(e) {
    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);
  }
}
const Og = 100;
class $$ extends Wh {
  constructor(e, n, r) {
    super(e, n, r, "audio-stream-controller", pe.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();
  }
  resetItem() {
    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (super.unregisterListeners(), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this));
  }
  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value
  onInitPtsFound(e, {
    frag: n,
    id: r,
    initPTS: i,
    timescale: s,
    trackId: a
  }) {
    if (r === pe.MAIN) {
      const o = n.cc, u = this.fragCurrent;
      if (this.initPTS[o] = {
        baseTime: i,
        timescale: s,
        trackId: a
      }, this.log(`InitPTS for cc: ${o} found from main: ${i / s} (${i}/${s}) trackId: ${a}`), this.mainAnchor = n, this.state === Z.WAITING_INIT_PTS) {
        const l = this.waitingData;
        (!l && !this.loadingParts || l && l.frag.cc !== o) && this.syncWithAnchor(n, l == null ? void 0 : l.frag);
      } else !this.hls.hasEnoughToStart && u && u.cc !== o ? (u.abortRequests(), this.syncWithAnchor(n, u)) : this.state === Z.IDLE && this.tick();
    }
  }
  getLoadPosition() {
    return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition();
  }
  syncWithAnchor(e, n) {
    var r;
    const i = ((r = this.mainFragLoading) == null ? void 0 : r.frag) || null;
    if (n && (i == null ? void 0 : i.cc) === n.cc)
      return;
    const s = (i || e).cc, a = this.getLevelDetails(), o = this.getLoadPosition(), u = Ex(a, s, o);
    u && (this.log(`Syncing with main frag at ${u.start} cc ${u.cc}`), this.startFragRequested = !1, this.nextLoadPosition = u.start, this.resetLoadingState(), this.state === Z.IDLE && this.doTickIdle());
  }
  startLoad(e, n) {
    if (!this.levels) {
      this.startPosition = e, this.state = Z.STOPPED;
      return;
    }
    const r = this.lastCurrentTime;
    this.stopLoad(), this.setInterval(Og), r > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = Z.IDLE) : this.state = Z.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
  }
  doTick() {
    switch (this.state) {
      case Z.IDLE:
        this.doTickIdle();
        break;
      case Z.WAITING_TRACK: {
        const {
          levels: e,
          trackId: n
        } = this, r = e == null ? void 0 : e[n], i = r == null ? void 0 : r.details;
        if (i && !this.waitForLive(r)) {
          if (this.waitForCdnTuneIn(i))
            break;
          this.state = Z.WAITING_INIT_PTS;
        }
        break;
      }
      case Z.FRAG_LOADING_WAITING_RETRY: {
        this.checkRetryDate();
        break;
      }
      case Z.WAITING_INIT_PTS: {
        const e = this.waitingData;
        if (e) {
          const {
            frag: n,
            part: r,
            cache: i,
            complete: s
          } = e, a = this.mainAnchor;
          if (this.initPTS[n.cc] !== void 0) {
            this.waitingData = null, this.state = Z.FRAG_LOADING;
            const o = i.flush().buffer, u = {
              frag: n,
              part: r,
              payload: o,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(u), s && super._handleFragmentLoadComplete(u);
          } else a && a.cc !== e.frag.cc && this.syncWithAnchor(a, e.frag);
        } else
          this.state = Z.IDLE;
      }
    }
    this.onTickEnd();
  }
  resetLoadingState() {
    const e = this.waitingData;
    e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media: e
    } = this;
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime);
  }
  doTickIdle() {
    var e;
    const {
      hls: n,
      levels: r,
      media: i,
      trackId: s
    } = this, a = n.config;
    if (!this.buffering || !i && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(r != null && r[s]))
      return;
    const o = r[s], u = o.details;
    if (!u || this.waitForLive(o) || this.waitForCdnTuneIn(u)) {
      this.state = Z.WAITING_TRACK, this.startFragRequested = !1;
      return;
    }
    const l = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.bufferFlushed && l && (this.bufferFlushed = !1, this.afterBufferFlushed(l, Qe.AUDIO, pe.AUDIO));
    const c = this.getFwdBufferInfo(l, pe.AUDIO);
    if (c === null)
      return;
    if (!this.switchingTrack && this._streamEnded(c, u)) {
      n.trigger(x.BUFFER_EOS, {
        type: "audio"
      }), this.state = Z.ENDED;
      return;
    }
    const d = c.len, f = n.maxBufferLength, h = u.fragments, m = h[0].start, p = this.getLoadPosition(), g = this.flushing ? p : c.end;
    if (this.switchingTrack && i) {
      const T = p;
      u.PTSKnown && T < m && (c.end > m || c.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = m + 0.05);
    }
    if (d >= f && !this.switchingTrack && g < h[h.length - 1].start)
      return;
    let b = this.getNextFragment(g, u);
    if (b && this.isLoopLoading(b, g) && (b = this.getNextFragmentLoopLoading(b, u, c, pe.MAIN, f)), !b) {
      this.bufferFlushed = !0;
      return;
    }
    let y = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
    if (!this.audioOnly && this.startFragRequested && y && gt(b) && !b.endList && (!u.live || !this.loadingParts && g < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(y) === Tt.OK && (this.mainFragLoading = y = null), y && gt(y))) {
      if (b.start > y.end) {
        const S = this.fragmentTracker.getFragAtPos(g, pe.MAIN);
        S && S.end > y.end && (y = S, this.mainFragLoading = {
          frag: S,
          targetBufferTime: null
        });
      }
      if (b.start > y.end)
        return;
    }
    this.loadFragment(b, o, g);
  }
  onMediaDetaching(e, n) {
    this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, n);
  }
  onAudioTracksUpdated(e, {
    audioTracks: n
  }) {
    this.resetTransmuxer(), this.levels = n.map((r) => new Ia(r));
  }
  onAudioTrackSwitching(e, n) {
    const r = !!n.url;
    this.trackId = n.id;
    const {
      fragCurrent: i
    } = this;
    i && (i.abortRequests(), this.removeUnbufferedFrags(i.start)), this.resetLoadingState(), r ? (this.switchingTrack = n, this.flushAudioIfNeeded(n), this.state !== Z.STOPPED && (this.setInterval(Og), this.state = Z.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = n, this.clearInterval());
  }
  onManifestLoading() {
    super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;
  }
  onLevelLoaded(e, n) {
    this.mainDetails = n.details;
    const r = this.cachedTrackLoadedData;
    r && (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(x.AUDIO_TRACK_LOADED, r));
  }
  onAudioTrackLoaded(e, n) {
    var r;
    const {
      levels: i
    } = this, {
      details: s,
      id: a,
      groupId: o,
      track: u
    } = n;
    if (!i) {
      this.warn(`Audio tracks reset while loading track ${a} "${u.name}" of "${o}"`);
      return;
    }
    const l = this.mainDetails;
    if (!l || s.endCC > l.endCC || l.expired) {
      this.cachedTrackLoadedData = n, this.state !== Z.STOPPED && (this.state = Z.WAITING_TRACK);
      return;
    }
    this.cachedTrackLoadedData = null, this.log(`Audio track ${a} "${u.name}" of "${o}" loaded [${s.startSN},${s.endSN}]${s.lastPartSn ? `[part-${s.lastPartSn}-${s.lastPartIndex}]` : ""},duration:${s.totalduration}`);
    const c = i[a];
    let d = 0;
    if (s.live || (r = c.details) != null && r.live) {
      if (this.checkLiveUpdate(s), s.deltaUpdateFailed)
        return;
      if (c.details) {
        var f;
        d = this.alignPlaylists(s, c.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
      }
      s.alignedSliding || (Mx(s, l), s.alignedSliding || $u(s, l), d = s.fragmentStart);
    }
    c.details = s, this.levelLastLoaded = c, this.startFragRequested || this.setStartPosition(l, d), this.hls.trigger(x.AUDIO_TRACK_UPDATED, {
      details: s,
      id: a,
      groupId: n.groupId
    }), this.state === Z.WAITING_TRACK && !this.waitForCdnTuneIn(s) && (this.state = Z.IDLE), this.tick();
  }
  _handleFragmentLoadProgress(e) {
    var n;
    const r = e.frag, {
      part: i,
      payload: s
    } = e, {
      config: a,
      trackId: o,
      levels: u
    } = this;
    if (!u) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const l = u[o];
    if (!l) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const c = l.details;
    if (!c) {
      this.warn("Audio track details undefined on fragment load progress"), this.removeUnbufferedFrags(r.start);
      return;
    }
    const d = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
    let f = this.transmuxer;
    f || (f = this.transmuxer = new nv(this.hls, pe.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
    const h = this.initPTS[r.cc], m = (n = r.initSegment) == null ? void 0 : n.data;
    if (h !== void 0) {
      const g = i ? i.index : -1, b = g !== -1, y = new Gh(r.level, r.sn, r.stats.chunkCount, s.byteLength, g, b);
      f.push(s, m, d, "", r, i, c.totalduration, !1, y, h);
    } else {
      this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${c.startSN} ,${c.endSN}],track ${o}`);
      const {
        cache: p
      } = this.waitingData = this.waitingData || {
        frag: r,
        part: i,
        cache: new Fx(),
        complete: !1
      };
      p.push(new Uint8Array(s)), this.state !== Z.STOPPED && (this.state = Z.WAITING_INIT_PTS);
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0;
      return;
    }
    super._handleFragmentLoadComplete(e);
  }
  onBufferReset() {
    this.mediaBuffer = null;
  }
  onBufferCreated(e, n) {
    this.bufferFlushed = this.flushing = !1;
    const r = n.tracks.audio;
    r && (this.mediaBuffer = r.buffer || null);
  }
  onFragLoading(e, n) {
    !this.audioOnly && n.frag.type === pe.MAIN && gt(n.frag) && (this.mainFragLoading = n, this.state === Z.IDLE && this.tick());
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n;
    if (r.type !== pe.AUDIO) {
      !this.audioOnly && r.type === pe.MAIN && !r.elementaryStreams.video && !r.elementaryStreams.audiovideo && (this.audioOnly = !0, this.mainFragLoading = null);
      return;
    }
    if (this.fragContextChanged(r)) {
      this.warn(`Fragment ${r.sn}${i ? " p: " + i.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (gt(r)) {
      this.fragPrevious = r;
      const s = this.switchingTrack;
      s && (this.bufferedTrack = s, this.switchingTrack = null, this.hls.trigger(x.AUDIO_TRACK_SWITCHED, ze({}, s)));
    }
    this.fragBufferedComplete(r, i), this.media && this.tick();
  }
  onError(e, n) {
    var r;
    if (n.fatal) {
      this.state = Z.ERROR;
      return;
    }
    switch (n.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(pe.AUDIO, n);
        break;
      case q.AUDIO_TRACK_LOAD_ERROR:
      case q.AUDIO_TRACK_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !n.levelRetry && this.state === Z.WAITING_TRACK && ((r = n.context) == null ? void 0 : r.type) === Me.AUDIO_TRACK && (this.state = Z.IDLE);
        break;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (n.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(n) || this.resetLoadingState();
        break;
      case q.BUFFER_FULL_ERROR:
        if (n.parent !== "audio")
          return;
        this.reduceLengthAndFlushBuffer(n) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(n);
        break;
    }
  }
  onBufferFlushing(e, {
    type: n
  }) {
    n !== Qe.VIDEO && (this.flushing = !0);
  }
  onBufferFlushed(e, {
    type: n
  }) {
    if (n !== Qe.VIDEO) {
      this.flushing = !1, this.bufferFlushed = !0, this.state === Z.ENDED && (this.state = Z.IDLE);
      const r = this.mediaBuffer || this.media;
      r && (this.afterBufferFlushed(r, n, pe.AUDIO), this.tick());
    }
  }
  _handleTransmuxComplete(e) {
    var n;
    const r = "audio", {
      hls: i
    } = this, {
      remuxResult: s,
      chunkMeta: a
    } = e, o = this.getCurrentContext(a);
    if (!o) {
      this.resetWhenMissingContext(a);
      return;
    }
    const {
      frag: u,
      part: l,
      level: c
    } = o, {
      details: d
    } = c, {
      audio: f,
      text: h,
      id3: m,
      initSegment: p
    } = s;
    if (this.fragContextChanged(u) || !d) {
      this.fragmentTracker.removeFragment(u);
      return;
    }
    if (this.state = Z.PARSING, this.switchingTrack && f && this.completeAudioSwitch(this.switchingTrack), p != null && p.tracks) {
      const g = u.initSegment || u;
      if (this.unhandledEncryptionError(p, u))
        return;
      this._bufferInitSegment(c, p.tracks, g, a), i.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
        frag: g,
        id: r,
        tracks: p.tracks
      });
    }
    if (f) {
      const {
        startPTS: g,
        endPTS: b,
        startDTS: y,
        endDTS: T
      } = f;
      l && (l.elementaryStreams[Qe.AUDIO] = {
        startPTS: g,
        endPTS: b,
        startDTS: y,
        endDTS: T
      }), u.setElementaryStreamInfo(Qe.AUDIO, g, b, y, T), this.bufferFragmentData(f, u, l, a);
    }
    if (m != null && (n = m.samples) != null && n.length) {
      const g = Xe({
        id: r,
        frag: u,
        details: d
      }, m);
      i.trigger(x.FRAG_PARSING_METADATA, g);
    }
    if (h) {
      const g = Xe({
        id: r,
        frag: u,
        details: d
      }, h);
      i.trigger(x.FRAG_PARSING_USERDATA, g);
    }
  }
  _bufferInitSegment(e, n, r, i) {
    if (this.state !== Z.PARSING || (n.video && delete n.video, n.audiovideo && delete n.audiovideo, !n.audio))
      return;
    const s = n.audio;
    s.id = pe.AUDIO;
    const a = e.audioCodec;
    this.log(`Init audio buffer, container:${s.container}, codecs[level/parsed]=[${a}/${s.codec}]`), a && a.split(",").length === 1 && (s.levelCodec = a), this.hls.trigger(x.BUFFER_CODECS, n);
    const o = s.initSegment;
    if (o != null && o.byteLength) {
      const u = {
        type: "audio",
        frag: r,
        part: null,
        chunkMeta: i,
        parent: r.type,
        data: o
      };
      this.hls.trigger(x.BUFFER_APPENDING, u);
    }
    this.tickImmediate();
  }
  loadFragment(e, n, r) {
    const i = this.fragmentTracker.getState(e);
    if (this.switchingTrack || i === Tt.NOT_LOADED || i === Tt.PARTIAL) {
      var s;
      if (!gt(e))
        this._loadInitSegment(e, n);
      else if ((s = n.details) != null && s.live && !this.initPTS[e.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = Z.WAITING_INIT_PTS;
        const a = this.mainDetails;
        a && a.fragmentStart !== n.details.fragmentStart && $u(n.details, a);
      } else
        super.loadFragment(e, n, r);
    } else
      this.clearTrackerIfNeeded(e);
  }
  flushAudioIfNeeded(e) {
    if (this.media && this.bufferedTrack) {
      const {
        name: n,
        lang: r,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      } = this.bufferedTrack;
      ti({
        name: n,
        lang: r,
        assocLang: i,
        characteristics: s,
        audioCodec: a,
        channels: o
      }, e, jr) || (Ou(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"), this.bufferedTrack = null) : this.bufferedTrack = e);
    }
  }
  completeAudioSwitch(e) {
    const {
      hls: n
    } = this;
    this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, n.trigger(x.AUDIO_TRACK_SWITCHED, ze({}, e));
  }
}
class e0 extends En {
  constructor(e, n) {
    super(n, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;
  }
  destroy() {
    this.clearTimer(), this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    this.timer !== -1 && (self.clearTimeout(this.timer), this.timer = -1);
  }
  startLoad() {
    this.canLoad = !0, this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = !1, this.clearTimer();
  }
  switchParams(e, n, r) {
    const i = n == null ? void 0 : n.renditionReports;
    if (i) {
      let s = -1;
      for (let a = 0; a < i.length; a++) {
        const o = i[a];
        let u;
        try {
          u = new self.URL(o.URI, n.url).href;
        } catch (l) {
          this.warn(`Could not construct new URL for Rendition Report: ${l}`), u = o.URI || "";
        }
        if (u === e) {
          s = a;
          break;
        } else u === e.substring(0, u.length) && (s = a);
      }
      if (s !== -1) {
        const a = i[s], o = parseInt(a["LAST-MSN"]) || n.lastPartSn;
        let u = parseInt(a["LAST-PART"]) || n.lastPartIndex;
        if (this.hls.config.lowLatencyMode) {
          const c = Math.min(n.age - n.partTarget, n.targetduration);
          u >= 0 && c > n.partTarget && (u += 1);
        }
        const l = r && Yp(r);
        return new Xp(o, u >= 0 ? u : void 0, l);
      }
    }
  }
  loadPlaylist(e) {
    this.clearTimer();
  }
  loadingPlaylist(e, n) {
    this.clearTimer();
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);
  }
  getUrlWithDirectives(e, n) {
    if (n)
      try {
        return n.addDirectives(e);
      } catch (r) {
        this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`);
      }
    return e;
  }
  playlistLoaded(e, n, r) {
    const {
      details: i,
      stats: s
    } = n, a = self.performance.now(), o = s.loading.first ? Math.max(0, a - s.loading.first) : 0;
    i.advancedDateTime = Date.now() - o;
    const u = this.hls.config.timelineOffset;
    if (u !== i.appliedTimelineOffset) {
      const c = Math.max(u || 0, 0);
      i.appliedTimelineOffset = c, i.fragments.forEach((d) => {
        d.setStart(d.playlistOffset + c);
      });
    }
    if (i.live || r != null && r.live) {
      const c = "levelInfo" in n ? n.levelInfo : n.track;
      if (i.reloaded(r), r && i.fragments.length > 0) {
        k9(r, i, this);
        const y = i.playlistParsingError;
        if (y) {
          this.warn(y);
          const T = this.hls;
          if (!T.config.ignorePlaylistParsingErrors) {
            var l;
            const {
              networkDetails: S
            } = n;
            T.trigger(x.ERROR, {
              type: be.NETWORK_ERROR,
              details: q.LEVEL_PARSING_ERROR,
              fatal: !1,
              url: i.url,
              error: y,
              reason: y.message,
              level: n.level || void 0,
              parent: (l = i.fragments[0]) == null ? void 0 : l.type,
              networkDetails: S,
              stats: s
            });
            return;
          }
          i.playlistParsingError = null;
        }
      }
      i.requestScheduled === -1 && (i.requestScheduled = s.loading.start);
      const d = this.hls.mainForwardBufferInfo, f = d ? d.end - d.len : 0, h = (i.edge - f) * 1e3, m = kx(i, h);
      if (i.requestScheduled + m < a ? i.requestScheduled = a : i.requestScheduled += m, this.log(`live playlist ${e} ${i.advanced ? "REFRESHED " + i.lastPartSn + "-" + i.lastPartIndex : i.updated ? "UPDATED" : "MISSED"}`), !this.canLoad || !i.live)
        return;
      let p, g, b;
      if (i.canBlockReload && i.endSN && i.advanced) {
        const y = this.hls.config.lowLatencyMode, T = i.lastPartSn, S = i.endSN, I = i.lastPartIndex, C = I !== -1, _ = T === S;
        C ? _ ? (g = S + 1, b = y ? 0 : I) : (g = T, b = y ? I + 1 : i.maxPartIndex) : g = S + 1;
        const R = i.age, k = R + i.ageHeader;
        let A = Math.min(k - i.partTarget, i.targetduration * 1.5);
        if (A > 0) {
          if (k > i.targetduration * 3)
            this.log(`Playlist last advanced ${R.toFixed(2)}s ago. Omitting segment and part directives.`), g = void 0, b = void 0;
          else if (r != null && r.tuneInGoal && k - i.partTarget > r.tuneInGoal)
            this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${A} with playlist age: ${i.age}`), A = 0;
          else {
            const L = Math.floor(A / i.targetduration);
            if (g += L, b !== void 0) {
              const P = Math.round(A % i.targetduration / i.partTarget);
              b += P;
            }
            this.log(`CDN Tune-in age: ${i.ageHeader}s last advanced ${R.toFixed(2)}s goal: ${A} skip sn ${L} to part ${b}`);
          }
          i.tuneInGoal = A;
        }
        if (p = this.getDeliveryDirectives(i, n.deliveryDirectives, g, b), y || !_) {
          i.requestScheduled = a, this.loadingPlaylist(c, p);
          return;
        }
      } else (i.canBlockReload || i.canSkipUntil) && (p = this.getDeliveryDirectives(i, n.deliveryDirectives, g, b));
      p && g !== void 0 && i.canBlockReload && (i.requestScheduled = s.loading.first + Math.max(m - o * 2, m / 2)), this.scheduleLoading(c, p, i);
    } else
      this.clearTimer();
  }
  scheduleLoading(e, n, r) {
    const i = r || e.details;
    if (!i) {
      this.loadingPlaylist(e, n);
      return;
    }
    const s = self.performance.now(), a = i.requestScheduled;
    if (s >= a) {
      this.loadingPlaylist(e, n);
      return;
    }
    const o = a - s;
    this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`), this.clearTimer(), this.timer = self.setTimeout(() => this.loadingPlaylist(e, n), o);
  }
  getDeliveryDirectives(e, n, r, i) {
    let s = Yp(e);
    return n != null && n.skip && e.deltaUpdateFailed && (r = n.msn, i = n.part, s = Jo.No), new Xp(r, i, s);
  }
  checkRetry(e) {
    const n = e.details, r = Nu(e), i = e.errorAction, {
      action: s,
      retryCount: a = 0,
      retryConfig: o
    } = i || {}, u = !!i && !!o && (s === Lt.RetryRequest || !i.resolved && s === Lt.SendAlternateToPenaltyBox);
    if (u) {
      var l;
      if (a >= o.maxNumRetry)
        return !1;
      if (r && (l = e.context) != null && l.deliveryDirectives)
        this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${n}" without delivery-directives`), this.loadPlaylist();
      else {
        const c = Hh(o, a);
        this.clearTimer(), this.timer = self.setTimeout(() => this.loadPlaylist(), c), this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${n}" in ${c}ms`);
      }
      e.levelRetry = !0, i.resolved = !0;
    }
    return u;
  }
}
function rv(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!Ra(t[n].attrs, e[n].attrs))
      return !1;
  return !0;
}
function Ra(t, e, n) {
  const r = t["STABLE-RENDITION-ID"];
  return r && !n ? r === e["STABLE-RENDITION-ID"] : !(n || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((i) => t[i] !== e[i]);
}
function nf(t, e) {
  return e.label.toLowerCase() === t.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (t.lang || "").toLowerCase());
}
class U$ extends e0 {
  constructor(e) {
    super(e, "audio-track-controller"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();
  }
  onManifestLoading() {
    this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;
  }
  onManifestParsed(e, n) {
    this.tracks = n.audioTracks || [];
  }
  onAudioTrackLoaded(e, n) {
    const {
      id: r,
      groupId: i,
      details: s
    } = n, a = this.tracksInGroup[r];
    if (!a || a.groupId !== i) {
      this.warn(`Audio track with id:${r} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = n.details, this.log(`Audio track ${r} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, n, o);
  }
  onLevelLoading(e, n) {
    this.switchLevel(n.level);
  }
  onLevelSwitching(e, n) {
    this.switchLevel(n.level);
  }
  switchLevel(e) {
    const n = this.hls.levels[e];
    if (!n)
      return;
    const r = n.audioGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some((o) => (i == null ? void 0 : i.indexOf(o)) === -1)) {
      this.groupIds = r, this.trackId = -1, this.currentTrack = null;
      const o = this.tracks.filter((f) => !r || r.indexOf(f.groupId) !== -1);
      if (o.length)
        this.selectDefaultTrack && !o.some((f) => f.default) && (this.selectDefaultTrack = !1), o.forEach((f, h) => {
          f.id = h;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = o;
      const u = this.hls.config.audioPreference;
      if (!s && u) {
        const f = $n(u, o, jr);
        if (f > -1)
          s = o[f];
        else {
          const h = $n(u, this.tracks);
          s = this.tracks[h];
        }
      }
      let l = this.findTrackId(s);
      l === -1 && s && (l = this.findTrackId(null));
      const c = {
        audioTracks: o
      };
      this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${r == null ? void 0 : r.join(",")}`), this.hls.trigger(x.AUDIO_TRACKS_UPDATED, c);
      const d = this.trackId;
      if (l !== -1 && d === -1)
        this.setAudioTrack(l);
      else if (o.length && d === -1) {
        var a;
        const f = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`);
        this.warn(f.message), this.hls.trigger(x.ERROR, {
          type: be.MEDIA_ERROR,
          details: q.AUDIO_TRACK_LOAD_ERROR,
          fatal: !0,
          error: f
        });
      }
    }
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === Me.AUDIO_TRACK && n.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(n.context.groupId) !== -1) && this.checkRetry(n);
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(e) {
    this.selectDefaultTrack = !1, this.setAudioTrack(e);
  }
  setAudioOption(e) {
    const n = this.hls;
    if (n.config.audioPreference = e, e) {
      const r = this.allAudioTracks;
      if (this.selectDefaultTrack = !1, r.length) {
        const i = this.currentTrack;
        if (i && ti(e, i, jr))
          return i;
        const s = $n(e, this.tracksInGroup, jr);
        if (s > -1) {
          const a = this.tracksInGroup[s];
          return this.setAudioTrack(s), a;
        } else if (i) {
          let a = n.loadLevel;
          a === -1 && (a = n.firstAutoLevel);
          const o = ZB(e, n.levels, r, a, jr);
          if (o === -1)
            return null;
          n.nextLoadLevel = o;
        }
        if (e.channels || e.audioCodec) {
          const a = $n(e, r);
          if (a > -1)
            return r[a];
        }
      }
    }
    return null;
  }
  setAudioTrack(e) {
    const n = this.tracksInGroup;
    if (e < 0 || e >= n.length) {
      this.warn(`Invalid audio track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const r = this.currentTrack, i = n[e], s = i.details && !i.details.live;
    if (e === this.trackId && i === r && s || (this.log(`Switching to audio-track ${e} "${i.name}" lang:${i.lang} group:${i.groupId} channels:${i.channels}`), this.trackId = e, this.currentTrack = i, this.hls.trigger(x.AUDIO_TRACK_SWITCHING, ze({}, i)), s))
      return;
    const a = this.switchParams(i.url, r == null ? void 0 : r.details, i.details);
    this.loadPlaylist(a);
  }
  findTrackId(e) {
    const n = this.tracksInGroup;
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      if (!(this.selectDefaultTrack && !i.default) && (!e || ti(e, i, jr)))
        return r;
    }
    if (e) {
      const {
        name: r,
        lang: i,
        assocLang: s,
        characteristics: a,
        audioCodec: o,
        channels: u
      } = e;
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (ti({
          name: r,
          lang: i,
          assocLang: s,
          characteristics: a,
          audioCodec: o,
          channels: u
        }, c, jr))
          return l;
      }
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (Ra(e.attrs, c.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return l;
      }
      for (let l = 0; l < n.length; l++) {
        const c = n[l];
        if (Ra(e.attrs, c.attrs, ["LANGUAGE"]))
          return l;
      }
    }
    return -1;
  }
  loadPlaylist(e) {
    super.loadPlaylist();
    const n = this.currentTrack;
    this.shouldLoadPlaylist(n) && Ou(n.url, this.hls) && this.scheduleLoading(n, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, n), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading audio-track ${r} "${e.name}" lang:${e.lang} group:${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(x.AUDIO_TRACK_LOADING, {
      url: s,
      id: r,
      groupId: i,
      deliveryDirectives: n || null,
      track: e
    });
  }
}
class H$ {
  constructor(e) {
    this.tracks = void 0, this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    }, this.tracks = e;
  }
  destroy() {
    this.tracks = this.queues = null;
  }
  append(e, n, r) {
    if (this.queues === null || this.tracks === null)
      return;
    const i = this.queues[n];
    i.push(e), i.length === 1 && !r && this.executeNext(n);
  }
  appendBlocker(e) {
    return new Promise((n) => {
      const r = {
        label: "async-blocker",
        execute: n,
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: () => {
        }
      };
      this.append(r, e);
    });
  }
  prependBlocker(e) {
    return new Promise((n) => {
      if (this.queues) {
        const r = {
          label: "async-blocker-prepend",
          execute: n,
          onStart: () => {
          },
          onComplete: () => {
          },
          onError: () => {
          }
        };
        this.queues[e].unshift(r);
      }
    });
  }
  removeBlockers() {
    this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((e) => {
      var n;
      const r = (n = e[0]) == null ? void 0 : n.label;
      (r === "async-blocker" || r === "async-blocker-prepend") && (e[0].execute(), e.splice(0, 1));
    });
  }
  unblockAudio(e) {
    if (this.queues === null)
      return;
    this.queues.audio[0] === e && this.shiftAndExecuteNext("audio");
  }
  executeNext(e) {
    if (this.queues === null || this.tracks === null)
      return;
    const n = this.queues[e];
    if (n.length) {
      const i = n[0];
      try {
        i.execute();
      } catch (s) {
        var r;
        if (i.onError(s), this.queues === null || this.tracks === null)
          return;
        const a = (r = this.tracks[e]) == null ? void 0 : r.buffer;
        a != null && a.updating || this.shiftAndExecuteNext(e);
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues !== null && (this.queues[e].shift(), this.executeNext(e));
  }
  current(e) {
    var n;
    return ((n = this.queues) == null ? void 0 : n[e][0]) || null;
  }
  toString() {
    const {
      queues: e,
      tracks: n
    } = this;
    return e === null || n === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`;
  }
  list(e) {
    var n, r;
    return (n = this.queues) != null && n[e] || (r = this.tracks) != null && r[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : "";
  }
  listSbInfo(e) {
    var n;
    const r = (n = this.tracks) == null ? void 0 : n[e], i = r == null ? void 0 : r.buffer;
    return i ? `SourceBuffer${i.updating ? " updating" : ""}${r.ended ? " ended" : ""}${r.ending ? " ending" : ""}` : "none";
  }
  listOps(e) {
    var n;
    return ((n = this.queues) == null ? void 0 : n[e].map((r) => r.label).join(", ")) || "";
  }
}
const Ng = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/, iv = "HlsJsTrackRemovedError";
class V$ extends Error {
  constructor(e) {
    super(e), this.name = iv;
  }
}
class G$ extends En {
  constructor(e, n) {
    super("buffer-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = (r) => {
      var i;
      this.hls && ((i = this.mediaSource) == null ? void 0 : i.readyState) === "open" && this.hls.pauseBuffering();
    }, this._onStartStreaming = (r) => {
      this.hls && this.hls.resumeBuffering();
    }, this._onMediaSourceOpen = (r) => {
      const {
        media: i,
        mediaSource: s
      } = this;
      r && this.log("Media source opened"), !(!i || !s) && (s.removeEventListener("sourceopen", this._onMediaSourceOpen), i.removeEventListener("emptied", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(x.MEDIA_ATTACHED, {
        media: i,
        mediaSource: s
      }), this.mediaSource !== null && this.checkPendingTracks());
    }, this._onMediaSourceClose = () => {
      this.log("Media source closed");
    }, this._onMediaSourceEnded = () => {
      this.log("Media source ended");
    }, this._onMediaEmptied = () => {
      const {
        mediaSrc: r,
        _objectUrl: i
      } = this;
      r !== i && this.error(`Media element src was set while attaching MediaSource (${i} > ${r})`);
    }, this.hls = e, this.fragmentTracker = n, this.appendSource = dB(Or(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();
  }
  hasSourceTypes() {
    return Object.keys(this.tracks).length > 0;
  }
  destroy() {
    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue && (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.BUFFER_RESET, this.onBufferReset, this), e.on(x.BUFFER_APPENDING, this.onBufferAppending, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.BUFFER_EOS, this.onBufferEos, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.FRAG_PARSED, this.onFragParsed, this), e.on(x.FRAG_CHANGED, this.onFragChanged, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.BUFFER_RESET, this.onBufferReset, this), e.off(x.BUFFER_APPENDING, this.onBufferAppending, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_EOS, this.onBufferEos, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.FRAG_PARSED, this.onFragParsed, this), e.off(x.FRAG_CHANGED, this.onFragChanged, this), e.off(x.ERROR, this.onError, this);
  }
  transferMedia() {
    const {
      media: e,
      mediaSource: n
    } = this;
    if (!e)
      return null;
    const r = {};
    if (this.operationQueue) {
      const s = this.isUpdating();
      s || this.operationQueue.removeBlockers();
      const a = this.isQueued();
      (s || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${s ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`), this.operationQueue.destroy();
    }
    const i = this.transferData;
    return !this.sourceBufferCount && i && i.mediaSource === n ? Xe(r, i.tracks) : this.sourceBuffers.forEach((s) => {
      const [a] = s;
      a && (r[a] = Xe({}, this.tracks[a]), this.removeBuffer(a)), s[0] = s[1] = null;
    }), {
      media: e,
      mediaSource: n,
      tracks: r
    };
  }
  initTracks() {
    const e = {};
    this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;
  }
  onManifestLoading() {
    this.bufferCodecEventsTotal = 0, this.details = null;
  }
  onManifestParsed(e, n) {
    var r;
    let i = 2;
    (n.audio && !n.video || !n.altAudio) && (i = 1), this.bufferCodecEventsTotal = i, this.log(`${i} bufferCodec event(s) expected.`), (r = this.transferData) != null && r.mediaSource && this.sourceBufferCount && i && this.bufferCreated();
  }
  onMediaAttaching(e, n) {
    const r = this.media = n.media;
    this.transferData = this.overrides = void 0;
    const i = Or(this.appendSource);
    if (i) {
      const s = !!n.mediaSource;
      (s || n.overrides) && (this.transferData = n, this.overrides = n.overrides);
      const a = this.mediaSource = n.mediaSource || new i();
      if (this.assignMediaSource(a), s)
        this._objectUrl = r.src, this.attachTransferred();
      else {
        const o = this._objectUrl = self.URL.createObjectURL(a);
        if (this.appendSource)
          try {
            r.removeAttribute("src");
            const u = self.ManagedMediaSource;
            r.disableRemotePlayback = r.disableRemotePlayback || u && a instanceof u, Mg(r), z$(r, o), r.load();
          } catch {
            r.src = o;
          }
        else
          r.src = o;
      }
      r.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  assignMediaSource(e) {
    var n, r;
    this.log(`${((n = this.transferData) == null ? void 0 : n.mediaSource) === e ? "transferred" : "created"} media source: ${(r = e.constructor) == null ? void 0 : r.name}`), e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming), e.addEventListener("endstreaming", this._onEndStreaming));
  }
  attachTransferred() {
    const e = this.media, n = this.transferData;
    if (!n || !e)
      return;
    const r = this.tracks, i = n.tracks, s = i ? Object.keys(i) : null, a = s ? s.length : 0, o = () => {
      Promise.resolve().then(() => {
        this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen();
      });
    };
    if (i && s && a) {
      if (!this.tracksReady) {
        this.hls.config.startFragPrefetch = !0, this.log("attachTransferred: waiting for SourceBuffer track info");
        return;
      }
      if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${Ze(r, (u, l) => u === "initSegment" ? void 0 : l)};
transfer tracks: ${Ze(i, (u, l) => u === "initSegment" ? void 0 : l)}}`), !ex(i, r)) {
        n.mediaSource = null, n.tracks = void 0;
        const u = e.currentTime, l = this.details, c = Math.max(u, (l == null ? void 0 : l.fragments[0].start) || 0);
        if (c - u > 1) {
          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${u} -> ${c}`);
          return;
        }
        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(i)}"->"${Object.keys(r)}") start time: ${c} currentTime: ${u}`), this.onMediaDetaching(x.MEDIA_DETACHING, {}), this.onMediaAttaching(x.MEDIA_ATTACHING, n), e.currentTime = c;
        return;
      }
      this.transferData = void 0, s.forEach((u) => {
        const l = u, c = i[l];
        if (c) {
          const d = c.buffer;
          if (d) {
            const f = this.fragmentTracker, h = c.id;
            if (f.hasFragments(h) || f.hasParts(h)) {
              const g = Ce.getBuffered(d);
              f.detectEvictedFragments(l, g, h, null, !0);
            }
            const m = Lc(l), p = [l, d];
            this.sourceBuffers[m] = p, d.updating && this.operationQueue && this.operationQueue.prependBlocker(l), this.trackSourceBuffer(l, c);
          }
        }
      }), o(), this.bufferCreated();
    } else
      this.log("attachTransferred: MediaSource w/o SourceBuffers"), o();
  }
  get mediaSourceOpenOrEnded() {
    var e;
    const n = (e = this.mediaSource) == null ? void 0 : e.readyState;
    return n === "open" || n === "ended";
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia;
    this.transferData = this.overrides = void 0;
    const {
      media: i,
      mediaSource: s,
      _objectUrl: a
    } = this;
    if (s) {
      if (this.log(`media source ${r ? "transferring" : "detaching"}`), r)
        this.sourceBuffers.forEach(([o]) => {
          o && this.removeBuffer(o);
        }), this.resetQueue();
      else {
        if (this.mediaSourceOpenOrEnded) {
          const o = s.readyState === "open";
          try {
            const u = s.sourceBuffers;
            for (let l = u.length; l--; )
              o && u[l].abort(), s.removeSourceBuffer(u[l]);
            o && s.endOfStream();
          } catch (u) {
            this.warn(`onMediaDetaching: ${u.message} while calling endOfStream`);
          }
        }
        this.sourceBufferCount && this.onBufferReset();
      }
      s.removeEventListener("sourceopen", this._onMediaSourceOpen), s.removeEventListener("sourceended", this._onMediaSourceEnded), s.removeEventListener("sourceclose", this._onMediaSourceClose), this.appendSource && (s.removeEventListener("startstreaming", this._onStartStreaming), s.removeEventListener("endstreaming", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;
    }
    i && (i.removeEventListener("emptied", this._onMediaEmptied), r || (a && self.URL.revokeObjectURL(a), this.mediaSrc === a ? (i.removeAttribute("src"), this.appendSource && Mg(i), i.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")), this.media = null), this.hls.trigger(x.MEDIA_DETACHED, n);
  }
  onBufferReset() {
    this.sourceBuffers.forEach(([e]) => {
      e && this.resetBuffer(e);
    }), this.initTracks();
  }
  resetBuffer(e) {
    var n;
    const r = (n = this.tracks[e]) == null ? void 0 : n.buffer;
    if (this.removeBuffer(e), r)
      try {
        var i;
        (i = this.mediaSource) != null && i.sourceBuffers.length && this.mediaSource.removeSourceBuffer(r);
      } catch (s) {
        this.warn(`onBufferReset ${e}`, s);
      }
    delete this.tracks[e];
  }
  removeBuffer(e) {
    this.removeBufferListeners(e), this.sourceBuffers[Lc(e)] = [null, null];
    const n = this.tracks[e];
    n && (n.buffer = void 0);
  }
  resetQueue() {
    this.operationQueue && this.operationQueue.destroy(), this.operationQueue = new H$(this.tracks);
  }
  onBufferCodecs(e, n) {
    var r;
    const i = this.tracks, s = Object.keys(n);
    this.log(`BUFFER_CODECS: "${s}" (current SB count ${this.sourceBufferCount})`);
    const a = "audiovideo" in n && (i.audio || i.video) || i.audiovideo && ("audio" in n || "video" in n), o = !a && this.sourceBufferCount && this.media && s.some((u) => !i[u]);
    if (a || o) {
      this.warn(`Unsupported transition between "${Object.keys(i)}" and "${s}" SourceBuffers`);
      return;
    }
    s.forEach((u) => {
      var l, c;
      const d = n[u], {
        id: f,
        codec: h,
        levelCodec: m,
        container: p,
        metadata: g,
        supplemental: b
      } = d;
      let y = i[u];
      const T = (l = this.transferData) == null || (l = l.tracks) == null ? void 0 : l[u], S = T != null && T.buffer ? T : y, I = (S == null ? void 0 : S.pendingCodec) || (S == null ? void 0 : S.codec), C = S == null ? void 0 : S.levelCodec;
      y || (y = i[u] = {
        buffer: void 0,
        listeners: [],
        codec: h,
        supplemental: b,
        container: p,
        levelCodec: m,
        metadata: g,
        id: f
      });
      const _ = Zo(I, C), R = _ == null ? void 0 : _.replace(Ng, "$1");
      let k = Zo(h, m);
      const A = (c = k) == null ? void 0 : c.replace(Ng, "$1");
      k && _ && R !== A && (u.slice(0, 5) === "audio" && (k = Du(k, this.appendSource)), this.log(`switching codec ${I} to ${k}`), k !== (y.pendingCodec || y.codec) && (y.pendingCodec = k), y.container = p, this.appendChangeType(u, p, k));
    }), (this.tracksReady || this.sourceBufferCount) && (n.tracks = this.sourceBufferTracks), !this.sourceBufferCount && (this.bufferCodecEventsTotal > 1 && !this.tracks.video && !n.video && ((r = n.audio) == null ? void 0 : r.id) === "main" && (this.log("Main audio-only"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded && this.checkPendingTracks());
  }
  get sourceBufferTracks() {
    return Object.keys(this.tracks).reduce((e, n) => {
      const r = this.tracks[n];
      return e[n] = {
        id: r.id,
        container: r.container,
        codec: r.codec,
        levelCodec: r.levelCodec
      }, e;
    }, {});
  }
  appendChangeType(e, n, r) {
    const i = `${n};codecs=${r}`, s = {
      label: `change-type=${i}`,
      execute: () => {
        const a = this.tracks[e];
        if (a) {
          const o = a.buffer;
          o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${i}`), o.changeType(i), a.codec = r, a.container = n);
        }
        this.shiftAndExecuteNext(e);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (a) => {
        this.warn(`Failed to change ${e} SourceBuffer type`, a);
      }
    };
    this.append(s, e, this.isPending(this.tracks[e]));
  }
  blockAudio(e) {
    var n;
    const r = e.start, i = r + e.duration * 0.05;
    if (((n = this.fragmentTracker.getAppendedFrag(r, pe.MAIN)) == null ? void 0 : n.gap) === !0)
      return;
    const a = {
      label: "block-audio",
      execute: () => {
        var o;
        const u = this.tracks.video;
        (this.lastVideoAppendEnd > i || u != null && u.buffer && Ce.isBuffered(u.buffer, i) || ((o = this.fragmentTracker.getAppendedFrag(i, pe.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null, this.shiftAndExecuteNext("audio"));
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (o) => {
        this.warn("Error executing block-audio operation", o);
      }
    };
    this.blockedAudioAppend = {
      op: a,
      frag: e
    }, this.append(a, "audio", !0);
  }
  unblockAudio() {
    const {
      blockedAudioAppend: e,
      operationQueue: n
    } = this;
    e && n && (this.blockedAudioAppend = null, n.unblockAudio(e.op));
  }
  onBufferAppending(e, n) {
    const {
      tracks: r
    } = this, {
      data: i,
      type: s,
      parent: a,
      frag: o,
      part: u,
      chunkMeta: l,
      offset: c
    } = n, d = l.buffering[s], {
      sn: f,
      cc: h
    } = o, m = self.performance.now();
    d.start = m;
    const p = o.stats.buffering, g = u ? u.stats.buffering : null;
    p.start === 0 && (p.start = m), g && g.start === 0 && (g.start = m);
    const b = r.audio;
    let y = !1;
    s === "audio" && (b == null ? void 0 : b.container) === "audio/mpeg" && (y = !this.lastMpegAudioChunk || l.id === 1 || this.lastMpegAudioChunk.sn !== l.sn, this.lastMpegAudioChunk = l);
    const T = r.video, S = T == null ? void 0 : T.buffer;
    if (S && f !== "initSegment") {
      const _ = u || o, R = this.blockedAudioAppend;
      if (s === "audio" && a !== "main" && !this.blockedAudioAppend && !(T.ending || T.ended)) {
        const A = _.start + _.duration * 0.05, L = S.buffered, P = this.currentOp("video");
        !L.length && !P ? this.blockAudio(_) : !P && !Ce.isBuffered(S, A) && this.lastVideoAppendEnd < A && this.blockAudio(_);
      } else if (s === "video") {
        const k = _.end;
        if (R) {
          const A = R.frag.start;
          (k > A || k < this.lastVideoAppendEnd || Ce.isBuffered(S, A)) && this.unblockAudio();
        }
        this.lastVideoAppendEnd = k;
      }
    }
    const I = (u || o).start, C = {
      label: `append-${s}`,
      execute: () => {
        var _;
        d.executeStart = self.performance.now();
        const R = (_ = this.tracks[s]) == null ? void 0 : _.buffer;
        R && (y ? this.updateTimestampOffset(R, I, 0.1, s, f, h) : c !== void 0 && de(c) && this.updateTimestampOffset(R, c, 1e-6, s, f, h)), this.appendExecutor(i, s);
      },
      onStart: () => {
      },
      onComplete: () => {
        const _ = self.performance.now();
        d.executeEnd = d.end = _, p.first === 0 && (p.first = _), g && g.first === 0 && (g.first = _);
        const R = {};
        this.sourceBuffers.forEach(([k, A]) => {
          k && (R[k] = Ce.getBuffered(A));
        }), this.appendErrors[s] = 0, s === "audio" || s === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(x.BUFFER_APPENDED, {
          type: s,
          frag: o,
          part: u,
          chunkMeta: l,
          parent: o.type,
          timeRanges: R
        });
      },
      onError: (_) => {
        var R;
        const k = {
          type: be.MEDIA_ERROR,
          parent: o.type,
          details: q.BUFFER_APPEND_ERROR,
          sourceBufferName: s,
          frag: o,
          part: u,
          chunkMeta: l,
          error: _,
          err: _,
          fatal: !1
        }, A = (R = this.media) == null ? void 0 : R.error;
        if (_.code === DOMException.QUOTA_EXCEEDED_ERR || _.name == "QuotaExceededError" || "quota" in _)
          k.details = q.BUFFER_FULL_ERROR;
        else if (_.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !A)
          k.errorAction = ji(!0);
        else if (_.name === iv && this.sourceBufferCount === 0)
          k.errorAction = ji(!0);
        else {
          const L = ++this.appendErrors[s];
          this.warn(`Failed ${L}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${s}" sourceBuffer (${A || "no media error"})`), (L >= this.hls.config.appendErrorMaxRetry || A) && (k.fatal = !0);
        }
        this.hls.trigger(x.ERROR, k);
      }
    };
    this.log(`queuing "${s}" append sn: ${f}${u ? " p: " + u.index : ""} of ${o.type === pe.MAIN ? "level" : "track"} ${o.level} cc: ${h}`), this.append(C, s, this.isPending(this.tracks[s]));
  }
  getFlushOp(e, n, r) {
    return this.log(`queuing "${e}" remove ${n}-${r}`), {
      label: "remove",
      execute: () => {
        this.removeExecutor(e, n, r);
      },
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(x.BUFFER_FLUSHED, {
          type: e
        });
      },
      onError: (i) => {
        this.warn(`Failed to remove ${n}-${r} from "${e}" SourceBuffer`, i);
      }
    };
  }
  onBufferFlushing(e, n) {
    const {
      type: r,
      startOffset: i,
      endOffset: s
    } = n;
    r ? this.append(this.getFlushOp(r, i, s), r) : this.sourceBuffers.forEach(([a]) => {
      a && this.append(this.getFlushOp(a, i, s), a);
    });
  }
  onFragParsed(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = [], a = i ? i.elementaryStreams : r.elementaryStreams;
    a[Qe.AUDIOVIDEO] ? s.push("audiovideo") : (a[Qe.AUDIO] && s.push("audio"), a[Qe.VIDEO] && s.push("video"));
    const o = () => {
      const u = self.performance.now();
      r.stats.buffering.end = u, i && (i.stats.buffering.end = u);
      const l = i ? i.stats : r.stats;
      this.hls.trigger(x.FRAG_BUFFERED, {
        frag: r,
        part: i,
        stats: l,
        id: r.type
      });
    };
    s.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(o, s).catch((u) => {
      this.warn(`Fragment buffered callback ${u}`), this.stepOperationQueue(this.sourceBufferTypes);
    });
  }
  onFragChanged(e, n) {
    this.trimBuffers();
  }
  get bufferedToEnd() {
    return this.sourceBufferCount > 0 && !this.sourceBuffers.some(([e]) => {
      if (e) {
        const n = this.tracks[e];
        if (n)
          return !n.ended || n.ending;
      }
      return !1;
    });
  }
  // on BUFFER_EOS mark matching sourcebuffer(s) as "ending" and "ended" and queue endOfStream after remaining operations(s)
  // an undefined data.type will mark all buffers as EOS.
  onBufferEos(e, n) {
    var r;
    this.sourceBuffers.forEach(([a]) => {
      if (a) {
        const o = this.tracks[a];
        (!n.type || n.type === a) && (o.ending = !0, o.ended || (o.ended = !0, this.log(`${a} buffer reached EOS`)));
      }
    });
    const i = ((r = this.overrides) == null ? void 0 : r.endOfStream) !== !1;
    this.sourceBufferCount > 0 && !this.sourceBuffers.some(([a]) => {
      var o;
      return a && !((o = this.tracks[a]) != null && o.ended);
    }) ? i ? (this.log("Queueing EOS"), this.blockUntilOpen(() => {
      this.tracksEnded();
      const {
        mediaSource: a
      } = this;
      if (!a || a.readyState !== "open") {
        a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`);
        return;
      }
      this.log("Calling mediaSource.endOfStream()"), a.endOfStream(), this.hls.trigger(x.BUFFERED_TO_END, void 0);
    })) : (this.tracksEnded(), this.hls.trigger(x.BUFFERED_TO_END, void 0)) : n.type === "video" && this.unblockAudio();
  }
  tracksEnded() {
    this.sourceBuffers.forEach(([e]) => {
      if (e !== null) {
        const n = this.tracks[e];
        n && (n.ending = !1);
      }
    });
  }
  onLevelUpdated(e, {
    details: n
  }) {
    n.fragments.length && (this.details = n, this.updateDuration());
  }
  updateDuration() {
    this.blockUntilOpen(() => {
      const e = this.getDurationAndRange();
      e && this.updateMediaSource(e);
    });
  }
  onError(e, n) {
    if (n.details === q.BUFFER_APPEND_ERROR && n.frag) {
      var r;
      const i = (r = n.errorAction) == null ? void 0 : r.nextAutoLevel;
      de(i) && i !== n.frag.level && this.resetAppendErrors();
    }
  }
  resetAppendErrors() {
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
  }
  trimBuffers() {
    const {
      hls: e,
      details: n,
      media: r
    } = this;
    if (!r || n === null || !this.sourceBufferCount)
      return;
    const i = e.config, s = r.currentTime, a = n.levelTargetDuration, o = n.live && i.liveBackBufferLength !== null ? i.liveBackBufferLength : i.backBufferLength;
    if (de(o) && o >= 0) {
      const l = Math.max(o, a), c = Math.floor(s / a) * a - l;
      this.flushBackBuffer(s, a, c);
    }
    const u = i.frontBufferFlushThreshold;
    if (de(u) && u > 0) {
      const l = Math.max(i.maxBufferLength, u), c = Math.max(l, a), d = Math.floor(s / a) * a + c;
      this.flushFrontBuffer(s, a, d);
    }
  }
  flushBackBuffer(e, n, r) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const o = Ce.getBuffered(s);
        if (o.length > 0 && r > o.start(0)) {
          var a;
          this.hls.trigger(x.BACK_BUFFER_REACHED, {
            bufferEnd: r
          });
          const u = this.tracks[i];
          if ((a = this.details) != null && a.live)
            this.hls.trigger(x.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: r
            });
          else if (u != null && u.ended) {
            this.log(`Cannot flush ${i} back buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(x.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: r,
            type: i
          });
        }
      }
    });
  }
  flushFrontBuffer(e, n, r) {
    this.sourceBuffers.forEach(([i, s]) => {
      if (s) {
        const a = Ce.getBuffered(s), o = a.length;
        if (o < 2)
          return;
        const u = a.start(o - 1), l = a.end(o - 1);
        if (r > u || e >= u && e <= l)
          return;
        this.hls.trigger(x.BUFFER_FLUSHING, {
          startOffset: u,
          endOffset: 1 / 0,
          type: i
        });
      }
    });
  }
  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */
  getDurationAndRange() {
    var e;
    const {
      details: n,
      mediaSource: r
    } = this;
    if (!n || !this.media || (r == null ? void 0 : r.readyState) !== "open")
      return null;
    const i = n.edge;
    if (n.live && this.hls.config.liveDurationInfinity) {
      if (n.fragments.length && r.setLiveSeekableRange) {
        const l = Math.max(0, n.fragmentStart), c = Math.max(l, i);
        return {
          duration: 1 / 0,
          start: l,
          end: c
        };
      }
      return {
        duration: 1 / 0
      };
    }
    const s = (e = this.overrides) == null ? void 0 : e.duration;
    if (s)
      return de(s) ? {
        duration: s
      } : null;
    const a = this.media.duration, o = de(r.duration) ? r.duration : 0;
    return i > o && i > a || !de(a) ? {
      duration: i
    } : null;
  }
  updateMediaSource({
    duration: e,
    start: n,
    end: r
  }) {
    const i = this.mediaSource;
    !this.media || !i || i.readyState !== "open" || (i.duration !== e && (de(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), i.duration = e), n !== void 0 && r !== void 0 && (this.log(`MediaSource duration is set to ${i.duration}. Setting seekable range to ${n}-${r}.`), i.setLiveSeekableRange(n, r)));
  }
  get tracksReady() {
    const e = this.pendingTrackCount;
    return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsTotal: e,
      pendingTrackCount: n,
      tracks: r
    } = this;
    if (this.log(`checkPendingTracks (pending: ${n} codec events expected: ${e}) ${Ze(r)}`), this.tracksReady) {
      var i;
      const s = (i = this.transferData) == null ? void 0 : i.tracks;
      s && Object.keys(s).length ? this.attachTransferred() : this.createSourceBuffers();
    }
  }
  bufferCreated() {
    if (this.sourceBufferCount) {
      const e = {};
      this.sourceBuffers.forEach(([n, r]) => {
        if (n) {
          const i = this.tracks[n];
          e[n] = {
            buffer: r,
            container: i.container,
            codec: i.codec,
            supplemental: i.supplemental,
            levelCodec: i.levelCodec,
            id: i.id,
            metadata: i.metadata
          };
        }
      }), this.hls.trigger(x.BUFFER_CREATED, {
        tracks: e
      }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([n]) => {
        this.executeNext(n);
      });
    } else {
      const e = new Error("could not create source buffer for media codec(s)");
      this.hls.trigger(x.ERROR, {
        type: be.MEDIA_ERROR,
        details: q.BUFFER_INCOMPATIBLE_CODECS_ERROR,
        fatal: !0,
        error: e,
        reason: e.message
      });
    }
  }
  createSourceBuffers() {
    const {
      tracks: e,
      sourceBuffers: n,
      mediaSource: r
    } = this;
    if (!r)
      throw new Error("createSourceBuffers called when mediaSource was null");
    for (const s in e) {
      const a = s, o = e[a];
      if (this.isPending(o)) {
        const u = this.getTrackCodec(o, a), l = `${o.container};codecs=${u}`;
        o.codec = u, this.log(`creating sourceBuffer(${l})${this.currentOp(a) ? " Queued" : ""} ${Ze(o)}`);
        try {
          const c = r.addSourceBuffer(l), d = Lc(a), f = [a, c];
          n[d] = f, o.buffer = c;
        } catch (c) {
          var i;
          this.error(`error while trying to add sourceBuffer: ${c.message}`), this.shiftAndExecuteNext(a), (i = this.operationQueue) == null || i.removeBlockers(), delete this.tracks[a], this.hls.trigger(x.ERROR, {
            type: be.MEDIA_ERROR,
            details: q.BUFFER_ADD_CODEC_ERROR,
            fatal: !1,
            error: c,
            sourceBufferName: a,
            mimeType: l,
            parent: o.id
          });
          return;
        }
        this.trackSourceBuffer(a, o);
      }
    }
    this.bufferCreated();
  }
  getTrackCodec(e, n) {
    const r = e.supplemental;
    let i = e.codec;
    r && (n === "video" || n === "audiovideo") && va(r, "video") && (i = PB(i, r));
    const s = Zo(i, e.levelCodec);
    return s ? n.slice(0, 5) === "audio" ? Du(s, this.appendSource) : s : "";
  }
  trackSourceBuffer(e, n) {
    const r = n.buffer;
    if (!r)
      return;
    const i = this.getTrackCodec(n, e);
    this.tracks[e] = {
      buffer: r,
      codec: i,
      container: n.container,
      levelCodec: n.levelCodec,
      supplemental: n.supplemental,
      metadata: n.metadata,
      id: n.id,
      listeners: []
    }, this.removeBufferListeners(e), this.addBufferListener(e, "updatestart", this.onSBUpdateStart), this.addBufferListener(e, "updateend", this.onSBUpdateEnd), this.addBufferListener(e, "error", this.onSBUpdateError), this.appendSource && this.addBufferListener(e, "bufferedchange", (s, a) => {
      const o = a.removedRanges;
      o != null && o.length && this.hls.trigger(x.BUFFER_FLUSHED, {
        type: s
      });
    });
  }
  get mediaSrc() {
    var e, n;
    const r = ((e = this.media) == null || (n = e.querySelector) == null ? void 0 : n.call(e, "source")) || this.media;
    return r == null ? void 0 : r.src;
  }
  onSBUpdateStart(e) {
    const n = this.currentOp(e);
    n && n.onStart();
  }
  onSBUpdateEnd(e) {
    var n;
    if (((n = this.mediaSource) == null ? void 0 : n.readyState) === "closed") {
      this.resetBuffer(e);
      return;
    }
    const r = this.currentOp(e);
    r && (r.onComplete(), this.shiftAndExecuteNext(e));
  }
  onSBUpdateError(e, n) {
    var r;
    const i = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`);
    this.error(`${i}`, n), this.hls.trigger(x.ERROR, {
      type: be.MEDIA_ERROR,
      details: q.BUFFER_APPENDING_ERROR,
      sourceBufferName: e,
      error: i,
      fatal: !1
    });
    const s = this.currentOp(e);
    s && s.onError(i);
  }
  updateTimestampOffset(e, n, r, i, s, a) {
    const o = n - e.timestampOffset;
    Math.abs(o) >= r && (this.log(`Updating ${i} SourceBuffer timestampOffset to ${n} (sn: ${s} cc: ${a})`), e.timestampOffset = n);
  }
  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually
  removeExecutor(e, n, r) {
    const {
      media: i,
      mediaSource: s
    } = this, a = this.tracks[e], o = a == null ? void 0 : a.buffer;
    if (!i || !s || !o) {
      this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);
      return;
    }
    const u = de(i.duration) ? i.duration : 1 / 0, l = de(s.duration) ? s.duration : 1 / 0, c = Math.max(0, n), d = Math.min(r, u, l);
    d > c && (!a.ending || a.ended) ? (a.ended = !1, this.log(`Removing [${c},${d}] from the ${e} SourceBuffer`), o.remove(c, d)) : this.shiftAndExecuteNext(e);
  }
  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually
  appendExecutor(e, n) {
    const r = this.tracks[n], i = r == null ? void 0 : r.buffer;
    if (!i)
      throw new V$(`Attempting to append to the ${n} SourceBuffer, but it does not exist`);
    r.ending = !1, r.ended = !1, i.appendBuffer(e);
  }
  blockUntilOpen(e) {
    if (this.isUpdating() || this.isQueued())
      this.blockBuffers(e).catch((n) => {
        this.warn(`SourceBuffer blocked callback ${n}`), this.stepOperationQueue(this.sourceBufferTypes);
      });
    else
      try {
        e();
      } catch (n) {
        this.warn(`Callback run without blocking ${this.operationQueue} ${n}`);
      }
  }
  isUpdating() {
    return this.sourceBuffers.some(([e, n]) => e && n.updating);
  }
  isQueued() {
    return this.sourceBuffers.some(([e]) => e && !!this.currentOp(e));
  }
  isPending(e) {
    return !!e && !e.buffer;
  }
  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises
  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue
  // upon completion, since we already do it here
  blockBuffers(e, n = this.sourceBufferTypes) {
    if (!n.length)
      return this.log("Blocking operation requested, but no SourceBuffers exist"), Promise.resolve().then(e);
    const {
      operationQueue: r
    } = this, i = n.map((a) => this.appendBlocker(a));
    return n.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(), Promise.all(i).then((a) => {
      r === this.operationQueue && (e(), this.stepOperationQueue(this.sourceBufferTypes));
    });
  }
  stepOperationQueue(e) {
    e.forEach((n) => {
      var r;
      const i = (r = this.tracks[n]) == null ? void 0 : r.buffer;
      !i || i.updating || this.shiftAndExecuteNext(n);
    });
  }
  append(e, n, r) {
    this.operationQueue && this.operationQueue.append(e, n, r);
  }
  appendBlocker(e) {
    if (this.operationQueue)
      return this.operationQueue.appendBlocker(e);
  }
  currentOp(e) {
    return this.operationQueue ? this.operationQueue.current(e) : null;
  }
  executeNext(e) {
    e && this.operationQueue && this.operationQueue.executeNext(e);
  }
  shiftAndExecuteNext(e) {
    this.operationQueue && this.operationQueue.shiftAndExecuteNext(e);
  }
  get pendingTrackCount() {
    return Object.keys(this.tracks).reduce((e, n) => e + (this.isPending(this.tracks[n]) ? 1 : 0), 0);
  }
  get sourceBufferCount() {
    return this.sourceBuffers.reduce((e, [n]) => e + (n ? 1 : 0), 0);
  }
  get sourceBufferTypes() {
    return this.sourceBuffers.map(([e]) => e).filter((e) => !!e);
  }
  addBufferListener(e, n, r) {
    const i = this.tracks[e];
    if (!i)
      return;
    const s = i.buffer;
    if (!s)
      return;
    const a = r.bind(this, e);
    i.listeners.push({
      event: n,
      listener: a
    }), s.addEventListener(n, a);
  }
  removeBufferListeners(e) {
    const n = this.tracks[e];
    if (!n)
      return;
    const r = n.buffer;
    r && (n.listeners.forEach((i) => {
      r.removeEventListener(i.event, i.listener);
    }), n.listeners.length = 0);
  }
}
function Mg(t) {
  const e = t.querySelectorAll("source");
  [].slice.call(e).forEach((n) => {
    t.removeChild(n);
  });
}
function z$(t, e) {
  const n = self.document.createElement("source");
  n.type = "video/mp4", n.src = e, t.appendChild(n);
}
function Lc(t) {
  return t === "audio" ? 1 : 0;
}
class t0 {
  constructor(e) {
    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  destroy() {
    this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.BUFFER_CODECS, this.onBufferCodecs, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls: e
    } = this;
    e.off(x.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(e, n) {
    const r = this.hls.levels[n.droppedLevel];
    this.isLevelAllowed(r) && this.restrictedLevels.push({
      bitrate: r.bitrate,
      height: r.height,
      width: r.width
    });
  }
  onMediaAttaching(e, n) {
    this.media = n.media instanceof HTMLVideoElement ? n.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();
  }
  onManifestParsed(e, n) {
    const r = this.hls;
    this.restrictedLevels = [], this.firstLevel = n.firstLevel, r.config.capLevelToPlayerSize && n.video && this.startCapping();
  }
  onLevelsUpdated(e, n) {
    this.timer && de(this.autoLevelCapping) && this.detectPlayerSize();
  }
  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted
  // to the first level
  onBufferCodecs(e, n) {
    this.hls.config.capLevelToPlayerSize && n.video && this.startCapping();
  }
  onMediaDetaching() {
    this.stopCapping(), this.media = null;
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const e = this.hls.levels;
      if (e.length) {
        const n = this.hls, r = this.getMaxLevel(e.length - 1);
        r !== this.autoLevelCapping && n.logger.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), n.autoLevelCapping = r, n.autoLevelEnabled && n.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = n.autoLevelCapping;
      }
    }
  }
  /*
   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
   */
  getMaxLevel(e) {
    const n = this.hls.levels;
    if (!n.length)
      return -1;
    const r = n.filter((i, s) => this.isLevelAllowed(i) && s <= e);
    return this.clientRect = null, t0.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
  }
  stopCapping() {
    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);
  }
  getDimensions() {
    if (this.clientRect)
      return this.clientRect;
    const e = this.media, n = {
      width: 0,
      height: 0
    };
    if (e) {
      const r = e.getBoundingClientRect();
      n.width = r.width, n.height = r.height, !n.width && !n.height && (n.width = r.right - r.left || e.width || 0, n.height = r.bottom - r.top || e.height || 0);
    }
    return this.clientRect = n, n;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let e = 1;
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio;
      } catch {
      }
    return Math.min(e, this.hls.config.maxDevicePixelRatio);
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some((r) => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height);
  }
  static getMaxLevelByMediaSize(e, n, r) {
    if (!(e != null && e.length))
      return -1;
    const i = (o, u) => u ? o.width !== u.width || o.height !== u.height : !0;
    let s = e.length - 1;
    const a = Math.max(n, r);
    for (let o = 0; o < e.length; o += 1) {
      const u = e[o];
      if ((u.width >= a || u.height >= a) && i(u, e[o + 1])) {
        s = o;
        break;
      }
    }
    return s;
  }
}
const q$ = {
  /**
   * text file, such as a manifest or playlist
   */
  MANIFEST: "m",
  /**
   * audio only
   */
  AUDIO: "a",
  /**
   * video only
   */
  VIDEO: "v",
  /**
   * muxed audio and video
   */
  MUXED: "av",
  /**
   * init segment
   */
  INIT: "i",
  /**
   * caption or subtitle
   */
  CAPTION: "c",
  /**
   * ISOBMFF timed text track
   */
  TIMED_TEXT: "tt",
  /**
   * cryptographic key, license or certificate.
   */
  KEY: "k",
  /**
   * other
   */
  OTHER: "o"
}, Ht = q$, W$ = {
  /**
   * HTTP Live Streaming (HLS)
   */
  HLS: "h"
}, K$ = W$;
class qn {
  constructor(e, n) {
    Array.isArray(e) && (e = e.map((r) => r instanceof qn ? r : new qn(r))), this.value = e, this.params = n;
  }
}
const j$ = "Dict";
function Y$(t) {
  return Array.isArray(t) ? JSON.stringify(t) : t instanceof Map ? "Map{}" : t instanceof Set ? "Set{}" : typeof t == "object" ? JSON.stringify(t) : String(t);
}
function X$(t, e, n, r) {
  return new Error(`failed to ${t} "${Y$(e)}" as ${n}`, {
    cause: r
  });
}
function Wn(t, e, n) {
  return X$("serialize", t, e, n);
}
class sv {
  constructor(e) {
    this.description = e;
  }
}
const Fg = "Bare Item", Q$ = "Boolean";
function Z$(t) {
  if (typeof t != "boolean")
    throw Wn(t, Q$);
  return t ? "?1" : "?0";
}
function J$(t) {
  return btoa(String.fromCharCode(...t));
}
const eU = "Byte Sequence";
function tU(t) {
  if (ArrayBuffer.isView(t) === !1)
    throw Wn(t, eU);
  return `:${J$(t)}:`;
}
const nU = "Integer";
function rU(t) {
  return t < -999999999999999 || 999999999999999 < t;
}
function av(t) {
  if (rU(t))
    throw Wn(t, nU);
  return t.toString();
}
function iU(t) {
  return `@${av(t.getTime() / 1e3)}`;
}
function ov(t, e) {
  if (t < 0)
    return -ov(-t, e);
  const n = Math.pow(10, e);
  if (Math.abs(t * n % 1 - 0.5) < Number.EPSILON) {
    const i = Math.floor(t * n);
    return (i % 2 === 0 ? i : i + 1) / n;
  } else
    return Math.round(t * n) / n;
}
const sU = "Decimal";
function aU(t) {
  const e = ov(t, 3);
  if (Math.floor(Math.abs(e)).toString().length > 12)
    throw Wn(t, sU);
  const n = e.toString();
  return n.includes(".") ? n : `${n}.0`;
}
const oU = "String", uU = /[\x00-\x1f\x7f]+/;
function lU(t) {
  if (uU.test(t))
    throw Wn(t, oU);
  return `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function cU(t) {
  return t.description || t.toString().slice(7, -1);
}
const dU = "Token";
function Bg(t) {
  const e = cU(t);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
    throw Wn(e, dU);
  return e;
}
function rf(t) {
  switch (typeof t) {
    case "number":
      if (!de(t))
        throw Wn(t, Fg);
      return Number.isInteger(t) ? av(t) : aU(t);
    case "string":
      return lU(t);
    case "symbol":
      return Bg(t);
    case "boolean":
      return Z$(t);
    case "object":
      if (t instanceof Date)
        return iU(t);
      if (t instanceof Uint8Array)
        return tU(t);
      if (t instanceof sv)
        return Bg(t);
    default:
      throw Wn(t, Fg);
  }
}
const fU = "Key";
function sf(t) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(t) === !1)
    throw Wn(t, fU);
  return t;
}
function n0(t) {
  return t == null ? "" : Object.entries(t).map(([e, n]) => n === !0 ? `;${sf(e)}` : `;${sf(e)}=${rf(n)}`).join("");
}
function uv(t) {
  return t instanceof qn ? `${rf(t.value)}${n0(t.params)}` : rf(t);
}
function hU(t) {
  return `(${t.value.map(uv).join(" ")})${n0(t.params)}`;
}
function mU(t, e = {
  whitespace: !0
}) {
  if (typeof t != "object" || t == null)
    throw Wn(t, j$);
  const n = t instanceof Map ? t.entries() : Object.entries(t), r = e != null && e.whitespace ? " " : "";
  return Array.from(n).map(([i, s]) => {
    s instanceof qn || (s = new qn(s));
    let a = sf(i);
    return s.value === !0 ? a += n0(s.params) : (a += "=", Array.isArray(s.value) ? a += hU(s) : a += uv(s)), a;
  }).join(`,${r}`);
}
function lv(t, e) {
  return mU(t, e);
}
const kn = "CMCD-Object", ct = "CMCD-Request", Wr = "CMCD-Session", vr = "CMCD-Status", pU = {
  // Object
  br: kn,
  ab: kn,
  d: kn,
  ot: kn,
  tb: kn,
  tpb: kn,
  lb: kn,
  tab: kn,
  lab: kn,
  url: kn,
  // Request
  pb: ct,
  bl: ct,
  tbl: ct,
  dl: ct,
  ltc: ct,
  mtp: ct,
  nor: ct,
  nrr: ct,
  rc: ct,
  sn: ct,
  sta: ct,
  su: ct,
  ttfb: ct,
  ttfbb: ct,
  ttlb: ct,
  cmsdd: ct,
  cmsds: ct,
  smrt: ct,
  df: ct,
  cs: ct,
  // TODO: Which header to put the `ts` field is not defined yet.
  ts: ct,
  // Session
  cid: Wr,
  pr: Wr,
  sf: Wr,
  sid: Wr,
  st: Wr,
  v: Wr,
  msd: Wr,
  // Status
  bs: vr,
  bsd: vr,
  cdn: vr,
  rtp: vr,
  bg: vr,
  pt: vr,
  ec: vr,
  e: vr
}, gU = {
  /**
   * keys whose values vary with each request.
   */
  REQUEST: ct
};
function bU(t) {
  return Object.keys(t).reduce((e, n) => {
    var r;
    return (r = t[n]) === null || r === void 0 || r.forEach((i) => e[i] = n), e;
  }, {});
}
function EU(t, e) {
  const n = {};
  if (!t)
    return n;
  const r = Object.keys(t), i = e ? bU(e) : {};
  return r.reduce((s, a) => {
    var o;
    const u = pU[a] || i[a] || gU.REQUEST, l = (o = s[u]) !== null && o !== void 0 ? o : s[u] = {};
    return l[a] = t[a], s;
  }, n);
}
function yU(t) {
  return ["ot", "sf", "st", "e", "sta"].includes(t);
}
function TU(t) {
  return typeof t == "number" ? de(t) : t != null && t !== "" && t !== !1;
}
const cv = "event";
function SU(t, e) {
  const n = new URL(t), r = new URL(e);
  if (n.origin !== r.origin)
    return t;
  const i = n.pathname.split("/").slice(1), s = r.pathname.split("/").slice(1, -1);
  for (; i[0] === s[0]; )
    i.shift(), s.shift();
  for (; s.length; )
    s.shift(), i.unshift("..");
  return i.join("/") + n.search + n.hash;
}
const ru = (t) => Math.round(t), af = (t, e) => Array.isArray(t) ? t.map((n) => af(n, e)) : t instanceof qn && typeof t.value == "string" ? new qn(af(t.value, e), t.params) : (e.baseUrl && (t = SU(t, e.baseUrl)), e.version === 1 ? encodeURIComponent(t) : t), wo = (t) => ru(t / 100) * 100, xU = (t, e) => {
  let n = t;
  return e.version >= 2 && (t instanceof qn && typeof t.value == "string" ? n = new qn([t]) : typeof t == "string" && (n = [t])), af(n, e);
}, vU = {
  /**
   * Bitrate (kbps) rounded integer
   */
  br: ru,
  /**
   * Duration (milliseconds) rounded integer
   */
  d: ru,
  /**
   * Buffer Length (milliseconds) rounded nearest 100ms
   */
  bl: wo,
  /**
   * Deadline (milliseconds) rounded nearest 100ms
   */
  dl: wo,
  /**
   * Measured Throughput (kbps) rounded nearest 100kbps
   */
  mtp: wo,
  /**
   * Next Object Request URL encoded
   */
  nor: xU,
  /**
   * Requested maximum throughput (kbps) rounded nearest 100kbps
   */
  rtp: wo,
  /**
   * Top Bitrate (kbps) rounded integer
   */
  tb: ru
}, dv = "request", fv = "response", r0 = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"], AU = ["e"], IU = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
function Il(t) {
  return IU.test(t);
}
function CU(t) {
  return r0.includes(t) || AU.includes(t) || Il(t);
}
const hv = ["d", "dl", "nor", "ot", "rtp", "su"];
function LU(t) {
  return r0.includes(t) || hv.includes(t) || Il(t);
}
const _U = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"];
function RU(t) {
  return r0.includes(t) || hv.includes(t) || _U.includes(t) || Il(t);
}
const wU = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"];
function kU(t) {
  return wU.includes(t) || Il(t);
}
const DU = {
  [fv]: RU,
  [cv]: CU,
  [dv]: LU
};
function mv(t, e = {}) {
  const n = {};
  if (t == null || typeof t != "object")
    return n;
  const r = e.version || t.v || 1, i = e.reportingMode || dv, s = r === 1 ? kU : DU[i];
  let a = Object.keys(t).filter(s);
  const o = e.filter;
  typeof o == "function" && (a = a.filter(o));
  const u = i === fv || i === cv;
  u && !a.includes("ts") && a.push("ts"), r > 1 && !a.includes("v") && a.push("v");
  const l = Xe({}, vU, e.formatters), c = {
    version: r,
    reportingMode: i,
    baseUrl: e.baseUrl
  };
  return a.sort().forEach((d) => {
    let f = t[d];
    const h = l[d];
    if (typeof h == "function" && (f = h(f, c)), d === "v") {
      if (r === 1)
        return;
      f = r;
    }
    d == "pr" && f === 1 || (u && d === "ts" && !de(f) && (f = Date.now()), TU(f) && (yU(d) && typeof f == "string" && (f = new sv(f)), n[d] = f));
  }), n;
}
function PU(t, e = {}) {
  const n = {};
  if (!t)
    return n;
  const r = mv(t, e), i = EU(r, e == null ? void 0 : e.customHeaderMap);
  return Object.entries(i).reduce((s, [a, o]) => {
    const u = lv(o, {
      whitespace: !1
    });
    return u && (s[a] = u), s;
  }, n);
}
function OU(t, e, n) {
  return Xe(t, PU(e, n));
}
const NU = "CMCD";
function MU(t, e = {}) {
  return t ? lv(mv(t, e), {
    whitespace: !1
  }) : "";
}
function FU(t, e = {}) {
  if (!t)
    return "";
  const n = MU(t, e);
  return encodeURIComponent(n);
}
function BU(t, e = {}) {
  if (!t)
    return "";
  const n = FU(t, e);
  return `${NU}=${n}`;
}
const $g = /CMCD=[^&#]+/;
function $U(t, e, n) {
  const r = BU(e, n);
  if (!r)
    return t;
  if ($g.test(t))
    return t.replace($g, r);
  const i = t.includes("?") ? "&" : "?";
  return `${t}${i}${r}`;
}
class UU {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
      this.initialized && (this.starved = !0), this.buffering = !0;
    }, this.onPlaying = () => {
      this.initialized || (this.initialized = !0), this.buffering = !1;
    }, this.applyPlaylistData = (i) => {
      try {
        this.apply(i, {
          ot: Ht.MANIFEST,
          su: !this.initialized
        });
      } catch (s) {
        this.hls.logger.warn("Could not generate manifest CMCD data.", s);
      }
    }, this.applyFragmentData = (i) => {
      try {
        const {
          frag: s,
          part: a
        } = i, o = this.hls.levels[s.level], u = this.getObjectType(s), l = {
          d: (a || s).duration * 1e3,
          ot: u
        };
        (u === Ht.VIDEO || u === Ht.AUDIO || u == Ht.MUXED) && (l.br = o.bitrate / 1e3, l.tb = this.getTopBandwidth(u) / 1e3, l.bl = this.getBufferLength(u));
        const c = a ? this.getNextPart(a) : this.getNextFrag(s);
        c != null && c.url && c.url !== s.url && (l.nor = c.url), this.apply(i, l);
      } catch (s) {
        this.hls.logger.warn("Could not generate segment CMCD data.", s);
      }
    }, this.hls = e;
    const n = this.config = e.config, {
      cmcd: r
    } = n;
    r != null && (n.pLoader = this.createPlaylistLoader(), n.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e.sessionId, this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners());
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHED, this.onMediaDetached, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHED, this.onMediaDetached, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;
  }
  onMediaAttached(e, n) {
    this.media = n.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null);
  }
  onBufferCreated(e, n) {
    var r, i;
    this.audioBuffer = (r = n.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (i = n.tracks.video) == null ? void 0 : i.buffer;
  }
  /**
   * Create baseline CMCD data
   */
  createData() {
    var e;
    return {
      v: 1,
      sf: K$.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    };
  }
  /**
   * Apply CMCD data to a request.
   */
  apply(e, n = {}) {
    Xe(n, this.createData());
    const r = n.ot === Ht.INIT || n.ot === Ht.VIDEO || n.ot === Ht.MUXED;
    this.starved && r && (n.bs = !0, n.su = !0, this.starved = !1), n.su == null && (n.su = this.buffering);
    const {
      includeKeys: i
    } = this;
    i && (n = Object.keys(n).reduce((a, o) => (i.includes(o) && (a[o] = n[o]), a), {}));
    const s = {
      baseUrl: e.url
    };
    this.useHeaders ? (e.headers || (e.headers = {}), OU(e.headers, n, s)) : e.url = $U(e.url, n, s);
  }
  getNextFrag(e) {
    var n;
    const r = (n = this.hls.levels[e.level]) == null ? void 0 : n.details;
    if (r) {
      const i = e.sn - r.startSN;
      return r.fragments[i + 1];
    }
  }
  getNextPart(e) {
    var n;
    const {
      index: r,
      fragment: i
    } = e, s = (n = this.hls.levels[i.level]) == null || (n = n.details) == null ? void 0 : n.partList;
    if (s) {
      const {
        sn: a
      } = i;
      for (let o = s.length - 1; o >= 0; o--) {
        const u = s[o];
        if (u.index === r && u.fragment.sn === a)
          return s[o + 1];
      }
    }
  }
  /**
   * The CMCD object type.
   */
  getObjectType(e) {
    const {
      type: n
    } = e;
    if (n === "subtitle")
      return Ht.TIMED_TEXT;
    if (e.sn === "initSegment")
      return Ht.INIT;
    if (n === "audio")
      return Ht.AUDIO;
    if (n === "main")
      return this.hls.audioTracks.length ? Ht.VIDEO : Ht.MUXED;
  }
  /**
   * Get the highest bitrate.
   */
  getTopBandwidth(e) {
    let n = 0, r;
    const i = this.hls;
    if (e === Ht.AUDIO)
      r = i.audioTracks;
    else {
      const s = i.maxAutoLevel, a = s > -1 ? s + 1 : i.levels.length;
      r = i.levels.slice(0, a);
    }
    return r.forEach((s) => {
      s.bitrate > n && (n = s.bitrate);
    }), n > 0 ? n : NaN;
  }
  /**
   * Get the buffer length for a media type in milliseconds
   */
  getBufferLength(e) {
    const n = this.media, r = e === Ht.AUDIO ? this.audioBuffer : this.videoBuffer;
    return !r || !n ? NaN : Ce.bufferInfo(r, n.currentTime, this.config.maxBufferHole).len * 1e3;
  }
  /**
   * Create a playlist loader
   */
  createPlaylistLoader() {
    const {
      pLoader: e
    } = this.config, n = this.applyPlaylistData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        n(s), this.loader.load(s, a, o);
      }
    };
  }
  /**
   * Create a playlist loader
   */
  createFragmentLoader() {
    const {
      fLoader: e
    } = this.config, n = this.applyFragmentData, r = e || this.config.loader;
    return class {
      constructor(s) {
        this.loader = void 0, this.loader = new r(s);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(s, a, o) {
        n(s), this.loader.load(s, a, o);
      }
    };
  }
}
const HU = 3e5;
class VU extends En {
  constructor(e) {
    super("content-steering", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.ERROR, this.onError, this));
  }
  pathways() {
    return (this.levels || []).reduce((e, n) => (e.indexOf(n.pathwayId) === -1 && e.push(n.pathwayId), e), []);
  }
  get pathwayPriority() {
    return this._pathwayPriority;
  }
  set pathwayPriority(e) {
    this.updatePathwayPriority(e);
  }
  startLoad() {
    if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {
      if (this.updated) {
        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
        if (e > 0) {
          this.scheduleRefresh(this.uri, e);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();
  }
  clearTimeout() {
    this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(e) {
    const n = this.levels;
    n && (this.levels = n.filter((r) => r !== e));
  }
  onManifestLoading() {
    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(e, n) {
    const {
      contentSteering: r
    } = n;
    r !== null && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad());
  }
  onManifestParsed(e, n) {
    this.audioTracks = n.audioTracks, this.subtitleTracks = n.subtitleTracks;
  }
  onError(e, n) {
    const {
      errorAction: r
    } = n;
    if ((r == null ? void 0 : r.action) === Lt.SendAlternateToPenaltyBox && r.flags === an.MoveAllAlternatesMatchingHost) {
      const i = this.levels;
      let s = this._pathwayPriority, a = this.pathwayId;
      if (n.context) {
        const {
          groupId: o,
          pathwayId: u,
          type: l
        } = n.context;
        o && i ? a = this.getPathwayForGroupId(o, l, a) : u && (a = u);
      }
      a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()), !s && i && (s = this.pathways()), s && s.length > 1 && (this.updatePathwayPriority(s), r.resolved = this.pathwayId !== a), n.details === q.BUFFER_APPEND_ERROR && !n.fatal ? r.resolved = !0 : r.resolved || this.warn(`Could not resolve ${n.details} ("${n.error.message}") with content-steering for Pathway: ${a} levels: ${i && i.length} priorities: ${Ze(s)} penalized: ${Ze(this.penalizedPathways)}`);
    }
  }
  filterParsedLevels(e) {
    this.levels = e;
    let n = this.getLevelsForPathway(this.pathwayId);
    if (n.length === 0) {
      const r = e[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`), n = this.getLevelsForPathway(r), this.pathwayId = r;
    }
    return n.length !== e.length && this.log(`Found ${n.length}/${e.length} levels in Pathway "${this.pathwayId}"`), n;
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((n) => e === n.pathwayId);
  }
  updatePathwayPriority(e) {
    this._pathwayPriority = e;
    let n;
    const r = this.penalizedPathways, i = performance.now();
    Object.keys(r).forEach((s) => {
      i - r[s] > HU && delete r[s];
    });
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (a in r)
        continue;
      if (a === this.pathwayId)
        return;
      const o = this.hls.nextLoadLevel, u = this.hls.levels[o];
      if (n = this.getLevelsForPathway(a), n.length > 0) {
        this.log(`Setting Pathway to "${a}"`), this.pathwayId = a, Ox(n), this.hls.trigger(x.LEVELS_UPDATED, {
          levels: n
        });
        const l = this.hls.levels[o];
        u && l && this.levels && (l.attrs["STABLE-VARIANT-ID"] !== u.attrs["STABLE-VARIANT-ID"] && l.bitrate !== u.bitrate && this.log(`Unstable Pathways change from bitrate ${u.bitrate} to ${l.bitrate}`), this.hls.nextLoadLevel = o);
        break;
      }
    }
  }
  getPathwayForGroupId(e, n, r) {
    const i = this.getLevelsForPathway(r).concat(this.levels || []);
    for (let s = 0; s < i.length; s++)
      if (n === Me.AUDIO_TRACK && i[s].hasAudioGroup(e) || n === Me.SUBTITLE_TRACK && i[s].hasSubtitleGroup(e))
        return i[s].pathwayId;
    return r;
  }
  clonePathways(e) {
    const n = this.levels;
    if (!n)
      return;
    const r = {}, i = {};
    e.forEach((s) => {
      const {
        ID: a,
        "BASE-ID": o,
        "URI-REPLACEMENT": u
      } = s;
      if (n.some((c) => c.pathwayId === a))
        return;
      const l = this.getLevelsForPathway(o).map((c) => {
        const d = new ut(c.attrs);
        d["PATHWAY-ID"] = a;
        const f = d.AUDIO && `${d.AUDIO}_clone_${a}`, h = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`;
        f && (r[d.AUDIO] = f, d.AUDIO = f), h && (i[d.SUBTITLES] = h, d.SUBTITLES = h);
        const m = pv(c.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", u), p = new Ia({
          attrs: d,
          audioCodec: c.audioCodec,
          bitrate: c.bitrate,
          height: c.height,
          name: c.name,
          url: m,
          videoCodec: c.videoCodec,
          width: c.width
        });
        if (c.audioGroups)
          for (let g = 1; g < c.audioGroups.length; g++)
            p.addGroupId("audio", `${c.audioGroups[g]}_clone_${a}`);
        if (c.subtitleGroups)
          for (let g = 1; g < c.subtitleGroups.length; g++)
            p.addGroupId("text", `${c.subtitleGroups[g]}_clone_${a}`);
        return p;
      });
      n.push(...l), Ug(this.audioTracks, r, u, a), Ug(this.subtitleTracks, i, u, a);
    });
  }
  loadSteeringManifest(e) {
    const n = this.hls.config, r = n.loader;
    this.loader && this.loader.destroy(), this.loader = new r(n);
    let i;
    try {
      i = new self.URL(e);
    } catch {
      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);
      return;
    }
    if (i.protocol !== "data:") {
      const c = (this.hls.bandwidthEstimate || n.abrEwmaDefaultEstimate) | 0;
      i.searchParams.set("_HLS_pathway", this.pathwayId), i.searchParams.set("_HLS_throughput", "" + c);
    }
    const s = {
      responseType: "json",
      url: i.href
    }, a = n.steeringManifestLoadPolicy.default, o = a.errorRetry || a.timeoutRetry || {}, u = {
      loadPolicy: a,
      timeout: a.maxLoadTimeMs,
      maxRetry: o.maxNumRetry || 0,
      retryDelay: o.retryDelayMs || 0,
      maxRetryDelay: o.maxRetryDelayMs || 0
    }, l = {
      onSuccess: (c, d, f, h) => {
        this.log(`Loaded steering manifest: "${i}"`);
        const m = c.data;
        if ((m == null ? void 0 : m.VERSION) !== 1) {
          this.log(`Steering VERSION ${m.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now(), this.timeToLoad = m.TTL;
        const {
          "RELOAD-URI": p,
          "PATHWAY-CLONES": g,
          "PATHWAY-PRIORITY": b
        } = m;
        if (p)
          try {
            this.uri = new self.URL(p, i).href;
          } catch {
            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${p}`);
            return;
          }
        this.scheduleRefresh(this.uri || f.url), g && this.clonePathways(g);
        const y = {
          steeringManifest: m,
          url: i.toString()
        };
        this.hls.trigger(x.STEERING_MANIFEST_LOADED, y), b && this.updatePathwayPriority(b);
      },
      onError: (c, d, f, h) => {
        if (this.log(`Error loading steering manifest: ${c.code} ${c.text} (${d.url})`), this.stopLoad(), c.code === 410) {
          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);
          return;
        }
        let m = this.timeToLoad * 1e3;
        if (c.code === 429) {
          const p = this.loader;
          if (typeof (p == null ? void 0 : p.getResponseHeader) == "function") {
            const g = p.getResponseHeader("Retry-After");
            g && (m = parseFloat(g) * 1e3);
          }
          this.log(`Steering manifest ${d.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || d.url, m);
      },
      onTimeout: (c, d, f) => {
        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);
      }
    };
    this.log(`Requesting steering manifest: ${i}`), this.loader.load(s, u, l);
  }
  scheduleRefresh(e, n = this.timeToLoad * 1e3) {
    this.clearTimeout(), this.reloadTimer = self.setTimeout(() => {
      var r;
      const i = (r = this.hls) == null ? void 0 : r.media;
      if (i && !i.ended) {
        this.loadSteeringManifest(e);
        return;
      }
      this.scheduleRefresh(e, this.timeToLoad * 1e3);
    }, n);
  }
}
function Ug(t, e, n, r) {
  t && Object.keys(e).forEach((i) => {
    const s = t.filter((a) => a.groupId === i).map((a) => {
      const o = Xe({}, a);
      return o.details = void 0, o.attrs = new ut(o.attrs), o.url = o.attrs.URI = pv(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", n), o.groupId = o.attrs["GROUP-ID"] = e[i], o.attrs["PATHWAY-ID"] = r, o;
    });
    t.push(...s);
  });
}
function pv(t, e, n, r) {
  const {
    HOST: i,
    PARAMS: s,
    [n]: a
  } = r;
  let o;
  e && (o = a == null ? void 0 : a[e], o && (t = o));
  const u = new self.URL(t);
  return i && !o && (u.host = i), s && Object.keys(s).sort().forEach((l) => {
    l && u.searchParams.set(l, s[l]);
  }), u.href;
}
class Xi extends En {
  constructor(e) {
    super("eme", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = Xi.CDMCleanupPromise ? [Xi.CDMCleanupPromise] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = (n) => {
      const {
        initDataType: r,
        initData: i
      } = n, s = `"${n.type}" event: init data type: "${r}"`;
      if (this.debug(s), i !== null) {
        if (!this.keyFormatPromise) {
          let a = Object.keys(this.keySystemAccessPromises);
          a.length || (a = Ks(this.config));
          const o = a.map(yc).filter((u) => !!u);
          this.keyFormatPromise = this.getKeyFormatPromise(o);
        }
        this.keyFormatPromise.then((a) => {
          const o = eu(a);
          if (r !== "sinf" || o !== lt.FAIRPLAY) {
            this.log(`Ignoring "${n.type}" event with init data type: "${r}" for selected key-system ${o}`);
            return;
          }
          let u;
          try {
            const h = Et(new Uint8Array(i)), m = qh(JSON.parse(h).sinf), p = lx(m);
            if (!p)
              throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
            u = new Uint8Array(p.subarray(8, 24));
          } catch (h) {
            this.warn(`${s} Failed to parse sinf: ${h}`);
            return;
          }
          const l = Ft(u), {
            keyIdToKeySessionPromise: c,
            mediaKeySessions: d
          } = this;
          let f = c[l];
          for (let h = 0; h < d.length; h++) {
            const m = d[h], p = m.decryptdata;
            if (!p.keyId)
              continue;
            const g = Ft(p.keyId);
            if (Fu(u, p.keyId) || p.uri.replace(/-/g, "").indexOf(l) !== -1) {
              if (f = c[g], !f)
                continue;
              if (p.pssh)
                break;
              delete c[g], p.pssh = new Uint8Array(i), p.keyId = u, f = c[l] = f.then(() => this.generateRequestWithPreferredKeySession(m, r, i, "encrypted-event-key-match")), f.catch((b) => this.handleError(b));
              break;
            }
          }
          f || this.handleError(new Error(`Key ID ${l} not encountered in playlist. Key-system sessions ${d.length}.`));
        }).catch((a) => this.handleError(a));
      }
    }, this.onWaitingForKey = (n) => {
      this.log(`"${n.type}" event`);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  destroy() {
    this.onDestroying(), this.onMediaDetached();
    const e = this.config;
    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(x.DESTROYING, this.onDestroying, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(x.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(x.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(x.DESTROYING, this.onDestroying, this);
  }
  getLicenseServerUrl(e) {
    const {
      drmSystems: n,
      widevineLicenseUrl: r
    } = this.config, i = n == null ? void 0 : n[e];
    if (i)
      return i.licenseUrl;
    if (e === lt.WIDEVINE && r)
      return r;
  }
  getLicenseServerUrlOrThrow(e) {
    const n = this.getLicenseServerUrl(e);
    if (n === void 0)
      throw new Error(`no license server URL configured for key-system "${e}"`);
    return n;
  }
  getServerCertificateUrl(e) {
    const {
      drmSystems: n
    } = this.config, r = n == null ? void 0 : n[e];
    if (r)
      return r.serverCertificateUrl;
    this.log(`No Server Certificate in config.drmSystems["${e}"]`);
  }
  attemptKeySystemAccess(e) {
    const n = this.hls.levels, r = (a, o, u) => !!a && u.indexOf(a) === o, i = n.map((a) => a.audioCodec).filter(r), s = n.map((a) => a.videoCodec).filter(r);
    return i.length + s.length === 0 && s.push("avc1.42e01e"), new Promise((a, o) => {
      const u = (l) => {
        const c = l.shift();
        this.getMediaKeysPromise(c, i, s).then((d) => a({
          keySystem: c,
          mediaKeys: d
        })).catch((d) => {
          l.length ? u(l) : d instanceof sn ? o(d) : o(new sn({
            type: be.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_NO_ACCESS,
            error: d,
            fatal: !0
          }, d.message));
        });
      };
      u(e);
    });
  }
  requestMediaKeySystemAccess(e, n) {
    const {
      requestMediaKeySystemAccessFunc: r
    } = this.config;
    if (typeof r != "function") {
      let i = `Configured requestMediaKeySystemAccess is not a function ${r}`;
      return Cx === null && self.location.protocol === "http:" && (i = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(i));
    }
    return r(e, n);
  }
  getMediaKeysPromise(e, n, r) {
    var i;
    const s = x9(e, n, r, this.config.drmSystemOptions || {});
    let a = this.keySystemAccessPromises[e], o = (i = a) == null ? void 0 : i.keySystemAccess;
    if (!o) {
      this.log(`Requesting encrypted media "${e}" key-system access with config: ${Ze(s)}`), o = this.requestMediaKeySystemAccess(e, s);
      const u = a = this.keySystemAccessPromises[e] = {
        keySystemAccess: o
      };
      return o.catch((l) => {
        this.log(`Failed to obtain access to key-system "${e}": ${l}`);
      }), o.then((l) => {
        this.log(`Access for key-system "${l.keySystem}" obtained`);
        const c = this.fetchServerCertificate(e);
        this.log(`Create media-keys for "${e}"`);
        const d = u.mediaKeys = l.createMediaKeys().then((f) => (this.log(`Media-keys created for "${e}"`), u.hasMediaKeys = !0, c.then((h) => h ? this.setMediaKeysServerCertificate(f, e, h) : f)));
        return d.catch((f) => {
          this.error(`Failed to create media-keys for "${e}"}: ${f}`);
        }), d;
      });
    }
    return o.then(() => a.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata: e,
    keySystem: n,
    mediaKeys: r
  }) {
    this.log(`Creating key-system session "${n}" keyId: ${Ft(e.keyId || [])} keyUri: ${e.uri}`);
    const i = r.createSession(), s = {
      decryptdata: e,
      keySystem: n,
      mediaKeys: r,
      mediaKeysSession: i,
      keyStatus: "status-pending"
    };
    return this.mediaKeySessions.push(s), s;
  }
  renewKeySession(e) {
    const n = e.decryptdata;
    if (n.pssh) {
      const r = this.createMediaKeySessionContext(e), i = ko(n), s = "cenc";
      this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(r, s, n.pssh.buffer, "expired");
    } else
      this.warn("Could not renew expired session. Missing pssh initData.");
    this.removeSession(e);
  }
  updateKeySession(e, n) {
    const r = e.mediaKeysSession;
    return this.log(`Updating key-session "${r.sessionId}" for keyId ${Ft(e.decryptdata.keyId || [])}
      } (data length: ${n.byteLength})`), r.update(n);
  }
  getSelectedKeySystemFormats() {
    return Object.keys(this.keySystemAccessPromises).map((e) => ({
      keySystem: e,
      hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
    })).filter(({
      hasMediaKeys: e
    }) => !!e).map(({
      keySystem: e
    }) => yc(e)).filter((e) => !!e);
  }
  getKeySystemAccess(e) {
    return this.getKeySystemSelectionPromise(e).then(({
      keySystem: n,
      mediaKeys: r
    }) => this.attemptSetMediaKeys(n, r));
  }
  selectKeySystem(e) {
    return new Promise((n, r) => {
      this.getKeySystemSelectionPromise(e).then(({
        keySystem: i
      }) => {
        const s = yc(i);
        s ? n(s) : r(new Error(`Unable to find format for key-system "${i}"`));
      }).catch(r);
    });
  }
  selectKeySystemFormat(e) {
    const n = Object.keys(e.levelkeys || {});
    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${n.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(n)), this.keyFormatPromise;
  }
  getKeyFormatPromise(e) {
    const n = Ks(this.config), r = e.map(eu).filter((i) => !!i && n.indexOf(i) !== -1);
    return this.selectKeySystem(r);
  }
  getKeyStatus(e) {
    const {
      mediaKeySessions: n
    } = this;
    for (let r = 0; r < n.length; r++) {
      const i = GU(e, n[r]);
      if (i)
        return i;
    }
  }
  loadKey(e) {
    const n = e.keyInfo.decryptdata, r = ko(n), i = this.bannedKeyIds[r];
    if (i || this.getKeyStatus(n) === "internal-error") {
      const o = Hg(i || "internal-error", n);
      return this.handleError(o, e.frag), Promise.reject(o);
    }
    const s = `(keyId: ${r} format: "${n.keyFormat}" method: ${n.method} uri: ${n.uri})`;
    this.log(`Starting session for key ${s}`);
    const a = this.keyIdToKeySessionPromise[r];
    if (!a) {
      const o = this.getKeySystemForKeyPromise(n).then(({
        keySystem: u,
        mediaKeys: l
      }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${s}`), this.attemptSetMediaKeys(u, l).then(() => (this.throwIfDestroyed(), this.createMediaKeySessionContext({
        keySystem: u,
        mediaKeys: l,
        decryptdata: n
      }))))).then((u) => {
        const l = "cenc", c = n.pssh ? n.pssh.buffer : null;
        return this.generateRequestWithPreferredKeySession(u, l, c, "playlist-key");
      });
      return o.catch((u) => this.handleError(u, e.frag)), this.keyIdToKeySessionPromise[r] = o, o;
    }
    return a.catch((o) => {
      if (o instanceof sn) {
        const u = ze({}, o.data);
        this.getKeyStatus(n) === "internal-error" && (u.decryptdata = n);
        const l = new sn(u, o.message);
        this.handleError(l, e.frag);
      }
    }), a;
  }
  throwIfDestroyed(e = "Invalid state") {
    if (!this.hls)
      throw new Error("invalid state");
  }
  handleError(e, n) {
    if (this.hls)
      if (e instanceof sn) {
        n && (e.data.frag = n);
        const r = e.data.decryptdata;
        this.error(`${e.message}${r ? ` (${Ft(r.keyId || [])})` : ""}`), this.hls.trigger(x.ERROR, e.data);
      } else
        this.error(e.message), this.hls.trigger(x.ERROR, {
          type: be.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_NO_KEYS,
          error: e,
          fatal: !0
        });
  }
  getKeySystemForKeyPromise(e) {
    const n = ko(e), r = this.keyIdToKeySessionPromise[n];
    if (!r) {
      const i = eu(e.keyFormat), s = i ? [i] : Ks(this.config);
      return this.attemptKeySystemAccess(s);
    }
    return r;
  }
  getKeySystemSelectionPromise(e) {
    if (e.length || (e = Ks(this.config)), e.length === 0)
      throw new sn({
        type: be.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: !0
      }, `Missing key-system license configuration options ${Ze({
        drmSystems: this.config.drmSystems
      })}`);
    return this.attemptKeySystemAccess(e);
  }
  attemptSetMediaKeys(e, n) {
    if (this.mediaKeys === n)
      return Promise.resolve();
    const r = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${e}"`);
    const i = Promise.all(r).then(() => {
      if (!this.media)
        throw this.mediaKeys = null, new Error("Attempted to set mediaKeys without media element attached");
      return this.media.setMediaKeys(n);
    });
    return this.mediaKeys = n, this.setMediaKeysQueue.push(i), i.then(() => {
      this.log(`Media-keys set for "${e}"`), r.push(i), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((s) => r.indexOf(s) === -1);
    });
  }
  generateRequestWithPreferredKeySession(e, n, r, i) {
    var s;
    const a = (s = this.config.drmSystems) == null || (s = s[e.keySystem]) == null ? void 0 : s.generateRequest;
    if (a)
      try {
        const m = a.call(this.hls, n, r, e);
        if (!m)
          throw new Error("Invalid response from configured generateRequest filter");
        n = m.initDataType, r = m.initData ? m.initData : null, e.decryptdata.pssh = r ? new Uint8Array(r) : null;
      } catch (m) {
        if (this.warn(m.message), this.hls && this.hls.config.debug)
          throw m;
      }
    if (r === null)
      return this.log(`Skipping key-session request for "${i}" (no initData)`), Promise.resolve(e);
    const o = ko(e.decryptdata), u = e.decryptdata.uri;
    this.log(`Generating key-session request for "${i}" keyId: ${o} URI: ${u} (init data type: ${n} length: ${r.byteLength})`);
    const l = new Kh(), c = e._onmessage = (m) => {
      const p = e.mediaKeysSession;
      if (!p) {
        l.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType: g,
        message: b
      } = m;
      this.log(`"${g}" message event for session "${p.sessionId}" message size: ${b.byteLength}`), g === "license-request" || g === "license-renewal" ? this.renewLicense(e, b).catch((y) => {
        l.eventNames().length ? l.emit("error", y) : this.handleError(y);
      }) : g === "license-release" ? e.keySystem === lt.FAIRPLAY && this.updateKeySession(e, Qd("acknowledged")).then(() => this.removeSession(e)).catch((y) => this.handleError(y)) : this.warn(`unhandled media key message type "${g}"`);
    }, d = (m, p) => {
      p.keyStatus = m;
      let g;
      m.startsWith("usable") ? l.emit("resolved") : m === "internal-error" || m === "output-restricted" || m === "output-downscaled" ? g = Hg(m, p.decryptdata) : m === "expired" ? g = new Error(`key expired (keyId: ${o})`) : m === "released" ? g = new Error("key released") : m === "status-pending" || this.warn(`unhandled key status change "${m}" (keyId: ${o})`), g && (l.eventNames().length ? l.emit("error", g) : this.handleError(g));
    }, f = e._onkeystatuseschange = (m) => {
      if (!e.mediaKeysSession) {
        l.emit("error", new Error("invalid state"));
        return;
      }
      const g = this.getKeyStatuses(e);
      if (!Object.keys(g).some((S) => g[S] !== "status-pending"))
        return;
      if (g[o] === "expired") {
        this.log(`Expired key ${Ze(g)} in key-session "${e.mediaKeysSession.sessionId}"`), this.renewKeySession(e);
        return;
      }
      let y = g[o];
      if (y)
        d(y, e);
      else {
        var T;
        e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (T = e.keyStatusTimeouts)[o] || (T[o] = self.setTimeout(() => {
          if (!e.mediaKeysSession || !this.mediaKeys)
            return;
          const I = this.getKeyStatus(e.decryptdata);
          if (I && I !== "status-pending")
            return this.log(`No status for keyId ${o} in key-session "${e.mediaKeysSession.sessionId}". Using session key-status ${I} from other session.`), d(I, e);
          this.log(`key status for ${o} in key-session "${e.mediaKeysSession.sessionId}" timed out after 1000ms`), y = "internal-error", d(y, e);
        }, 1e3)), this.log(`No status for keyId ${o} (${Ze(g)}).`);
      }
    };
    Bt(e.mediaKeysSession, "message", c), Bt(e.mediaKeysSession, "keystatuseschange", f);
    const h = new Promise((m, p) => {
      l.on("error", p), l.on("resolved", m);
    });
    return e.mediaKeysSession.generateRequest(n, r).then(() => {
      this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${o} URI: ${u}`);
    }).catch((m) => {
      throw new sn({
        type: be.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_NO_SESSION,
        error: m,
        decryptdata: e.decryptdata,
        fatal: !1
      }, `Error generating key-session request: ${m}`);
    }).then(() => h).catch((m) => (l.removeAllListeners(), this.removeSession(e).then(() => {
      throw m;
    }))).then(() => (l.removeAllListeners(), e));
  }
  getKeyStatuses(e) {
    const n = {};
    return e.mediaKeysSession.keyStatuses.forEach((r, i) => {
      if (typeof i == "string" && typeof r == "object") {
        const o = i;
        i = r, r = o;
      }
      const s = "buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i);
      e.keySystem === lt.PLAYREADY && s.length === 16 && Ax(s);
      const a = Ft(s);
      r === "internal-error" && (this.bannedKeyIds[a] = r), this.log(`key status change "${r}" for keyStatuses keyId: ${a} key-session "${e.mediaKeysSession.sessionId}"`), n[a] = r;
    }), n;
  }
  fetchServerCertificate(e) {
    const n = this.config, r = n.loader, i = new r(n), s = this.getServerCertificateUrl(e);
    return s ? (this.log(`Fetching server certificate for "${e}"`), new Promise((a, o) => {
      const u = {
        responseType: "arraybuffer",
        url: s
      }, l = n.certLoadPolicy.default, c = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, m, p) => {
          a(f.data);
        },
        onError: (f, h, m, p) => {
          o(new sn({
            type: be.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: m,
            response: ze({
              url: u.url,
              data: void 0
            }, f)
          }, `"${e}" certificate request failed (${s}). Status: ${f.code} (${f.text})`));
        },
        onTimeout: (f, h, m) => {
          o(new sn({
            type: be.KEY_SYSTEM_ERROR,
            details: q.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: !0,
            networkDetails: m,
            response: {
              url: u.url,
              data: void 0
            }
          }, `"${e}" certificate request timed out (${s})`));
        },
        onAbort: (f, h, m) => {
          o(new Error("aborted"));
        }
      };
      i.load(u, c, d);
    })) : Promise.resolve();
  }
  setMediaKeysServerCertificate(e, n, r) {
    return new Promise((i, s) => {
      e.setServerCertificate(r).then((a) => {
        this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${r.byteLength}) on "${n}"`), i(e);
      }).catch((a) => {
        s(new sn({
          type: be.KEY_SYSTEM_ERROR,
          details: q.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error: a,
          fatal: !0
        }, a.message));
      });
    });
  }
  renewLicense(e, n) {
    return this.requestLicense(e, new Uint8Array(n)).then((r) => this.updateKeySession(e, new Uint8Array(r)).catch((i) => {
      throw new sn({
        type: be.KEY_SYSTEM_ERROR,
        details: q.KEY_SYSTEM_SESSION_UPDATE_FAILED,
        decryptdata: e.decryptdata,
        error: i,
        fatal: !1
      }, i.message);
    }));
  }
  unpackPlayReadyKeyMessage(e, n) {
    const r = String.fromCharCode.apply(null, new Uint16Array(n.buffer));
    if (!r.includes("PlayReadyKeyMessage"))
      return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"), n;
    const i = new DOMParser().parseFromString(r, "application/xml"), s = i.querySelectorAll("HttpHeader");
    if (s.length > 0) {
      let c;
      for (let d = 0, f = s.length; d < f; d++) {
        var a, o;
        c = s[d];
        const h = (a = c.querySelector("name")) == null ? void 0 : a.textContent, m = (o = c.querySelector("value")) == null ? void 0 : o.textContent;
        h && m && e.setRequestHeader(h, m);
      }
    }
    const u = i.querySelector("Challenge"), l = u == null ? void 0 : u.textContent;
    if (!l)
      throw new Error("Cannot find <Challenge> in key message");
    return Qd(atob(l));
  }
  setupLicenseXHR(e, n, r, i) {
    const s = this.config.licenseXhrSetup;
    return s ? Promise.resolve().then(() => {
      if (!r.decryptdata)
        throw new Error("Key removed");
      return s.call(this.hls, e, n, r, i);
    }).catch((a) => {
      if (!r.decryptdata)
        throw a;
      return e.open("POST", n, !0), s.call(this.hls, e, n, r, i);
    }).then((a) => (e.readyState || e.open("POST", n, !0), {
      xhr: e,
      licenseChallenge: a || i
    })) : (e.open("POST", n, !0), Promise.resolve({
      xhr: e,
      licenseChallenge: i
    }));
  }
  requestLicense(e, n) {
    const r = this.config.keyLoadPolicy.default;
    return new Promise((i, s) => {
      const a = this.getLicenseServerUrlOrThrow(e.keySystem);
      this.log(`Sending license request to URL: ${a}`);
      const o = new XMLHttpRequest();
      o.responseType = "arraybuffer", o.onreadystatechange = () => {
        if (!this.hls || !e.mediaKeysSession)
          return s(new Error("invalid state"));
        if (o.readyState === 4)
          if (o.status === 200) {
            this._requestLicenseFailureCount = 0;
            let u = o.response;
            this.log(`License received ${u instanceof ArrayBuffer ? u.byteLength : u}`);
            const l = this.config.licenseResponseCallback;
            if (l)
              try {
                u = l.call(this.hls, o, a, e);
              } catch (c) {
                this.error(c);
              }
            i(u);
          } else {
            const u = r.errorRetry, l = u ? u.maxNumRetry : 0;
            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || o.status >= 400 && o.status < 500)
              s(new sn({
                type: be.KEY_SYSTEM_ERROR,
                details: q.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                decryptdata: e.decryptdata,
                fatal: !0,
                networkDetails: o,
                response: {
                  url: a,
                  data: void 0,
                  code: o.status,
                  text: o.statusText
                }
              }, `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`));
            else {
              const c = l - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${c} attempts left`), this.requestLicense(e, n).then(i, s);
            }
          }
      }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = o, this.setupLicenseXHR(o, a, e, n).then(({
        xhr: u,
        licenseChallenge: l
      }) => {
        e.keySystem == lt.PLAYREADY && (l = this.unpackPlayReadyKeyMessage(u, l)), u.send(l);
      }).catch(s);
    });
  }
  onDestroying() {
    this.unregisterListeners(), this._clear();
  }
  onMediaAttached(e, n) {
    if (!this.config.emeEnabled)
      return;
    const r = n.media;
    this.media = r, Bt(r, "encrypted", this.onMediaEncrypted), Bt(r, "waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const e = this.media;
    e && (zt(e, "encrypted", this.onMediaEncrypted), zt(e, "waitingforkey", this.onWaitingForKey), this.media = null, this.mediaKeys = null);
  }
  _clear() {
    var e;
    if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {}, !this.mediaKeys && !this.mediaKeySessions.length)
      return;
    const n = this.media, r = this.mediaKeySessions.slice();
    this.mediaKeySessions = [], this.mediaKeys = null, ni.clearKeyUriToKeyIdMap();
    const i = r.length;
    Xi.CDMCleanupPromise = Promise.all(r.map((s) => this.removeSession(s)).concat((n == null || (e = n.setMediaKeys(null)) == null ? void 0 : e.catch((s) => {
      this.log(`Could not clear media keys: ${s}`), this.hls && this.hls.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
        fatal: !1,
        error: new Error(`Could not clear media keys: ${s}`)
      });
    })) || Promise.resolve())).catch((s) => {
      this.log(`Could not close sessions and clear media keys: ${s}`), this.hls && this.hls.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
        fatal: !1,
        error: new Error(`Could not close sessions and clear media keys: ${s}`)
      });
    }).then(() => {
      i && this.log("finished closing key sessions and clearing media keys");
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null, this.bannedKeyIds = {};
  }
  onManifestLoaded(e, {
    sessionKeys: n
  }) {
    if (!(!n || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const r = n.reduce((i, s) => (i.indexOf(s.keyFormat) === -1 && i.push(s.keyFormat), i), []);
      this.log(`Selecting key-system from session-keys ${r.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(r);
    }
  }
  removeSession(e) {
    const {
      mediaKeysSession: n,
      licenseXhr: r,
      decryptdata: i
    } = e;
    if (n) {
      this.log(`Remove licenses and keys and close session "${n.sessionId}" keyId: ${Ft((i == null ? void 0 : i.keyId) || [])}`), e._onmessage && (n.removeEventListener("message", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange && (n.removeEventListener("keystatuseschange", e._onkeystatuseschange), e._onkeystatuseschange = void 0), r && r.readyState !== XMLHttpRequest.DONE && r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
      const s = this.mediaKeySessions.indexOf(e);
      s > -1 && this.mediaKeySessions.splice(s, 1);
      const {
        keyStatusTimeouts: a
      } = e;
      a && Object.keys(a).forEach((l) => self.clearTimeout(a[l]));
      const {
        drmSystemOptions: o
      } = this.config;
      return (A9(o) ? new Promise((l, c) => {
        self.setTimeout(() => c(new Error("MediaKeySession.remove() timeout")), 8e3), n.remove().then(l).catch(c);
      }) : Promise.resolve()).catch((l) => {
        this.log(`Could not remove session: ${l}`), this.hls && this.hls.trigger(x.ERROR, {
          type: be.OTHER_ERROR,
          details: q.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not remove session: ${l}`)
        });
      }).then(() => n.close()).catch((l) => {
        this.log(`Could not close session: ${l}`), this.hls && this.hls.trigger(x.ERROR, {
          type: be.OTHER_ERROR,
          details: q.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
          fatal: !1,
          error: new Error(`Could not close session: ${l}`)
        });
      });
    }
    return Promise.resolve();
  }
}
Xi.CDMCleanupPromise = void 0;
function ko(t) {
  if (!t)
    throw new Error("Could not read keyId of undefined decryptdata");
  if (t.keyId === null)
    throw new Error("keyId is null");
  return Ft(t.keyId);
}
function GU(t, e) {
  if (t.keyId && e.mediaKeysSession.keyStatuses.has(t.keyId))
    return e.mediaKeysSession.keyStatuses.get(t.keyId);
  if (t.matches(e.decryptdata))
    return e.keyStatus;
}
class sn extends Error {
  constructor(e, n) {
    super(n), this.data = void 0, e.error || (e.error = new Error(n)), this.data = e, e.err = e.error;
  }
}
function Hg(t, e) {
  const n = t === "output-restricted", r = n ? q.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : q.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
  return new sn({
    type: be.KEY_SYSTEM_ERROR,
    details: r,
    fatal: !1,
    decryptdata: e
  }, n ? "HDCP level output restricted" : `key status changed to "${t}"`);
}
class zU {
  constructor(e) {
    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();
  }
  setStreamController(e) {
    this.streamController = e;
  }
  registerListeners() {
    this.hls.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListeners() {
    this.hls.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(x.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  destroy() {
    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;
  }
  onMediaAttaching(e, n) {
    const r = this.hls.config;
    if (r.capLevelOnFPSDrop) {
      const i = n.media instanceof self.HTMLVideoElement ? n.media : null;
      this.media = i, i && typeof i.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);
    }
  }
  onMediaDetaching() {
    this.media = null;
  }
  checkFPS(e, n, r) {
    const i = performance.now();
    if (n) {
      if (this.lastTime) {
        const s = i - this.lastTime, a = r - this.lastDroppedFrames, o = n - this.lastDecodedFrames, u = 1e3 * a / s, l = this.hls;
        if (l.trigger(x.FPS_DROP, {
          currentDropped: a,
          currentDecoded: o,
          totalDroppedFrames: r
        }), u > 0 && a > l.config.fpsDroppedMonitoringThreshold * o) {
          let c = l.currentLevel;
          l.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + c), c > 0 && (l.autoLevelCapping === -1 || l.autoLevelCapping >= c) && (c = c - 1, l.trigger(x.FPS_DROP_LEVEL_CAPPING, {
            level: c,
            droppedLevel: l.currentLevel
          }), l.autoLevelCapping = c, this.streamController.nextLevelSwitch());
        }
      }
      this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = n;
    }
  }
  checkFPSInterval() {
    const e = this.media;
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const n = e.getVideoPlaybackQuality();
        this.checkFPS(e, n.totalVideoFrames, n.droppedVideoFrames);
      } else
        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);
  }
}
function gv(t, e) {
  let n;
  try {
    n = new Event("addtrack");
  } catch {
    n = document.createEvent("Event"), n.initEvent("addtrack", !1, !1);
  }
  n.track = t, e.dispatchEvent(n);
}
function bv(t, e) {
  const n = t.mode;
  if (n === "disabled" && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id))
    try {
      if (t.addCue(e), !t.cues.getCueById(e.id))
        throw new Error(`addCue is failed for: ${e}`);
    } catch (r) {
      qe.debug(`[texttrack-utils]: ${r}`);
      try {
        const i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
        i.id = e.id, t.addCue(i);
      } catch (i) {
        qe.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${i}`);
      }
    }
  n === "disabled" && (t.mode = n);
}
function Hi(t, e) {
  const n = t.mode;
  if (n === "disabled" && (t.mode = "hidden"), t.cues)
    for (let r = t.cues.length; r--; )
      e && t.cues[r].removeEventListener("enter", e), t.removeCue(t.cues[r]);
  n === "disabled" && (t.mode = n);
}
function of(t, e, n, r) {
  const i = t.mode;
  if (i === "disabled" && (t.mode = "hidden"), t.cues && t.cues.length > 0) {
    const s = WU(t.cues, e, n);
    for (let a = 0; a < s.length; a++)
      (!r || r(s[a])) && t.removeCue(s[a]);
  }
  i === "disabled" && (t.mode = i);
}
function qU(t, e) {
  if (e <= t[0].startTime)
    return 0;
  const n = t.length - 1;
  if (e > t[n].endTime)
    return -1;
  let r = 0, i = n, s;
  for (; r <= i; )
    if (s = Math.floor((i + r) / 2), e < t[s].startTime)
      i = s - 1;
    else if (e > t[s].startTime && r < n)
      r = s + 1;
    else
      return s;
  return t[r].startTime - e < e - t[i].startTime ? r : i;
}
function WU(t, e, n) {
  const r = [], i = qU(t, e);
  if (i > -1)
    for (let s = i, a = t.length; s < a; s++) {
      const o = t[s];
      if (o.startTime >= e && o.endTime <= n)
        r.push(o);
      else if (o.startTime > n)
        return r;
    }
  return r;
}
function iu(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    (r.kind === "subtitles" || r.kind === "captions") && r.label && e.push(t[n]);
  }
  return e;
}
class KU extends e0 {
  constructor(e) {
    super(e, "subtitle-track-controller"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () => this.pollTrackChange(0), this.onTextTracksChanged = () => {
      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)
        return;
      let n = null;
      const r = iu(this.media.textTracks);
      for (let s = 0; s < r.length; s++)
        if (r[s].mode === "hidden")
          n = r[s];
        else if (r[s].mode === "showing") {
          n = r[s];
          break;
        }
      const i = this.findTrackForTextTrack(n);
      this.subtitleTrack !== i && this.setSubtitleTrack(i);
    }, this.registerListeners();
  }
  destroy() {
    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(e) {
    this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.ERROR, this.onError, this);
  }
  // Listen for subtitle track change, then extract the current track ID.
  onMediaAttached(e, n) {
    this.media = n.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange));
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);
  }
  onMediaDetaching(e, n) {
    const r = this.media;
    if (!r)
      return;
    const i = !!n.transferMedia;
    if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || r.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, i)
      return;
    iu(r.textTracks).forEach((a) => {
      Hi(a);
    });
  }
  onManifestLoading() {
    this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;
  }
  // Fired whenever a new manifest is loaded.
  onManifestParsed(e, n) {
    this.tracks = n.subtitleTracks;
  }
  onSubtitleTrackLoaded(e, n) {
    const {
      id: r,
      groupId: i,
      details: s
    } = n, a = this.tracksInGroup[r];
    if (!a || a.groupId !== i) {
      this.warn(`Subtitle track with id:${r} and group:${i} not found in active group ${a == null ? void 0 : a.groupId}`);
      return;
    }
    const o = a.details;
    a.details = n.details, this.log(`Subtitle track ${r} "${a.name}" lang:${a.lang} group:${i} loaded [${s.startSN}-${s.endSN}]`), r === this.trackId && this.playlistLoaded(r, n, o);
  }
  onLevelLoading(e, n) {
    this.switchLevel(n.level);
  }
  onLevelSwitching(e, n) {
    this.switchLevel(n.level);
  }
  switchLevel(e) {
    const n = this.hls.levels[e];
    if (!n)
      return;
    const r = n.subtitleGroups || null, i = this.groupIds;
    let s = this.currentTrack;
    if (!r || (i == null ? void 0 : i.length) !== (r == null ? void 0 : r.length) || r != null && r.some((a) => (i == null ? void 0 : i.indexOf(a)) === -1)) {
      this.groupIds = r, this.trackId = -1, this.currentTrack = null;
      const a = this.tracks.filter((c) => !r || r.indexOf(c.groupId) !== -1);
      if (a.length)
        this.selectDefaultTrack && !a.some((c) => c.default) && (this.selectDefaultTrack = !1), a.forEach((c, d) => {
          c.id = d;
        });
      else if (!s && !this.tracksInGroup.length)
        return;
      this.tracksInGroup = a;
      const o = this.hls.config.subtitlePreference;
      if (!s && o) {
        this.selectDefaultTrack = !1;
        const c = $n(o, a);
        if (c > -1)
          s = a[c];
        else {
          const d = $n(o, this.tracks);
          s = this.tracks[d];
        }
      }
      let u = this.findTrackId(s);
      u === -1 && s && (u = this.findTrackId(null));
      const l = {
        subtitleTracks: a
      };
      this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${r == null ? void 0 : r.join(",")}" group-id`), this.hls.trigger(x.SUBTITLE_TRACKS_UPDATED, l), u !== -1 && this.trackId === -1 && this.setSubtitleTrack(u);
    }
  }
  findTrackId(e) {
    const n = this.tracksInGroup, r = this.selectDefaultTrack;
    for (let i = 0; i < n.length; i++) {
      const s = n[i];
      if (!(r && !s.default || !r && !e) && (!e || ti(s, e)))
        return i;
    }
    if (e) {
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (Ra(e.attrs, s.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
          return i;
      }
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (Ra(e.attrs, s.attrs, ["LANGUAGE"]))
          return i;
      }
    }
    return -1;
  }
  findTrackForTextTrack(e) {
    if (e) {
      const n = this.tracksInGroup;
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        if (nf(i, e))
          return r;
      }
    }
    return -1;
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === Me.SUBTITLE_TRACK && n.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(n.context.groupId) !== -1) && this.checkRetry(n);
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  /** get alternate subtitle tracks list from playlist **/
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1, this.setSubtitleTrack(e);
  }
  setSubtitleOption(e) {
    if (this.hls.config.subtitlePreference = e, e) {
      if (e.id === -1)
        return this.setSubtitleTrack(-1), null;
      const n = this.allSubtitleTracks;
      if (this.selectDefaultTrack = !1, n.length) {
        const r = this.currentTrack;
        if (r && ti(e, r))
          return r;
        const i = $n(e, this.tracksInGroup);
        if (i > -1) {
          const s = this.tracksInGroup[i];
          return this.setSubtitleTrack(i), s;
        } else {
          if (r)
            return null;
          {
            const s = $n(e, n);
            if (s > -1)
              return n[s];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = e.id, i = e.groupId, s = this.getUrlWithDirectives(e.url, n), a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading subtitle ${r} "${e.name}" lang:${e.lang} group:${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${s}`), this.hls.trigger(x.SUBTITLE_TRACK_LOADING, {
      url: s,
      id: r,
      groupId: i,
      deliveryDirectives: n || null,
      track: e
    });
  }
  /**
   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.
   * This operates on the DOM textTracks.
   * A value of -1 will disable all subtitle tracks.
   */
  toggleTrackModes() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = iu(e.textTracks), r = this.currentTrack;
    let i;
    if (r && (i = n.filter((s) => nf(r, s))[0], i || this.warn(`Unable to find subtitle TextTrack with name "${r.name}" and language "${r.lang}"`)), [].slice.call(n).forEach((s) => {
      s.mode !== "disabled" && s !== i && (s.mode = "disabled");
    }), i) {
      const s = this.subtitleDisplay ? "showing" : "hidden";
      i.mode !== s && (i.mode = s);
    }
  }
  /**
   * This method is responsible for validating the subtitle index and periodically reloading if live.
   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.
   */
  setSubtitleTrack(e) {
    const n = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = e;
      return;
    }
    if (e < -1 || e >= n.length || !de(e)) {
      this.warn(`Invalid subtitle track id: ${e}`);
      return;
    }
    this.selectDefaultTrack = !1;
    const r = this.currentTrack, i = n[e] || null;
    if (this.trackId = e, this.currentTrack = i, this.toggleTrackModes(), !i) {
      this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
        id: e
      });
      return;
    }
    const s = !!i.details && !i.details.live;
    if (e === this.trackId && i === r && s)
      return;
    this.log(`Switching to subtitle-track ${e}` + (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : ""));
    const {
      id: a,
      groupId: o = "",
      name: u,
      type: l,
      url: c
    } = i;
    this.hls.trigger(x.SUBTITLE_TRACK_SWITCH, {
      id: a,
      groupId: o,
      name: u,
      type: l,
      url: c
    });
    const d = this.switchParams(i.url, r == null ? void 0 : r.details, i.details);
    this.loadPlaylist(d);
  }
}
function jU() {
  try {
    return crypto.randomUUID();
  } catch {
    try {
      const e = URL.createObjectURL(new Blob()), n = e.toString();
      return URL.revokeObjectURL(e), n.slice(n.lastIndexOf("/") + 1);
    } catch {
      let n = (/* @__PURE__ */ new Date()).getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (i) => {
        const s = (n + Math.random() * 16) % 16 | 0;
        return n = Math.floor(n / 16), (i == "x" ? s : s & 3 | 8).toString(16);
      });
    }
  }
}
function aa(t) {
  let e = 5381, n = t.length;
  for (; n; )
    e = e * 33 ^ t.charCodeAt(--n);
  return (e >>> 0).toString();
}
const Qi = 0.025;
let Hu = /* @__PURE__ */ function(t) {
  return t[t.Point = 0] = "Point", t[t.Range = 1] = "Range", t;
}({});
function YU(t, e, n) {
  return `${t.identifier}-${n + 1}-${aa(e)}`;
}
class XU {
  constructor(e, n) {
    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {
      skip: !1,
      jump: !1
    }, this.snapOptions = {
      out: !1,
      in: !1
    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = n, this.dateRange = e, this.setDateRange(e);
  }
  setDateRange(e) {
    this.dateRange = e, this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions), this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions);
  }
  reset() {
    var e;
    this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);
  }
  isAssetPastPlayoutLimit(e) {
    var n;
    if (e > 0 && e >= this.assetList.length)
      return !0;
    const r = this.playoutLimit;
    return e <= 0 || isNaN(r) ? !1 : r === 0 ? !0 : (((n = this.assetList[e]) == null ? void 0 : n.startOffset) || 0) > r;
  }
  findAssetIndex(e) {
    return this.assetList.indexOf(e);
  }
  get identifier() {
    return this.dateRange.id;
  }
  get startDate() {
    return this.dateRange.startDate;
  }
  get startTime() {
    const e = this.dateRange.startTime;
    if (this.snapOptions.out) {
      const n = this.dateRange.tagAnchor;
      if (n)
        return _c(e, n);
    }
    return e;
  }
  get startOffset() {
    return this.cue.pre ? 0 : this.startTime;
  }
  get startIsAligned() {
    if (this.startTime === 0 || this.snapOptions.out)
      return !0;
    const e = this.dateRange.tagAnchor;
    if (e) {
      const n = this.dateRange.startTime, r = _c(n, e);
      return n - r < 0.1;
    }
    return !1;
  }
  get resumptionOffset() {
    const e = this.resumeOffset, n = de(e) ? e : this.duration;
    return this.cumulativeDuration + n;
  }
  get resumeTime() {
    const e = this.startOffset + this.resumptionOffset;
    if (this.snapOptions.in) {
      const n = this.resumeAnchor;
      if (n)
        return _c(e, n);
    }
    return e;
  }
  get appendInPlace() {
    return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && // preroll starts at startPosition before startPosition is known (live)
    this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < Qi));
  }
  set appendInPlace(e) {
    if (this.appendInPlaceStarted) {
      this.resetOnResume = !e;
      return;
    }
    this.appendInPlaceDisabled = !e;
  }
  // Extended timeline start time
  get timelineStart() {
    return this._timelineStart !== null ? this._timelineStart : this.startTime;
  }
  set timelineStart(e) {
    this._timelineStart = e;
  }
  get duration() {
    const e = this.playoutLimit;
    let n;
    return this._duration !== null ? n = this._duration : this.dateRange.duration ? n = this.dateRange.duration : n = this.dateRange.plannedDuration || 0, !isNaN(e) && e < n && (n = e), n;
  }
  set duration(e) {
    this._duration = e;
  }
  get cue() {
    return this.dateRange.cue;
  }
  get timelineOccupancy() {
    return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? Hu.Range : Hu.Point;
  }
  get supplementsPrimary() {
    return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY";
  }
  get contentMayVary() {
    return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO";
  }
  get assetUrl() {
    return this.dateRange.attr["X-ASSET-URI"];
  }
  get assetListUrl() {
    return this.dateRange.attr["X-ASSET-LIST"];
  }
  get baseUrl() {
    return this.base.url;
  }
  get assetListLoaded() {
    return this.assetList.length > 0 || this.assetListResponse !== null;
  }
  toString() {
    return QU(this);
  }
}
function _c(t, e) {
  return t - e.start < e.duration / 2 && !(Math.abs(t - (e.start + e.duration)) < Qi) ? e.start : e.start + e.duration;
}
function Ev(t, e, n) {
  const r = new self.URL(t, n);
  return r.protocol !== "data:" && r.searchParams.set("_HLS_primary_id", e), r;
}
function Rc(t, e) {
  for (; (n = t.assetList[++e]) != null && n.error; )
    var n;
  return e;
}
function QU(t) {
  return `["${t.identifier}" ${t.cue.pre ? "<pre>" : t.cue.post ? "<post>" : ""}${t.timelineStart.toFixed(2)}-${t.resumeTime.toFixed(2)}]`;
}
function Fi(t) {
  const e = t.timelineStart, n = t.duration || 0;
  return `["${t.identifier}" ${e.toFixed(2)}-${(e + n).toFixed(2)}]`;
}
class ZU {
  constructor(e, n, r, i) {
    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () => {
      this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(x.PLAYOUT_LIMIT_REACHED, {});
    };
    const s = this.hls = new e(n);
    this.interstitial = r, this.assetItem = i;
    const a = () => {
      this.hasDetails = !0;
    };
    s.once(x.LEVEL_LOADED, a), s.once(x.AUDIO_TRACK_LOADED, a), s.once(x.SUBTITLE_TRACK_LOADED, a), s.on(x.MEDIA_ATTACHING, (o, {
      media: u
    }) => {
      this.removeMediaListeners(), this.mediaAttached = u, this.interstitial.playoutLimit && (u.addEventListener("timeupdate", this.checkPlayout), this.appendInPlace && s.on(x.BUFFER_APPENDED, () => {
        const c = this.bufferedEnd;
        this.reachedPlayout(c) && (this._bufferedEosTime = c, s.trigger(x.BUFFERED_TO_END, void 0));
      }));
    });
  }
  get appendInPlace() {
    return this.interstitial.appendInPlace;
  }
  loadSource() {
    const e = this.hls;
    if (e)
      if (e.url)
        e.levels.length && !e.started && e.startLoad(-1, !0);
      else {
        let n = this.assetItem.uri;
        try {
          n = Ev(n, e.config.primarySessionId || "").href;
        } catch {
        }
        e.loadSource(n);
      }
  }
  bufferedInPlaceToEnd(e) {
    var n;
    if (!this.appendInPlace)
      return !1;
    if ((n = this.hls) != null && n.bufferedToEnd)
      return !0;
    if (!e)
      return !1;
    const r = Math.min(this._bufferedEosTime || 1 / 0, this.duration), i = this.timelineOffset, s = Ce.bufferInfo(e, i, 0);
    return this.getAssetTime(s.end) >= r - 0.02;
  }
  reachedPlayout(e) {
    const r = this.interstitial.playoutLimit;
    return this.startOffset + e >= r;
  }
  get destroyed() {
    var e;
    return !((e = this.hls) != null && e.userConfig);
  }
  get assetId() {
    return this.assetItem.identifier;
  }
  get interstitialId() {
    return this.assetItem.parentIdentifier;
  }
  get media() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.media) || null;
  }
  get bufferedEnd() {
    const e = this.media || this.mediaAttached;
    if (!e)
      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
    const n = Ce.bufferInfo(e, e.currentTime, 1e-3);
    return this.getAssetTime(n.end);
  }
  get currentTime() {
    const e = this.media || this.mediaAttached;
    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;
  }
  get duration() {
    const e = this.assetItem.duration;
    if (!e)
      return 0;
    const n = this.interstitial.playoutLimit;
    if (n) {
      const r = n - this.startOffset;
      if (r > 0 && r < e)
        return r;
    }
    return e;
  }
  get remaining() {
    const e = this.duration;
    return e ? Math.max(0, e - this.currentTime) : 0;
  }
  get startOffset() {
    return this.assetItem.startOffset;
  }
  get timelineOffset() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;
  }
  set timelineOffset(e) {
    const n = this.timelineOffset;
    if (e !== n) {
      const r = e - n;
      if (Math.abs(r) > 1 / 9e4 && this.hls) {
        if (this.hasDetails)
          throw new Error("Cannot set timelineOffset after playlists are loaded");
        this.hls.config.timelineOffset = e;
      }
    }
  }
  getAssetTime(e) {
    const n = this.timelineOffset, r = this.duration;
    return Math.min(Math.max(0, e - n), r);
  }
  removeMediaListeners() {
    const e = this.mediaAttached;
    e && (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener("timeupdate", this.checkPlayout));
  }
  bufferSnapShot() {
    if (this.mediaAttached) {
      var e;
      (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd);
    }
  }
  destroy() {
    this.removeMediaListeners(), this.hls && this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null;
  }
  attachMedia(e) {
    var n;
    this.loadSource(), (n = this.hls) == null || n.attachMedia(e);
  }
  detachMedia() {
    var e;
    this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia();
  }
  resumeBuffering() {
    var e;
    (e = this.hls) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.hls) == null || e.pauseBuffering();
  }
  transferMedia() {
    var e;
    return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null;
  }
  resetDetails() {
    const e = this.hls;
    if (e && this.hasDetails) {
      e.stopLoad();
      const n = (r) => delete r.details;
      e.levels.forEach(n), e.allAudioTracks.forEach(n), e.allSubtitleTracks.forEach(n), this.hasDetails = !1;
    }
  }
  on(e, n, r) {
    var i;
    (i = this.hls) == null || i.on(e, n);
  }
  once(e, n, r) {
    var i;
    (i = this.hls) == null || i.once(e, n);
  }
  off(e, n, r) {
    var i;
    (i = this.hls) == null || i.off(e, n);
  }
  toString() {
    var e;
    return `HlsAssetPlayer: ${Fi(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`;
  }
}
const Vg = 0.033;
class JU extends En {
  constructor(e, n) {
    super("interstitials-sched", n), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {
      primary: 0,
      playout: 0,
      integrated: 0
    }, this.onScheduleUpdate = e;
  }
  destroy() {
    this.reset(), this.onScheduleUpdate = null;
  }
  reset() {
    this.eventMap = {}, this.setDurations(0, 0, 0), this.events && this.events.forEach((e) => e.reset()), this.events = this.items = null;
  }
  resetErrorsInRange(e, n) {
    return this.events ? this.events.reduce((r, i) => e <= i.startOffset && n > i.startOffset ? (delete i.error, r + 1) : r, 0) : 0;
  }
  get duration() {
    const e = this.items;
    return e ? e[e.length - 1].end : 0;
  }
  get length() {
    return this.items ? this.items.length : 0;
  }
  getEvent(e) {
    return e && this.eventMap[e] || null;
  }
  hasEvent(e) {
    return e in this.eventMap;
  }
  findItemIndex(e, n) {
    if (e.event)
      return this.findEventIndex(e.event.identifier);
    let r = -1;
    e.nextEvent ? r = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (r = this.findEventIndex(e.previousEvent.identifier) + 1);
    const i = this.items;
    if (i)
      for (i[r] || (n === void 0 && (n = e.start), r = this.findItemIndexAtTime(n)); r >= 0 && (s = i[r]) != null && s.event; ) {
        var s;
        r--;
      }
    return r;
  }
  findItemIndexAtTime(e, n) {
    const r = this.items;
    if (r)
      for (let i = 0; i < r.length; i++) {
        let s = r[i];
        if (n && n !== "primary" && (s = s[n]), e === s.start || e > s.start && e < s.end)
          return i;
      }
    return -1;
  }
  findJumpRestrictedIndex(e, n) {
    const r = this.items;
    if (r)
      for (let i = e; i <= n && r[i]; i++) {
        const s = r[i].event;
        if (s != null && s.restrictions.jump && !s.appendInPlace)
          return i;
      }
    return -1;
  }
  findEventIndex(e) {
    const n = this.items;
    if (n)
      for (let i = n.length; i--; ) {
        var r;
        if (((r = n[i].event) == null ? void 0 : r.identifier) === e)
          return i;
      }
    return -1;
  }
  findAssetIndex(e, n) {
    const r = e.assetList, i = r.length;
    if (i > 1)
      for (let s = 0; s < i; s++) {
        const a = r[s];
        if (!a.error) {
          const o = a.timelineStart;
          if (n === o || n > o && (n < o + (a.duration || 0) || s === i - 1))
            return s;
        }
      }
    return 0;
  }
  get assetIdAtEnd() {
    var e;
    const n = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;
    if (n) {
      const r = n.assetList, i = r[r.length - 1];
      if (i)
        return i.identifier;
    }
    return null;
  }
  parseInterstitialDateRanges(e, n) {
    const r = e.main.details, {
      dateRanges: i
    } = r, s = this.events, a = this.parseDateRanges(i, {
      url: r.url
    }, n), o = Object.keys(i), u = s ? s.filter((l) => !o.includes(l.identifier)) : [];
    a.length && a.sort((l, c) => {
      const d = l.cue.pre, f = l.cue.post, h = c.cue.pre, m = c.cue.post;
      if (d && !h)
        return -1;
      if (h && !d || f && !m)
        return 1;
      if (m && !f)
        return -1;
      if (!d && !h && !f && !m) {
        const p = l.startTime, g = c.startTime;
        if (p !== g)
          return p - g;
      }
      return l.dateRange.tagOrder - c.dateRange.tagOrder;
    }), this.events = a, u.forEach((l) => {
      this.removeEvent(l);
    }), this.updateSchedule(e, u);
  }
  updateSchedule(e, n = [], r = !1) {
    const i = this.events || [];
    if (i.length || n.length || this.length < 2) {
      const s = this.items, a = this.parseSchedule(i, e);
      (r || n.length || (s == null ? void 0 : s.length) !== a.length || a.some((u, l) => Math.abs(u.playout.start - s[l].playout.start) > 5e-3 || Math.abs(u.playout.end - s[l].playout.end) > 5e-3)) && (this.items = a, this.onScheduleUpdate(n, s));
    }
  }
  parseDateRanges(e, n, r) {
    const i = [], s = Object.keys(e);
    for (let a = 0; a < s.length; a++) {
      const o = s[a], u = e[o];
      if (u.isInterstitial) {
        let l = this.eventMap[o];
        l ? l.setDateRange(u) : (l = new XU(u, n), this.eventMap[o] = l, r === !1 && (l.appendInPlace = r)), i.push(l);
      }
    }
    return i;
  }
  parseSchedule(e, n) {
    const r = [], i = n.main.details, s = i.live ? 1 / 0 : i.edge;
    let a = 0;
    if (e = e.filter((u) => !u.error && !(u.cue.once && u.hasPlayed)), e.length) {
      this.resolveOffsets(e, n);
      let u = 0, l = 0;
      if (e.forEach((c, d) => {
        const f = c.cue.pre, h = c.cue.post, m = e[d - 1] || null, p = c.appendInPlace, g = h ? s : c.startOffset, b = c.duration, y = c.timelineOccupancy === Hu.Range ? b : 0, T = c.resumptionOffset, S = (m == null ? void 0 : m.startTime) === g, I = g + c.cumulativeDuration;
        let C = p ? I + b : g + T;
        if (f || !h && g <= 0) {
          const R = l;
          l += y, c.timelineStart = I;
          const k = a;
          a += b, r.push({
            event: c,
            start: I,
            end: C,
            playout: {
              start: k,
              end: a
            },
            integrated: {
              start: R,
              end: l
            }
          });
        } else if (g <= s) {
          if (!S) {
            const A = g - u;
            if (A > Vg) {
              const L = u, P = l;
              l += A;
              const $ = a;
              a += A;
              const G = {
                previousEvent: e[d - 1] || null,
                nextEvent: c,
                start: L,
                end: L + A,
                playout: {
                  start: $,
                  end: a
                },
                integrated: {
                  start: P,
                  end: l
                }
              };
              r.push(G);
            } else A > 0 && m && (m.cumulativeDuration += A, r[r.length - 1].end = g);
          }
          h && (C = I), c.timelineStart = I;
          const R = l;
          l += y;
          const k = a;
          a += b, r.push({
            event: c,
            start: I,
            end: C,
            playout: {
              start: k,
              end: a
            },
            integrated: {
              start: R,
              end: l
            }
          });
        } else
          return;
        const _ = c.resumeTime;
        h || _ > s ? u = s : u = _;
      }), u < s) {
        var o;
        const c = u, d = l, f = s - u;
        l += f;
        const h = a;
        a += f, r.push({
          previousEvent: ((o = r[r.length - 1]) == null ? void 0 : o.event) || null,
          nextEvent: null,
          start: u,
          end: c + f,
          playout: {
            start: h,
            end: a
          },
          integrated: {
            start: d,
            end: l
          }
        });
      }
      this.setDurations(s, a, l);
    } else
      r.push({
        previousEvent: null,
        nextEvent: null,
        start: 0,
        end: s,
        playout: {
          start: 0,
          end: s
        },
        integrated: {
          start: 0,
          end: s
        }
      }), this.setDurations(s, s, s);
    return r;
  }
  setDurations(e, n, r) {
    this.durations = {
      primary: e,
      playout: n,
      integrated: r
    };
  }
  resolveOffsets(e, n) {
    const r = n.main.details, i = r.live ? 1 / 0 : r.edge;
    let s = 0, a = -1;
    e.forEach((o, u) => {
      const l = o.cue.pre, c = o.cue.post, d = l ? 0 : c ? i : o.startTime;
      this.updateAssetDurations(o), a === d ? o.cumulativeDuration = s : (s = 0, a = d), !c && o.snapOptions.in && (o.resumeAnchor = ai(null, r.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0), o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, n) || (o.appendInPlace = !1)), !o.appendInPlace && u + 1 < e.length && e[u + 1].startTime - e[u].resumeTime < Vg && (e[u + 1].appendInPlace = !1, e[u + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
      const h = de(o.resumeOffset) ? o.resumeOffset : o.duration;
      s += h;
    });
  }
  primaryCanResumeInPlaceAt(e, n) {
    const r = e.resumeTime, i = e.startTime + e.resumptionOffset;
    return Math.abs(r - i) > Qi ? (this.log(`"${e.identifier}" resumption ${r} not aligned with estimated timeline end ${i}`), !1) : !Object.keys(n).some((a) => {
      const o = n[a].details, u = o.edge;
      if (r >= u)
        return this.log(`"${e.identifier}" resumption ${r} past ${a} playlist end ${u}`), !1;
      const l = ai(null, o.fragments, r);
      if (!l)
        return this.log(`"${e.identifier}" resumption ${r} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`), !0;
      const c = a === "audio" ? 0.175 : 0;
      return Math.abs(l.start - r) < Qi + c || Math.abs(l.end - r) < Qi + c ? !1 : (this.log(`"${e.identifier}" resumption ${r} not aligned with ${a} fragment bounds (${l.start}-${l.end} sn: ${l.sn} cc: ${l.cc})`), !0);
    });
  }
  updateAssetDurations(e) {
    if (!e.assetListLoaded)
      return;
    const n = e.timelineStart;
    let r = 0, i = !1, s = !1;
    for (let a = 0; a < e.assetList.length; a++) {
      const o = e.assetList[a], u = n + r;
      o.startOffset = r, o.timelineStart = u, i || (i = o.duration === null), s || (s = !!o.error);
      const l = o.error ? 0 : o.duration || 0;
      r += l;
    }
    i && !s ? e.duration = Math.max(r, e.duration) : e.duration = r;
  }
  removeEvent(e) {
    e.reset(), delete this.eventMap[e.identifier];
  }
}
function yn(t) {
  return `[${t.event ? '"' + t.event.identifier + '"' : "primary"}: ${t.start.toFixed(2)}-${t.end.toFixed(2)}]`;
}
class e7 {
  constructor(e) {
    this.hls = void 0, this.hls = e;
  }
  destroy() {
    this.hls = null;
  }
  loadAssetList(e, n) {
    const r = e.assetListUrl;
    let i;
    try {
      i = Ev(r, this.hls.sessionId, e.baseUrl);
    } catch (f) {
      const h = this.assignAssetListError(e, q.ASSET_LIST_LOAD_ERROR, f, r);
      this.hls.trigger(x.ERROR, h);
      return;
    }
    n && i.protocol !== "data:" && i.searchParams.set("_HLS_start_offset", "" + n);
    const s = this.hls.config, a = s.loader, o = new a(s), u = {
      responseType: "json",
      url: i.href
    }, l = s.interstitialAssetListLoadPolicy.default, c = {
      loadPolicy: l,
      timeout: l.maxLoadTimeMs,
      maxRetry: 0,
      retryDelay: 0,
      maxRetryDelay: 0
    }, d = {
      onSuccess: (f, h, m, p) => {
        const g = f.data, b = g == null ? void 0 : g.ASSETS;
        if (!Array.isArray(b)) {
          const y = this.assignAssetListError(e, q.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), m.url, h, p);
          this.hls.trigger(x.ERROR, y);
          return;
        }
        e.assetListResponse = g, this.hls.trigger(x.ASSET_LIST_LOADED, {
          event: e,
          assetListResponse: g,
          networkDetails: p
        });
      },
      onError: (f, h, m, p) => {
        const g = this.assignAssetListError(e, q.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${f.code} ${f.text} (${h.url})`), h.url, p, m);
        this.hls.trigger(x.ERROR, g);
      },
      onTimeout: (f, h, m) => {
        const p = this.assignAssetListError(e, q.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${h.url})`), h.url, f, m);
        this.hls.trigger(x.ERROR, p);
      }
    };
    return o.load(u, c, d), this.hls.trigger(x.ASSET_LIST_LOADING, {
      event: e
    }), o;
  }
  assignAssetListError(e, n, r, i, s, a) {
    return e.error = r, {
      type: be.NETWORK_ERROR,
      details: n,
      fatal: !1,
      interstitial: e,
      url: i,
      error: r,
      networkDetails: a,
      stats: s
    };
  }
}
function Gg(t) {
  t == null || t.play().catch(() => {
  });
}
function Do(t, e) {
  return `[${t}] Advancing timeline position to ${e}`;
}
class t7 extends En {
  constructor(e, n) {
    super("interstitials", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () => {
      this.shouldPlay = !0;
    }, this.onPause = () => {
      this.shouldPlay = !1;
    }, this.onSeeking = () => {
      const r = this.currentTime;
      if (r === void 0 || this.playbackDisabled || !this.schedule)
        return;
      const i = r - this.timelinePos;
      if (Math.abs(i) < 1 / 7056e5)
        return;
      const a = i <= -0.01;
      this.timelinePos = r, this.bufferedPos = r;
      const o = this.playingItem;
      if (!o) {
        this.checkBuffer();
        return;
      }
      if (a && this.schedule.resetErrorsInRange(r, r - i) && this.updateSchedule(!0), this.checkBuffer(), a && r < o.start || r >= o.end) {
        var u;
        const h = this.findItemIndex(o);
        let m = this.schedule.findItemIndexAtTime(r);
        if (m === -1 && (m = h + (a ? -1 : 1), this.log(`seeked ${a ? "back " : ""}to position not covered by schedule ${r} (resolving from ${h} to ${m})`)), !this.isInterstitial(o) && (u = this.media) != null && u.paused && (this.shouldPlay = !1), !a && m > h) {
          const p = this.schedule.findJumpRestrictedIndex(h + 1, m);
          if (p > h) {
            this.setSchedulePosition(p);
            return;
          }
        }
        this.setSchedulePosition(m);
        return;
      }
      const l = this.playingAsset;
      if (!l) {
        if (this.playingLastItem && this.isInterstitial(o)) {
          const h = o.event.assetList[0];
          h && (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(r, h));
        }
        return;
      }
      const c = l.timelineStart, d = l.duration || 0;
      if (a && r < c || r >= c + d) {
        var f;
        (f = o.event) != null && f.appendInPlace && (this.clearInterstitial(o.event, o), this.flushFrontBuffer(r)), this.setScheduleToAssetAtTime(r, l);
      }
    }, this.onTimeupdate = () => {
      const r = this.currentTime;
      if (r === void 0 || this.playbackDisabled)
        return;
      if (r > this.timelinePos)
        this.timelinePos = r, r > this.bufferedPos && this.checkBuffer();
      else
        return;
      const i = this.playingItem;
      if (!i || this.playingLastItem)
        return;
      if (r >= i.end) {
        this.timelinePos = i.end;
        const o = this.findItemIndex(i);
        this.setSchedulePosition(o + 1);
      }
      const s = this.playingAsset;
      if (!s)
        return;
      const a = s.timelineStart + (s.duration || 0);
      r >= a && this.setScheduleToAssetAtTime(r, s);
    }, this.onScheduleUpdate = (r, i) => {
      const s = this.schedule;
      if (!s)
        return;
      const a = this.playingItem, o = s.events || [], u = s.items || [], l = s.durations, c = r.map((p) => p.identifier), d = !!(o.length || c.length);
      (d || i) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${u.map((p) => yn(p))} pos: ${this.timelinePos}`), c.length && this.log(`Removed events ${c}`);
      let f = null, h = null;
      a && (f = this.updateItem(a, this.timelinePos), this.itemsMatch(a, f) ? this.playingItem = f : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);
      const m = this.bufferingItem;
      if (m && (h = this.updateItem(m, this.bufferedPos), this.itemsMatch(m, h) ? this.bufferingItem = h : m.event && (this.bufferingItem = this.playingItem, this.clearInterstitial(m.event, null))), r.forEach((p) => {
        p.assetList.forEach((g) => {
          this.clearAssetPlayer(g.identifier, null);
        });
      }), this.playerQueue.forEach((p) => {
        if (p.interstitial.appendInPlace) {
          const g = p.assetItem.timelineStart, b = p.timelineOffset - g;
          if (b)
            try {
              p.timelineOffset = g;
            } catch (y) {
              Math.abs(b) > Qi && this.warn(`${y} ("${p.assetId}" ${p.timelineOffset}->${g})`);
            }
        }
      }), d || i) {
        if (this.hls.trigger(x.INTERSTITIALS_UPDATED, {
          events: o.slice(0),
          schedule: u.slice(0),
          durations: l,
          removedIds: c
        }), this.isInterstitial(a) && c.includes(a.event.identifier)) {
          this.warn(`Interstitial "${a.event.identifier}" removed while playing`), this.primaryFallback(a.event);
          return;
        }
        a && this.trimInPlace(f, a), m && h !== f && this.trimInPlace(h, m), this.checkBuffer();
      }
    }, this.hls = e, this.HlsPlayerClass = n, this.assetListLoader = new e7(e), this.schedule = new JU(this.onScheduleUpdate, e.logger), this.registerListeners();
  }
  registerListeners() {
    const e = this.hls;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(x.MEDIA_ENDED, this.onMediaEnded, this), e.on(x.ERROR, this.onError, this), e.on(x.DESTROYING, this.onDestroying, this));
  }
  unregisterListeners() {
    const e = this.hls;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(x.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(x.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(x.BUFFER_CODECS, this.onBufferCodecs, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(x.MEDIA_ENDED, this.onMediaEnded, this), e.off(x.ERROR, this.onError, this), e.off(x.DESTROYING, this.onDestroying, this));
  }
  startLoad() {
    this.resumeBuffering();
  }
  stopLoad() {
    this.pauseBuffering();
  }
  resumeBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();
  }
  pauseBuffering() {
    var e;
    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();
  }
  destroy() {
    this.unregisterListeners(), this.stopLoad(), this.assetListLoader && this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule && this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;
  }
  onDestroying() {
    const e = this.primaryMedia || this.media;
    e && this.removeMediaListeners(e);
  }
  removeMediaListeners(e) {
    zt(e, "play", this.onPlay), zt(e, "pause", this.onPause), zt(e, "seeking", this.onSeeking), zt(e, "timeupdate", this.onTimeupdate);
  }
  onMediaAttaching(e, n) {
    const r = this.media = n.media;
    Bt(r, "seeking", this.onSeeking), Bt(r, "timeupdate", this.onTimeupdate), Bt(r, "play", this.onPlay), Bt(r, "pause", this.onPause);
  }
  onMediaAttached(e, n) {
    const r = this.effectivePlayingItem, i = this.detachedData;
    if (this.detachedData = null, r === null)
      this.checkStart();
    else if (!i) {
      this.clearScheduleState();
      const s = this.findItemIndex(r);
      this.setSchedulePosition(s);
    }
  }
  clearScheduleState() {
    this.log("clear schedule state"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia, i = this.media;
    if (this.media = null, !r && (i && this.removeMediaListeners(i), this.detachedData)) {
      const s = this.getBufferingPlayer();
      s && (this.log(`Removing schedule state for detachedData and ${s}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, s.detachMedia()), this.shouldPlay = !1;
    }
  }
  get interstitialsManager() {
    if (!this.hls)
      return null;
    if (this.manager)
      return this.manager;
    const e = this, n = () => e.bufferingItem || e.waitingItem, r = (d) => d && e.getAssetPlayer(d.identifier), i = (d, f, h, m, p) => {
      if (d) {
        let g = d[f].start;
        const b = d.event;
        if (b) {
          if (f === "playout" || b.timelineOccupancy !== Hu.Point) {
            const y = r(h);
            (y == null ? void 0 : y.interstitial) === b && (g += y.assetItem.startOffset + y[p]);
          }
        } else {
          const y = m === "bufferedPos" ? a() : e[m];
          g += y - d.start;
        }
        return g;
      }
      return 0;
    }, s = (d, f) => {
      var h;
      if (d !== 0 && f !== "primary" && (h = e.schedule) != null && h.length) {
        var m;
        const p = e.schedule.findItemIndexAtTime(d), g = (m = e.schedule.items) == null ? void 0 : m[p];
        if (g) {
          const b = g[f].start - g.start;
          return d + b;
        }
      }
      return d;
    }, a = () => {
      const d = e.bufferedPos;
      return d === Number.MAX_VALUE ? o("primary") : Math.max(d, 0);
    }, o = (d) => {
      var f, h;
      return (f = e.primaryDetails) != null && f.live ? e.primaryDetails.edge : ((h = e.schedule) == null ? void 0 : h.durations[d]) || 0;
    }, u = (d, f) => {
      var h, m;
      const p = e.effectivePlayingItem;
      if (p != null && (h = p.event) != null && h.restrictions.skip || !e.schedule)
        return;
      e.log(`seek to ${d} "${f}"`);
      const g = e.effectivePlayingItem, b = e.schedule.findItemIndexAtTime(d, f), y = (m = e.schedule.items) == null ? void 0 : m[b], T = e.getBufferingPlayer(), S = T == null ? void 0 : T.interstitial, I = S == null ? void 0 : S.appendInPlace, C = g && e.itemsMatch(g, y);
      if (g && (I || C)) {
        const _ = r(e.playingAsset), R = (_ == null ? void 0 : _.media) || e.primaryMedia;
        if (R) {
          const k = f === "primary" ? R.currentTime : i(g, f, e.playingAsset, "timelinePos", "currentTime"), A = d - k, L = (I ? k : R.currentTime) + A;
          if (L >= 0 && (!_ || I || L <= _.duration)) {
            R.currentTime = L;
            return;
          }
        }
      }
      if (y) {
        let _ = d;
        if (f !== "primary") {
          const k = y[f].start, A = d - k;
          _ = y.start + A;
        }
        const R = !e.isInterstitial(y);
        if ((!e.isInterstitial(g) || g.event.appendInPlace) && (R || y.event.appendInPlace)) {
          const k = e.media || (I ? T == null ? void 0 : T.media : null);
          k && (k.currentTime = _);
        } else if (g) {
          const k = e.findItemIndex(g);
          if (b > k) {
            const L = e.schedule.findJumpRestrictedIndex(k + 1, b);
            if (L > k) {
              e.setSchedulePosition(L);
              return;
            }
          }
          let A = 0;
          if (R)
            e.timelinePos = _, e.checkBuffer();
          else {
            const L = y.event.assetList, P = d - (y[f] || y).start;
            for (let $ = L.length; $--; ) {
              const G = L[$];
              if (G.duration && P >= G.startOffset && P < G.startOffset + G.duration) {
                A = $;
                break;
              }
            }
          }
          e.setSchedulePosition(b, A);
        }
      }
    }, l = () => {
      const d = e.effectivePlayingItem;
      if (e.isInterstitial(d))
        return d;
      const f = n();
      return e.isInterstitial(f) ? f : null;
    }, c = {
      get bufferedEnd() {
        const d = n(), f = e.bufferingItem;
        if (f && f === d) {
          var h;
          return i(f, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - f.playout.start || ((h = e.bufferingAsset) == null ? void 0 : h.startOffset) || 0;
        }
        return 0;
      },
      get currentTime() {
        const d = l(), f = e.effectivePlayingItem;
        return f && f === d ? i(f, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - f.playout.start : 0;
      },
      set currentTime(d) {
        const f = l(), h = e.effectivePlayingItem;
        h && h === f && u(d + h.playout.start, "playout");
      },
      get duration() {
        const d = l();
        return d ? d.playout.end - d.playout.start : 0;
      },
      get assetPlayers() {
        var d;
        const f = (d = l()) == null ? void 0 : d.event.assetList;
        return f ? f.map((h) => e.getAssetPlayer(h.identifier)) : [];
      },
      get playingIndex() {
        var d;
        const f = (d = l()) == null ? void 0 : d.event;
        return f && e.effectivePlayingAsset ? f.findAssetIndex(e.effectivePlayingAsset) : -1;
      },
      get scheduleItem() {
        return l();
      }
    };
    return this.manager = {
      get events() {
        var d;
        return ((d = e.schedule) == null || (d = d.events) == null ? void 0 : d.slice(0)) || [];
      },
      get schedule() {
        var d;
        return ((d = e.schedule) == null || (d = d.items) == null ? void 0 : d.slice(0)) || [];
      },
      get interstitialPlayer() {
        return l() ? c : null;
      },
      get playerQueue() {
        return e.playerQueue.slice(0);
      },
      get bufferingAsset() {
        return e.bufferingAsset;
      },
      get bufferingItem() {
        return n();
      },
      get bufferingIndex() {
        const d = n();
        return e.findItemIndex(d);
      },
      get playingAsset() {
        return e.effectivePlayingAsset;
      },
      get playingItem() {
        return e.effectivePlayingItem;
      },
      get playingIndex() {
        const d = e.effectivePlayingItem;
        return e.findItemIndex(d);
      },
      primary: {
        get bufferedEnd() {
          return a();
        },
        get currentTime() {
          const d = e.timelinePos;
          return d > 0 ? d : 0;
        },
        set currentTime(d) {
          u(d, "primary");
        },
        get duration() {
          return o("primary");
        },
        get seekableStart() {
          var d;
          return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0;
        }
      },
      integrated: {
        get bufferedEnd() {
          return i(n(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd");
        },
        get currentTime() {
          return i(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime");
        },
        set currentTime(d) {
          u(d, "integrated");
        },
        get duration() {
          return o("integrated");
        },
        get seekableStart() {
          var d;
          return s(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, "integrated");
        }
      },
      skip: () => {
        const d = e.effectivePlayingItem, f = d == null ? void 0 : d.event;
        if (f && !f.restrictions.skip) {
          const h = e.findItemIndex(d);
          if (f.appendInPlace) {
            const m = d.playout.start + d.event.duration;
            u(m + 1e-3, "playout");
          } else
            e.advanceAfterAssetEnded(f, h, 1 / 0);
        }
      }
    };
  }
  // Schedule getters
  get effectivePlayingItem() {
    return this.waitingItem || this.playingItem || this.endedItem;
  }
  get effectivePlayingAsset() {
    return this.playingAsset || this.endedAsset;
  }
  get playingLastItem() {
    var e;
    const n = this.playingItem, r = (e = this.schedule) == null ? void 0 : e.items;
    return !this.playbackStarted || !n || !r ? !1 : this.findItemIndex(n) === r.length - 1;
  }
  get playbackStarted() {
    return this.effectivePlayingItem !== null;
  }
  // Media getters and event callbacks
  get currentTime() {
    var e, n;
    if (this.mediaSelection === null)
      return;
    const r = this.waitingItem || this.playingItem;
    if (this.isInterstitial(r) && !r.event.appendInPlace)
      return;
    let i = this.media;
    !i && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (i = this.primaryMedia);
    const s = (n = i) == null ? void 0 : n.currentTime;
    if (!(s === void 0 || !de(s)))
      return s;
  }
  get primaryMedia() {
    var e;
    return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;
  }
  isInterstitial(e) {
    return !!(e != null && e.event);
  }
  retreiveMediaSource(e, n) {
    const r = this.getAssetPlayer(e);
    r && this.transferMediaFromPlayer(r, n);
  }
  transferMediaFromPlayer(e, n) {
    const r = e.interstitial.appendInPlace, i = e.media;
    if (r && i === this.primaryMedia) {
      if (this.bufferingAsset = null, (!n || this.isInterstitial(n) && !n.event.appendInPlace) && n && i) {
        this.detachedData = {
          media: i
        };
        return;
      }
      const s = e.transferMedia();
      this.log(`transfer MediaSource from ${e} ${Ze(s)}`), this.detachedData = s;
    } else n && i && (this.shouldPlay || (this.shouldPlay = !i.paused));
  }
  transferMediaTo(e, n) {
    var r, i;
    if (e.media === n)
      return;
    let s = null;
    const a = this.hls, o = e !== a, u = o && e.interstitial.appendInPlace, l = (r = this.detachedData) == null ? void 0 : r.mediaSource;
    let c;
    if (a.media)
      u && (s = a.transferMedia(), this.detachedData = s), c = "Primary";
    else if (l) {
      const m = this.getBufferingPlayer();
      m ? (s = m.transferMedia(), c = `${m}`) : c = "detached MediaSource";
    } else
      c = "detached media";
    if (!s) {
      if (l)
        s = this.detachedData, this.log(`using detachedData: MediaSource ${Ze(s)}`);
      else if (!this.detachedData || a.media === n) {
        const m = this.playerQueue;
        m.length > 1 && m.forEach((p) => {
          if (o && p.interstitial.appendInPlace !== u) {
            const g = p.interstitial;
            this.clearInterstitial(p.interstitial, null), g.appendInPlace = !1, g.appendInPlace && this.warn(`Could not change append strategy for queued assets ${g}`);
          }
        }), this.hls.detachMedia(), this.detachedData = {
          media: n
        };
      }
    }
    const d = s && "mediaSource" in s && ((i = s.mediaSource) == null ? void 0 : i.readyState) !== "closed", f = d && s ? s : n;
    this.log(`${d ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${c} (media.currentTime: ${n.currentTime})`);
    const h = this.schedule;
    if (f === s && h) {
      const m = o && e.assetId === h.assetIdAtEnd;
      f.overrides = {
        duration: h.duration,
        endOfStream: !o || m,
        cueRemoval: !o
      };
    }
    e.attachMedia(f);
  }
  onInterstitialCueEnter() {
    this.onTimeupdate();
  }
  // Scheduling methods
  checkStart() {
    const e = this.schedule, n = e == null ? void 0 : e.events;
    if (!n || this.playbackDisabled || !this.media)
      return;
    this.bufferedPos === -1 && (this.bufferedPos = 0);
    const r = this.timelinePos, i = this.effectivePlayingItem;
    if (r === -1) {
      const s = this.hls.startPosition;
      if (this.log(Do("checkStart", s)), this.timelinePos = s, n.length && n[0].cue.pre) {
        const a = e.findEventIndex(n[0].identifier);
        this.setSchedulePosition(a);
      } else if (s >= 0 || !this.primaryLive) {
        const a = this.timelinePos = s > 0 ? s : 0, o = e.findItemIndexAtTime(a);
        this.setSchedulePosition(o);
      }
    } else if (i && !this.playingItem) {
      const s = e.findItemIndex(i);
      this.setSchedulePosition(s);
    }
  }
  advanceAssetBuffering(e, n) {
    const r = e.event, i = r.findAssetIndex(n), s = Rc(r, i);
    if (!r.isAssetPastPlayoutLimit(s))
      this.bufferedToEvent(e, s);
    else if (this.schedule) {
      var a;
      const o = (a = this.schedule.items) == null ? void 0 : a[this.findItemIndex(e) + 1];
      o && this.bufferedToItem(o);
    }
  }
  advanceAfterAssetEnded(e, n, r) {
    const i = Rc(e, r);
    if (e.isAssetPastPlayoutLimit(i)) {
      if (this.schedule) {
        const s = this.schedule.items;
        if (s) {
          const a = n + 1, o = s.length;
          if (a >= o) {
            this.setSchedulePosition(-1);
            return;
          }
          const u = e.resumeTime;
          this.timelinePos < u && (this.log(Do("advanceAfterAssetEnded", u)), this.timelinePos = u, e.appendInPlace && this.advanceInPlace(u), this.checkBuffer(this.bufferedPos < u)), this.setSchedulePosition(a);
        }
      }
    } else {
      if (e.appendInPlace) {
        const s = e.assetList[i];
        s && this.advanceInPlace(s.timelineStart);
      }
      this.setSchedulePosition(n, i);
    }
  }
  setScheduleToAssetAtTime(e, n) {
    const r = this.schedule;
    if (!r)
      return;
    const i = n.parentIdentifier, s = r.getEvent(i);
    if (s) {
      const a = r.findEventIndex(i), o = r.findAssetIndex(s, e);
      this.advanceAfterAssetEnded(s, a, o - 1);
    }
  }
  setSchedulePosition(e, n) {
    var r;
    const i = (r = this.schedule) == null ? void 0 : r.items;
    if (!i || this.playbackDisabled)
      return;
    const s = e >= 0 ? i[e] : null;
    this.log(`setSchedulePosition ${e}, ${n} (${s && yn(s)}) pos: ${this.timelinePos}`);
    const a = this.waitingItem || this.playingItem, o = this.playingLastItem;
    if (this.isInterstitial(a)) {
      const c = a.event, d = this.playingAsset, f = d == null ? void 0 : d.identifier, h = f ? this.getAssetPlayer(f) : null;
      if (h && f && (!this.eventItemsMatch(a, s) || n !== void 0 && f !== c.assetList[n].identifier)) {
        var u;
        const m = c.findAssetIndex(d);
        if (this.log(`INTERSTITIAL_ASSET_ENDED ${m + 1}/${c.assetList.length} ${Fi(d)}`), this.endedAsset = d, this.playingAsset = null, this.hls.trigger(x.INTERSTITIAL_ASSET_ENDED, {
          asset: d,
          assetListIndex: m,
          event: c,
          schedule: i.slice(0),
          scheduleIndex: e,
          player: h
        }), a !== this.playingItem) {
          this.itemsMatch(a, this.playingItem) && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          !this.playingAsset && this.advanceAfterAssetEnded(c, this.findItemIndex(this.playingItem), m);
          return;
        }
        this.retreiveMediaSource(f, s), h.media && !((u = this.detachedData) != null && u.mediaSource) && h.detachMedia();
      }
      if (!this.eventItemsMatch(a, s) && (this.endedItem = a, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${c} ${yn(a)}`), c.hasPlayed = !0, this.hls.trigger(x.INTERSTITIAL_ENDED, {
        event: c,
        schedule: i.slice(0),
        scheduleIndex: e
      }), c.cue.once)) {
        var l;
        this.updateSchedule();
        const m = (l = this.schedule) == null ? void 0 : l.items;
        if (s && m) {
          const p = this.findItemIndex(s);
          this.advanceSchedule(p, m, n, a, o);
        }
        return;
      }
    }
    this.advanceSchedule(e, i, n, a, o);
  }
  advanceSchedule(e, n, r, i, s) {
    const a = this.schedule;
    if (!a)
      return;
    const o = n[e] || null, u = this.primaryMedia, l = this.playerQueue;
    if (l.length && l.forEach((c) => {
      const d = c.interstitial, f = a.findEventIndex(d.identifier);
      (f < e || f > e + 1) && this.clearInterstitial(d, o);
    }), this.isInterstitial(o)) {
      this.timelinePos = Math.min(Math.max(this.timelinePos, o.start), o.end);
      const c = o.event;
      if (r === void 0) {
        r = a.findAssetIndex(c, this.timelinePos);
        const m = Rc(c, r - 1);
        if (c.isAssetPastPlayoutLimit(m) || c.appendInPlace && this.timelinePos === o.end) {
          this.advanceAfterAssetEnded(c, e, r);
          return;
        }
        r = m;
      }
      const d = this.waitingItem;
      this.assetsBuffered(o, u) || this.setBufferingItem(o);
      let f = this.preloadAssets(c, r);
      if (this.eventItemsMatch(o, d || i) || (this.waitingItem = o, this.log(`INTERSTITIAL_STARTED ${yn(o)} ${c.appendInPlace ? "append in place" : ""}`), this.hls.trigger(x.INTERSTITIAL_STARTED, {
        event: c,
        schedule: n.slice(0),
        scheduleIndex: e
      })), !c.assetListLoaded) {
        this.log(`Waiting for ASSET-LIST to complete loading ${c}`);
        return;
      }
      if (c.assetListLoader && (c.assetListLoader.destroy(), c.assetListLoader = void 0), !u) {
        this.log(`Waiting for attachMedia to start Interstitial ${c}`);
        return;
      }
      this.waitingItem = this.endedItem = null, this.playingItem = o;
      const h = c.assetList[r];
      if (!h) {
        this.advanceAfterAssetEnded(c, e, r || 0);
        return;
      }
      if (f || (f = this.getAssetPlayer(h.identifier)), f === null || f.destroyed) {
        const m = c.assetList.length;
        this.warn(`asset ${r + 1}/${m} player destroyed ${c}`), f = this.createAssetPlayer(c, h, r), f.loadSource();
      }
      if (!this.eventItemsMatch(o, this.bufferingItem) && c.appendInPlace && this.isAssetBuffered(h))
        return;
      this.startAssetPlayer(f, r, n, e, u), this.shouldPlay && Gg(f.media);
    } else o ? (this.resumePrimary(o, e, i), this.shouldPlay && Gg(this.hls.media)) : s && this.isInterstitial(i) && (this.endedItem = null, this.playingItem = i, i.event.appendInPlace || this.attachPrimary(a.durations.primary, null));
  }
  get playbackDisabled() {
    return this.hls.config.enableInterstitialPlayback === !1;
  }
  get primaryDetails() {
    var e;
    return (e = this.mediaSelection) == null ? void 0 : e.main.details;
  }
  get primaryLive() {
    var e;
    return !!((e = this.primaryDetails) != null && e.live);
  }
  resumePrimary(e, n, r) {
    var i, s;
    if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${yn(e)}`), !((i = this.detachedData) != null && i.mediaSource)) {
      let o = this.timelinePos;
      (o < e.start || o >= e.end) && (o = this.getPrimaryResumption(e, n), this.log(Do("resumePrimary", o)), this.timelinePos = o), this.attachPrimary(o, e);
    }
    if (!r)
      return;
    const a = (s = this.schedule) == null ? void 0 : s.items;
    a && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${yn(e)}`), this.hls.trigger(x.INTERSTITIALS_PRIMARY_RESUMED, {
      schedule: a.slice(0),
      scheduleIndex: n
    }), this.checkBuffer());
  }
  getPrimaryResumption(e, n) {
    const r = e.start;
    if (this.primaryLive) {
      const i = this.primaryDetails;
      if (n === 0)
        return this.hls.startPosition;
      if (i && (r < i.fragmentStart || r > i.edge))
        return this.hls.liveSyncPosition || -1;
    }
    return r;
  }
  isAssetBuffered(e) {
    const n = this.getAssetPlayer(e.identifier);
    return n != null && n.hls ? n.hls.bufferedToEnd : Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0);
  }
  attachPrimary(e, n, r) {
    n ? this.setBufferingItem(n) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;
    const i = this.primaryMedia;
    if (!i)
      return;
    const s = this.hls;
    s.media ? this.checkBuffer() : (this.transferMediaTo(s, i), r && this.startLoadingPrimaryAt(e, r)), r || (this.log(Do("attachPrimary", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, r));
  }
  startLoadingPrimaryAt(e, n) {
    var r;
    const i = this.hls;
    !i.loadingEnabled || !i.media || Math.abs((((r = i.mainForwardBufferInfo) == null ? void 0 : r.start) || i.media.currentTime) - e) > 0.5 ? i.startLoad(e, n) : i.bufferingEnabled || i.resumeBuffering();
  }
  // HLS.js event callbacks
  onManifestLoading() {
    var e;
    this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(x.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(x.BUFFER_CODECS, this.onBufferCodecs, this);
  }
  onLevelUpdated(e, n) {
    if (n.level === -1 || !this.schedule)
      return;
    const r = this.hls.levels[n.level];
    if (!r.details)
      return;
    const i = ze(ze({}, this.mediaSelection || this.altSelection), {}, {
      main: r
    });
    this.mediaSelection = i, this.schedule.parseInterstitialDateRanges(i, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem && this.schedule.items && this.checkStart();
  }
  onAudioTrackUpdated(e, n) {
    const r = this.hls.audioTracks[n.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = ze(ze({}, this.altSelection), {}, {
        audio: r
      });
      return;
    }
    const s = ze(ze({}, i), {}, {
      audio: r
    });
    this.mediaSelection = s;
  }
  onSubtitleTrackUpdated(e, n) {
    const r = this.hls.subtitleTracks[n.id], i = this.mediaSelection;
    if (!i) {
      this.altSelection = ze(ze({}, this.altSelection), {}, {
        subtitles: r
      });
      return;
    }
    const s = ze(ze({}, i), {}, {
      subtitles: r
    });
    this.mediaSelection = s;
  }
  onAudioTrackSwitching(e, n) {
    const r = Zp(n);
    this.playerQueue.forEach(({
      hls: i
    }) => i && (i.setAudioOption(n) || i.setAudioOption(r)));
  }
  onSubtitleTrackSwitch(e, n) {
    const r = Zp(n);
    this.playerQueue.forEach(({
      hls: i
    }) => i && (i.setSubtitleOption(n) || n.id !== -1 && i.setSubtitleOption(r)));
  }
  onBufferCodecs(e, n) {
    const r = n.tracks;
    r && (this.requiredTracks = r);
  }
  onBufferAppended(e, n) {
    this.checkBuffer();
  }
  onBufferFlushed(e, n) {
    const r = this.playingItem;
    if (r && !this.itemsMatch(r, this.bufferingItem) && !this.isInterstitial(r)) {
      const i = this.timelinePos;
      this.bufferedPos = i, this.checkBuffer();
    }
  }
  onBufferedToEnd(e) {
    if (!this.schedule)
      return;
    const n = this.schedule.events;
    if (this.bufferedPos < Number.MAX_VALUE && n) {
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (s.cue.post) {
          var r;
          const a = this.schedule.findEventIndex(s.identifier), o = (r = this.schedule.items) == null ? void 0 : r[a];
          this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0);
          break;
        }
      }
      this.bufferedPos = Number.MAX_VALUE;
    }
  }
  onMediaEnded(e) {
    const n = this.playingItem;
    if (!this.playingLastItem && n) {
      const r = this.findItemIndex(n);
      this.setSchedulePosition(r + 1);
    } else
      this.shouldPlay = !1;
  }
  updateItem(e, n) {
    var r;
    const i = (r = this.schedule) == null ? void 0 : r.items;
    if (e && i) {
      const s = this.findItemIndex(e, n);
      return i[s] || null;
    }
    return null;
  }
  trimInPlace(e, n) {
    if (this.isInterstitial(e) && e.event.appendInPlace && n.end - e.end > 0.25) {
      e.event.assetList.forEach((s, a) => {
        e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(s.identifier, null);
      });
      const r = e.end + 0.25, i = Ce.bufferInfo(this.primaryMedia, r, 0);
      (i.end > r || (i.nextStart || 0) > r) && (this.log(`trim buffered interstitial ${yn(e)} (was ${yn(n)})`), this.attachPrimary(r, null, !0), this.flushFrontBuffer(r));
    }
  }
  itemsMatch(e, n) {
    return !!n && (e === n || e.event && n.event && this.eventItemsMatch(e, n) || !e.event && !n.event && this.findItemIndex(e) === this.findItemIndex(n));
  }
  eventItemsMatch(e, n) {
    var r;
    return !!n && (e === n || e.event.identifier === ((r = n.event) == null ? void 0 : r.identifier));
  }
  findItemIndex(e, n) {
    return e && this.schedule ? this.schedule.findItemIndex(e, n) : -1;
  }
  updateSchedule(e = !1) {
    var n;
    const r = this.mediaSelection;
    r && ((n = this.schedule) == null || n.updateSchedule(r, [], e));
  }
  // Schedule buffer control
  checkBuffer(e) {
    var n;
    const r = (n = this.schedule) == null ? void 0 : n.items;
    if (!r)
      return;
    const i = Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0);
    e && (this.bufferedPos = this.timelinePos), e || (e = i.len < 1), this.updateBufferedPos(i.end, r, e);
  }
  updateBufferedPos(e, n, r) {
    const i = this.schedule, s = this.bufferingItem;
    if (this.bufferedPos > e || !i)
      return;
    if (n.length === 1 && this.itemsMatch(n[0], s)) {
      this.bufferedPos = e;
      return;
    }
    const a = this.playingItem, o = this.findItemIndex(a);
    let u = i.findItemIndexAtTime(e);
    if (this.bufferedPos < e) {
      var l;
      const c = this.findItemIndex(s), d = Math.min(c + 1, n.length - 1), f = n[d];
      if ((u === -1 && s && e >= s.end || (l = f.event) != null && l.appendInPlace && e + 0.01 >= f.start) && (u = d), this.isInterstitial(s)) {
        const h = s.event;
        if (d - o > 1 && h.appendInPlace === !1 || h.assetList.length === 0 && h.assetListLoader)
          return;
      }
      if (this.bufferedPos = e, u > c && u > o)
        this.bufferedToItem(f);
      else {
        const h = this.primaryDetails;
        this.primaryLive && h && e > h.edge - h.targetduration && f.start < h.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(f) && this.preloadAssets(f.event, 0);
      }
    } else r && a && !this.itemsMatch(a, s) && (u === o ? this.bufferedToItem(a) : u === o + 1 && this.bufferedToItem(n[u]));
  }
  assetsBuffered(e, n) {
    return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((i) => {
      const s = this.getAssetPlayer(i.identifier);
      return !(s != null && s.bufferedInPlaceToEnd(n));
    });
  }
  setBufferingItem(e) {
    const n = this.bufferingItem, r = this.schedule;
    if (!this.itemsMatch(e, n) && r) {
      const {
        items: i,
        events: s
      } = r;
      if (!i || !s)
        return n;
      const a = this.isInterstitial(e), o = this.getBufferingPlayer();
      this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
      const u = o ? o.remaining : n ? n.end - this.timelinePos : 0;
      if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${yn(e)}` + (n ? ` (${u.toFixed(2)} remaining)` : "")), !this.playbackDisabled)
        if (a) {
          const l = r.findAssetIndex(e.event, this.bufferedPos);
          e.event.assetList.forEach((c, d) => {
            const f = this.getAssetPlayer(c.identifier);
            f && (d === l && f.loadSource(), f.resumeBuffering());
          });
        } else
          this.hls.resumeBuffering(), this.playerQueue.forEach((l) => l.pauseBuffering());
      this.hls.trigger(x.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
        events: s.slice(0),
        schedule: i.slice(0),
        bufferingIndex: this.findItemIndex(e),
        playingIndex: this.findItemIndex(this.playingItem)
      });
    } else this.bufferingItem !== e && (this.bufferingItem = e);
    return n;
  }
  bufferedToItem(e, n = 0) {
    const r = this.setBufferingItem(e);
    if (!this.playbackDisabled) {
      if (this.isInterstitial(e))
        this.bufferedToEvent(e, n);
      else if (r !== null) {
        this.bufferingAsset = null;
        const i = this.detachedData;
        i ? i.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);
      }
    }
  }
  preloadPrimary(e) {
    const n = this.findItemIndex(e), r = this.getPrimaryResumption(e, n);
    this.startLoadingPrimaryAt(r);
  }
  bufferedToEvent(e, n) {
    const r = e.event, i = r.assetList.length === 0 && !r.assetListLoader, s = r.cue.once;
    if (i || !s) {
      const a = this.preloadAssets(r, n);
      if (a != null && a.interstitial.appendInPlace) {
        const o = this.primaryMedia;
        o && this.bufferAssetPlayer(a, o);
      }
    }
  }
  preloadAssets(e, n) {
    const r = e.assetUrl, i = e.assetList.length, s = i === 0 && !e.assetListLoader, a = e.cue.once;
    if (s) {
      const u = e.timelineStart;
      if (e.appendInPlace) {
        var o;
        const f = this.playingItem;
        !this.isInterstitial(f) && (f == null || (o = f.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(u + 0.25);
      }
      let l, c = 0;
      if (!this.playingItem && this.primaryLive && (c = this.hls.startPosition, c === -1 && (c = this.hls.liveSyncPosition || 0)), c && !(e.cue.pre || e.cue.post)) {
        const f = c - u;
        f > 0 && (l = Math.round(f * 1e3) / 1e3);
      }
      if (this.log(`Load interstitial asset ${n + 1}/${r ? 1 : i} ${e}${l ? ` live-start: ${c} start-offset: ${l}` : ""}`), r)
        return this.createAsset(e, 0, 0, u, e.duration, r);
      const d = this.assetListLoader.loadAssetList(e, l);
      d && (e.assetListLoader = d);
    } else if (!a && i) {
      for (let l = n; l < i; l++) {
        const c = e.assetList[l], d = this.getAssetPlayerQueueIndex(c.identifier);
        (d === -1 || this.playerQueue[d].destroyed) && !c.error && this.createAssetPlayer(e, c, l);
      }
      const u = e.assetList[n];
      if (u) {
        const l = this.getAssetPlayer(u.identifier);
        return l && l.loadSource(), l;
      }
    }
    return null;
  }
  flushFrontBuffer(e) {
    const n = this.requiredTracks;
    if (!n)
      return;
    this.log(`Removing front buffer starting at ${e}`), Object.keys(n).forEach((i) => {
      this.hls.trigger(x.BUFFER_FLUSHING, {
        startOffset: e,
        endOffset: 1 / 0,
        type: i
      });
    });
  }
  // Interstitial Asset Player control
  getAssetPlayerQueueIndex(e) {
    const n = this.playerQueue;
    for (let r = 0; r < n.length; r++)
      if (e === n[r].assetId)
        return r;
    return -1;
  }
  getAssetPlayer(e) {
    const n = this.getAssetPlayerQueueIndex(e);
    return this.playerQueue[n] || null;
  }
  getBufferingPlayer() {
    const {
      playerQueue: e,
      primaryMedia: n
    } = this;
    if (n) {
      for (let r = 0; r < e.length; r++)
        if (e[r].media === n)
          return e[r];
    }
    return null;
  }
  createAsset(e, n, r, i, s, a) {
    const o = {
      parentIdentifier: e.identifier,
      identifier: YU(e, a, n),
      duration: s,
      startOffset: r,
      timelineStart: i,
      uri: a
    };
    return this.createAssetPlayer(e, o, n);
  }
  createAssetPlayer(e, n, r) {
    const i = this.hls, s = i.userConfig;
    let a = s.videoPreference;
    const o = i.loadLevelObj || i.levels[i.currentLevel];
    (a || o) && (a = Xe({}, a), o.videoCodec && (a.videoCodec = o.videoCodec), o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
    const u = i.audioTracks[i.audioTrack], l = i.subtitleTracks[i.subtitleTrack];
    let c = 0;
    if (this.primaryLive || e.appendInPlace) {
      const S = this.timelinePos - n.timelineStart;
      if (S > 1) {
        const I = n.duration;
        I && S < I && (c = S);
      }
    }
    const d = n.identifier, f = ze(ze({}, s), {}, {
      maxMaxBufferLength: Math.min(180, i.config.maxMaxBufferLength),
      autoStartLoad: !0,
      startFragPrefetch: !0,
      primarySessionId: i.sessionId,
      assetPlayerId: d,
      abrEwmaDefaultEstimate: i.bandwidthEstimate,
      interstitialsController: void 0,
      startPosition: c,
      liveDurationInfinity: !1,
      testBandwidth: !1,
      videoPreference: a,
      audioPreference: u || s.audioPreference,
      subtitlePreference: l || s.subtitlePreference
    });
    e.appendInPlace && (e.appendInPlaceStarted = !0, n.timelineStart && (f.timelineOffset = n.timelineStart));
    const h = f.cmcd;
    h != null && h.sessionId && h.contentId && (f.cmcd = Xe({}, h, {
      contentId: aa(n.uri)
    })), this.getAssetPlayer(d) && this.warn(`Duplicate date range identifier ${e} and asset ${d}`);
    const m = new ZU(this.HlsPlayerClass, f, e, n);
    this.playerQueue.push(m), e.assetList[r] = n;
    let p = !0;
    const g = (S) => {
      if (S.live) {
        var I;
        const R = new Error(`Interstitials MUST be VOD assets ${e}`), k = {
          fatal: !0,
          type: be.OTHER_ERROR,
          details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: R
        }, A = ((I = this.schedule) == null ? void 0 : I.findEventIndex(e.identifier)) || -1;
        this.handleAssetItemError(k, e, A, r, R.message);
        return;
      }
      const C = S.edge - S.fragmentStart, _ = n.duration;
      (p || _ === null || C > _) && (p = !1, this.log(`Interstitial asset "${d}" duration change ${_} > ${C}`), n.duration = C, this.updateSchedule());
    };
    m.on(x.LEVEL_UPDATED, (S, {
      details: I
    }) => g(I)), m.on(x.LEVEL_PTS_UPDATED, (S, {
      details: I
    }) => g(I)), m.on(x.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter());
    const b = (S, I) => {
      const C = this.getAssetPlayer(d);
      if (C && I.tracks) {
        C.off(x.BUFFER_CODECS, b), C.tracks = I.tracks;
        const _ = this.primaryMedia;
        this.bufferingAsset === C.assetItem && _ && !C.media && this.bufferAssetPlayer(C, _);
      }
    };
    m.on(x.BUFFER_CODECS, b);
    const y = () => {
      var S;
      const I = this.getAssetPlayer(d);
      if (this.log(`buffered to end of asset ${I}`), !I || !this.schedule)
        return;
      const C = this.schedule.findEventIndex(e.identifier), _ = (S = this.schedule.items) == null ? void 0 : S[C];
      this.isInterstitial(_) && this.advanceAssetBuffering(_, n);
    };
    m.on(x.BUFFERED_TO_END, y);
    const T = (S) => () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      this.shouldPlay = !0;
      const C = this.schedule.findEventIndex(e.identifier);
      this.advanceAfterAssetEnded(e, C, S);
    };
    return m.once(x.MEDIA_ENDED, T(r)), m.once(x.PLAYOUT_LIMIT_REACHED, T(1 / 0)), m.on(x.ERROR, (S, I) => {
      if (!this.schedule)
        return;
      const C = this.getAssetPlayer(d);
      if (I.details === q.BUFFER_STALLED_ERROR) {
        if (C != null && C.appendInPlace) {
          this.handleInPlaceStall(e);
          return;
        }
        this.onTimeupdate(), this.checkBuffer(!0);
        return;
      }
      this.handleAssetItemError(I, e, this.schedule.findEventIndex(e.identifier), r, `Asset player error ${I.error} ${e}`);
    }), m.on(x.DESTROYING, () => {
      if (!this.getAssetPlayer(d) || !this.schedule)
        return;
      const I = new Error(`Asset player destroyed unexpectedly ${d}`), C = {
        fatal: !0,
        type: be.OTHER_ERROR,
        details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
        error: I
      };
      this.handleAssetItemError(C, e, this.schedule.findEventIndex(e.identifier), r, I.message);
    }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Fi(n)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_PLAYER_CREATED, {
      asset: n,
      assetListIndex: r,
      event: e,
      player: m
    }), m;
  }
  clearInterstitial(e, n) {
    e.assetList.forEach((r) => {
      this.clearAssetPlayer(r.identifier, n);
    }), e.reset();
  }
  resetAssetPlayer(e) {
    const n = this.getAssetPlayerQueueIndex(e);
    if (n !== -1) {
      this.log(`reset asset player "${e}" after error`);
      const r = this.playerQueue[n];
      this.transferMediaFromPlayer(r, null), r.resetDetails();
    }
  }
  clearAssetPlayer(e, n) {
    const r = this.getAssetPlayerQueueIndex(e);
    if (r !== -1) {
      const i = this.playerQueue[r];
      this.log(`clear ${i} toSegment: ${n && yn(n)}`), this.transferMediaFromPlayer(i, n), this.playerQueue.splice(r, 1), i.destroy();
    }
  }
  emptyPlayerQueue() {
    let e;
    for (; e = this.playerQueue.pop(); )
      e.destroy();
    this.playerQueue = [];
  }
  startAssetPlayer(e, n, r, i, s) {
    const {
      interstitial: a,
      assetItem: o,
      assetId: u
    } = e, l = a.assetList.length, c = this.playingAsset;
    this.endedAsset = null, this.playingAsset = o, (!c || c.identifier !== u) && (c && (this.clearAssetPlayer(c.identifier, r[i]), delete c.error), this.log(`INTERSTITIAL_ASSET_STARTED ${n + 1}/${l} ${Fi(o)}`), this.hls.trigger(x.INTERSTITIAL_ASSET_STARTED, {
      asset: o,
      assetListIndex: n,
      event: a,
      schedule: r.slice(0),
      scheduleIndex: i,
      player: e
    })), this.bufferAssetPlayer(e, s);
  }
  bufferAssetPlayer(e, n) {
    var r, i;
    if (!this.schedule)
      return;
    const {
      interstitial: s,
      assetItem: a
    } = e, o = this.schedule.findEventIndex(s.identifier), u = (r = this.schedule.items) == null ? void 0 : r[o];
    if (!u)
      return;
    e.loadSource(), this.setBufferingItem(u), this.bufferingAsset = a;
    const l = this.getBufferingPlayer();
    if (l === e)
      return;
    const c = s.appendInPlace;
    if (c && (l == null ? void 0 : l.interstitial.appendInPlace) === !1)
      return;
    const d = (l == null ? void 0 : l.tracks) || ((i = this.detachedData) == null ? void 0 : i.tracks) || this.requiredTracks;
    if (c && a !== this.playingAsset) {
      if (!e.tracks) {
        this.log(`Waiting for track info before buffering ${e}`);
        return;
      }
      if (d && !ex(d, e.tracks)) {
        const f = new Error(`Asset ${Fi(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`), h = {
          fatal: !0,
          type: be.OTHER_ERROR,
          details: q.INTERSTITIAL_ASSET_ITEM_ERROR,
          error: f
        }, m = s.findAssetIndex(a);
        this.handleAssetItemError(h, s, o, m, f.message);
        return;
      }
    }
    this.transferMediaTo(e, n);
  }
  handleInPlaceStall(e) {
    const n = this.schedule, r = this.primaryMedia;
    if (!n || !r)
      return;
    const i = r.currentTime, s = n.findAssetIndex(e, i), a = e.assetList[s];
    if (a) {
      const o = this.getAssetPlayer(a.identifier);
      if (o) {
        const u = o.currentTime || i - a.timelineStart, l = o.duration - u;
        if (this.warn(`Stalled at ${u} of ${u + l} in ${o} ${e} (media.currentTime: ${i})`), u && (l / r.playbackRate < 0.5 || o.bufferedInPlaceToEnd(r)) && o.hls) {
          const c = n.findEventIndex(e.identifier);
          this.advanceAfterAssetEnded(e, c, s);
        }
      }
    }
  }
  advanceInPlace(e) {
    const n = this.primaryMedia;
    n && n.currentTime < e && (n.currentTime = e);
  }
  handleAssetItemError(e, n, r, i, s) {
    if (e.details === q.BUFFER_STALLED_ERROR)
      return;
    const a = n.assetList[i] || null;
    if (this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Fi(a)} ${e.error}`), !this.schedule)
      return;
    const o = (a == null ? void 0 : a.identifier) || "", u = this.getAssetPlayerQueueIndex(o), l = this.playerQueue[u] || null, c = this.schedule.items, d = Xe({}, e, {
      fatal: !1,
      errorAction: ji(!0),
      asset: a,
      assetListIndex: i,
      event: n,
      schedule: c,
      scheduleIndex: r,
      player: l
    });
    if (this.hls.trigger(x.INTERSTITIAL_ASSET_ERROR, d), !e.fatal)
      return;
    const f = this.playingAsset, h = this.bufferingAsset, m = new Error(s);
    if (a && (this.clearAssetPlayer(o, null), a.error = m), !n.assetList.some((p) => !p.error))
      n.error = m;
    else
      for (let p = i; p < n.assetList.length; p++)
        this.resetAssetPlayer(n.assetList[p].identifier);
    this.updateSchedule(!0), n.error ? this.primaryFallback(n) : f && f.identifier === o ? this.advanceAfterAssetEnded(n, r, i) : h && h.identifier === o && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, h);
  }
  primaryFallback(e) {
    const n = e.timelineStart, r = this.effectivePlayingItem;
    if (r) {
      this.log(`Fallback to primary from event "${e.identifier}" start: ${n} pos: ${this.timelinePos} playing: ${yn(r)} error: ${e.error}`);
      let i = this.timelinePos;
      i === -1 && (i = this.hls.startPosition);
      const s = this.updateItem(r, i);
      if (this.itemsMatch(r, s) && this.clearInterstitial(e, null), e.appendInPlace && (this.attachPrimary(n, null), this.flushFrontBuffer(n)), !this.schedule)
        return;
      const a = this.schedule.findItemIndexAtTime(i);
      this.setSchedulePosition(a);
    } else
      this.checkStart();
  }
  // Asset List loading
  onAssetListLoaded(e, n) {
    var r, i;
    const s = n.event, a = s.identifier, o = n.assetListResponse.ASSETS;
    if (!((r = this.schedule) != null && r.hasEvent(a)))
      return;
    const u = s.timelineStart, l = s.duration;
    let c = 0;
    o.forEach((p, g) => {
      const b = parseFloat(p.DURATION);
      this.createAsset(s, g, c, u + c, b, p.URI), c += b;
    }), s.duration = c, this.log(`Loaded asset-list with duration: ${c} (was: ${l}) ${s}`);
    const d = this.waitingItem, f = (d == null ? void 0 : d.event.identifier) === a;
    this.updateSchedule();
    const h = (i = this.bufferingItem) == null ? void 0 : i.event;
    if (f) {
      var m;
      const p = this.schedule.findEventIndex(a), g = (m = this.schedule.items) == null ? void 0 : m[p];
      if (g) {
        if (!this.playingItem && this.timelinePos > g.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== p) {
          s.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${s}`), this.updateSchedule(!0), this.primaryFallback(s);
          return;
        }
        this.setBufferingItem(g);
      }
      this.setSchedulePosition(p);
    } else if ((h == null ? void 0 : h.identifier) === a) {
      const p = s.assetList[0];
      if (p) {
        const g = this.getAssetPlayer(p.identifier);
        if (h.appendInPlace) {
          const b = this.primaryMedia;
          g && b && this.bufferAssetPlayer(g, b);
        } else g && g.loadSource();
      }
    }
  }
  onError(e, n) {
    if (this.schedule)
      switch (n.details) {
        case q.ASSET_LIST_PARSING_ERROR:
        case q.ASSET_LIST_LOAD_ERROR:
        case q.ASSET_LIST_LOAD_TIMEOUT: {
          const r = n.interstitial;
          r && (this.updateSchedule(!0), this.primaryFallback(r));
          break;
        }
        case q.BUFFER_STALLED_ERROR: {
          const r = this.endedItem || this.waitingItem || this.playingItem;
          if (this.isInterstitial(r) && r.event.appendInPlace) {
            this.handleInPlaceStall(r.event);
            return;
          }
          this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0);
          break;
        }
      }
  }
}
const zg = 500;
class n7 extends Wh {
  constructor(e, n, r) {
    super(e, n, r, "subtitle-stream-controller", pe.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();
  }
  onHandlerDestroying() {
    this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(x.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(x.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  startLoad(e, n) {
    this.stopLoad(), this.state = Z.IDLE, this.setInterval(zg), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
  }
  onManifestLoading() {
    super.onManifestLoading(), this.mainDetails = null;
  }
  onMediaDetaching(e, n) {
    this.tracksBuffered = [], super.onMediaDetaching(e, n);
  }
  onLevelLoaded(e, n) {
    this.mainDetails = n.details;
  }
  onSubtitleFragProcessed(e, n) {
    const {
      frag: r,
      success: i
    } = n;
    if (this.fragContextChanged(r) || (gt(r) && (this.fragPrevious = r), this.state = Z.IDLE), !i)
      return;
    const s = this.tracksBuffered[this.currentTrackId];
    if (!s)
      return;
    let a;
    const o = r.start;
    for (let l = 0; l < s.length; l++)
      if (o >= s[l].start && o <= s[l].end) {
        a = s[l];
        break;
      }
    const u = r.start + r.duration;
    a ? a.end = u : (a = {
      start: o,
      end: u
    }, s.push(a)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null), this.media && this.tick();
  }
  onBufferFlushing(e, n) {
    const {
      startOffset: r,
      endOffset: i
    } = n;
    if (r === 0 && i !== Number.POSITIVE_INFINITY) {
      const s = i - 1;
      if (s <= 0)
        return;
      n.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach((a) => {
        for (let o = 0; o < a.length; ) {
          if (a[o].end <= s) {
            a.shift();
            continue;
          } else if (a[o].start < s)
            a[o].start = s;
          else
            break;
          o++;
        }
      }), this.fragmentTracker.removeFragmentsInRange(r, s, pe.SUBTITLE);
    }
  }
  // If something goes wrong, proceed to next frag, if we were processing one.
  onError(e, n) {
    const r = n.frag;
    (r == null ? void 0 : r.type) === pe.SUBTITLE && (n.details === q.FRAG_GAP && this.fragmentTracker.fragBuffered(r, !0), this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== Z.STOPPED && (this.state = Z.IDLE));
  }
  // Got all new subtitle levels.
  onSubtitleTracksUpdated(e, {
    subtitleTracks: n
  }) {
    if (this.levels && rv(this.levels, n)) {
      this.levels = n.map((r) => new Ia(r));
      return;
    }
    this.tracksBuffered = [], this.levels = n.map((r) => {
      const i = new Ia(r);
      return this.tracksBuffered[i.id] = [], i;
    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, pe.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(e, n) {
    var r;
    if (this.currentTrackId = n.id, !((r = this.levels) != null && r.length) || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const i = this.levels[this.currentTrackId];
    i != null && i.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, i && this.state !== Z.STOPPED && this.setInterval(zg);
  }
  // Got a new set of subtitle fragments.
  onSubtitleTrackLoaded(e, n) {
    var r;
    const {
      currentTrackId: i,
      levels: s
    } = this, {
      details: a,
      id: o
    } = n;
    if (!s) {
      this.warn(`Subtitle tracks were reset while loading level ${o}`);
      return;
    }
    const u = s[o];
    if (o >= s.length || !u)
      return;
    this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;
    let l = 0;
    if (a.live || (r = u.details) != null && r.live) {
      if (a.deltaUpdateFailed)
        return;
      const d = this.mainDetails;
      if (!d) {
        this.startFragRequested = !1;
        return;
      }
      const f = d.fragments[0];
      if (!u.details)
        a.hasProgramDateTime && d.hasProgramDateTime ? ($u(a, d), l = a.fragmentStart) : f && (l = f.start, Jd(a, l));
      else {
        var c;
        l = this.alignPlaylists(a, u.details, (c = this.levelLastLoaded) == null ? void 0 : c.details), l === 0 && f && (l = f.start, Jd(a, l));
      }
      d && !this.startFragRequested && this.setStartPosition(d, l);
    }
    u.details = a, this.levelLastLoaded = u, o === i && (this.hls.trigger(x.SUBTITLE_TRACK_UPDATED, {
      details: a,
      id: o,
      groupId: n.groupId
    }), this.tick(), a.live && !this.fragCurrent && this.media && this.state === Z.IDLE && (ai(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), u.details = void 0)));
  }
  _handleFragmentLoadComplete(e) {
    const {
      frag: n,
      payload: r
    } = e, i = n.decryptdata, s = this.hls;
    if (!this.fragContextChanged(n) && r && r.byteLength > 0 && i != null && i.key && i.iv && Yi(i.method)) {
      const a = performance.now();
      this.decrypter.decrypt(new Uint8Array(r), i.key.buffer, i.iv.buffer, zh(i.method)).catch((o) => {
        throw s.trigger(x.ERROR, {
          type: be.MEDIA_ERROR,
          details: q.FRAG_DECRYPT_ERROR,
          fatal: !1,
          error: o,
          reason: o.message,
          frag: n
        }), o;
      }).then((o) => {
        const u = performance.now();
        s.trigger(x.FRAG_DECRYPTED, {
          frag: n,
          payload: o,
          stats: {
            tstart: a,
            tdecrypt: u
          }
        });
      }).catch((o) => {
        this.warn(`${o.name}: ${o.message}`), this.state = Z.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = Z.IDLE;
      return;
    }
    if (this.state === Z.IDLE) {
      const {
        currentTrackId: e,
        levels: n
      } = this, r = n == null ? void 0 : n[e];
      if (!r || !n.length || !r.details || this.waitForLive(r))
        return;
      const {
        config: i
      } = this, s = this.getLoadPosition(), a = Ce.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], s, i.maxBufferHole), {
        end: o,
        len: u
      } = a, l = r.details, c = this.hls.maxBufferLength + l.levelTargetDuration;
      if (u > c)
        return;
      const d = l.fragments, f = d.length, h = l.edge;
      let m = null;
      const p = this.fragPrevious;
      if (o < h) {
        const y = i.maxFragLookUpTolerance, T = o > h - y ? 0 : y;
        m = ai(p, d, Math.max(d[0].start, o), T), !m && p && p.start < d[0].start && (m = d[0]);
      } else
        m = d[f - 1];
      if (m = this.filterReplacedPrimary(m, r.details), !m)
        return;
      const g = m.sn - l.startSN, b = d[g - 1];
      if (b && b.cc === m.cc && this.fragmentTracker.getState(b) === Tt.NOT_LOADED && (m = b), this.fragmentTracker.getState(m) === Tt.NOT_LOADED) {
        const y = this.mapToInitFragWhenRequired(m);
        y && this.loadFragment(y, r, o);
      }
    }
  }
  loadFragment(e, n, r) {
    gt(e) ? super.loadFragment(e, n, r) : this._loadInitSegment(e, n);
  }
  get mediaBufferTimeRanges() {
    return new r7(this.tracksBuffered[this.currentTrackId] || []);
  }
}
class r7 {
  constructor(e) {
    this.buffered = void 0;
    const n = (r, i, s) => {
      if (i = i >>> 0, i > s - 1)
        throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${s})`);
      return e[i][r];
    };
    this.buffered = {
      get length() {
        return e.length;
      },
      end(r) {
        return n("end", r, e.length);
      },
      start(r) {
        return n("start", r, e.length);
      }
    };
  }
}
const i7 = {
  42: 225,
  // lowercase a, acute accent
  92: 233,
  // lowercase e, acute accent
  94: 237,
  // lowercase i, acute accent
  95: 243,
  // lowercase o, acute accent
  96: 250,
  // lowercase u, acute accent
  123: 231,
  // lowercase c with cedilla
  124: 247,
  // division symbol
  125: 209,
  // uppercase N tilde
  126: 241,
  // lowercase n tilde
  127: 9608,
  // Full block
  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
  // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
  128: 174,
  // Registered symbol (R)
  129: 176,
  // degree sign
  130: 189,
  // 1/2 symbol
  131: 191,
  // Inverted (open) question mark
  132: 8482,
  // Trademark symbol (TM)
  133: 162,
  // Cents symbol
  134: 163,
  // Pounds sterling
  135: 9834,
  // Music 8'th note
  136: 224,
  // lowercase a, grave accent
  137: 32,
  // transparent space (regular)
  138: 232,
  // lowercase e, grave accent
  139: 226,
  // lowercase a, circumflex accent
  140: 234,
  // lowercase e, circumflex accent
  141: 238,
  // lowercase i, circumflex accent
  142: 244,
  // lowercase o, circumflex accent
  143: 251,
  // lowercase u, circumflex accent
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
  144: 193,
  // capital letter A with acute
  145: 201,
  // capital letter E with acute
  146: 211,
  // capital letter O with acute
  147: 218,
  // capital letter U with acute
  148: 220,
  // capital letter U with diaresis
  149: 252,
  // lowercase letter U with diaeresis
  150: 8216,
  // opening single quote
  151: 161,
  // inverted exclamation mark
  152: 42,
  // asterisk
  153: 8217,
  // closing single quote
  154: 9473,
  // box drawings heavy horizontal
  155: 169,
  // copyright sign
  156: 8480,
  // Service mark
  157: 8226,
  // (round) bullet
  158: 8220,
  // Left double quotation mark
  159: 8221,
  // Right double quotation mark
  160: 192,
  // uppercase A, grave accent
  161: 194,
  // uppercase A, circumflex
  162: 199,
  // uppercase C with cedilla
  163: 200,
  // uppercase E, grave accent
  164: 202,
  // uppercase E, circumflex
  165: 203,
  // capital letter E with diaresis
  166: 235,
  // lowercase letter e with diaresis
  167: 206,
  // uppercase I, circumflex
  168: 207,
  // uppercase I, with diaresis
  169: 239,
  // lowercase i, with diaresis
  170: 212,
  // uppercase O, circumflex
  171: 217,
  // uppercase U, grave accent
  172: 249,
  // lowercase u, grave accent
  173: 219,
  // uppercase U, circumflex
  174: 171,
  // left-pointing double angle quotation mark
  175: 187,
  // right-pointing double angle quotation mark
  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
  176: 195,
  // Uppercase A, tilde
  177: 227,
  // Lowercase a, tilde
  178: 205,
  // Uppercase I, acute accent
  179: 204,
  // Uppercase I, grave accent
  180: 236,
  // Lowercase i, grave accent
  181: 210,
  // Uppercase O, grave accent
  182: 242,
  // Lowercase o, grave accent
  183: 213,
  // Uppercase O, tilde
  184: 245,
  // Lowercase o, tilde
  185: 123,
  // Open curly brace
  186: 125,
  // Closing curly brace
  187: 92,
  // Backslash
  188: 94,
  // Caret
  189: 95,
  // Underscore
  190: 124,
  // Pipe (vertical line)
  191: 8764,
  // Tilde operator
  192: 196,
  // Uppercase A, umlaut
  193: 228,
  // Lowercase A, umlaut
  194: 214,
  // Uppercase O, umlaut
  195: 246,
  // Lowercase o, umlaut
  196: 223,
  // Esszett (sharp S)
  197: 165,
  // Yen symbol
  198: 164,
  // Generic currency sign
  199: 9475,
  // Box drawings heavy vertical
  200: 197,
  // Uppercase A, ring
  201: 229,
  // Lowercase A, ring
  202: 216,
  // Uppercase O, stroke
  203: 248,
  // Lowercase o, strok
  204: 9487,
  // Box drawings heavy down and right
  205: 9491,
  // Box drawings heavy down and left
  206: 9495,
  // Box drawings heavy up and right
  207: 9499
  // Box drawings heavy up and left
}, yv = (t) => String.fromCharCode(i7[t] || t), Tn = 15, sr = 100, s7 = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
}, a7 = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
}, o7 = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
}, u7 = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
}, l7 = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class c7 {
  constructor() {
    this.time = null, this.verboseLevel = 0;
  }
  log(e, n) {
    if (this.verboseLevel >= e) {
      const r = typeof n == "function" ? n() : n;
      qe.log(`${this.time} [${e}] ${r}`);
    }
  }
}
const Kr = function(e) {
  const n = [];
  for (let r = 0; r < e.length; r++)
    n.push(e[r].toString(16));
  return n;
};
class Tv {
  constructor() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  reset() {
    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
  }
  setStyles(e) {
    const n = ["foreground", "underline", "italics", "background", "flash"];
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      e.hasOwnProperty(i) && (this[i] = e[i]);
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(e) {
    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash;
  }
  copy(e) {
    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}
class d7 {
  constructor() {
    this.uchar = " ", this.penState = new Tv();
  }
  reset() {
    this.uchar = " ", this.penState.reset();
  }
  setChar(e, n) {
    this.uchar = e, this.penState.copy(n);
  }
  setPenState(e) {
    this.penState.copy(e);
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState);
  }
  copy(e) {
    this.uchar = e.uchar, this.penState.copy(e.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}
class f7 {
  constructor(e) {
    this.chars = [], this.pos = 0, this.currPenState = new Tv(), this.cueStartTime = null, this.logger = void 0;
    for (let n = 0; n < sr; n++)
      this.chars.push(new d7());
    this.logger = e;
  }
  equals(e) {
    for (let n = 0; n < sr; n++)
      if (!this.chars[n].equals(e.chars[n]))
        return !1;
    return !0;
  }
  copy(e) {
    for (let n = 0; n < sr; n++)
      this.chars[n].copy(e.chars[n]);
  }
  isEmpty() {
    let e = !0;
    for (let n = 0; n < sr; n++)
      if (!this.chars[n].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  /**
   *  Set the cursor to a valid column.
   */
  setCursor(e) {
    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > sr && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = sr);
  }
  /**
   * Move the cursor relative to current position.
   */
  moveCursor(e) {
    const n = this.pos + e;
    if (e > 1)
      for (let r = this.pos + 1; r < n + 1; r++)
        this.chars[r].setPenState(this.currPenState);
    this.setCursor(n);
  }
  /**
   * Backspace, move one step back and clear character.
   */
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(e) {
    e >= 144 && this.backSpace();
    const n = yv(e);
    if (this.pos >= sr) {
      this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + n + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(n, this.currPenState), this.moveCursor(1);
  }
  clearFromPos(e) {
    let n;
    for (n = e; n < sr; n++)
      this.chars[n].reset();
  }
  clear() {
    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const e = [];
    let n = !0;
    for (let r = 0; r < sr; r++) {
      const i = this.chars[r].uchar;
      i !== " " && (n = !1), e.push(i);
    }
    return n ? "" : e.join("");
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);
  }
}
class wc {
  constructor(e) {
    this.rows = [], this.currRow = Tn - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;
    for (let n = 0; n < Tn; n++)
      this.rows.push(new f7(e));
    this.logger = e;
  }
  reset() {
    for (let e = 0; e < Tn; e++)
      this.rows[e].clear();
    this.currRow = Tn - 1;
  }
  equals(e) {
    let n = !0;
    for (let r = 0; r < Tn; r++)
      if (!this.rows[r].equals(e.rows[r])) {
        n = !1;
        break;
      }
    return n;
  }
  copy(e) {
    for (let n = 0; n < Tn; n++)
      this.rows[n].copy(e.rows[n]);
  }
  isEmpty() {
    let e = !0;
    for (let n = 0; n < Tn; n++)
      if (!this.rows[n].isEmpty()) {
        e = !1;
        break;
      }
    return e;
  }
  backSpace() {
    this.rows[this.currRow].backSpace();
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow();
  }
  /**
   * Insert a character (without styling) in the current row.
   */
  insertChar(e) {
    this.rows[this.currRow].insertChar(e);
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e);
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e);
  }
  setCursor(e) {
    this.logger.log(2, "setCursor: " + e), this.rows[this.currRow].setCursor(e);
  }
  setPAC(e) {
    this.logger.log(2, () => "pacData = " + Ze(e));
    let n = e.row - 1;
    if (this.nrRollUpRows && n < this.nrRollUpRows - 1 && (n = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== n) {
      for (let o = 0; o < Tn; o++)
        this.rows[o].clear();
      const s = this.currRow + 1 - this.nrRollUpRows, a = this.lastOutputScreen;
      if (a) {
        const o = a.rows[s].cueStartTime, u = this.logger.time;
        if (o !== null && u !== null && o < u)
          for (let l = 0; l < this.nrRollUpRows; l++)
            this.rows[n - this.nrRollUpRows + l + 1].copy(a.rows[s + l]);
      }
    }
    this.currRow = n;
    const r = this.rows[this.currRow];
    if (e.indent !== null) {
      const s = e.indent, a = Math.max(s - 1, 0);
      r.setCursor(e.indent), e.color = r.chars[a].penState.foreground;
    }
    const i = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: "black",
      flash: !1
    };
    this.setPen(i);
  }
  /**
   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
   */
  setBkgData(e) {
    this.logger.log(2, () => "bkgData = " + Ze(e)), this.backSpace(), this.setPen(e), this.insertChar(32);
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const e = this.currRow + 1 - this.nrRollUpRows, n = this.rows.splice(e, 1)[0];
    n.clear(), this.rows.splice(this.currRow, 0, n), this.logger.log(2, "Rolling up");
  }
  /**
   * Get all non-empty rows with as unicode text.
   */
  getDisplayText(e) {
    e = e || !1;
    const n = [];
    let r = "", i = -1;
    for (let s = 0; s < Tn; s++) {
      const a = this.rows[s].getTextString();
      a && (i = s + 1, e ? n.push("Row " + i + ": '" + a + "'") : n.push(a.trim()));
    }
    return n.length > 0 && (e ? r = "[" + n.join(" | ") + "]" : r = n.join(`
`)), r;
  }
  getTextAndFormat() {
    return this.rows;
  }
}
class qg {
  constructor(e, n, r) {
    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = n, this.mode = null, this.verbose = 0, this.displayedMemory = new wc(r), this.nonDisplayedMemory = new wc(r), this.lastOutputScreen = new wc(r), this.currRollUpRow = this.displayedMemory.rows[Tn - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r;
  }
  reset() {
    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Tn - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(e) {
    this.outputFilter = e;
  }
  setPAC(e) {
    this.writeScreen.setPAC(e);
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e);
  }
  setMode(e) {
    e !== this.mode && (this.mode = e, this.logger.log(2, () => "MODE=" + e), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);
  }
  insertChars(e) {
    for (let r = 0; r < e.length; r++)
      this.writeScreen.insertChar(e[r]);
    const n = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => n + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
  }
  ccRU(e) {
    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
      flash: !0
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
      const e = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(!0);
  }
  ccTO(e) {
    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e);
  }
  ccMIDROW(e) {
    const n = {
      flash: !1
    };
    if (n.underline = e % 2 === 1, n.italics = e >= 46, n.italics)
      n.foreground = "white";
    else {
      const r = Math.floor(e / 2) - 16, i = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      n.foreground = i[r];
    }
    this.logger.log(2, "MIDROW: " + Ze(n)), this.writeScreen.setPen(n);
  }
  outputDataUpdate(e = !1) {
    const n = this.logger.time;
    n !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = n : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, n, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : n), this.lastOutputScreen.copy(this.displayedMemory));
  }
  cueSplitAtTime(e) {
    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));
  }
}
class Wg {
  constructor(e, n, r) {
    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = m7(), this.logger = void 0;
    const i = this.logger = new c7();
    this.channels = [null, new qg(e, n, i), new qg(e + 1, r, i)];
  }
  getHandler(e) {
    return this.channels[e].getHandler();
  }
  setHandler(e, n) {
    this.channels[e].setHandler(n);
  }
  /**
   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
   */
  addData(e, n) {
    this.logger.time = e;
    for (let r = 0; r < n.length; r += 2) {
      const i = n[r] & 127, s = n[r + 1] & 127;
      let a = !1, o = null;
      if (i === 0 && s === 0)
        continue;
      this.logger.log(3, () => "[" + Kr([n[r], n[r + 1]]) + "] -> (" + Kr([i, s]) + ")");
      const u = this.cmdHistory;
      if (i >= 16 && i <= 31) {
        if (h7(i, s, u)) {
          Po(null, null, u), this.logger.log(3, () => "Repeated command (" + Kr([i, s]) + ") is dropped");
          continue;
        }
        Po(i, s, this.cmdHistory), a = this.parseCmd(i, s), a || (a = this.parseMidrow(i, s)), a || (a = this.parsePAC(i, s)), a || (a = this.parseBackgroundAttributes(i, s));
      } else
        Po(null, null, u);
      if (!a && (o = this.parseChars(i, s), o)) {
        const c = this.currentChannel;
        c && c > 0 ? this.channels[c].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
      }
      !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + Kr([i, s]) + " orig: " + Kr([n[r], n[r + 1]]));
    }
  }
  /**
   * Parse Command.
   * @returns True if a command was found
   */
  parseCmd(e, n) {
    const r = (e === 20 || e === 28 || e === 21 || e === 29) && n >= 32 && n <= 47, i = (e === 23 || e === 31) && n >= 33 && n <= 35;
    if (!(r || i))
      return !1;
    const s = e === 20 || e === 21 || e === 23 ? 1 : 2, a = this.channels[s];
    return e === 20 || e === 21 || e === 28 || e === 29 ? n === 32 ? a.ccRCL() : n === 33 ? a.ccBS() : n === 34 ? a.ccAOF() : n === 35 ? a.ccAON() : n === 36 ? a.ccDER() : n === 37 ? a.ccRU(2) : n === 38 ? a.ccRU(3) : n === 39 ? a.ccRU(4) : n === 40 ? a.ccFON() : n === 41 ? a.ccRDC() : n === 42 ? a.ccTR() : n === 43 ? a.ccRTD() : n === 44 ? a.ccEDM() : n === 45 ? a.ccCR() : n === 46 ? a.ccENM() : n === 47 && a.ccEOC() : a.ccTO(n - 32), this.currentChannel = s, !0;
  }
  /**
   * Parse midrow styling command
   */
  parseMidrow(e, n) {
    let r = 0;
    if ((e === 17 || e === 25) && n >= 32 && n <= 47) {
      if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel)
        return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
      const i = this.channels[r];
      return i ? (i.ccMIDROW(n), this.logger.log(3, () => "MIDROW (" + Kr([e, n]) + ")"), !0) : !1;
    }
    return !1;
  }
  /**
   * Parse Preable Access Codes (Table 53).
   * @returns {Boolean} Tells if PAC found
   */
  parsePAC(e, n) {
    let r;
    const i = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && n >= 64 && n <= 127, s = (e === 16 || e === 24) && n >= 64 && n <= 95;
    if (!(i || s))
      return !1;
    const a = e <= 23 ? 1 : 2;
    n >= 64 && n <= 95 ? r = a === 1 ? s7[e] : o7[e] : r = a === 1 ? a7[e] : u7[e];
    const o = this.channels[a];
    return o ? (o.setPAC(this.interpretPAC(r, n)), this.currentChannel = a, !0) : !1;
  }
  /**
   * Interpret the second byte of the pac, and return the information.
   * @returns pacData with style parameters
   */
  interpretPAC(e, n) {
    let r;
    const i = {
      color: null,
      italics: !1,
      indent: null,
      underline: !1,
      row: e
    };
    return n > 95 ? r = n - 96 : r = n - 64, i.underline = (r & 1) === 1, r <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = "white") : i.indent = Math.floor((r - 16) / 2) * 4, i;
  }
  /**
   * Parse characters.
   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
   */
  parseChars(e, n) {
    let r, i = null, s = null;
    if (e >= 25 ? (r = 2, s = e - 8) : (r = 1, s = e), s >= 17 && s <= 19) {
      let a;
      s === 17 ? a = n + 80 : s === 18 ? a = n + 112 : a = n + 144, this.logger.log(2, () => "Special char '" + yv(a) + "' in channel " + r), i = [a];
    } else e >= 32 && e <= 127 && (i = n === 0 ? [e] : [e, n]);
    return i && this.logger.log(3, () => "Char codes =  " + Kr(i).join(",")), i;
  }
  /**
   * Parse extended background attributes as well as new foreground color black.
   * @returns True if background attributes are found
   */
  parseBackgroundAttributes(e, n) {
    const r = (e === 16 || e === 24) && n >= 32 && n <= 47, i = (e === 23 || e === 31) && n >= 45 && n <= 47;
    if (!(r || i))
      return !1;
    let s;
    const a = {};
    e === 16 || e === 24 ? (s = Math.floor((n - 32) / 2), a.background = l7[s], n % 2 === 1 && (a.background = a.background + "_semi")) : n === 45 ? a.background = "transparent" : (a.foreground = "black", n === 47 && (a.underline = !0));
    const o = e <= 23 ? 1 : 2;
    return this.channels[o].setBkgData(a), !0;
  }
  /**
   * Reset state of parser and its channels.
   */
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const n = this.channels[e];
      n && n.reset();
    }
    Po(null, null, this.cmdHistory);
  }
  /**
   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
   */
  cueSplitAtTime(e) {
    for (let n = 0; n < this.channels.length; n++) {
      const r = this.channels[n];
      r && r.cueSplitAtTime(e);
    }
  }
}
function Po(t, e, n) {
  n.a = t, n.b = e;
}
function h7(t, e, n) {
  return n.a === t && n.b === e;
}
function m7() {
  return {
    a: null,
    b: null
  };
}
var i0 = function() {
  if (Bu != null && Bu.VTTCue)
    return self.VTTCue;
  const t = ["", "lr", "rl"], e = ["start", "middle", "end", "left", "right"];
  function n(o, u) {
    if (typeof u != "string" || !Array.isArray(o))
      return !1;
    const l = u.toLowerCase();
    return ~o.indexOf(l) ? l : !1;
  }
  function r(o) {
    return n(t, o);
  }
  function i(o) {
    return n(e, o);
  }
  function s(o, ...u) {
    let l = 1;
    for (; l < arguments.length; l++) {
      const c = arguments[l];
      for (const d in c)
        o[d] = c[d];
    }
    return o;
  }
  function a(o, u, l) {
    const c = this, d = {
      enumerable: !0
    };
    c.hasBeenReset = !1;
    let f = "", h = !1, m = o, p = u, g = l, b = null, y = "", T = !0, S = "auto", I = "start", C = 50, _ = "middle", R = 50, k = "middle";
    Object.defineProperty(c, "id", s({}, d, {
      get: function() {
        return f;
      },
      set: function(A) {
        f = "" + A;
      }
    })), Object.defineProperty(c, "pauseOnExit", s({}, d, {
      get: function() {
        return h;
      },
      set: function(A) {
        h = !!A;
      }
    })), Object.defineProperty(c, "startTime", s({}, d, {
      get: function() {
        return m;
      },
      set: function(A) {
        if (typeof A != "number")
          throw new TypeError("Start time must be set to a number.");
        m = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "endTime", s({}, d, {
      get: function() {
        return p;
      },
      set: function(A) {
        if (typeof A != "number")
          throw new TypeError("End time must be set to a number.");
        p = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "text", s({}, d, {
      get: function() {
        return g;
      },
      set: function(A) {
        g = "" + A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "region", s({}, d, {
      get: function() {
        return b;
      },
      set: function(A) {
        b = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "vertical", s({}, d, {
      get: function() {
        return y;
      },
      set: function(A) {
        const L = r(A);
        if (L === !1)
          throw new SyntaxError("An invalid or illegal string was specified.");
        y = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "snapToLines", s({}, d, {
      get: function() {
        return T;
      },
      set: function(A) {
        T = !!A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "line", s({}, d, {
      get: function() {
        return S;
      },
      set: function(A) {
        if (typeof A != "number" && A !== "auto")
          throw new SyntaxError("An invalid number or illegal string was specified.");
        S = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "lineAlign", s({}, d, {
      get: function() {
        return I;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        I = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "position", s({}, d, {
      get: function() {
        return C;
      },
      set: function(A) {
        if (A < 0 || A > 100)
          throw new Error("Position must be between 0 and 100.");
        C = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "positionAlign", s({}, d, {
      get: function() {
        return _;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        _ = L, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "size", s({}, d, {
      get: function() {
        return R;
      },
      set: function(A) {
        if (A < 0 || A > 100)
          throw new Error("Size must be between 0 and 100.");
        R = A, this.hasBeenReset = !0;
      }
    })), Object.defineProperty(c, "align", s({}, d, {
      get: function() {
        return k;
      },
      set: function(A) {
        const L = i(A);
        if (!L)
          throw new SyntaxError("An invalid or illegal string was specified.");
        k = L, this.hasBeenReset = !0;
      }
    })), c.displayState = void 0;
  }
  return a.prototype.getCueAsHTML = function() {
    return self.WebVTT.convertCueToDOMTree(self, this.text);
  }, a;
}();
class p7 {
  decode(e, n) {
    if (!e)
      return "";
    if (typeof e != "string")
      throw new Error("Error - expected string data.");
    return decodeURIComponent(encodeURIComponent(e));
  }
}
function Sv(t) {
  function e(r, i, s, a) {
    return (r | 0) * 3600 + (i | 0) * 60 + (s | 0) + parseFloat(a || 0);
  }
  const n = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  return n ? parseFloat(n[2]) > 59 ? e(n[2], n[3], 0, n[4]) : e(n[1], n[2], n[3], n[4]) : null;
}
class g7 {
  constructor() {
    this.values = /* @__PURE__ */ Object.create(null);
  }
  // Only accept the first assignment to any key.
  set(e, n) {
    !this.get(e) && n !== "" && (this.values[e] = n);
  }
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get(e, n, r) {
    return r ? this.has(e) ? this.values[e] : n[r] : this.has(e) ? this.values[e] : n;
  }
  // Check whether we have a value for a key.
  has(e) {
    return e in this.values;
  }
  // Accept a setting if its one of the given alternatives.
  alt(e, n, r) {
    for (let i = 0; i < r.length; ++i)
      if (n === r[i]) {
        this.set(e, n);
        break;
      }
  }
  // Accept a setting if its a valid (signed) integer.
  integer(e, n) {
    /^-?\d+$/.test(n) && this.set(e, parseInt(n, 10));
  }
  // Accept a setting if its a valid percentage.
  percent(e, n) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(n)) {
      const r = parseFloat(n);
      if (r >= 0 && r <= 100)
        return this.set(e, r), !0;
    }
    return !1;
  }
}
function xv(t, e, n, r) {
  const i = r ? t.split(r) : [t];
  for (const s in i) {
    if (typeof i[s] != "string")
      continue;
    const a = i[s].split(n);
    if (a.length !== 2)
      continue;
    const o = a[0], u = a[1];
    e(o, u);
  }
}
const uf = new i0(0, 0, ""), Oo = uf.align === "middle" ? "middle" : "center";
function b7(t, e, n) {
  const r = t;
  function i() {
    const o = Sv(t);
    if (o === null)
      throw new Error("Malformed timestamp: " + r);
    return t = t.replace(/^[^\sa-zA-Z-]+/, ""), o;
  }
  function s(o, u) {
    const l = new g7();
    xv(o, function(f, h) {
      let m;
      switch (f) {
        case "region":
          for (let p = n.length - 1; p >= 0; p--)
            if (n[p].id === h) {
              l.set(f, n[p].region);
              break;
            }
          break;
        case "vertical":
          l.alt(f, h, ["rl", "lr"]);
          break;
        case "line":
          m = h.split(","), l.integer(f, m[0]), l.percent(f, m[0]) && l.set("snapToLines", !1), l.alt(f, m[0], ["auto"]), m.length === 2 && l.alt("lineAlign", m[1], ["start", Oo, "end"]);
          break;
        case "position":
          m = h.split(","), l.percent(f, m[0]), m.length === 2 && l.alt("positionAlign", m[1], ["start", Oo, "end", "line-left", "line-right", "auto"]);
          break;
        case "size":
          l.percent(f, h);
          break;
        case "align":
          l.alt(f, h, ["start", Oo, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/), u.region = l.get("region", null), u.vertical = l.get("vertical", "");
    let c = l.get("line", "auto");
    c === "auto" && uf.line === -1 && (c = -1), u.line = c, u.lineAlign = l.get("lineAlign", "start"), u.snapToLines = l.get("snapToLines", !0), u.size = l.get("size", 100), u.align = l.get("align", Oo);
    let d = l.get("position", "auto");
    d === "auto" && uf.position === 50 && (d = u.align === "start" || u.align === "left" ? 0 : u.align === "end" || u.align === "right" ? 100 : 50), u.position = d;
  }
  function a() {
    t = t.replace(/^\s+/, "");
  }
  if (a(), e.startTime = i(), a(), t.slice(0, 3) !== "-->")
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r);
  t = t.slice(3), a(), e.endTime = i(), a(), s(t, e);
}
function vv(t) {
  return t.replace(/<br(?: \/)?>/gi, `
`);
}
class E7 {
  constructor() {
    this.state = "INITIAL", this.buffer = "", this.decoder = new p7(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;
  }
  parse(e) {
    const n = this;
    e && (n.buffer += n.decoder.decode(e, {
      stream: !0
    }));
    function r() {
      let s = n.buffer, a = 0;
      for (s = vv(s); a < s.length && s[a] !== "\r" && s[a] !== `
`; )
        ++a;
      const o = s.slice(0, a);
      return s[a] === "\r" && ++a, s[a] === `
` && ++a, n.buffer = s.slice(a), o;
    }
    function i(s) {
      xv(s, function(a, o) {
      }, /:/);
    }
    try {
      let s = "";
      if (n.state === "INITIAL") {
        if (!/\r\n|\n/.test(n.buffer))
          return this;
        s = r();
        const o = s.match(/^()?WEBVTT([ \t].*)?$/);
        if (!(o != null && o[0]))
          throw new Error("Malformed WebVTT signature.");
        n.state = "HEADER";
      }
      let a = !1;
      for (; n.buffer; ) {
        if (!/\r\n|\n/.test(n.buffer))
          return this;
        switch (a ? a = !1 : s = r(), n.state) {
          case "HEADER":
            /:/.test(s) ? i(s) : s || (n.state = "ID");
            continue;
          case "NOTE":
            s || (n.state = "ID");
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(s)) {
              n.state = "NOTE";
              break;
            }
            if (!s)
              continue;
            if (n.cue = new i0(0, 0, ""), n.state = "CUE", s.indexOf("-->") === -1) {
              n.cue.id = s;
              continue;
            }
          case "CUE":
            if (!n.cue) {
              n.state = "BADCUE";
              continue;
            }
            try {
              b7(s, n.cue, n.regionList);
            } catch {
              n.cue = null, n.state = "BADCUE";
              continue;
            }
            n.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const o = s.indexOf("-->") !== -1;
              if (!s || o && (a = !0)) {
                n.oncue && n.cue && n.oncue(n.cue), n.cue = null, n.state = "ID";
                continue;
              }
              if (n.cue === null)
                continue;
              n.cue.text && (n.cue.text += `
`), n.cue.text += s;
            }
            continue;
          case "BADCUE":
            s || (n.state = "ID");
        }
      }
    } catch {
      n.state === "CUETEXT" && n.cue && n.oncue && n.oncue(n.cue), n.cue = null, n.state = n.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const e = this;
    try {
      if ((e.cue || e.state === "HEADER") && (e.buffer += `

`, e.parse()), e.state === "INITIAL" || e.state === "BADWEBVTT")
        throw new Error("Malformed WebVTT signature.");
    } catch (n) {
      e.onparsingerror && e.onparsingerror(n);
    }
    return e.onflush && e.onflush(), this;
  }
}
const y7 = /\r\n|\n\r|\n|\r/g, kc = function(e, n, r = 0) {
  return e.slice(r, r + n.length) === n;
}, T7 = function(e) {
  let n = parseInt(e.slice(-3));
  const r = parseInt(e.slice(-6, -4)), i = parseInt(e.slice(-9, -7)), s = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
  if (!de(n) || !de(r) || !de(i) || !de(s))
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
  return n += 1e3 * r, n += 60 * 1e3 * i, n += 60 * 60 * 1e3 * s, n;
};
function s0(t, e, n) {
  return aa(t.toString()) + aa(e.toString()) + aa(n);
}
const S7 = function(e, n, r) {
  let i = e[n], s = e[i.prevCC];
  if (!s || !s.new && i.new) {
    e.ccOffset = e.presentationOffset = i.start, i.new = !1;
    return;
  }
  for (; (a = s) != null && a.new; ) {
    var a;
    e.ccOffset += i.start - s.start, i.new = !1, i = s, s = e[i.prevCC];
  }
  e.presentationOffset = r;
};
function x7(t, e, n, r, i, s, a) {
  const o = new E7(), u = cn(new Uint8Array(t)).trim().replace(y7, `
`).split(`
`), l = [], c = e ? _$(e.baseTime, e.timescale) : 0;
  let d = "00:00.000", f = 0, h = 0, m, p = !0;
  o.oncue = function(g) {
    const b = n[r];
    let y = n.ccOffset;
    const T = (f - c) / 9e4;
    if (b != null && b.new && (h !== void 0 ? y = n.ccOffset = b.start : S7(n, r, T)), T) {
      if (!e) {
        m = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      y = T - n.presentationOffset;
    }
    const S = g.endTime - g.startTime, I = on((g.startTime + y - h) * 9e4, i * 9e4) / 9e4;
    g.startTime = Math.max(I, 0), g.endTime = Math.max(I + S, 0);
    const C = g.text.trim();
    g.text = decodeURIComponent(encodeURIComponent(C)), g.id || (g.id = s0(g.startTime, g.endTime, C)), g.endTime > 0 && l.push(g);
  }, o.onparsingerror = function(g) {
    m = g;
  }, o.onflush = function() {
    if (m) {
      a(m);
      return;
    }
    s(l);
  }, u.forEach((g) => {
    if (p)
      if (kc(g, "X-TIMESTAMP-MAP=")) {
        p = !1, g.slice(16).split(",").forEach((b) => {
          kc(b, "LOCAL:") ? d = b.slice(6) : kc(b, "MPEGTS:") && (f = parseInt(b.slice(7)));
        });
        try {
          h = T7(d) / 1e3;
        } catch (b) {
          m = b;
        }
        return;
      } else g === "" && (p = !1);
    o.parse(g + `
`);
  }), o.flush();
}
const Dc = "stpp.ttml.im1t", Av = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/, Iv = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/, v7 = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function Kg(t, e, n, r) {
  const i = Pe(new Uint8Array(t), ["mdat"]);
  if (i.length === 0) {
    r(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const s = i.map((o) => cn(o)), a = L$(e.baseTime, 1, e.timescale);
  try {
    s.forEach((o) => n(A7(o, a)));
  } catch (o) {
    r(o);
  }
}
function A7(t, e) {
  const i = new DOMParser().parseFromString(t, "text/xml").getElementsByTagName("tt")[0];
  if (!i)
    throw new Error("Invalid ttml");
  const s = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  }, a = Object.keys(s).reduce((d, f) => (d[f] = i.getAttribute(`ttp:${f}`) || s[f], d), {}), o = i.getAttribute("xml:space") !== "preserve", u = jg(Pc(i, "styling", "style")), l = jg(Pc(i, "layout", "region")), c = Pc(i, "body", "[begin]");
  return [].map.call(c, (d) => {
    const f = Cv(d, o);
    if (!f || !d.hasAttribute("begin"))
      return null;
    const h = Nc(d.getAttribute("begin"), a), m = Nc(d.getAttribute("dur"), a);
    let p = Nc(d.getAttribute("end"), a);
    if (h === null)
      throw Yg(d);
    if (p === null) {
      if (m === null)
        throw Yg(d);
      p = h + m;
    }
    const g = new i0(h - e, p - e, f);
    g.id = s0(g.startTime, g.endTime, g.text);
    const b = l[d.getAttribute("region")], y = u[d.getAttribute("style")], T = I7(b, y, u), {
      textAlign: S
    } = T;
    if (S) {
      const I = v7[S];
      I && (g.lineAlign = I), g.align = S;
    }
    return Xe(g, T), g;
  }).filter((d) => d !== null);
}
function Pc(t, e, n) {
  const r = t.getElementsByTagName(e)[0];
  return r ? [].slice.call(r.querySelectorAll(n)) : [];
}
function jg(t) {
  return t.reduce((e, n) => {
    const r = n.getAttribute("xml:id");
    return r && (e[r] = n), e;
  }, {});
}
function Cv(t, e) {
  return [].slice.call(t.childNodes).reduce((n, r, i) => {
    var s;
    return r.nodeName === "br" && i ? n + `
` : (s = r.childNodes) != null && s.length ? Cv(r, e) : e ? n + r.textContent.trim().replace(/\s+/g, " ") : n + r.textContent;
  }, "");
}
function I7(t, e, n) {
  const r = "http://www.w3.org/ns/ttml#styling";
  let i = null;
  const s = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
    // 'fontWeight',
    // 'lineHeight',
    // 'wrapOption',
    // 'fontStyle',
    // 'direction',
    // 'writingMode'
  ], a = t != null && t.hasAttribute("style") ? t.getAttribute("style") : null;
  return a && n.hasOwnProperty(a) && (i = n[a]), s.reduce((o, u) => {
    const l = Oc(e, r, u) || Oc(t, r, u) || Oc(i, r, u);
    return l && (o[u] = l), o;
  }, {});
}
function Oc(t, e, n) {
  return t && t.hasAttributeNS(e, n) ? t.getAttributeNS(e, n) : null;
}
function Yg(t) {
  return new Error(`Could not parse ttml timestamp ${t}`);
}
function Nc(t, e) {
  if (!t)
    return null;
  let n = Sv(t);
  return n === null && (Av.test(t) ? n = C7(t, e) : Iv.test(t) && (n = L7(t, e))), n;
}
function C7(t, e) {
  const n = Av.exec(t), r = (n[4] | 0) + (n[5] | 0) / e.subFrameRate;
  return (n[1] | 0) * 3600 + (n[2] | 0) * 60 + (n[3] | 0) + r / e.frameRate;
}
function L7(t, e) {
  const n = Iv.exec(t), r = Number(n[1]);
  switch (n[2]) {
    case "h":
      return r * 3600;
    case "m":
      return r * 60;
    case "ms":
      return r * 1e3;
    case "f":
      return r / e.frameRate;
    case "t":
      return r / e.tickRate;
  }
  return r;
}
class No {
  constructor(e, n) {
    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = n;
  }
  dispatchCue() {
    this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);
  }
  newCue(e, n, r) {
    (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = n, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [], this.startTime = null;
  }
}
class _7 {
  constructor(e) {
    this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Qg(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    }, e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(x.FRAG_LOADING, this.onFragLoading, this), e.on(x.FRAG_LOADED, this.onFragLoaded, this), e.on(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls: e
    } = this;
    e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(x.FRAG_LOADING, this.onFragLoading, this), e.off(x.FRAG_LOADED, this.onFragLoaded, this), e.off(x.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(x.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(x.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(x.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;
  }
  initCea608Parsers() {
    const e = new No(this, "textTrack1"), n = new No(this, "textTrack2"), r = new No(this, "textTrack3"), i = new No(this, "textTrack4");
    this.cea608Parser1 = new Wg(1, e, n), this.cea608Parser2 = new Wg(3, r, i);
  }
  addCues(e, n, r, i, s) {
    let a = !1;
    for (let o = s.length; o--; ) {
      const u = s[o], l = R7(u[0], u[1], n, r);
      if (l >= 0 && (u[0] = Math.min(u[0], n), u[1] = Math.max(u[1], r), a = !0, l / (r - n) > 0.5))
        return;
    }
    if (a || s.push([n, r]), this.config.renderTextTracksNatively) {
      const o = this.captionsTracks[e];
      this.Cues.newCue(o, n, r, i);
    } else {
      const o = this.Cues.newCue(null, n, r, i);
      this.hls.trigger(x.CUES_PARSED, {
        type: "captions",
        cues: o,
        track: e
      });
    }
  }
  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
  onInitPtsFound(e, {
    frag: n,
    id: r,
    initPTS: i,
    timescale: s,
    trackId: a
  }) {
    const {
      unparsedVttFrags: o
    } = this;
    r === pe.MAIN && (this.initPTS[n.cc] = {
      baseTime: i,
      timescale: s,
      trackId: a
    }), o.length && (this.unparsedVttFrags = [], o.forEach((u) => {
      this.initPTS[u.frag.cc] ? this.onFragLoaded(x.FRAG_LOADED, u) : this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: u.frag,
        error: new Error("Subtitle discontinuity domain does not match main")
      });
    }));
  }
  getExistingTrack(e, n) {
    const {
      media: r
    } = this;
    if (r)
      for (let i = 0; i < r.textTracks.length; i++) {
        const s = r.textTracks[i];
        if (Xg(s, {
          name: e,
          lang: n,
          characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
        }))
          return s;
      }
    return null;
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e])
      return;
    const {
      captionsProperties: n,
      captionsTracks: r,
      media: i
    } = this, {
      label: s,
      languageCode: a
    } = n[e], o = this.getExistingTrack(s, a);
    if (o)
      r[e] = o, Hi(r[e]), gv(r[e], i);
    else {
      const u = this.createTextTrack("captions", s, a);
      u && (u[e] = !0, r[e] = u);
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e])
      return;
    const n = this.captionsProperties[e];
    if (!n)
      return;
    const r = n.label, i = {
      _id: e,
      label: r,
      kind: "captions",
      default: n.media ? !!n.media.default : !1,
      closedCaptions: n.media
    };
    this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [i]
    });
  }
  createTextTrack(e, n, r) {
    const i = this.media;
    if (i)
      return i.addTextTrack(e, n, r);
  }
  onMediaAttaching(e, n) {
    this.media = n.media, n.mediaSource || this._cleanTracks();
  }
  onMediaDetaching(e, n) {
    const r = !!n.transferMedia;
    if (this.media = null, r)
      return;
    const {
      captionsTracks: i
    } = this;
    Object.keys(i).forEach((s) => {
      Hi(i[s]), delete i[s];
    }), this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = Qg(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset());
  }
  _cleanTracks() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = e.textTracks;
    if (n)
      for (let r = 0; r < n.length; r++)
        Hi(n[r]);
  }
  onSubtitleTracksUpdated(e, n) {
    const r = n.subtitleTracks || [], i = r.some((s) => s.textCodec === Dc);
    if (this.config.enableWebVTT || i && this.config.enableIMSC1) {
      if (rv(this.tracks, r)) {
        this.tracks = r;
        return;
      }
      if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) {
        const a = this.media, o = a ? iu(a.textTracks) : null;
        if (this.tracks.forEach((u, l) => {
          let c;
          if (o) {
            let d = null;
            for (let f = 0; f < o.length; f++)
              if (o[f] && Xg(o[f], u)) {
                d = o[f], o[f] = null;
                break;
              }
            d && (c = d);
          }
          if (c)
            Hi(c);
          else {
            const d = Lv(u);
            c = this.createTextTrack(d, u.name, u.lang), c && (c.mode = "disabled");
          }
          c && this.textTracks.push(c);
        }), o != null && o.length) {
          const u = o.filter((l) => l !== null).map((l) => l.label);
          u.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${u.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
        }
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }));
        this.hls.trigger(x.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: a
        });
      }
    }
  }
  onManifestLoaded(e, n) {
    this.config.enableCEA708Captions && n.captions && n.captions.forEach((r) => {
      const i = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId);
      if (!i)
        return;
      const s = `textTrack${i[1]}`, a = this.captionsProperties[s];
      a && (a.label = r.name, r.lang && (a.languageCode = r.lang), a.media = r);
    });
  }
  closedCaptionsForLevel(e) {
    const n = this.hls.levels[e.level];
    return n == null ? void 0 : n.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(e, n) {
    if (this.enabled && n.frag.type === pe.MAIN) {
      var r, i;
      const {
        cea608Parser1: s,
        cea608Parser2: a,
        lastSn: o
      } = this, {
        cc: u,
        sn: l
      } = n.frag, c = (r = (i = n.part) == null ? void 0 : i.index) != null ? r : -1;
      s && a && (l !== o + 1 || l === o && c !== this.lastPartIndex + 1 || u !== this.lastCc) && (s.reset(), a.reset()), this.lastCc = u, this.lastSn = l, this.lastPartIndex = c;
    }
  }
  onFragLoaded(e, n) {
    const {
      frag: r,
      payload: i
    } = n;
    if (r.type === pe.SUBTITLE)
      if (i.byteLength) {
        const s = r.decryptdata, a = "stats" in n;
        if (s == null || !s.encrypted || a) {
          const o = this.tracks[r.level], u = this.vttCCs;
          u[r.cc] || (u[r.cc] = {
            start: r.start,
            prevCC: this.prevCC,
            new: !0
          }, this.prevCC = r.cc), o && o.textCodec === Dc ? this._parseIMSC1(r, i) : this._parseVTTs(n);
        }
      } else
        this.hls.trigger(x.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: r,
          error: new Error("Empty subtitle payload")
        });
  }
  _parseIMSC1(e, n) {
    const r = this.hls;
    Kg(n, this.initPTS[e.cc], (i) => {
      this._appendCues(i, e.level), r.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: e
      });
    }, (i) => {
      r.logger.log(`Failed to parse IMSC1: ${i}`), r.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: e,
        error: i
      });
    });
  }
  _parseVTTs(e) {
    var n;
    const {
      frag: r,
      payload: i
    } = e, {
      initPTS: s,
      unparsedVttFrags: a
    } = this, o = s.length - 1;
    if (!s[r.cc] && o === -1) {
      a.push(e);
      return;
    }
    const u = this.hls, l = (n = r.initSegment) != null && n.data ? gn(r.initSegment.data, new Uint8Array(i)).buffer : i;
    x7(l, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, (c) => {
      this._appendCues(c, r.level), u.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !0,
        frag: r
      });
    }, (c) => {
      const d = c.message === "Missing initPTS for VTT MPEGTS";
      d ? a.push(e) : this._fallbackToIMSC1(r, i), u.logger.log(`Failed to parse VTT cue: ${c}`), !(d && o > r.cc) && u.trigger(x.SUBTITLE_FRAG_PROCESSED, {
        success: !1,
        frag: r,
        error: c
      });
    });
  }
  _fallbackToIMSC1(e, n) {
    const r = this.tracks[e.level];
    r.textCodec || Kg(n, this.initPTS[e.cc], () => {
      r.textCodec = Dc, this._parseIMSC1(e, n);
    }, () => {
      r.textCodec = "wvtt";
    });
  }
  _appendCues(e, n) {
    const r = this.hls;
    if (this.config.renderTextTracksNatively) {
      const i = this.textTracks[n];
      if (!i || i.mode === "disabled")
        return;
      e.forEach((s) => bv(i, s));
    } else {
      const i = this.tracks[n];
      if (!i)
        return;
      const s = i.default ? "default" : "subtitles" + n;
      r.trigger(x.CUES_PARSED, {
        type: "subtitles",
        cues: e,
        track: s
      });
    }
  }
  onFragDecrypted(e, n) {
    const {
      frag: r
    } = n;
    r.type === pe.SUBTITLE && this.onFragLoaded(x.FRAG_LOADED, n);
  }
  onSubtitleTracksCleared() {
    this.tracks = [], this.captionsTracks = {};
  }
  onFragParsingUserdata(e, n) {
    if (!this.enabled || !this.config.enableCEA708Captions)
      return;
    const {
      frag: r,
      samples: i
    } = n;
    if (!(r.type === pe.MAIN && this.closedCaptionsForLevel(r) === "NONE"))
      for (let s = 0; s < i.length; s++) {
        const a = i[s].bytes;
        if (a) {
          this.cea608Parser1 || this.initCea608Parsers();
          const o = this.extractCea608Data(a);
          this.cea608Parser1.addData(i[s].pts, o[0]), this.cea608Parser2.addData(i[s].pts, o[1]);
        }
      }
  }
  onBufferFlushing(e, {
    startOffset: n,
    endOffset: r,
    endOffsetSubtitles: i,
    type: s
  }) {
    const {
      media: a
    } = this;
    if (!(!a || a.currentTime < r)) {
      if (!s || s === "video") {
        const {
          captionsTracks: o
        } = this;
        Object.keys(o).forEach((u) => of(o[u], n, r));
      }
      if (this.config.renderTextTracksNatively && n === 0 && i !== void 0) {
        const {
          textTracks: o
        } = this;
        Object.keys(o).forEach((u) => of(o[u], n, i));
      }
    }
  }
  extractCea608Data(e) {
    const n = [[], []], r = e[0] & 31;
    let i = 2;
    for (let s = 0; s < r; s++) {
      const a = e[i++], o = 127 & e[i++], u = 127 & e[i++];
      if (o === 0 && u === 0)
        continue;
      if ((4 & a) !== 0) {
        const c = 3 & a;
        (c === 0 || c === 1) && (n[c].push(o), n[c].push(u));
      }
    }
    return n;
  }
}
function Lv(t) {
  return t.characteristics && /transcribes-spoken-dialog/gi.test(t.characteristics) && /describes-music-and-sound/gi.test(t.characteristics) ? "captions" : "subtitles";
}
function Xg(t, e) {
  return !!t && t.kind === Lv(e) && nf(e, t);
}
function R7(t, e, n, r) {
  return Math.min(e, r) - Math.max(t, n);
}
function Qg() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: !0
    }
  };
}
const w7 = /\s/, k7 = {
  newCue(t, e, n, r) {
    const i = [];
    let s, a, o, u, l;
    const c = self.VTTCue || self.TextTrackCue;
    for (let f = 0; f < r.rows.length; f++)
      if (s = r.rows[f], o = !0, u = 0, l = "", !s.isEmpty()) {
        var d;
        for (let p = 0; p < s.chars.length; p++)
          w7.test(s.chars[p].uchar) && o ? u++ : (l += s.chars[p].uchar, o = !1);
        s.cueStartTime = e, e === n && (n += 1e-4), u >= 16 ? u-- : u++;
        const h = vv(l.trim()), m = s0(e, n, h);
        t != null && (d = t.cues) != null && d.getCueById(m) || (a = new c(e, n, h), a.id = m, a.line = f + 1, a.align = "left", a.position = 10 + Math.min(80, Math.floor(u * 8 / 32) * 10), i.push(a));
      }
    return t && i.length && (i.sort((f, h) => f.line === "auto" || h.line === "auto" ? 0 : f.line > 8 && h.line > 8 ? h.line - f.line : f.line - h.line), i.forEach((f) => bv(t, f))), i;
  }
};
function D7() {
  if (
    // @ts-ignore
    self.fetch && self.AbortController && self.ReadableStream && self.Request
  )
    try {
      return new self.ReadableStream({}), !0;
    } catch {
    }
  return !1;
}
const P7 = /(\d+)-(\d+)\/(\d+)/;
class Zg {
  constructor(e) {
    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || F7, this.controller = new self.AbortController(), this.stats = new Fh();
  }
  destroy() {
    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;
  }
  abortInternal() {
    this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);
  }
  load(e, n, r) {
    const i = this.stats;
    if (i.loading.start)
      throw new Error("Loader can only be used once.");
    i.loading.start = self.performance.now();
    const s = O7(e, this.controller.signal), a = e.responseType === "arraybuffer", o = a ? "byteLength" : "length", {
      maxTimeToFirstByteMs: u,
      maxLoadTimeMs: l
    } = n.loadPolicy;
    this.context = e, this.config = n, this.callbacks = r, this.request = this.fetchSetup(e, s), self.clearTimeout(this.requestTimeout), n.timeout = u && de(u) ? u : l, this.requestTimeout = self.setTimeout(() => {
      this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
    }, n.timeout), (_a(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d) => {
      var f;
      this.response = this.loader = d;
      const h = Math.max(self.performance.now(), i.loading.start);
      if (self.clearTimeout(this.requestTimeout), n.timeout = l, this.requestTimeout = self.setTimeout(() => {
        this.callbacks && (this.abortInternal(), this.callbacks.onTimeout(i, e, this.response));
      }, l - (h - i.loading.start)), !d.ok) {
        const {
          status: p,
          statusText: g
        } = d;
        throw new B7(g || "fetch, bad network response", p, d);
      }
      i.loading.first = h, i.total = M7(d.headers) || i.total;
      const m = (f = this.callbacks) == null ? void 0 : f.onProgress;
      return m && de(n.highWaterMark) ? this.loadProgressively(d, i, e, n.highWaterMark, m) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text();
    }).then((d) => {
      var f, h;
      const m = this.response;
      if (!m)
        throw new Error("loader destroyed");
      self.clearTimeout(this.requestTimeout), i.loading.end = Math.max(self.performance.now(), i.loading.first);
      const p = d[o];
      p && (i.loaded = i.total = p);
      const g = {
        url: m.url,
        data: d,
        code: m.status
      }, b = (f = this.callbacks) == null ? void 0 : f.onProgress;
      b && !de(n.highWaterMark) && b(i, e, d, m), (h = this.callbacks) == null || h.onSuccess(g, i, e, m);
    }).catch((d) => {
      var f;
      if (self.clearTimeout(this.requestTimeout), i.aborted)
        return;
      const h = d && d.code || 0, m = d ? d.message : null;
      (f = this.callbacks) == null || f.onError({
        code: h,
        text: m
      }, e, d ? d.details : null, i);
    });
  }
  getCacheAge() {
    let e = null;
    if (this.response) {
      const n = this.response.headers.get("age");
      e = n ? parseFloat(n) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null;
  }
  loadProgressively(e, n, r, i = 0, s) {
    const a = new Fx(), o = e.body.getReader(), u = () => o.read().then((l) => {
      if (l.done)
        return a.dataLength && s(n, r, a.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));
      const c = l.value, d = c.length;
      return n.loaded += d, d < i || a.dataLength ? (a.push(c), a.dataLength >= i && s(n, r, a.flush().buffer, e)) : s(n, r, c.buffer, e), u();
    }).catch(() => Promise.reject());
    return u();
  }
}
function O7(t, e) {
  const n = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal: e,
    headers: new self.Headers(Xe({}, t.headers))
  };
  return t.rangeEnd && n.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1)), n;
}
function N7(t) {
  const e = P7.exec(t);
  if (e)
    return parseInt(e[2]) - parseInt(e[1]) + 1;
}
function M7(t) {
  const e = t.get("Content-Range");
  if (e) {
    const r = N7(e);
    if (de(r))
      return r;
  }
  const n = t.get("Content-Length");
  if (n)
    return parseInt(n);
}
function F7(t, e) {
  return new self.Request(t.url, e);
}
class B7 extends Error {
  constructor(e, n, r) {
    super(e), this.code = void 0, this.details = void 0, this.code = n, this.details = r;
  }
}
const $7 = /^age:\s*[\d.]+\s*$/im;
class _v {
  constructor(e) {
    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new Fh(), this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;
  }
  abortInternal() {
    const e = this.loader;
    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 && (this.stats.aborted = !0, e.abort()));
  }
  abort() {
    var e;
    this.abortInternal(), (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);
  }
  load(e, n, r) {
    if (this.stats.loading.start)
      throw new Error("Loader can only be used once.");
    this.stats.loading.start = self.performance.now(), this.context = e, this.config = n, this.callbacks = r, this.loadInternal();
  }
  loadInternal() {
    const {
      config: e,
      context: n
    } = this;
    if (!e || !n)
      return;
    const r = this.loader = new self.XMLHttpRequest(), i = this.stats;
    i.loading.first = 0, i.loaded = 0, i.aborted = !1;
    const s = this.xhrSetup;
    s ? Promise.resolve().then(() => {
      if (!(this.loader !== r || this.stats.aborted))
        return s(r, n.url);
    }).catch((a) => {
      if (!(this.loader !== r || this.stats.aborted))
        return r.open("GET", n.url, !0), s(r, n.url);
    }).then(() => {
      this.loader !== r || this.stats.aborted || this.openAndSendXhr(r, n, e);
    }).catch((a) => {
      var o;
      (o = this.callbacks) == null || o.onError({
        code: r.status,
        text: a.message
      }, n, r, i);
    }) : this.openAndSendXhr(r, n, e);
  }
  openAndSendXhr(e, n, r) {
    e.readyState || e.open("GET", n.url, !0);
    const i = n.headers, {
      maxTimeToFirstByteMs: s,
      maxLoadTimeMs: a
    } = r.loadPolicy;
    if (i)
      for (const o in i)
        e.setRequestHeader(o, i[o]);
    n.rangeEnd && e.setRequestHeader("Range", "bytes=" + n.rangeStart + "-" + (n.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = n.responseType, self.clearTimeout(this.requestTimeout), r.timeout = s && de(s) ? s : a, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();
  }
  readystatechange() {
    const {
      context: e,
      loader: n,
      stats: r
    } = this;
    if (!e || !n)
      return;
    const i = n.readyState, s = this.config;
    if (!r.aborted && i >= 2 && (r.loading.first === 0 && (r.loading.first = Math.max(self.performance.now(), r.loading.start), s.timeout !== s.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), s.timeout = s.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), i === 4)) {
      self.clearTimeout(this.requestTimeout), n.onreadystatechange = null, n.onprogress = null;
      const l = n.status, c = n.responseType === "text" ? n.responseText : null;
      if (l >= 200 && l < 300) {
        const m = c ?? n.response;
        if (m != null) {
          var a, o;
          r.loading.end = Math.max(self.performance.now(), r.loading.first);
          const p = n.responseType === "arraybuffer" ? m.byteLength : m.length;
          r.loaded = r.total = p, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first);
          const g = (a = this.callbacks) == null ? void 0 : a.onProgress;
          g && g(r, e, m, n);
          const b = {
            url: n.responseURL,
            data: m,
            code: l
          };
          (o = this.callbacks) == null || o.onSuccess(b, r, e, n);
          return;
        }
      }
      const d = s.loadPolicy.errorRetry, f = r.retry, h = {
        url: e.url,
        data: void 0,
        code: l
      };
      if (Mu(d, f, !1, h))
        this.retry(d);
      else {
        var u;
        qe.error(`${l} while loading ${e.url}`), (u = this.callbacks) == null || u.onError({
          code: l,
          text: n.statusText
        }, e, n, r);
      }
    }
  }
  loadtimeout() {
    if (!this.config) return;
    const e = this.config.loadPolicy.timeoutRetry, n = this.stats.retry;
    if (Mu(e, n, !0))
      this.retry(e);
    else {
      var r;
      qe.warn(`timeout while loading ${(r = this.context) == null ? void 0 : r.url}`);
      const i = this.callbacks;
      i && (this.abortInternal(), i.onTimeout(this.stats, this.context, this.loader));
    }
  }
  retry(e) {
    const {
      context: n,
      stats: r
    } = this;
    this.retryDelay = Hh(e, r.retry), r.retry++, qe.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${n == null ? void 0 : n.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(e) {
    const n = this.stats;
    n.loaded = e.loaded, e.lengthComputable && (n.total = e.total);
  }
  getCacheAge() {
    let e = null;
    if (this.loader && $7.test(this.loader.getAllResponseHeaders())) {
      const n = this.loader.getResponseHeader("age");
      e = n ? parseFloat(n) : null;
    }
    return e;
  }
  getResponseHeader(e) {
    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;
  }
}
const U7 = {
  maxTimeToFirstByteMs: 8e3,
  maxLoadTimeMs: 2e4,
  timeoutRetry: null,
  errorRetry: null
}, H7 = ze(ze({
  autoStartLoad: !0,
  // used by stream-controller
  startPosition: -1,
  // used by stream-controller
  defaultAudioCodec: void 0,
  // used by stream-controller
  debug: !1,
  // used by logger
  capLevelOnFPSDrop: !1,
  // used by fps-controller
  capLevelToPlayerSize: !1,
  // used by cap-level-controller
  ignoreDevicePixelRatio: !1,
  // used by cap-level-controller
  maxDevicePixelRatio: Number.POSITIVE_INFINITY,
  // used by cap-level-controller
  preferManagedMediaSource: !0,
  initialLiveManifestSize: 1,
  // used by stream-controller
  maxBufferLength: 30,
  // used by stream-controller
  backBufferLength: 1 / 0,
  // used by buffer-controller
  frontBufferFlushThreshold: 1 / 0,
  startOnSegmentBoundary: !1,
  // used by stream-controller
  maxBufferSize: 60 * 1e3 * 1e3,
  // used by stream-controller
  maxFragLookUpTolerance: 0.25,
  // used by stream-controller
  maxBufferHole: 0.1,
  // used by stream-controller and gap-controller
  detectStallWithCurrentTimeMs: 1250,
  // used by gap-controller
  highBufferWatchdogPeriod: 2,
  // used by gap-controller
  nudgeOffset: 0.1,
  // used by gap-controller
  nudgeMaxRetry: 3,
  // used by gap-controller
  nudgeOnVideoHole: !0,
  // used by gap-controller
  liveSyncMode: "edge",
  // used by stream-controller
  liveSyncDurationCount: 3,
  // used by latency-controller
  liveSyncOnStallIncrease: 1,
  // used by latency-controller
  liveMaxLatencyDurationCount: 1 / 0,
  // used by latency-controller
  liveSyncDuration: void 0,
  // used by latency-controller
  liveMaxLatencyDuration: void 0,
  // used by latency-controller
  maxLiveSyncPlaybackRate: 1,
  // used by latency-controller
  liveDurationInfinity: !1,
  // used by buffer-controller
  /**
   * @deprecated use backBufferLength
   */
  liveBackBufferLength: null,
  // used by buffer-controller
  maxMaxBufferLength: 600,
  // used by stream-controller
  enableWorker: !0,
  // used by transmuxer
  workerPath: null,
  // used by transmuxer
  enableSoftwareAES: !0,
  // used by decrypter
  startLevel: void 0,
  // used by level-controller
  startFragPrefetch: !1,
  // used by stream-controller
  fpsDroppedMonitoringPeriod: 5e3,
  // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2,
  // used by fps-controller
  appendErrorMaxRetry: 3,
  // used by buffer-controller
  ignorePlaylistParsingErrors: !1,
  loader: _v,
  // loader: FetchLoader,
  fLoader: void 0,
  // used by fragment-loader
  pLoader: void 0,
  // used by playlist-loader
  xhrSetup: void 0,
  // used by xhr-loader
  licenseXhrSetup: void 0,
  // used by eme-controller
  licenseResponseCallback: void 0,
  // used by eme-controller
  abrController: JB,
  bufferController: G$,
  capLevelController: t0,
  errorController: i9,
  fpsController: zU,
  stretchShortVideoTrack: !1,
  // used by mp4-remuxer
  maxAudioFramesDrift: 1,
  // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: !0,
  // used by ts-demuxer
  abrEwmaFastLive: 3,
  // used by abr-controller
  abrEwmaSlowLive: 9,
  // used by abr-controller
  abrEwmaFastVoD: 3,
  // used by abr-controller
  abrEwmaSlowVoD: 9,
  // used by abr-controller
  abrEwmaDefaultEstimate: 5e5,
  // 500 kbps  // used by abr-controller
  abrEwmaDefaultEstimateMax: 5e6,
  // 5 mbps
  abrBandWidthFactor: 0.95,
  // used by abr-controller
  abrBandWidthUpFactor: 0.7,
  // used by abr-controller
  abrMaxWithRealBitrate: !1,
  // used by abr-controller
  maxStarvationDelay: 4,
  // used by abr-controller
  maxLoadingDelay: 4,
  // used by abr-controller
  minAutoBitrate: 0,
  // used by hls
  emeEnabled: !1,
  // used by eme-controller
  widevineLicenseUrl: void 0,
  // used by eme-controller
  drmSystems: {},
  // used by eme-controller
  drmSystemOptions: {},
  // used by eme-controller
  requestMediaKeySystemAccessFunc: Cx,
  // used by eme-controller
  requireKeySystemAccessOnStart: !1,
  // used by eme-controller
  testBandwidth: !0,
  progressive: !1,
  lowLatencyMode: !0,
  cmcd: void 0,
  enableDateRangeMetadataCues: !0,
  enableEmsgMetadataCues: !0,
  enableEmsgKLVMetadata: !1,
  enableID3MetadataCues: !0,
  enableInterstitialPlayback: !0,
  interstitialAppendInPlace: !0,
  interstitialLiveLookAhead: 10,
  useMediaCapabilities: !0,
  preserveManualLevelOnError: !1,
  certLoadPolicy: {
    default: U7
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8e3,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 2e4,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1 / 0,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 12e4,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 2e4,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  interstitialAssetListLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 3e4,
      timeoutRetry: {
        maxNumRetry: 0,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 0,
        retryDelayMs: 1e3,
        maxRetryDelayMs: 8e3
      }
    }
  },
  // These default settings are deprecated in favor of the above policies
  // and are maintained for backwards compatibility
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1e3,
  manifestLoadingMaxRetryTimeout: 64e3,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1e3,
  levelLoadingMaxRetryTimeout: 64e3,
  fragLoadingTimeOut: 2e4,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1e3,
  fragLoadingMaxRetryTimeout: 64e3
}, V7()), {}, {
  subtitleStreamController: n7,
  subtitleTrackController: KU,
  timelineController: _7,
  audioStreamController: $$,
  audioTrackController: U$,
  emeController: Xi,
  cmcdController: UU,
  contentSteeringController: VU,
  interstitialsController: t7
});
function V7() {
  return {
    cueHandler: k7,
    // used by timeline-controller
    enableWebVTT: !0,
    // used by timeline-controller
    enableIMSC1: !0,
    // used by timeline-controller
    enableCEA708Captions: !0,
    // used by timeline-controller
    captionsTextTrack1Label: "English",
    // used by timeline-controller
    captionsTextTrack1LanguageCode: "en",
    // used by timeline-controller
    captionsTextTrack2Label: "Spanish",
    // used by timeline-controller
    captionsTextTrack2LanguageCode: "es",
    // used by timeline-controller
    captionsTextTrack3Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack3LanguageCode: "",
    // used by timeline-controller
    captionsTextTrack4Label: "Unknown CC",
    // used by timeline-controller
    captionsTextTrack4LanguageCode: "",
    // used by timeline-controller
    renderTextTracksNatively: !0
  };
}
function G7(t, e, n) {
  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  const r = lf(t), i = ["manifest", "level", "frag"], s = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  return i.forEach((a) => {
    const o = `${a === "level" ? "playlist" : a}LoadPolicy`, u = e[o] === void 0, l = [];
    s.forEach((c) => {
      const d = `${a}Loading${c}`, f = e[d];
      if (f !== void 0 && u) {
        l.push(d);
        const h = r[o].default;
        switch (e[o] = {
          default: h
        }, c) {
          case "TimeOut":
            h.maxLoadTimeMs = f, h.maxTimeToFirstByteMs = f;
            break;
          case "MaxRetry":
            h.errorRetry.maxNumRetry = f, h.timeoutRetry.maxNumRetry = f;
            break;
          case "RetryDelay":
            h.errorRetry.retryDelayMs = f, h.timeoutRetry.retryDelayMs = f;
            break;
          case "MaxRetryTimeout":
            h.errorRetry.maxRetryDelayMs = f, h.timeoutRetry.maxRetryDelayMs = f;
            break;
        }
      }
    }), l.length && n.warn(`hls.js config: "${l.join('", "')}" setting(s) are deprecated, use "${o}": ${Ze(e[o])}`);
  }), ze(ze({}, r), e);
}
function lf(t) {
  return t && typeof t == "object" ? Array.isArray(t) ? t.map(lf) : Object.keys(t).reduce((e, n) => (e[n] = lf(t[n]), e), {}) : t;
}
function z7(t, e) {
  const n = t.loader;
  n !== Zg && n !== _v ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1) : D7() && (t.loader = Zg, t.progressive = !0, t.enableSoftwareAES = !0, e.log("[config]: Progressive streaming enabled, using FetchLoader"));
}
const su = 2, q7 = 0.1, W7 = 0.05, K7 = 100;
class j7 extends Sx {
  constructor(e, n) {
    super("gap-controller", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () => {
      this.ended = 0, this.waiting = 0;
    }, this.onMediaWaiting = () => {
      var r;
      (r = this.media) != null && r.seeking || (this.waiting = self.performance.now(), this.tick());
    }, this.onMediaEnded = () => {
      if (this.hls) {
        var r;
        this.ended = ((r = this.media) == null ? void 0 : r.currentTime) || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !1
        });
      }
    }, this.hls = e, this.fragmentTracker = n, this.registerListeners();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.BUFFER_APPENDED, this.onBufferAppended, this));
  }
  destroy() {
    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;
  }
  onMediaAttached(e, n) {
    this.setInterval(K7), this.mediaSource = n.mediaSource;
    const r = this.media = n.media;
    Bt(r, "playing", this.onMediaPlaying), Bt(r, "waiting", this.onMediaWaiting), Bt(r, "ended", this.onMediaEnded);
  }
  onMediaDetaching(e, n) {
    this.clearInterval();
    const {
      media: r
    } = this;
    r && (zt(r, "playing", this.onMediaPlaying), zt(r, "waiting", this.onMediaWaiting), zt(r, "ended", this.onMediaEnded), this.media = null), this.mediaSource = void 0;
  }
  onBufferAppended(e, n) {
    this.buffered = n.timeRanges;
  }
  get hasBuffered() {
    return Object.keys(this.buffered).length > 0;
  }
  tick() {
    var e;
    if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
      return;
    const n = this.media.currentTime;
    this.poll(n, this.lastCurrentTime), this.lastCurrentTime = n;
  }
  /**
   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.
   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).
   *
   * @param lastCurrentTime - Previously read playhead position
   */
  poll(e, n) {
    var r, i;
    const s = (r = this.hls) == null ? void 0 : r.config;
    if (!s)
      return;
    const a = this.media;
    if (!a)
      return;
    const {
      seeking: o
    } = a, u = this.seeking && !o, l = !this.seeking && o, c = a.paused && !o || a.ended || a.playbackRate === 0;
    if (this.seeking = o, e !== n) {
      n && (this.ended = 0), this.moved = !0, o || (this.nudgeRetry = 0, s.nudgeOnVideoHole && !c && e > n && this.nudgeOnVideoHole(e, n)), this.waiting === 0 && this.stallResolved(e);
      return;
    }
    if (l || u) {
      u && this.stallResolved(e);
      return;
    }
    if (c) {
      this.nudgeRetry = 0, this.stallResolved(e), !this.ended && a.ended && this.hls && (this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
        stalled: !1
      }));
      return;
    }
    if (!Ce.getBuffered(a).length) {
      this.nudgeRetry = 0;
      return;
    }
    const d = Ce.bufferInfo(a, e, 0), f = d.nextStart || 0, h = this.fragmentTracker;
    if (o && h && this.hls) {
      const C = Jg(this.hls.inFlightFragments, e), _ = d.len > su, R = !f || C || f - e > su && !h.getPartialFragment(e);
      if (_ || R)
        return;
      this.moved = !1;
    }
    const m = (i = this.hls) == null ? void 0 : i.latestLevelDetails;
    if (!this.moved && this.stalled !== null && h) {
      if (!(d.len > 0) && !f)
        return;
      const _ = Math.max(f, d.start || 0) - e, k = !!(m != null && m.live) ? m.targetduration * 2 : su, A = Mo(e, h);
      if (_ > 0 && (_ <= k || A)) {
        a.paused || this._trySkipBufferHole(A);
        return;
      }
    }
    const p = s.detectStallWithCurrentTimeMs, g = self.performance.now(), b = this.waiting;
    let y = this.stalled;
    if (y === null)
      if (b > 0 && g - b < p)
        y = this.stalled = b;
      else {
        this.stalled = g;
        return;
      }
    const T = g - y;
    if (!o && (T >= p || b) && this.hls) {
      var S;
      if (((S = this.mediaSource) == null ? void 0 : S.readyState) === "ended" && !(m != null && m.live) && Math.abs(e - ((m == null ? void 0 : m.edge) || 0)) < 1) {
        if (this.ended)
          return;
        this.ended = e || 1, this.hls.trigger(x.MEDIA_ENDED, {
          stalled: !0
        });
        return;
      }
      if (this._reportStall(d), !this.media || !this.hls)
        return;
    }
    const I = Ce.bufferInfo(a, e, s.maxBufferHole);
    this._tryFixBufferStall(I, T, e);
  }
  stallResolved(e) {
    const n = this.stalled;
    if (n && this.hls && (this.stalled = null, this.stallReported)) {
      const r = self.performance.now() - n;
      this.log(`playback not stuck anymore @${e}, after ${Math.round(r)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(x.STALL_RESOLVED, {});
    }
  }
  nudgeOnVideoHole(e, n) {
    var r;
    const i = this.buffered.video;
    if (this.hls && this.media && this.fragmentTracker && (r = this.buffered.audio) != null && r.length && i && i.length > 1 && e > i.end(0)) {
      const s = Ce.bufferedInfo(Ce.timeRangesToArray(this.buffered.audio), e, 0);
      if (s.len > 1 && n >= s.start) {
        const a = Ce.timeRangesToArray(i), o = Ce.bufferedInfo(a, n, 0).bufferedIndex;
        if (o > -1 && o < a.length - 1) {
          const u = Ce.bufferedInfo(a, e, 0).bufferedIndex, l = a[o].end, c = a[o + 1].start;
          if ((u === -1 || u > o) && c - l < 1 && // `maxBufferHole` may be too small and setting it to 0 should not disable this feature
          e - l < 2) {
            const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${l} -> ${c} buffered index: ${u}`);
            this.warn(d.message), this.media.currentTime += 1e-6;
            let f = Mo(e, this.fragmentTracker);
            f && "fragment" in f ? f = f.fragment : f || (f = void 0);
            const h = Ce.bufferInfo(this.media, e, 0);
            this.hls.trigger(x.ERROR, {
              type: be.MEDIA_ERROR,
              details: q.BUFFER_SEEK_OVER_HOLE,
              fatal: !1,
              error: d,
              reason: d.message,
              frag: f,
              buffer: h.len,
              bufferInfo: h
            });
          }
        }
      }
    }
  }
  /**
   * Detects and attempts to fix known buffer stalling issues.
   * @param bufferInfo - The properties of the current buffer.
   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.
   * @private
   */
  _tryFixBufferStall(e, n, r) {
    var i, s;
    const {
      fragmentTracker: a,
      media: o
    } = this, u = (i = this.hls) == null ? void 0 : i.config;
    if (!o || !a || !u)
      return;
    const l = (s = this.hls) == null ? void 0 : s.latestLevelDetails, c = Mo(r, a);
    if ((c || l != null && l.live && r < l.fragmentStart) && (this._trySkipBufferHole(c) || !this.media))
      return;
    const d = e.buffered, f = this.adjacentTraversal(e, r);
    (d && d.length > 1 && e.len > u.maxBufferHole || e.nextStart && (e.nextStart - r < u.maxBufferHole || f)) && (n > u.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"), this._tryNudgeBuffer(e));
  }
  adjacentTraversal(e, n) {
    const r = this.fragmentTracker, i = e.nextStart;
    if (r && i) {
      const s = r.getFragAtPos(n, pe.MAIN), a = r.getFragAtPos(i, pe.MAIN);
      if (s && a)
        return a.sn - s.sn < 2;
    }
    return !1;
  }
  /**
   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.
   * @param bufferLen - The playhead distance from the end of the current buffer segment.
   * @private
   */
  _reportStall(e) {
    const {
      hls: n,
      media: r,
      stallReported: i,
      stalled: s
    } = this;
    if (!i && s !== null && r && n) {
      this.stallReported = !0;
      const a = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${Ze(e)})`);
      this.warn(a.message), n.trigger(x.ERROR, {
        type: be.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        fatal: !1,
        error: a,
        buffer: e.len,
        bufferInfo: e,
        stalled: {
          start: s
        }
      });
    }
  }
  /**
   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments
   * @param appended - The fragment or part found at the current time (where playback is stalling).
   * @private
   */
  _trySkipBufferHole(e) {
    var n;
    const {
      fragmentTracker: r,
      media: i
    } = this, s = (n = this.hls) == null ? void 0 : n.config;
    if (!i || !r || !s)
      return 0;
    const a = i.currentTime, o = Ce.bufferInfo(i, a, 0), u = a < o.start ? o.start : o.nextStart;
    if (u && this.hls) {
      const c = o.len <= s.maxBufferHole, d = o.len > 0 && o.len < 1 && i.readyState < 3, f = u - a;
      if (f > 0 && (c || d)) {
        if (f > s.maxBufferHole) {
          let m = !1;
          if (a === 0) {
            const p = r.getAppendedFrag(0, pe.MAIN);
            p && u < p.end && (m = !0);
          }
          if (!m && e) {
            var l;
            if (!((l = this.hls.loadLevelObj) != null && l.details) || Jg(this.hls.inFlightFragments, u))
              return 0;
            let g = !1, b = e.end;
            for (; b < u; ) {
              const y = Mo(b, r);
              if (y)
                b += y.duration;
              else {
                g = !0;
                break;
              }
            }
            if (g)
              return 0;
          }
        }
        const h = Math.max(u + W7, a + q7);
        if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${h}`), this.moved = !0, i.currentTime = h, !(e != null && e.gap)) {
          const m = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${h}`), p = {
            type: be.MEDIA_ERROR,
            details: q.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: m,
            reason: m.message,
            buffer: o.len,
            bufferInfo: o
          };
          e && ("fragment" in e ? p.part = e : p.frag = e), this.hls.trigger(x.ERROR, p);
        }
        return h;
      }
    }
    return 0;
  }
  /**
   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.
   * @private
   */
  _tryNudgeBuffer(e) {
    const {
      hls: n,
      media: r,
      nudgeRetry: i
    } = this, s = n == null ? void 0 : n.config;
    if (!r || !s)
      return 0;
    const a = r.currentTime;
    if (this.nudgeRetry++, i < s.nudgeMaxRetry) {
      const o = a + (i + 1) * s.nudgeOffset, u = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
      this.warn(u.message), r.currentTime = o, n.trigger(x.ERROR, {
        type: be.MEDIA_ERROR,
        details: q.BUFFER_NUDGE_ON_STALL,
        error: u,
        fatal: !1,
        buffer: e.len,
        bufferInfo: e
      });
    } else {
      const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${s.nudgeMaxRetry} nudges`);
      this.error(o.message), n.trigger(x.ERROR, {
        type: be.MEDIA_ERROR,
        details: q.BUFFER_STALLED_ERROR,
        error: o,
        fatal: !0,
        buffer: e.len,
        bufferInfo: e
      });
    }
  }
}
function Jg(t, e) {
  const n = e1(t.main);
  if (n && n.start <= e)
    return n;
  const r = e1(t.audio);
  return r && r.start <= e ? r : null;
}
function e1(t) {
  if (!t)
    return null;
  switch (t.state) {
    case Z.IDLE:
    case Z.STOPPED:
    case Z.ENDED:
    case Z.ERROR:
      return null;
  }
  return t.frag;
}
function Mo(t, e) {
  return e.getAppendedFrag(t, pe.MAIN) || e.getPartialFragment(t);
}
const Y7 = 0.25;
function cf() {
  if (!(typeof self > "u"))
    return self.VTTCue || self.TextTrackCue;
}
function Mc(t, e, n, r, i) {
  let s = new t(e, n, "");
  try {
    s.value = r, i && (s.type = i);
  } catch {
    s = new t(e, n, Ze(i ? ze({
      type: i
    }, r) : r));
  }
  return s;
}
const Fo = (() => {
  const t = cf();
  try {
    t && new t(0, Number.POSITIVE_INFINITY, "");
  } catch {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
class X7 {
  constructor(e) {
    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = () => {
      this.hls && this.hls.trigger(x.EVENT_CUE_ENTER, {});
    }, this.hls = e, this._registerListeners();
  }
  destroy() {
    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(x.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));
  }
  // Add ID3 metatadata text track.
  onMediaAttaching(e, n) {
    var r;
    this.media = n.media, ((r = n.overrides) == null ? void 0 : r.cueRemoval) === !1 && (this.removeCues = !1);
  }
  onMediaAttached() {
    var e;
    const n = (e = this.hls) == null ? void 0 : e.latestLevelDetails;
    n && this.updateDateRangeCues(n);
  }
  onMediaDetaching(e, n) {
    this.media = null, !n.transferMedia && (this.id3Track && (this.removeCues && Hi(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(e) {
    const n = this.getID3Track(e.textTracks);
    return n.mode = "hidden", n;
  }
  getID3Track(e) {
    if (this.media) {
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (r.kind === "metadata" && r.label === "id3")
          return gv(r, this.media), r;
      }
      return this.media.addTextTrack("metadata", "id3");
    }
  }
  onFragParsingMetadata(e, n) {
    if (!this.media || !this.hls)
      return;
    const {
      enableEmsgMetadataCues: r,
      enableID3MetadataCues: i
    } = this.hls.config;
    if (!r && !i)
      return;
    const {
      samples: s
    } = n;
    this.id3Track || (this.id3Track = this.createTrack(this.media));
    const a = cf();
    if (a)
      for (let o = 0; o < s.length; o++) {
        const u = s[o].type;
        if (u === un.emsg && !r || !i)
          continue;
        const l = zx(s[o].data), c = s[o].pts;
        let d = c + s[o].duration;
        d > Fo && (d = Fo), d - c <= 0 && (d = c + Y7);
        for (let h = 0; h < l.length; h++) {
          const m = l[h];
          if (!qx(m)) {
            this.updateId3CueEnds(c, u);
            const p = Mc(a, c, d, m, u);
            p && this.id3Track.addCue(p);
          }
        }
      }
  }
  updateId3CueEnds(e, n) {
    var r;
    const i = (r = this.id3Track) == null ? void 0 : r.cues;
    if (i)
      for (let s = i.length; s--; ) {
        const a = i[s];
        a.type === n && a.startTime < e && a.endTime === Fo && (a.endTime = e);
      }
  }
  onBufferFlushing(e, {
    startOffset: n,
    endOffset: r,
    type: i
  }) {
    const {
      id3Track: s,
      hls: a
    } = this;
    if (!a)
      return;
    const {
      config: {
        enableEmsgMetadataCues: o,
        enableID3MetadataCues: u
      }
    } = a;
    if (s && (o || u)) {
      let l;
      i === "audio" ? l = (c) => c.type === un.audioId3 && u : i === "video" ? l = (c) => c.type === un.emsg && o : l = (c) => c.type === un.audioId3 && u || c.type === un.emsg && o, of(s, n, r, l);
    }
  }
  onLevelUpdated(e, {
    details: n
  }) {
    this.updateDateRangeCues(n, !0);
  }
  onLevelPtsUpdated(e, n) {
    Math.abs(n.drift) > 0.01 && this.updateDateRangeCues(n.details);
  }
  updateDateRangeCues(e, n) {
    if (!this.hls || !this.media)
      return;
    const {
      assetPlayerId: r,
      timelineOffset: i,
      enableDateRangeMetadataCues: s,
      interstitialsController: a
    } = this.hls.config;
    if (!s)
      return;
    const o = cf();
    if (r && i && !a) {
      const {
        fragmentStart: p,
        fragmentEnd: g
      } = e;
      let b = this.assetCue;
      b ? (b.startTime = p, b.endTime = g) : o && (b = this.assetCue = Mc(o, p, g, {
        assetPlayerId: this.hls.config.assetPlayerId
      }, "hlsjs.interstitial.asset"), b && (b.id = r, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(b), b.addEventListener("enter", this.onEventCueEnter)));
    }
    if (!e.hasProgramDateTime)
      return;
    const {
      id3Track: u
    } = this, {
      dateRanges: l
    } = e, c = Object.keys(l);
    let d = this.dateRangeCuesAppended;
    if (u && n) {
      var f;
      if ((f = u.cues) != null && f.length) {
        const p = Object.keys(d).filter((g) => !c.includes(g));
        for (let g = p.length; g--; ) {
          var h;
          const b = p[g], y = (h = d[b]) == null ? void 0 : h.cues;
          delete d[b], y && Object.keys(y).forEach((T) => {
            const S = y[T];
            if (S) {
              S.removeEventListener("enter", this.onEventCueEnter);
              try {
                u.removeCue(S);
              } catch {
              }
            }
          });
        }
      } else
        d = this.dateRangeCuesAppended = {};
    }
    const m = e.fragments[e.fragments.length - 1];
    if (!(c.length === 0 || !de(m == null ? void 0 : m.programDateTime))) {
      this.id3Track || (this.id3Track = this.createTrack(this.media));
      for (let p = 0; p < c.length; p++) {
        const g = c[p], b = l[g], y = b.startTime, T = d[g], S = (T == null ? void 0 : T.cues) || {};
        let I = (T == null ? void 0 : T.durationKnown) || !1, C = Fo;
        const {
          duration: _,
          endDate: R
        } = b;
        if (R && _ !== null)
          C = y + _, I = !0;
        else if (b.endOnNext && !I) {
          const A = c.reduce((L, P) => {
            if (P !== b.id) {
              const $ = l[P];
              if ($.class === b.class && $.startDate > b.startDate && (!L || b.startDate < L.startDate))
                return $;
            }
            return L;
          }, null);
          A && (C = A.startTime, I = !0);
        }
        const k = Object.keys(b.attr);
        for (let A = 0; A < k.length; A++) {
          const L = k[A];
          if (!b9(L))
            continue;
          const P = S[L];
          if (P)
            I && !(T != null && T.durationKnown) ? P.endTime = C : Math.abs(P.startTime - y) > 0.01 && (P.startTime = y, P.endTime = C);
          else if (o) {
            let $ = b.attr[L];
            E9(L) && ($ = tx($));
            const N = Mc(o, y, C, {
              key: L,
              data: $
            }, un.dateRange);
            N && (N.id = g, this.id3Track.addCue(N), S[L] = N, a && (L === "X-ASSET-LIST" || L === "X-ASSET-URL") && N.addEventListener("enter", this.onEventCueEnter));
          }
        }
        d[g] = {
          cues: S,
          dateRange: b,
          durationKnown: I
        };
      }
    }
  }
}
class Q7 {
  constructor(e) {
    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () => {
      const {
        media: n
      } = this, r = this.levelDetails;
      if (!n || !r)
        return;
      this.currentTime = n.currentTime;
      const i = this.computeLatency();
      if (i === null)
        return;
      this._latency = i;
      const {
        lowLatencyMode: s,
        maxLiveSyncPlaybackRate: a
      } = this.config;
      if (!s || a === 1 || !r.live)
        return;
      const o = this.targetLatency;
      if (o === null)
        return;
      const u = i - o, l = Math.min(this.maxLatency, o + r.targetduration);
      if (u < l && u > 0.05 && this.forwardBufferLength > 1) {
        const d = Math.min(2, Math.max(1, a)), f = Math.round(2 / (1 + Math.exp(-0.75 * u - this.edgeStalled)) * 20) / 20, h = Math.min(d, Math.max(1, f));
        this.changeMediaPlaybackRate(n, h);
      } else n.playbackRate !== 1 && n.playbackRate !== 0 && this.changeMediaPlaybackRate(n, 1);
    }, this.hls = e, this.config = e.config, this.registerListeners();
  }
  get levelDetails() {
    var e;
    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config: e
    } = this;
    if (e.liveMaxLatencyDuration !== void 0)
      return e.liveMaxLatencyDuration;
    const n = this.levelDetails;
    return n ? e.liveMaxLatencyDurationCount * n.targetduration : 0;
  }
  get targetLatency() {
    const e = this.levelDetails;
    if (e === null || this.hls === null)
      return null;
    const {
      holdBack: n,
      partHoldBack: r,
      targetduration: i
    } = e, {
      liveSyncDuration: s,
      liveSyncDurationCount: a,
      lowLatencyMode: o
    } = this.config, u = this.hls.userConfig;
    let l = o && r || n;
    (this._targetLatencyUpdated || u.liveSyncDuration || u.liveSyncDurationCount || l === 0) && (l = s !== void 0 ? s : a * i);
    const c = i;
    return l + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, c);
  }
  set targetLatency(e) {
    this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(), n = this.targetLatency;
    if (e === null || n === null)
      return null;
    const r = this.levelDetails;
    if (r === null)
      return null;
    const i = r.edge, s = e - n - this.edgeStalled, a = i - r.totalduration, o = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
    return Math.min(Math.max(a, s), o);
  }
  get drift() {
    const e = this.levelDetails;
    return e === null ? 1 : e.drift;
  }
  get edgeStalled() {
    const e = this.levelDetails;
    if (e === null)
      return 0;
    const n = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
    return Math.max(e.age - n, 0);
  }
  get forwardBufferLength() {
    const {
      media: e
    } = this, n = this.levelDetails;
    if (!e || !n)
      return 0;
    const r = e.buffered.length;
    return (r ? e.buffered.end(r - 1) : n.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e && (e.on(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(x.ERROR, this.onError, this));
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e && (e.off(x.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(x.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(x.ERROR, this.onError, this));
  }
  onMediaAttached(e, n) {
    this.media = n.media, this.media.addEventListener("timeupdate", this.onTimeupdate);
  }
  onMediaDetaching() {
    this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate), this.media = null);
  }
  onManifestLoading() {
    this._latency = null, this.stallCount = 0;
  }
  onLevelUpdated(e, {
    details: n
  }) {
    n.advanced && this.onTimeupdate(), !n.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate);
  }
  onError(e, n) {
    var r;
    n.details === q.BUFFER_STALLED_ERROR && (this.stallCount++, this.hls && (r = this.levelDetails) != null && r.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"));
  }
  changeMediaPlaybackRate(e, n) {
    var r, i;
    e.playbackRate !== n && ((r = this.hls) == null || r.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(i = this.targetLatency) == null ? void 0 : i.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${n}`), e.playbackRate = n);
  }
  estimateLiveEdge() {
    const e = this.levelDetails;
    return e === null ? null : e.edge + e.age;
  }
  computeLatency() {
    const e = this.estimateLiveEdge();
    return e === null ? null : e - this.currentTime;
  }
}
class Z7 extends e0 {
  constructor(e, n) {
    super(e, "level-controller"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = n, this._registerListeners();
  }
  _registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this), e.on(x.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this), e.off(x.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();
  }
  stopLoad() {
    this._levels.forEach((n) => {
      n.loadError = 0, n.fragmentError = 0;
    }), super.stopLoad();
  }
  resetLevels() {
    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;
  }
  onManifestLoading(e, n) {
    this.resetLevels();
  }
  onManifestLoaded(e, n) {
    const r = this.hls.config.preferManagedMediaSource, i = [], s = {}, a = {};
    let o = !1, u = !1, l = !1;
    n.levels.forEach((c) => {
      const d = c.attrs;
      let {
        audioCodec: f,
        videoCodec: h
      } = c;
      f && (c.audioCodec = f = Du(f, r) || void 0), h && (h = c.videoCodec = OB(h));
      const {
        width: m,
        height: p,
        unknownCodecs: g
      } = c, b = (g == null ? void 0 : g.length) || 0;
      if (o || (o = !!(m && p)), u || (u = !!h), l || (l = !!f), b || f && !this.isAudioSupported(f) || h && !this.isVideoSupported(h)) {
        this.log(`Some or all CODECS not supported "${d.CODECS}"`);
        return;
      }
      const {
        CODECS: y,
        "FRAME-RATE": T,
        "HDCP-LEVEL": S,
        "PATHWAY-ID": I,
        RESOLUTION: C,
        "VIDEO-RANGE": _
      } = d, k = `${`${I || "."}-`}${c.bitrate}-${C}-${T}-${y}-${_}-${S}`;
      if (s[k])
        if (s[k].uri !== c.url && !c.attrs["PATHWAY-ID"]) {
          const A = a[k] += 1;
          c.attrs["PATHWAY-ID"] = new Array(A + 1).join(".");
          const L = this.createLevel(c);
          s[k] = L, i.push(L);
        } else
          s[k].addGroupId("audio", d.AUDIO), s[k].addGroupId("text", d.SUBTITLES);
      else {
        const A = this.createLevel(c);
        s[k] = A, a[k] = 1, i.push(A);
      }
    }), this.filterAndSortMediaOptions(i, n, o, u, l);
  }
  createLevel(e) {
    const n = new Ia(e), r = e.supplemental;
    if (r != null && r.videoCodec && !this.isVideoSupported(r.videoCodec)) {
      const i = new Error(`SUPPLEMENTAL-CODECS not supported "${r.videoCodec}"`);
      this.log(i.message), n.supportedResult = hx(i, []);
    }
    return n;
  }
  isAudioSupported(e) {
    return va(e, "audio", this.hls.config.preferManagedMediaSource);
  }
  isVideoSupported(e) {
    return va(e, "video", this.hls.config.preferManagedMediaSource);
  }
  filterAndSortMediaOptions(e, n, r, i, s) {
    var a;
    let o = [], u = [], l = e;
    const c = ((a = n.stats) == null ? void 0 : a.parsing) || {};
    if ((r || i) && s && (l = l.filter(({
      videoCodec: y,
      videoRange: T,
      width: S,
      height: I
    }) => (!!y || !!(S && I)) && zB(T))), l.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          let y = "no level with compatible codecs found in manifest", T = y;
          n.levels.length && (T = `one or more CODECS in variant not supported: ${Ze(n.levels.map((I) => I.attrs.CODECS).filter((I, C, _) => _.indexOf(I) === C))}`, this.warn(T), y += ` (${T})`);
          const S = new Error(y);
          this.hls.trigger(x.ERROR, {
            type: be.MEDIA_ERROR,
            details: q.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: n.url,
            error: S,
            reason: T
          });
        }
      }), c.end = performance.now();
      return;
    }
    n.audioTracks && (o = n.audioTracks.filter((y) => !y.audioCodec || this.isAudioSupported(y.audioCodec)), t1(o)), n.subtitles && (u = n.subtitles, t1(u));
    const d = l.slice(0);
    l.sort((y, T) => {
      if (y.attrs["HDCP-LEVEL"] !== T.attrs["HDCP-LEVEL"])
        return (y.attrs["HDCP-LEVEL"] || "") > (T.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      if (r && y.height !== T.height)
        return y.height - T.height;
      if (y.frameRate !== T.frameRate)
        return y.frameRate - T.frameRate;
      if (y.videoRange !== T.videoRange)
        return Pu.indexOf(y.videoRange) - Pu.indexOf(T.videoRange);
      if (y.videoCodec !== T.videoCodec) {
        const S = Wp(y.videoCodec), I = Wp(T.videoCodec);
        if (S !== I)
          return I - S;
      }
      if (y.uri === T.uri && y.codecSet !== T.codecSet) {
        const S = ku(y.codecSet), I = ku(T.codecSet);
        if (S !== I)
          return I - S;
      }
      return y.averageBitrate !== T.averageBitrate ? y.averageBitrate - T.averageBitrate : 0;
    });
    let f = d[0];
    if (this.steering && (l = this.steering.filterParsedLevels(l), l.length !== d.length)) {
      for (let y = 0; y < d.length; y++)
        if (d[y].pathwayId === l[0].pathwayId) {
          f = d[y];
          break;
        }
    }
    this._levels = l;
    for (let y = 0; y < l.length; y++)
      if (l[y] === f) {
        var h;
        this._firstLevel = y;
        const T = f.bitrate, S = this.hls.bandwidthEstimate;
        if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${T}`), ((h = this.hls.userConfig) == null ? void 0 : h.abrEwmaDefaultEstimate) === void 0) {
          const I = Math.min(T, this.hls.config.abrEwmaDefaultEstimateMax);
          I > S && S === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = I);
        }
        break;
      }
    const m = s && !i, p = this.hls.config, g = !!(p.audioStreamController && p.audioTrackController), b = {
      levels: l,
      audioTracks: o,
      subtitleTracks: u,
      sessionData: n.sessionData,
      sessionKeys: n.sessionKeys,
      firstLevel: this._firstLevel,
      stats: n.stats,
      audio: s,
      video: i,
      altAudio: g && !m && o.some((y) => !!y.url)
    };
    c.end = performance.now(), this.hls.trigger(x.MANIFEST_PARSED, b);
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels;
  }
  get loadLevelObj() {
    return this.currentLevel;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(e) {
    const n = this._levels;
    if (n.length === 0)
      return;
    if (e < 0 || e >= n.length) {
      const c = new Error("invalid level idx"), d = e < 0;
      if (this.hls.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.LEVEL_SWITCH_ERROR,
        level: e,
        fatal: d,
        error: c,
        reason: c.message
      }), d)
        return;
      e = Math.min(e, n.length - 1);
    }
    const r = this.currentLevelIndex, i = this.currentLevel, s = i ? i.attrs["PATHWAY-ID"] : void 0, a = n[e], o = a.attrs["PATHWAY-ID"];
    if (this.currentLevelIndex = e, this.currentLevel = a, r === e && i && s === o)
      return;
    this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${r}${s ? " with Pathway " + s : ""}`);
    const u = {
      level: e,
      attrs: a.attrs,
      details: a.details,
      bitrate: a.bitrate,
      averageBitrate: a.averageBitrate,
      maxBitrate: a.maxBitrate,
      realBitrate: a.realBitrate,
      width: a.width,
      height: a.height,
      codecSet: a.codecSet,
      audioCodec: a.audioCodec,
      videoCodec: a.videoCodec,
      audioGroups: a.audioGroups,
      subtitleGroups: a.subtitleGroups,
      loaded: a.loaded,
      loadError: a.loadError,
      fragmentError: a.fragmentError,
      name: a.name,
      id: a.id,
      uri: a.uri,
      url: a.url,
      urlId: 0,
      audioGroupIds: a.audioGroupIds,
      textGroupIds: a.textGroupIds
    };
    this.hls.trigger(x.LEVEL_SWITCHING, u);
    const l = a.details;
    if (!l || l.live) {
      const c = this.switchParams(a.uri, i == null ? void 0 : i.details, l);
      this.loadPlaylist(c);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(e) {
    this.manualLevelIndex = e, this._startLevel === void 0 && (this._startLevel = e), e !== -1 && (this.level = e);
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(e) {
    this._firstLevel = e;
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel;
      return e !== void 0 ? e : this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(e) {
    this._startLevel = e;
  }
  get pathways() {
    return this.steering ? this.steering.pathways() : [];
  }
  get pathwayPriority() {
    return this.steering ? this.steering.pathwayPriority : null;
  }
  set pathwayPriority(e) {
    if (this.steering) {
      const n = this.steering.pathways(), r = e.filter((i) => n.indexOf(i) !== -1);
      if (e.length < 1) {
        this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${n}`);
        return;
      }
      this.steering.pathwayPriority = r;
    }
  }
  onError(e, n) {
    n.fatal || !n.context || n.context.type === Me.LEVEL && n.context.level === this.level && this.checkRetry(n);
  }
  // reset errors on the successful load of a fragment
  onFragBuffered(e, {
    frag: n
  }) {
    if (n !== void 0 && n.type === pe.MAIN) {
      const r = n.elementaryStreams;
      if (!Object.keys(r).some((s) => !!r[s]))
        return;
      const i = this._levels[n.level];
      i != null && i.loadError && (this.log(`Resetting level error count of ${i.loadError} on frag buffered`), i.loadError = 0);
    }
  }
  onLevelLoaded(e, n) {
    var r;
    const {
      level: i,
      details: s
    } = n, a = n.levelInfo;
    if (!a) {
      var o;
      this.warn(`Invalid level index ${i}`), (o = n.deliveryDirectives) != null && o.skip && (s.deltaUpdateFailed = !0);
      return;
    }
    if (a === this.currentLevel || n.withoutMultiVariant) {
      a.fragmentError === 0 && (a.loadError = 0);
      let u = a.details;
      u === n.details && u.advanced && (u = void 0), this.playlistLoaded(i, n, u);
    } else (r = n.deliveryDirectives) != null && r.skip && (s.deltaUpdateFailed = !0);
  }
  loadPlaylist(e) {
    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e);
  }
  loadingPlaylist(e, n) {
    super.loadingPlaylist(e, n);
    const r = this.getUrlWithDirectives(e.uri, n), i = this.currentLevelIndex, s = e.attrs["PATHWAY-ID"], a = e.details, o = a == null ? void 0 : a.age;
    this.log(`Loading level index ${i}${(n == null ? void 0 : n.msn) !== void 0 ? " at sn " + n.msn + " part " + n.part : ""}${s ? " Pathway " + s : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${r}`), this.hls.trigger(x.LEVEL_LOADING, {
      url: r,
      level: i,
      levelInfo: e,
      pathwayId: e.attrs["PATHWAY-ID"],
      id: 0,
      // Deprecated Level urlId
      deliveryDirectives: n || null
    });
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
  }
  set nextLoadLevel(e) {
    this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e);
  }
  removeLevel(e) {
    var n;
    if (this._levels.length === 1)
      return;
    const r = this._levels.filter((s, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(s), s === this.currentLevel && (this.currentLevel = null, this.currentLevelIndex = -1, s.details && s.details.fragments.forEach((o) => o.level = -1)), !1));
    Ox(r), this._levels = r, this.currentLevelIndex > -1 && (n = this.currentLevel) != null && n.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
    const i = r.length - 1;
    this._firstLevel = Math.min(this._firstLevel, i), this._startLevel && (this._startLevel = Math.min(this._startLevel, i)), this.hls.trigger(x.LEVELS_UPDATED, {
      levels: r
    });
  }
  onLevelsUpdated(e, {
    levels: n
  }) {
    this._levels = n;
  }
  checkMaxAutoUpdated() {
    const {
      autoLevelCapping: e,
      maxAutoLevel: n,
      maxHdcpLevel: r
    } = this.hls;
    this._maxAutoLevel !== n && (this._maxAutoLevel = n, this.hls.trigger(x.MAX_AUTO_LEVEL_UPDATED, {
      autoLevelCapping: e,
      levels: this.levels,
      maxAutoLevel: n,
      minAutoLevel: this.hls.minAutoLevel,
      maxHdcpLevel: r
    }));
  }
}
function t1(t) {
  const e = {};
  t.forEach((n) => {
    const r = n.groupId || "";
    n.id = e[r] = e[r] || 0, e[r]++;
  });
}
function Rv() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function wv() {
  if (!Or())
    return !1;
  const e = Rv();
  return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function";
}
function J7() {
  if (!wv())
    return !1;
  const t = Or();
  return typeof (t == null ? void 0 : t.isTypeSupported) == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((e) => t.isTypeSupported(Aa(e, "video"))) || ["mp4a.40.2", "fLaC"].some((e) => t.isTypeSupported(Aa(e, "audio"))));
}
function eH() {
  var t;
  const e = Rv();
  return typeof (e == null || (t = e.prototype) == null ? void 0 : t.changeType) == "function";
}
const tH = 100;
class nH extends Wh {
  constructor(e, n, r) {
    super(e, n, r, "stream-controller", pe.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () => {
      this.tick();
    }, this.onMediaSeeked = () => {
      const i = this.media, s = i ? i.currentTime : null;
      if (s === null || !de(s) || (this.log(`Media seeked to ${s.toFixed(3)}`), !this.getBufferedFrag(s)))
        return;
      const a = this.getFwdBufferInfoAtPos(i, s, pe.MAIN, 0);
      if (a === null || a.len === 0) {
        this.warn(`Main forward buffer length at ${s} on "seeked" event ${a ? a.len : "empty"})`);
        return;
      }
      this.tick();
    }, this.registerListeners();
  }
  registerListeners() {
    super.registerListeners();
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_PARSED, this.onManifestParsed, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.LEVEL_LOADED, this.onLevelLoaded, this), e.on(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(x.BUFFER_CREATED, this.onBufferCreated, this), e.on(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  unregisterListeners() {
    super.unregisterListeners();
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_PARSED, this.onManifestParsed, this), e.off(x.LEVEL_LOADED, this.onLevelLoaded, this), e.off(x.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(x.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(x.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(x.BUFFER_CREATED, this.onBufferCreated, this), e.off(x.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(x.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();
  }
  startLoad(e, n) {
    if (this.levels) {
      const {
        lastCurrentTime: r,
        hls: i
      } = this;
      if (this.stopLoad(), this.setInterval(tH), this.level = -1, !this.startFragRequested) {
        let s = i.startLevel;
        s === -1 && (i.config.testBandwidth && this.levels.length > 1 ? (s = 0, this.bitrateTest = !0) : s = i.firstAutoLevel), i.nextLoadLevel = s, this.level = i.loadLevel, this._hasEnoughToStart = !!n;
      }
      r > 0 && e === -1 && !n && (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = Z.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = n ? -1 : e, this.tick();
    } else
      this._forceStartLoad = !0, this.state = Z.STOPPED;
  }
  stopLoad() {
    this._forceStartLoad = !1, super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case Z.WAITING_LEVEL: {
        const {
          levels: e,
          level: n
        } = this, r = e == null ? void 0 : e[n], i = r == null ? void 0 : r.details;
        if (i && (!i.live || this.levelLastLoaded === r && !this.waitForLive(r))) {
          if (this.waitForCdnTuneIn(i))
            break;
          this.state = Z.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = Z.IDLE;
          break;
        }
        break;
      }
      case Z.FRAG_LOADING_WAITING_RETRY:
        this.checkRetryDate();
        break;
    }
    this.state === Z.IDLE && this.doTickIdle(), this.onTickEnd();
  }
  onTickEnd() {
    var e;
    super.onTickEnd(), (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls: e,
      levelLastLoaded: n,
      levels: r,
      media: i
    } = this;
    if (n === null || !i && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
      return;
    const s = this.buffering ? e.nextLoadLevel : e.loadLevel;
    if (!(r != null && r[s]))
      return;
    const a = r[s], o = this.getMainFwdBufferInfo();
    if (o === null)
      return;
    const u = this.getLevelDetails();
    if (u && this._streamEnded(o, u)) {
      const p = {};
      this.altAudio === 2 && (p.type = "video"), this.hls.trigger(x.BUFFER_EOS, p), this.state = Z.ENDED;
      return;
    }
    if (!this.buffering)
      return;
    e.loadLevel !== s && e.manualLevel === -1 && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
    const l = a.details;
    if (!l || this.state === Z.WAITING_LEVEL || this.waitForLive(a)) {
      this.level = s, this.state = Z.WAITING_LEVEL, this.startFragRequested = !1;
      return;
    }
    const c = o.len, d = this.getMaxBufferLength(a.maxBitrate);
    if (c >= d)
      return;
    this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
    const f = this.backtrackFragment ? this.backtrackFragment.start : o.end;
    let h = this.getNextFragment(f, l);
    if (this.couldBacktrack && !this.fragPrevious && h && gt(h) && this.fragmentTracker.getState(h) !== Tt.OK) {
      var m;
      const g = ((m = this.backtrackFragment) != null ? m : h).sn - l.startSN, b = l.fragments[g - 1];
      b && h.cc === b.cc && (h = b, this.fragmentTracker.removeFragment(b));
    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
    if (h && this.isLoopLoading(h, f)) {
      if (!h.gap) {
        const g = this.audioOnly && !this.altAudio ? Qe.AUDIO : Qe.VIDEO, b = (g === Qe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        b && this.afterBufferFlushed(b, g, pe.MAIN);
      }
      h = this.getNextFragmentLoopLoading(h, l, o, pe.MAIN, d);
    }
    h && (h.initSegment && !h.initSegment.data && !this.bitrateTest && (h = h.initSegment), this.loadFragment(h, a, f));
  }
  loadFragment(e, n, r) {
    const i = this.fragmentTracker.getState(e);
    i === Tt.NOT_LOADED || i === Tt.PARTIAL ? gt(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, n)) : super.loadFragment(e, n, r) : this._loadInitSegment(e, n) : this.clearTrackerIfNeeded(e);
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, pe.MAIN);
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null;
  }
  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  /**
   * try to switch ASAP without breaking video playback:
   * in order to ensure smooth but quick level switching,
   * we need to find the next flushable buffer range
   * we should take into account new segment fetch time
   */
  nextLevelSwitch() {
    const {
      levels: e,
      media: n
    } = this;
    if (n != null && n.readyState) {
      let r;
      const i = this.getAppendedFrag(n.currentTime);
      i && i.start > 1 && this.flushMainBuffer(0, i.start - 1);
      const s = this.getLevelDetails();
      if (s != null && s.live) {
        const o = this.getMainFwdBufferInfo();
        if (!o || o.len < s.targetduration * 2)
          return;
      }
      if (!n.paused && e) {
        const o = this.hls.nextLoadLevel, u = e[o], l = this.fragLastKbps;
        l && this.fragCurrent ? r = this.fragCurrent.duration * u.maxBitrate / (1e3 * l) + 1 : r = 0;
      } else
        r = 0;
      const a = this.getBufferedFrag(n.currentTime + r);
      if (a) {
        const o = this.followingBufferedFrag(a);
        if (o) {
          this.abortCurrentFrag();
          const u = o.maxStartPTS ? o.maxStartPTS : o.start, l = o.duration, c = Math.max(a.end, u + Math.min(Math.max(l - this.config.maxFragLookUpTolerance, l * (this.couldBacktrack ? 0.5 : 0.125)), l * (this.couldBacktrack ? 0.75 : 0.25)));
          this.flushMainBuffer(c, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent;
    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
      case Z.KEY_LOADING:
      case Z.FRAG_LOADING:
      case Z.FRAG_LOADING_WAITING_RETRY:
      case Z.PARSING:
      case Z.PARSED:
        this.state = Z.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(e, n) {
    super.flushMainBuffer(e, n, this.altAudio === 2 ? "video" : null);
  }
  onMediaAttached(e, n) {
    super.onMediaAttached(e, n);
    const r = n.media;
    Bt(r, "playing", this.onMediaPlaying), Bt(r, "seeked", this.onMediaSeeked);
  }
  onMediaDetaching(e, n) {
    const {
      media: r
    } = this;
    r && (zt(r, "playing", this.onMediaPlaying), zt(r, "seeked", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, n), !n.transferMedia && (this._hasEnoughToStart = !1);
  }
  onManifestLoading() {
    super.onManifestLoading(), this.log("Trigger BUFFER_RESET"), this.hls.trigger(x.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;
  }
  onManifestParsed(e, n) {
    let r = !1, i = !1;
    for (let s = 0; s < n.levels.length; s++) {
      const a = n.levels[s].audioCodec;
      a && (r = r || a.indexOf("mp4a.40.2") !== -1, i = i || a.indexOf("mp4a.40.5") !== -1);
    }
    this.audioCodecSwitch = r && i && !eH(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = n.levels, this.startFragRequested = !1;
  }
  onLevelLoading(e, n) {
    const {
      levels: r
    } = this;
    if (!r || this.state !== Z.IDLE)
      return;
    const i = n.levelInfo;
    (!i.details || i.details.live && (this.levelLastLoaded !== i || i.details.expired) || this.waitForCdnTuneIn(i.details)) && (this.state = Z.WAITING_LEVEL);
  }
  onLevelLoaded(e, n) {
    var r;
    const {
      levels: i,
      startFragRequested: s
    } = this, a = n.level, o = n.details, u = o.totalduration;
    if (!i) {
      this.warn(`Levels were reset while loading level ${a}`);
      return;
    }
    this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${u}`);
    const l = n.levelInfo, c = this.fragCurrent;
    c && (this.state === Z.FRAG_LOADING || this.state === Z.FRAG_LOADING_WAITING_RETRY) && c.level !== n.level && c.loader && this.abortCurrentFrag();
    let d = 0;
    if (o.live || (r = l.details) != null && r.live) {
      var f;
      if (this.checkLiveUpdate(o), o.deltaUpdateFailed)
        return;
      d = this.alignPlaylists(o, l.details, (f = this.levelLastLoaded) == null ? void 0 : f.details);
    }
    if (l.details = o, this.levelLastLoaded = l, s || this.setStartPosition(o, d), this.hls.trigger(x.LEVEL_UPDATED, {
      details: o,
      level: a
    }), this.state === Z.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(o))
        return;
      this.state = Z.IDLE;
    }
    s && o.live && this.synchronizeToLiveEdge(o), this.tick();
  }
  synchronizeToLiveEdge(e) {
    const {
      config: n,
      media: r
    } = this;
    if (!r)
      return;
    const i = this.hls.liveSyncPosition, s = this.getLoadPosition(), a = e.fragmentStart, o = e.edge, u = s >= a - n.maxFragLookUpTolerance && s <= o;
    if (i !== null && r.duration > i && (s < i || !u)) {
      const c = n.liveMaxLatencyDuration !== void 0 ? n.liveMaxLatencyDuration : n.liveMaxLatencyDurationCount * e.targetduration;
      if ((!u && r.readyState < 4 || s < o - c) && (this._hasEnoughToStart || (this.nextLoadPosition = i), r.readyState))
        if (this.warn(`Playback: ${s.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${i.toFixed(3)}`), this.config.liveSyncMode === "buffered") {
          var l;
          const d = Ce.bufferInfo(r, i, 0);
          if (!((l = d.buffered) != null && l.length)) {
            r.currentTime = i;
            return;
          }
          if (d.start <= s) {
            r.currentTime = i;
            return;
          }
          const {
            nextStart: h
          } = Ce.bufferedInfo(d.buffered, s, 0);
          h && (r.currentTime = h);
        } else
          r.currentTime = i;
    }
  }
  _handleFragmentLoadProgress(e) {
    var n;
    const r = e.frag, {
      part: i,
      payload: s
    } = e, {
      levels: a
    } = this;
    if (!a) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);
      return;
    }
    const o = a[r.level];
    if (!o) {
      this.warn(`Level ${r.level} not found on progress`);
      return;
    }
    const u = o.details;
    if (!u) {
      this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r);
      return;
    }
    const l = o.videoCodec, c = u.PTSKnown || !u.live, d = (n = r.initSegment) == null ? void 0 : n.data, f = this._getAudioCodec(o), h = this.transmuxer = this.transmuxer || new nv(this.hls, pe.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), m = i ? i.index : -1, p = m !== -1, g = new Gh(r.level, r.sn, r.stats.chunkCount, s.byteLength, m, p), b = this.initPTS[r.cc];
    h.push(s, d, f, l, r, i, u.totalduration, c, g, b);
  }
  onAudioTrackSwitching(e, n) {
    const r = this.hls, i = this.altAudio === 2;
    if (Ou(n.url, r))
      this.altAudio = 1;
    else {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
        const a = this.fragCurrent;
        a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests(), this.fragmentTracker.removeFragment(a)), this.resetTransmuxer(), this.resetLoadingState();
      } else this.audioOnly && this.resetTransmuxer();
      if (i) {
        this.fragmentTracker.removeAllFragments(), r.once(x.BUFFER_FLUSHED, () => {
          this.hls && this.hls.trigger(x.AUDIO_TRACK_SWITCHED, n);
        }), r.trigger(x.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        return;
      }
      r.trigger(x.AUDIO_TRACK_SWITCHED, n);
    }
  }
  onAudioTrackSwitched(e, n) {
    const r = Ou(n.url, this.hls);
    if (r) {
      const i = this.videoBuffer;
      i && this.mediaBuffer !== i && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = i);
    }
    this.altAudio = r ? 2 : 0, this.tick();
  }
  onBufferCreated(e, n) {
    const r = n.tracks;
    let i, s, a = !1;
    for (const o in r) {
      const u = r[o];
      if (u.id === "main") {
        if (s = o, i = u, o === "video") {
          const l = r[o];
          l && (this.videoBuffer = l.buffer);
        }
      } else
        a = !0;
    }
    a && i ? (this.log(`Alternate track found, use ${s}.buffered to schedule main fragment loading`), this.mediaBuffer = i.buffer) : this.mediaBuffer = this.media;
  }
  onFragBuffered(e, n) {
    const {
      frag: r,
      part: i
    } = n, s = r.type === pe.MAIN;
    if (s) {
      if (this.fragContextChanged(r)) {
        this.warn(`Fragment ${r.sn}${i ? " p: " + i.index : ""} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === Z.PARSED && (this.state = Z.IDLE);
        return;
      }
      const o = i ? i.stats : r.stats;
      this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)), gt(r) && (this.fragPrevious = r), this.fragBufferedComplete(r, i);
    }
    const a = this.media;
    a && (!this._hasEnoughToStart && Ce.getBuffered(a).length && (this._hasEnoughToStart = !0, this.seekToStartPos()), s && this.tick());
  }
  get hasEnoughToStart() {
    return this._hasEnoughToStart;
  }
  onError(e, n) {
    var r;
    if (n.fatal) {
      this.state = Z.ERROR;
      return;
    }
    switch (n.details) {
      case q.FRAG_GAP:
      case q.FRAG_PARSING_ERROR:
      case q.FRAG_DECRYPT_ERROR:
      case q.FRAG_LOAD_ERROR:
      case q.FRAG_LOAD_TIMEOUT:
      case q.KEY_LOAD_ERROR:
      case q.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(pe.MAIN, n);
        break;
      case q.LEVEL_LOAD_ERROR:
      case q.LEVEL_LOAD_TIMEOUT:
      case q.LEVEL_PARSING_ERROR:
        !n.levelRetry && this.state === Z.WAITING_LEVEL && ((r = n.context) == null ? void 0 : r.type) === Me.LEVEL && (this.state = Z.IDLE);
        break;
      case q.BUFFER_ADD_CODEC_ERROR:
      case q.BUFFER_APPEND_ERROR:
        if (n.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(n) && this.resetLoadingState();
        break;
      case q.BUFFER_FULL_ERROR:
        if (n.parent !== "main")
          return;
        this.reduceLengthAndFlushBuffer(n) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));
        break;
      case q.INTERNAL_EXCEPTION:
        this.recoverWorkerError(n);
        break;
    }
  }
  onFragLoadEmergencyAborted() {
    this.state = Z.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();
  }
  onBufferFlushed(e, {
    type: n
  }) {
    if (n !== Qe.AUDIO || !this.altAudio) {
      const r = (n === Qe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      r && (this.afterBufferFlushed(r, n, pe.MAIN), this.tick());
    }
  }
  onLevelsUpdated(e, n) {
    this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level, this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)), this.levels = n.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  /**
   * Seeks to the set startPosition if not equal to the mediaElement's current time.
   */
  seekToStartPos() {
    const {
      media: e
    } = this;
    if (!e)
      return;
    const n = e.currentTime;
    let r = this.startPosition;
    if (r >= 0 && n < r) {
      if (e.seeking) {
        this.log(`could not seek to ${r}, already seeking at ${n}`);
        return;
      }
      const i = this.timelineOffset;
      i && r && (r += i);
      const s = this.getLevelDetails(), a = Ce.getBuffered(e), o = a.length ? a.start(0) : 0, u = o - r, l = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
      (this.config.startOnSegmentBoundary || u > 0 && (u < l || this.loadingParts && u < 2 * ((s == null ? void 0 : s.partTarget) || 0))) && (this.log(`adjusting start position by ${u} to match buffer start`), r += u, this.startPosition = r), n < r && (this.log(`seek to target start position ${r} from current time ${n} buffer start ${o}`), e.currentTime = r);
    }
  }
  _getAudioCodec(e) {
    let n = this.config.defaultAudioCodec || e.audioCodec;
    return this.audioCodecSwap && n && (this.log("Swapping audio codec"), n.indexOf("mp4a.40.5") !== -1 ? n = "mp4a.40.2" : n = "mp4a.40.5"), n;
  }
  _loadBitrateTestFrag(e, n) {
    e.bitrateTest = !0, this._doFragLoad(e, n).then((r) => {
      const {
        hls: i
      } = this, s = r == null ? void 0 : r.frag;
      if (!s || this.fragContextChanged(s))
        return;
      n.fragmentError = 0, this.state = Z.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;
      const a = s.stats;
      a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger(x.FRAG_LOADED, r), s.bitrateTest = !1;
    }).catch((r) => {
      this.state === Z.STOPPED || this.state === Z.ERROR || (this.warn(r), this.resetFragmentLoading(e));
    });
  }
  _handleTransmuxComplete(e) {
    const n = this.playlistType, {
      hls: r
    } = this, {
      remuxResult: i,
      chunkMeta: s
    } = e, a = this.getCurrentContext(s);
    if (!a) {
      this.resetWhenMissingContext(s);
      return;
    }
    const {
      frag: o,
      part: u,
      level: l
    } = a, {
      video: c,
      text: d,
      id3: f,
      initSegment: h
    } = i, {
      details: m
    } = l, p = this.altAudio ? void 0 : i.audio;
    if (this.fragContextChanged(o)) {
      this.fragmentTracker.removeFragment(o);
      return;
    }
    if (this.state = Z.PARSING, h) {
      const g = h.tracks;
      if (g) {
        const S = o.initSegment || o;
        if (this.unhandledEncryptionError(h, o))
          return;
        this._bufferInitSegment(l, g, S, s), r.trigger(x.FRAG_PARSING_INIT_SEGMENT, {
          frag: S,
          id: n,
          tracks: g
        });
      }
      const b = h.initPTS, y = h.timescale, T = this.initPTS[o.cc];
      if (de(b) && (!T || T.baseTime !== b || T.timescale !== y)) {
        const S = h.trackId;
        this.initPTS[o.cc] = {
          baseTime: b,
          timescale: y,
          trackId: S
        }, r.trigger(x.INIT_PTS_FOUND, {
          frag: o,
          id: n,
          initPTS: b,
          timescale: y,
          trackId: S
        });
      }
    }
    if (c && m) {
      p && c.type === "audiovideo" && this.logMuxedErr(o);
      const g = m.fragments[o.sn - 1 - m.startSN], b = o.sn === m.startSN, y = !g || o.cc > g.cc;
      if (i.independent !== !1) {
        const {
          startPTS: T,
          endPTS: S,
          startDTS: I,
          endDTS: C
        } = c;
        if (u)
          u.elementaryStreams[c.type] = {
            startPTS: T,
            endPTS: S,
            startDTS: I,
            endDTS: C
          };
        else if (c.firstKeyFrame && c.independent && s.id === 1 && !y && (this.couldBacktrack = !0), c.dropped && c.independent) {
          const _ = this.getMainFwdBufferInfo(), R = (_ ? _.end : this.getLoadPosition()) + this.config.maxBufferHole, k = c.firstKeyFramePTS ? c.firstKeyFramePTS : T;
          if (!b && R < k - this.config.maxBufferHole && !y) {
            this.backtrack(o);
            return;
          } else y && (o.gap = !0);
          o.setElementaryStreamInfo(c.type, o.start, S, o.start, C, !0);
        } else b && T - (m.appliedTimelineOffset || 0) > su && (o.gap = !0);
        o.setElementaryStreamInfo(c.type, T, S, I, C), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(c, o, u, s, b || y);
      } else if (b || y)
        o.gap = !0;
      else {
        this.backtrack(o);
        return;
      }
    }
    if (p) {
      const {
        startPTS: g,
        endPTS: b,
        startDTS: y,
        endDTS: T
      } = p;
      u && (u.elementaryStreams[Qe.AUDIO] = {
        startPTS: g,
        endPTS: b,
        startDTS: y,
        endDTS: T
      }), o.setElementaryStreamInfo(Qe.AUDIO, g, b, y, T), this.bufferFragmentData(p, o, u, s);
    }
    if (m && f != null && f.samples.length) {
      const g = {
        id: n,
        frag: o,
        details: m,
        samples: f.samples
      };
      r.trigger(x.FRAG_PARSING_METADATA, g);
    }
    if (m && d) {
      const g = {
        id: n,
        frag: o,
        details: m,
        samples: d.samples
      };
      r.trigger(x.FRAG_PARSING_USERDATA, g);
    }
  }
  logMuxedErr(e) {
    this.warn(`${gt(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`);
  }
  _bufferInitSegment(e, n, r, i) {
    if (this.state !== Z.PARSING)
      return;
    this.audioOnly = !!n.audio && !n.video, this.altAudio && !this.audioOnly && (delete n.audio, n.audiovideo && this.logMuxedErr(r));
    const {
      audio: s,
      video: a,
      audiovideo: o
    } = n;
    if (s) {
      const l = e.audioCodec;
      let c = Zo(s.codec, l);
      c === "mp4a" && (c = "mp4a.40.5");
      const d = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        c && (c.indexOf("mp4a.40.5") !== -1 ? c = "mp4a.40.2" : c = "mp4a.40.5");
        const f = s.metadata;
        f && "channelCount" in f && (f.channelCount || 1) !== 1 && d.indexOf("firefox") === -1 && (c = "mp4a.40.5");
      }
      c && c.indexOf("mp4a.40.5") !== -1 && d.indexOf("android") !== -1 && s.container !== "audio/mpeg" && (c = "mp4a.40.2", this.log(`Android: force audio codec to ${c}`)), l && l !== c && this.log(`Swapping manifest audio codec "${l}" for "${c}"`), s.levelCodec = c, s.id = pe.MAIN, this.log(`Init audio buffer, container:${s.container}, codecs[selected/level/parsed]=[${c || ""}/${l || ""}/${s.codec}]`), delete n.audiovideo;
    }
    if (a) {
      a.levelCodec = e.videoCodec, a.id = pe.MAIN;
      const l = a.codec;
      if ((l == null ? void 0 : l.length) === 4)
        switch (l) {
          case "hvc1":
          case "hev1":
            a.codec = "hvc1.1.6.L120.90";
            break;
          case "av01":
            a.codec = "av01.0.04M.08";
            break;
          case "avc1":
            a.codec = "avc1.42e01e";
            break;
        }
      this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${l}]${a.codec !== l ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`), delete n.audiovideo;
    }
    o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`), delete n.video, delete n.audio);
    const u = Object.keys(n);
    if (u.length) {
      if (this.hls.trigger(x.BUFFER_CODECS, n), !this.hls)
        return;
      u.forEach((l) => {
        const d = n[l].initSegment;
        d != null && d.byteLength && this.hls.trigger(x.BUFFER_APPENDING, {
          type: l,
          data: d,
          frag: r,
          part: null,
          chunkMeta: i,
          parent: r.type
        });
      });
    }
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
    return this.getFwdBufferInfo(e, pe.MAIN);
  }
  get maxBufferLength() {
    const {
      levels: e,
      level: n
    } = this, r = e == null ? void 0 : e[n];
    return r ? this.getMaxBufferLength(r.maxBitrate) : this.config.maxBufferLength;
  }
  backtrack(e) {
    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = Z.IDLE;
  }
  checkFragmentChanged() {
    const e = this.media;
    let n = null;
    if (e && e.readyState > 1 && e.seeking === !1) {
      const r = e.currentTime;
      if (Ce.isBuffered(e, r) ? n = this.getAppendedFrag(r) : Ce.isBuffered(e, r + 0.1) && (n = this.getAppendedFrag(r + 0.1)), n) {
        this.backtrackFragment = null;
        const i = this.fragPlaying, s = n.level;
        (!i || n.sn !== i.sn || i.level !== s) && (this.fragPlaying = n, this.hls.trigger(x.FRAG_CHANGED, {
          frag: n
        }), (!i || i.level !== s) && this.hls.trigger(x.LEVEL_SWITCHED, {
          level: s
        }));
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag;
    return e ? e.level : -1;
  }
  get currentFrag() {
    var e;
    if (this.fragPlaying)
      return this.fragPlaying;
    const n = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    return de(n) ? this.getAppendedFrag(n) : null;
  }
  get currentProgramDateTime() {
    var e;
    const n = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
    if (de(n)) {
      const r = this.getLevelDetails(), i = this.currentFrag || (r ? ai(null, r.fragments, n) : null);
      if (i) {
        const s = i.programDateTime;
        if (s !== null) {
          const a = s + (n - i.start) * 1e3;
          return new Date(a);
        }
      }
    }
    return null;
  }
  get currentLevel() {
    const e = this.currentFrag;
    return e ? e.level : -1;
  }
  get nextBufferedFrag() {
    const e = this.currentFrag;
    return e ? this.followingBufferedFrag(e) : null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}
class rH extends En {
  constructor(e, n) {
    super("key-loader", n), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e;
  }
  abort(e) {
    for (const r in this.keyIdToKeyInfo) {
      const i = this.keyIdToKeyInfo[r].loader;
      if (i) {
        var n;
        if (e && e !== ((n = i.context) == null ? void 0 : n.frag.type))
          return;
        i.abort();
      }
    }
  }
  detach() {
    for (const e in this.keyIdToKeyInfo) {
      const n = this.keyIdToKeyInfo[e];
      (n.mediaKeySessionContext || n.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e];
    }
  }
  destroy() {
    this.detach();
    for (const e in this.keyIdToKeyInfo) {
      const n = this.keyIdToKeyInfo[e].loader;
      n && n.destroy();
    }
    this.keyIdToKeyInfo = {};
  }
  createKeyLoadError(e, n = q.KEY_LOAD_ERROR, r, i, s) {
    return new or({
      type: be.NETWORK_ERROR,
      details: n,
      fatal: !1,
      frag: e,
      response: s,
      error: r,
      networkDetails: i
    });
  }
  loadClear(e, n, r) {
    if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
      if (n.length)
        for (let i = 0, s = n.length; i < s; i++) {
          const a = n[i];
          if (e.cc <= a.cc && (!gt(e) || !gt(a) || e.sn < a.sn) || !r && i == s - 1)
            return this.emeController.selectKeySystemFormat(a).then((o) => {
              if (!this.emeController)
                return;
              a.setKeyFormat(o);
              const u = eu(o);
              if (u)
                return this.emeController.getKeySystemAccess([u]);
            });
        }
      if (this.config.requireKeySystemAccessOnStart) {
        const i = Ks(this.config);
        if (i.length)
          return this.emeController.getKeySystemAccess(i);
      }
    }
    return null;
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((n) => this.loadInternal(e, n)) : this.loadInternal(e);
  }
  loadInternal(e, n) {
    var r, i;
    n && e.setKeyFormat(n);
    const s = e.decryptdata;
    if (!s) {
      const l = new Error(n ? `Expected frag.decryptdata to be defined after setting format ${n}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController && this.config.emeEnabled})`);
      return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, l));
    }
    const a = s.uri;
    if (!a)
      return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
    const o = Fc(s);
    let u = this.keyIdToKeyInfo[o];
    if ((r = u) != null && r.decryptdata.key)
      return s.key = u.decryptdata.key, Promise.resolve({
        frag: e,
        keyInfo: u
      });
    if (this.emeController && (i = u) != null && i.keyLoadPromise)
      switch (this.emeController.getKeyStatus(u.decryptdata)) {
        case "usable":
        case "usable-in-future":
          return u.keyLoadPromise.then((c) => {
            const {
              keyInfo: d
            } = c;
            return s.key = d.decryptdata.key, {
              frag: e,
              keyInfo: d
            };
          });
      }
    switch (this.log(`${this.keyIdToKeyInfo[o] ? "Rel" : "L"}oading${s.keyId ? " keyId: " + Ft(s.keyId) : ""} URI: ${s.uri} from ${e.type} ${e.level}`), u = this.keyIdToKeyInfo[o] = {
      decryptdata: s,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    }, s.method) {
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        return s.keyFormat === "identity" ? this.loadKeyHTTP(u, e) : this.loadKeyEME(u, e);
      case "AES-128":
      case "AES-256":
      case "AES-256-CTR":
        return this.loadKeyHTTP(u, e);
      default:
        return Promise.reject(this.createKeyLoadError(e, q.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${s.method}"`)));
    }
  }
  loadKeyEME(e, n) {
    const r = {
      frag: n,
      keyInfo: e
    };
    if (this.emeController && this.config.emeEnabled) {
      var i;
      if (!e.decryptdata.keyId && (i = n.initSegment) != null && i.data) {
        const a = xB(n.initSegment.data);
        if (a.length) {
          const o = a[0];
          o.some((u) => u !== 0) && (this.log(`Using keyId found in init segment ${Ft(o)}`), e.decryptdata.keyId = o, ni.setKeyIdForUri(e.decryptdata.uri, o));
        }
      }
      const s = this.emeController.loadKey(r);
      return (e.keyLoadPromise = s.then((a) => (e.mediaKeySessionContext = a, r))).catch((a) => {
        throw e.keyLoadPromise = null, "data" in a && (a.data.frag = n), a;
      });
    }
    return Promise.resolve(r);
  }
  loadKeyHTTP(e, n) {
    const r = this.config, i = r.loader, s = new i(r);
    return n.keyLoader = e.loader = s, e.keyLoadPromise = new Promise((a, o) => {
      const u = {
        keyInfo: e,
        frag: n,
        responseType: "arraybuffer",
        url: e.decryptdata.uri
      }, l = r.keyLoadPolicy.default, c = {
        loadPolicy: l,
        timeout: l.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      }, d = {
        onSuccess: (f, h, m, p) => {
          const {
            frag: g,
            keyInfo: b
          } = m, y = Fc(b.decryptdata);
          if (!g.decryptdata || b !== this.keyIdToKeyInfo[y])
            return o(this.createKeyLoadError(g, q.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), p));
          b.decryptdata.key = g.decryptdata.key = new Uint8Array(f.data), g.keyLoader = null, b.loader = null, a({
            frag: g,
            keyInfo: b
          });
        },
        onError: (f, h, m, p) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.KEY_LOAD_ERROR, new Error(`HTTP Error ${f.code} loading key ${f.text}`), m, ze({
            url: u.url,
            data: void 0
          }, f)));
        },
        onTimeout: (f, h, m) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), m));
        },
        onAbort: (f, h, m) => {
          this.resetLoader(h), o(this.createKeyLoadError(n, q.INTERNAL_ABORTED, new Error("key loading aborted"), m));
        }
      };
      s.load(u, c, d);
    });
  }
  resetLoader(e) {
    const {
      frag: n,
      keyInfo: r,
      url: i
    } = e, s = r.loader;
    n.keyLoader === s && (n.keyLoader = null, r.loader = null);
    const a = Fc(r.decryptdata) || i;
    delete this.keyIdToKeyInfo[a], s && s.destroy();
  }
}
function Fc(t) {
  if (t.keyFormat !== _t.FAIRPLAY) {
    const e = t.keyId;
    if (e)
      return Ft(e);
  }
  return t.uri;
}
function n1(t) {
  const {
    type: e
  } = t;
  switch (e) {
    case Me.AUDIO_TRACK:
      return pe.AUDIO;
    case Me.SUBTITLE_TRACK:
      return pe.SUBTITLE;
    default:
      return pe.MAIN;
  }
}
function Bc(t, e) {
  let n = t.url;
  return (n === void 0 || n.indexOf("data:") === 0) && (n = e.url), n;
}
class iH {
  constructor(e) {
    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();
  }
  startLoad(e) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls: e
    } = this;
    e.on(x.MANIFEST_LOADING, this.onManifestLoading, this), e.on(x.LEVEL_LOADING, this.onLevelLoading, this), e.on(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  unregisterListeners() {
    const {
      hls: e
    } = this;
    e.off(x.MANIFEST_LOADING, this.onManifestLoading, this), e.off(x.LEVEL_LOADING, this.onLevelLoading, this), e.off(x.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(x.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(x.LEVELS_UPDATED, this.onLevelsUpdated, this);
  }
  /**
   * Returns defaults or configured loader-type overloads (pLoader and loader config params)
   */
  createInternalLoader(e) {
    const n = this.hls.config, r = n.pLoader, i = n.loader, s = r || i, a = new s(n);
    return this.loaders[e.type] = a, a;
  }
  getInternalLoader(e) {
    return this.loaders[e.type];
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e];
  }
  /**
   * Call `destroy` on all internal loader instances mapped (one per context type)
   */
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const n = this.loaders[e];
      n && n.destroy(), this.resetInternalLoader(e);
    }
  }
  destroy() {
    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();
  }
  onManifestLoading(e, n) {
    const {
      url: r
    } = n;
    this.variableList = null, this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: Me.MANIFEST,
      url: r,
      deliveryDirectives: null,
      levelOrTrack: null
    });
  }
  onLevelLoading(e, n) {
    const {
      id: r,
      level: i,
      pathwayId: s,
      url: a,
      deliveryDirectives: o,
      levelInfo: u
    } = n;
    this.load({
      id: r,
      level: i,
      pathwayId: s,
      responseType: "text",
      type: Me.LEVEL,
      url: a,
      deliveryDirectives: o,
      levelOrTrack: u
    });
  }
  onAudioTrackLoading(e, n) {
    const {
      id: r,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = n;
    this.load({
      id: r,
      groupId: i,
      level: null,
      responseType: "text",
      type: Me.AUDIO_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onSubtitleTrackLoading(e, n) {
    const {
      id: r,
      groupId: i,
      url: s,
      deliveryDirectives: a,
      track: o
    } = n;
    this.load({
      id: r,
      groupId: i,
      level: null,
      responseType: "text",
      type: Me.SUBTITLE_TRACK,
      url: s,
      deliveryDirectives: a,
      levelOrTrack: o
    });
  }
  onLevelsUpdated(e, n) {
    const r = this.loaders[Me.LEVEL];
    if (r) {
      const i = r.context;
      i && !n.levels.some((s) => s === i.levelOrTrack) && (r.abort(), delete this.loaders[Me.LEVEL]);
    }
  }
  load(e) {
    var n;
    const r = this.hls.config;
    let i = this.getInternalLoader(e);
    if (i) {
      const l = this.hls.logger, c = i.context;
      if (c && c.levelOrTrack === e.levelOrTrack && (c.url === e.url || c.deliveryDirectives && !e.deliveryDirectives)) {
        c.url === e.url ? l.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : l.log(`[playlist-loader]: ignore ${e.url} in favor of ${c.url}`);
        return;
      }
      l.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), i.abort();
    }
    let s;
    if (e.type === Me.MANIFEST ? s = r.manifestLoadPolicy.default : s = Xe({}, r.playlistLoadPolicy.default, {
      timeoutRetry: null,
      errorRetry: null
    }), i = this.createInternalLoader(e), de((n = e.deliveryDirectives) == null ? void 0 : n.part)) {
      let l;
      if (e.type === Me.LEVEL && e.level !== null ? l = this.hls.levels[e.level].details : e.type === Me.AUDIO_TRACK && e.id !== null ? l = this.hls.audioTracks[e.id].details : e.type === Me.SUBTITLE_TRACK && e.id !== null && (l = this.hls.subtitleTracks[e.id].details), l) {
        const c = l.partTarget, d = l.targetduration;
        if (c && d) {
          const f = Math.max(c * 3, d * 0.8) * 1e3;
          s = Xe({}, s, {
            maxTimeToFirstByteMs: Math.min(f, s.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(f, s.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const a = s.errorRetry || s.timeoutRetry || {}, o = {
      loadPolicy: s,
      timeout: s.maxLoadTimeMs,
      maxRetry: a.maxNumRetry || 0,
      retryDelay: a.retryDelayMs || 0,
      maxRetryDelay: a.maxRetryDelayMs || 0
    }, u = {
      onSuccess: (l, c, d, f) => {
        const h = this.getInternalLoader(d);
        this.resetInternalLoader(d.type);
        const m = l.data;
        c.parsing.start = performance.now(), Un.isMediaPlaylist(m) || d.type !== Me.MANIFEST ? this.handleTrackOrLevelPlaylist(l, c, d, f || null, h) : this.handleMasterPlaylist(l, c, d, f);
      },
      onError: (l, c, d, f) => {
        this.handleNetworkError(c, d, !1, l, f);
      },
      onTimeout: (l, c, d) => {
        this.handleNetworkError(c, d, !0, void 0, l);
      }
    };
    i.load(e, o, u);
  }
  checkAutostartLoad() {
    if (!this.hls)
      return;
    const {
      config: {
        autoStartLoad: e,
        startPosition: n
      },
      forceStartLoad: r
    } = this.hls;
    (e || r) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${n}`), this.hls.startLoad(n));
  }
  handleMasterPlaylist(e, n, r, i) {
    const s = this.hls, a = e.data, o = Bc(e, r), u = Un.parseMasterPlaylist(a, o);
    if (u.playlistParsingError) {
      n.parsing.end = performance.now(), this.handleManifestParsingError(e, r, u.playlistParsingError, i, n);
      return;
    }
    const {
      contentSteering: l,
      levels: c,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: m
    } = u;
    this.variableList = m, c.forEach((y) => {
      const {
        unknownCodecs: T
      } = y;
      if (T) {
        const {
          preferManagedMediaSource: S
        } = this.hls.config;
        let {
          audioCodec: I,
          videoCodec: C
        } = y;
        for (let _ = T.length; _--; ) {
          const R = T[_];
          va(R, "audio", S) ? (y.audioCodec = I = I ? `${I},${R}` : R, cs.audio[I.substring(0, 4)] = 2, T.splice(_, 1)) : va(R, "video", S) && (y.videoCodec = C = C ? `${C},${R}` : R, cs.video[C.substring(0, 4)] = 2, T.splice(_, 1));
        }
      }
    });
    const {
      AUDIO: p = [],
      SUBTITLES: g,
      "CLOSED-CAPTIONS": b
    } = Un.parseMasterPlaylistMedia(a, o, u);
    p.length && !p.some((T) => !T.url) && c[0].audioCodec && !c[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), p.unshift({
      type: "main",
      name: "main",
      groupId: "main",
      default: !1,
      autoselect: !1,
      forced: !1,
      id: -1,
      attrs: new ut({}),
      bitrate: 0,
      url: ""
    })), s.trigger(x.MANIFEST_LOADED, {
      levels: c,
      audioTracks: p,
      subtitles: g,
      captions: b,
      contentSteering: l,
      url: o,
      stats: n,
      networkDetails: i,
      sessionData: d,
      sessionKeys: f,
      startTimeOffset: h,
      variableList: m
    });
  }
  handleTrackOrLevelPlaylist(e, n, r, i, s) {
    const a = this.hls, {
      id: o,
      level: u,
      type: l
    } = r, c = Bc(e, r), d = de(u) ? u : de(o) ? o : 0, f = n1(r), h = Un.parseLevelPlaylist(e.data, c, d, f, 0, this.variableList);
    if (l === Me.MANIFEST) {
      const m = {
        attrs: new ut({}),
        bitrate: 0,
        details: h,
        name: "",
        url: c
      };
      h.requestScheduled = n.loading.start + kx(h, 0), a.trigger(x.MANIFEST_LOADED, {
        levels: [m],
        audioTracks: [],
        url: c,
        stats: n,
        networkDetails: i,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    n.parsing.end = performance.now(), r.levelDetails = h, this.handlePlaylistLoaded(h, e, n, r, i, s);
  }
  handleManifestParsingError(e, n, r, i, s) {
    this.hls.trigger(x.ERROR, {
      type: be.NETWORK_ERROR,
      details: q.MANIFEST_PARSING_ERROR,
      fatal: n.type === Me.MANIFEST,
      url: e.url,
      err: r,
      error: r,
      reason: r.message,
      response: e,
      context: n,
      networkDetails: i,
      stats: s
    });
  }
  handleNetworkError(e, n, r = !1, i, s) {
    let a = `A network ${r ? "timeout" : "error" + (i ? " (status " + i.code + ")" : "")} occurred while loading ${e.type}`;
    e.type === Me.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === Me.AUDIO_TRACK || e.type === Me.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`);
    const o = new Error(a);
    this.hls.logger.warn(`[playlist-loader]: ${a}`);
    let u = q.UNKNOWN, l = !1;
    const c = this.getInternalLoader(e);
    switch (e.type) {
      case Me.MANIFEST:
        u = r ? q.MANIFEST_LOAD_TIMEOUT : q.MANIFEST_LOAD_ERROR, l = !0;
        break;
      case Me.LEVEL:
        u = r ? q.LEVEL_LOAD_TIMEOUT : q.LEVEL_LOAD_ERROR, l = !1;
        break;
      case Me.AUDIO_TRACK:
        u = r ? q.AUDIO_TRACK_LOAD_TIMEOUT : q.AUDIO_TRACK_LOAD_ERROR, l = !1;
        break;
      case Me.SUBTITLE_TRACK:
        u = r ? q.SUBTITLE_TRACK_LOAD_TIMEOUT : q.SUBTITLE_LOAD_ERROR, l = !1;
        break;
    }
    c && this.resetInternalLoader(e.type);
    const d = {
      type: be.NETWORK_ERROR,
      details: u,
      fatal: l,
      url: e.url,
      loader: c,
      context: e,
      error: o,
      networkDetails: n,
      stats: s
    };
    if (i) {
      const f = (n == null ? void 0 : n.url) || e.url;
      d.response = ze({
        url: f,
        data: void 0
      }, i);
    }
    this.hls.trigger(x.ERROR, d);
  }
  handlePlaylistLoaded(e, n, r, i, s, a) {
    const o = this.hls, {
      type: u,
      level: l,
      levelOrTrack: c,
      id: d,
      groupId: f,
      deliveryDirectives: h
    } = i, m = Bc(n, i), p = n1(i);
    let g = typeof i.level == "number" && p === pe.MAIN ? l : void 0;
    const b = e.playlistParsingError;
    if (b) {
      if (this.hls.logger.warn(`${b} ${e.url}`), !o.config.ignorePlaylistParsingErrors) {
        o.trigger(x.ERROR, {
          type: be.NETWORK_ERROR,
          details: q.LEVEL_PARSING_ERROR,
          fatal: !1,
          url: m,
          error: b,
          reason: b.message,
          response: n,
          context: i,
          level: g,
          parent: p,
          networkDetails: s,
          stats: r
        });
        return;
      }
      e.playlistParsingError = null;
    }
    if (!e.fragments.length) {
      const y = e.playlistParsingError = new Error("No Segments found in Playlist");
      o.trigger(x.ERROR, {
        type: be.NETWORK_ERROR,
        details: q.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: m,
        error: y,
        reason: y.message,
        response: n,
        context: i,
        level: g,
        parent: p,
        networkDetails: s,
        stats: r
      });
      return;
    }
    switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0), (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)), u) {
      case Me.MANIFEST:
      case Me.LEVEL:
        if (g) {
          if (!c)
            g = 0;
          else if (c !== o.levels[g]) {
            const y = o.levels.indexOf(c);
            y > -1 && (g = y);
          }
        }
        o.trigger(x.LEVEL_LOADED, {
          details: e,
          levelInfo: c || o.levels[0],
          level: g || 0,
          id: d || 0,
          stats: r,
          networkDetails: s,
          deliveryDirectives: h,
          withoutMultiVariant: u === Me.MANIFEST
        });
        break;
      case Me.AUDIO_TRACK:
        o.trigger(x.AUDIO_TRACK_LOADED, {
          details: e,
          track: c,
          id: d || 0,
          groupId: f || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
      case Me.SUBTITLE_TRACK:
        o.trigger(x.SUBTITLE_TRACK_LOADED, {
          details: e,
          track: c,
          id: d || 0,
          groupId: f || "",
          stats: r,
          networkDetails: s,
          deliveryDirectives: h
        });
        break;
    }
  }
}
class Rt {
  /**
   * Get the video-dev/hls.js package version.
   */
  static get version() {
    return Ca;
  }
  /**
   * Check if the required MediaSource Extensions are available.
   */
  static isMSESupported() {
    return wv();
  }
  /**
   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.
   */
  static isSupported() {
    return J7();
  }
  /**
   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).
   */
  static getMediaSource() {
    return Or();
  }
  static get Events() {
    return x;
  }
  static get MetadataSchema() {
    return un;
  }
  static get ErrorTypes() {
    return be;
  }
  static get ErrorDetails() {
    return q;
  }
  /**
   * Get the default configuration applied to new instances.
   */
  static get DefaultConfig() {
    return Rt.defaultConfig ? Rt.defaultConfig : H7;
  }
  /**
   * Replace the default configuration applied to new instances.
   */
  static set DefaultConfig(e) {
    Rt.defaultConfig = e;
  }
  /**
   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`
   */
  constructor(e = {}) {
    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Kh(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;
    const n = this.logger = cB(e.debug || !1, "Hls instance", e.assetPlayerId), r = this.config = G7(Rt.DefaultConfig, e, n);
    this.userConfig = e, r.progressive && z7(r, n);
    const {
      abrController: i,
      bufferController: s,
      capLevelController: a,
      errorController: o,
      fpsController: u
    } = r, l = new o(this), c = this.abrController = new i(this), d = new s9(this), f = r.interstitialsController, h = f ? this.interstitialsController = new f(this, Rt) : null, m = this.bufferController = new s(this, d), p = this.capLevelController = new a(this), g = new u(this), b = new iH(this), y = r.contentSteeringController, T = y ? new y(this) : null, S = this.levelController = new Z7(this, T), I = new X7(this), C = new rH(this.config, this.logger), _ = this.streamController = new nH(this, d, C), R = this.gapController = new j7(this, d);
    p.setStreamController(_), g.setStreamController(_);
    const k = [b, S, _];
    h && k.splice(1, 0, h), T && k.splice(1, 0, T), this.networkControllers = k;
    const A = [c, m, R, p, g, I, d];
    this.audioTrackController = this.createController(r.audioTrackController, k);
    const L = r.audioStreamController;
    L && k.push(this.audioStreamController = new L(this, d, C)), this.subtitleTrackController = this.createController(r.subtitleTrackController, k);
    const P = r.subtitleStreamController;
    P && k.push(this.subtititleStreamController = new P(this, d, C)), this.createController(r.timelineController, A), C.emeController = this.emeController = this.createController(r.emeController, A), this.cmcdController = this.createController(r.cmcdController, A), this.latencyController = this.createController(Q7, A), this.coreComponents = A, k.push(l);
    const $ = l.onErrorOut;
    typeof $ == "function" && this.on(x.ERROR, $, l), this.on(x.MANIFEST_LOADED, b.onManifestLoaded, b);
  }
  createController(e, n) {
    if (e) {
      const r = new e(this);
      return n && n.push(r), r;
    }
    return null;
  }
  // Delegate the EventEmitter through the public API of Hls.js
  on(e, n, r = this) {
    this._emitter.on(e, n, r);
  }
  once(e, n, r = this) {
    this._emitter.once(e, n, r);
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e);
  }
  off(e, n, r = this, i) {
    this._emitter.off(e, n, r, i);
  }
  listeners(e) {
    return this._emitter.listeners(e);
  }
  emit(e, n, r) {
    return this._emitter.emit(e, n, r);
  }
  trigger(e, n) {
    if (this.config.debug)
      return this.emit(e, e, n);
    try {
      return this.emit(e, e, n);
    } catch (r) {
      if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + r.message + '". Here is a stacktrace:', r), !this.triggeringException) {
        this.triggeringException = !0;
        const i = e === x.ERROR;
        this.trigger(x.ERROR, {
          type: be.OTHER_ERROR,
          details: q.INTERNAL_EXCEPTION,
          fatal: i,
          event: e,
          error: r
        }), this.triggeringException = !1;
      }
    }
    return !1;
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
  /**
   * Dispose of the instance
   */
  destroy() {
    this.logger.log("destroy"), this.trigger(x.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((n) => n.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((n) => n.destroy()), this.coreComponents.length = 0;
    const e = this.config;
    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;
  }
  /**
   * Attaches Hls.js to a media element
   */
  attachMedia(e) {
    if (!e || "media" in e && !e.media) {
      const s = new Error(`attachMedia failed: invalid argument (${e})`);
      this.trigger(x.ERROR, {
        type: be.OTHER_ERROR,
        details: q.ATTACH_MEDIA_ERROR,
        fatal: !0,
        error: s
      });
      return;
    }
    this.logger.log("attachMedia"), this._media && (this.logger.warn("media must be detached before attaching"), this.detachMedia());
    const n = "media" in e, r = n ? e.media : e, i = n ? e : {
      media: r
    };
    this._media = r, this.trigger(x.MEDIA_ATTACHING, i);
  }
  /**
   * Detach Hls.js from the media
   */
  detachMedia() {
    this.logger.log("detachMedia"), this.trigger(x.MEDIA_DETACHING, {}), this._media = null;
  }
  /**
   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance
   */
  transferMedia() {
    this._media = null;
    const e = this.bufferController.transferMedia();
    return this.trigger(x.MEDIA_DETACHING, {
      transferMedia: e
    }), e;
  }
  /**
   * Set the source URL. Can be relative or absolute.
   */
  loadSource(e) {
    this.stopLoad();
    const n = this.media, r = this._url, i = this._url = Mh.buildAbsoluteURL(self.location.href, e, {
      alwaysNormalize: !0
    });
    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${i}`), n && r && (r !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(n)), this.trigger(x.MANIFEST_LOADING, {
      url: e
    });
  }
  /**
   * Gets the currently loaded URL
   */
  get url() {
    return this._url;
  }
  /**
   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position
   */
  get hasEnoughToStart() {
    return this.streamController.hasEnoughToStart;
  }
  /**
   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition
   */
  get startPosition() {
    return this.streamController.startPositionValue;
  }
  /**
   * Start loading data from the stream source.
   * Depending on default config, client starts loading automatically when a source is set.
   *
   * @param startPosition - Set the start position to stream from.
   * Defaults to -1 (None: starts from earliest point)
   */
  startLoad(e = -1, n) {
    this.logger.log(`startLoad(${e + (n ? ", <skip seek to start>" : "")})`), this.started = !0, this.resumeBuffering();
    for (let r = 0; r < this.networkControllers.length && (this.networkControllers[r].startLoad(e, n), !(!this.started || !this.networkControllers)); r++)
      ;
  }
  /**
   * Stop loading of any stream data.
   */
  stopLoad() {
    this.logger.log("stopLoad"), this.started = !1;
    for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++)
      ;
  }
  /**
   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.
   */
  get loadingEnabled() {
    return this.started;
  }
  /**
   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.
   */
  get bufferingEnabled() {
    return this.streamController.bufferingEnabled;
  }
  /**
   * Resumes stream controller segment loading after `pauseBuffering` has been called.
   */
  resumeBuffering() {
    this.bufferingEnabled || (this.logger.log("resume buffering"), this.networkControllers.forEach((e) => {
      e.resumeBuffering && e.resumeBuffering();
    }));
  }
  /**
   * Prevents stream controller from loading new segments until `resumeBuffering` is called.
   * This allows for media buffering to be paused without interupting playlist loading.
   */
  pauseBuffering() {
    this.bufferingEnabled && (this.logger.log("pause buffering"), this.networkControllers.forEach((e) => {
      e.pauseBuffering && e.pauseBuffering();
    }));
  }
  get inFlightFragments() {
    const e = {
      [pe.MAIN]: this.streamController.inFlightFrag
    };
    return this.audioStreamController && (e[pe.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController && (e[pe.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;
  }
  /**
   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)
   */
  swapAudioCodec() {
    this.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec();
  }
  /**
   * When the media-element fails, this allows to detach and then re-attach it
   * as one call (convenience method).
   *
   * Automatic recovery of media-errors by this process is configurable.
   */
  recoverMediaError() {
    this.logger.log("recoverMediaError");
    const e = this._media, n = e == null ? void 0 : e.currentTime;
    this.detachMedia(), e && (this.attachMedia(e), n && this.startLoad(n));
  }
  removeLevel(e) {
    this.levelController.removeLevel(e);
  }
  /**
   * @returns a UUID for this player instance
   */
  get sessionId() {
    let e = this._sessionId;
    return e || (e = this._sessionId = jU()), e;
  }
  /**
   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH
   */
  get levels() {
    const e = this.levelController.levels;
    return e || [];
  }
  /**
   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.
   */
  get latestLevelDetails() {
    return this.streamController.getLevelDetails() || null;
  }
  /**
   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.
   */
  get loadLevelObj() {
    return this.levelController.loadLevelObj;
  }
  /**
   * Index of quality level (variant) currently played
   */
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  /**
   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.
   */
  set currentLevel(e) {
    this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();
  }
  /**
   * Index of next quality level loaded as scheduled by stream controller.
   */
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  /**
   * Set quality level index for next loaded data.
   * This will switch the video quality asap, without interrupting playback.
   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).
   * @param newLevel - Pass -1 for automatic level selection
   */
  set nextLevel(e) {
    this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();
  }
  /**
   * Return the quality level of the currently or last (of none is loaded currently) segment
   */
  get loadLevel() {
    return this.levelController.level;
  }
  /**
   * Set quality level index for next loaded data in a conservative way.
   * This will switch the quality without flushing, but interrupt current loading.
   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.
   * @param newLevel - Pass -1 for automatic level selection
   */
  set loadLevel(e) {
    this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;
  }
  /**
   * get next quality level loaded
   */
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  /**
   * Set quality level of next loaded segment in a fully "non-destructive" way.
   * Same as `loadLevel` but will wait for next switch (until current loading is done).
   */
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e;
  }
  /**
   * Return "first level": like a default level, if not set,
   * falls back to index of first level referenced in manifest
   */
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  /**
   * Sets "first-level", see getter.
   */
  set firstLevel(e) {
    this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;
  }
  /**
   * Return the desired start level for the first fragment that will be loaded.
   * The default value of -1 indicates automatic start level selection.
   * Setting hls.nextAutoLevel without setting a startLevel will result in
   * the nextAutoLevel value being used for one fragment load.
   */
  get startLevel() {
    const e = this.levelController.startLevel;
    return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;
  }
  /**
   * set  start level (level of first fragment that will be played back)
   * if not overrided by user, first level appearing in manifest will be used as start level
   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
   * (determined from download of first segment)
   */
  set startLevel(e) {
    this.logger.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;
  }
  /**
   * Whether level capping is enabled.
   * Default value is set via `config.capLevelToPlayerSize`.
   */
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  /**
   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.
   */
  set capLevelToPlayerSize(e) {
    const n = !!e;
    n !== this.config.capLevelToPlayerSize && (n ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = n);
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  /**
   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.
   */
  get bandwidthEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimate() : NaN;
  }
  set bandwidthEstimate(e) {
    this.abrController.resetEstimator(e);
  }
  get abrEwmaDefaultEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.defaultEstimate : NaN;
  }
  /**
   * get time to first byte estimate
   * @type {number}
   */
  get ttfbEstimate() {
    const {
      bwEstimator: e
    } = this.abrController;
    return e ? e.getEstimateTTFB() : NaN;
  }
  /**
   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
   */
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(e) {
    GB(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());
  }
  /**
   * True when automatic level selection enabled
   */
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  /**
   * Level set manually (if any)
   */
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  /**
   * min level selectable in auto mode according to config.minAutoBitrate
   */
  get minAutoLevel() {
    const {
      levels: e,
      config: {
        minAutoBitrate: n
      }
    } = this;
    if (!e) return 0;
    const r = e.length;
    for (let i = 0; i < r; i++)
      if (e[i].maxBitrate >= n)
        return i;
    return 0;
  }
  /**
   * max level selectable in auto mode according to autoLevelCapping
   */
  get maxAutoLevel() {
    const {
      levels: e,
      autoLevelCapping: n,
      maxHdcpLevel: r
    } = this;
    let i;
    if (n === -1 && e != null && e.length ? i = e.length - 1 : i = n, r)
      for (let s = i; s--; ) {
        const a = e[s].attrs["HDCP-LEVEL"];
        if (a && a <= r)
          return s;
      }
    return i;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  /**
   * next automatically selected quality level
   */
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  /**
   * this setter is used to force next auto level.
   * this is useful to force a switch down in auto mode:
   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
   * forced value is valid for one fragment. upon successful frag loading at forced level,
   * this value will be resetted to -1 by ABR controller.
   */
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = e;
  }
  /**
   * get the datetime value relative to media.currentTime for the active level Program Date Time if present
   */
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  get maxBufferLength() {
    return this.streamController.maxBufferLength;
  }
  /**
   * Find and select the best matching audio track, making a level switch when a Group change is necessary.
   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.
   */
  setAudioOption(e) {
    var n;
    return ((n = this.audioTrackController) == null ? void 0 : n.setAudioOption(e)) || null;
  }
  /**
   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.
   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.
   */
  setSubtitleOption(e) {
    var n;
    return ((n = this.subtitleTrackController) == null ? void 0 : n.setSubtitleOption(e)) || null;
  }
  /**
   * Get the complete list of audio tracks across all media groups
   */
  get allAudioTracks() {
    const e = this.audioTrackController;
    return e ? e.allAudioTracks : [];
  }
  /**
   * Get the list of selectable audio tracks
   */
  get audioTracks() {
    const e = this.audioTrackController;
    return e ? e.audioTracks : [];
  }
  /**
   * index of the selected audio track (index in audio track lists)
   */
  get audioTrack() {
    const e = this.audioTrackController;
    return e ? e.audioTrack : -1;
  }
  /**
   * selects an audio track, based on its index in audio track lists
   */
  set audioTrack(e) {
    const n = this.audioTrackController;
    n && (n.audioTrack = e);
  }
  /**
   * get the complete list of subtitle tracks across all media groups
   */
  get allSubtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.allSubtitleTracks : [];
  }
  /**
   * get alternate subtitle tracks list from playlist
   */
  get subtitleTracks() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTracks : [];
  }
  /**
   * index of the selected subtitle track (index in subtitle track lists)
   */
  get subtitleTrack() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  /**
   * select an subtitle track, based on its index in subtitle track lists
   */
  set subtitleTrack(e) {
    const n = this.subtitleTrackController;
    n && (n.subtitleTrack = e);
  }
  /**
   * Whether subtitle display is enabled or not
   */
  get subtitleDisplay() {
    const e = this.subtitleTrackController;
    return e ? e.subtitleDisplay : !1;
  }
  /**
   * Enable/disable subtitle display rendering
   */
  set subtitleDisplay(e) {
    const n = this.subtitleTrackController;
    n && (n.subtitleDisplay = e);
  }
  /**
   * get mode for Low-Latency HLS loading
   */
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  /**
   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.
   */
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e;
  }
  /**
   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)
   * @returns null prior to loading live Playlist
   */
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  /**
   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)
   * @returns 0 before first playlist is loaded
   */
  get latency() {
    return this.latencyController.latency;
  }
  /**
   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```
   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```
   * @returns 0 before first playlist is loaded
   */
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  /**
   * target distance from the edge as calculated by the latency controller
   */
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  set targetLatency(e) {
    this.latencyController.targetLatency = e;
  }
  /**
   * the rate at which the edge of the current live playlist is advancing or 1 if there is none
   */
  get drift() {
    return this.latencyController.drift;
  }
  /**
   * set to true when startLoad is called before MANIFEST_PARSED event
   */
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
  /**
   * ContentSteering pathways getter
   */
  get pathways() {
    return this.levelController.pathways;
  }
  /**
   * ContentSteering pathwayPriority getter/setter
   */
  get pathwayPriority() {
    return this.levelController.pathwayPriority;
  }
  set pathwayPriority(e) {
    this.levelController.pathwayPriority = e;
  }
  /**
   * returns true when all SourceBuffers are buffered to the end
   */
  get bufferedToEnd() {
    var e;
    return !!((e = this.bufferController) != null && e.bufferedToEnd);
  }
  /**
   * returns Interstitials Program Manager
   */
  get interstitialsManager() {
    var e;
    return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;
  }
  /**
   * returns mediaCapabilities.decodingInfo for a variant/rendition
   */
  getMediaDecodingInfo(e, n = this.allAudioTracks) {
    const r = gx(n);
    return mx(e, r, navigator.mediaCapabilities);
  }
}
Rt.defaultConfig = void 0;
const sH = (t, e = "200,", n = "full") => {
  Array.isArray(t) && (t = t[0]);
  const { id: r, service: i } = t;
  let s;
  if (!i) return r;
  if (Array.isArray(t.service) && t.service.length > 0 && (s = i[0]), s) {
    if (s["@id"])
      return `${s["@id"]}/${n}/${e}/0/default.jpg`;
    if (s.id)
      return `${s.id}/${n}/${e}/0/default.jpg`;
  }
}, r1 = le("img", { objectFit: "cover" }), aH = (t) => {
  const e = ms(null), { contentResource: n, altAsLabel: r, region: i = "full" } = t;
  let s;
  r && (s = fn(r));
  const o = Qn(t, ["contentResource", "altAsLabel"]), { type: u, id: l, width: c = 200, height: d = 200, duration: f } = n;
  Se(() => {
    if (!l && !e.current || ["Image"].includes(u) || !l.includes("m3u8")) return;
    const p = new Rt();
    return e.current && (p.attachMedia(e.current), p.on(Rt.Events.MEDIA_ATTACHED, function() {
      p.loadSource(l);
    })), p.on(Rt.Events.ERROR, function(g, b) {
      if (b.fatal)
        switch (b.type) {
          case Rt.ErrorTypes.NETWORK_ERROR:
            console.error(
              `fatal ${g} network error encountered, try to recover`
            ), p.startLoad();
            break;
          case Rt.ErrorTypes.MEDIA_ERROR:
            console.error(
              `fatal ${g} media error encountered, try to recover`
            ), p.recoverMediaError();
            break;
          default:
            p.destroy();
            break;
        }
    }), () => {
      p && (p.detachMedia(), p.destroy());
    };
  }, [l, u]);
  const h = yt(() => {
    if (!e.current) return;
    let p = 0, g = 30;
    if (f && (g = f), !l.split("#t=") && f && (p = f * 0.1), l.split("#t=").pop()) {
      const y = l.split("#t=").pop();
      y && (p = parseInt(y.split(",")[0]));
    }
    const b = e.current;
    b.autoplay = !0, b.currentTime = p, setTimeout(() => h(), g * 1e3);
  }, [f, l]);
  Se(() => h(), [h]);
  const m = sH(
    n,
    `${c},${d}`,
    i
  );
  switch (u) {
    case "Image":
      return /* @__PURE__ */ v.createElement(
        r1,
        {
          as: "img",
          alt: s,
          css: { width: c, height: d },
          key: l,
          src: m,
          ...o
        }
      );
    case "Video":
      return /* @__PURE__ */ v.createElement(
        r1,
        {
          as: "video",
          css: { width: c, height: d },
          disablePictureInPicture: !0,
          key: l,
          loop: !0,
          muted: !0,
          onPause: h,
          ref: e,
          src: l
        }
      );
    default:
      return console.warn(
        `Resource type: ${u} is not valid or not yet supported in Primitives.`
      ), /* @__PURE__ */ v.createElement(v.Fragment, null);
  }
}, oH = le("a", {}), uH = (t) => {
  const { children: e, homepage: n } = t, i = Qn(t, ["children", "homepage"]);
  return /* @__PURE__ */ v.createElement(v.Fragment, null, n && n.map((s) => {
    const a = fn(
      s.label,
      i.lang
    );
    return /* @__PURE__ */ v.createElement(
      oH,
      {
        "aria-label": e ? a : void 0,
        href: s.id,
        key: s.id,
        ...i
      },
      e || a
    );
  }));
}, lH = {
  delimiter: ", "
}, a0 = du(void 0), kv = () => {
  const t = z1(a0);
  if (t === void 0)
    throw new Error(
      "usePrimitivesContext must be used with a PrimitivesProvider"
    );
  return t;
}, o0 = ({
  children: t,
  initialState: e = lH
}) => {
  const n = cH(e, "delimiter");
  return /* @__PURE__ */ v.createElement(a0.Provider, { value: { delimiter: n } }, t);
}, cH = (t, e) => Object.hasOwn(t, e) ? t[e].toString() : void 0, dH = le("span", {}), i1 = (t) => {
  const { as: e, markup: n } = t, { delimiter: r } = kv();
  if (!n) return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const s = Qn(t, ["as", "markup"]), a = JF(
    fn(n, s.lang, r)
  );
  return /* @__PURE__ */ v.createElement(dH, { as: e, ...s, dangerouslySetInnerHTML: a });
}, Dv = (t) => v.useContext(a0) ? /* @__PURE__ */ v.createElement(i1, { ...t }) : /* @__PURE__ */ v.createElement(o0, null, /* @__PURE__ */ v.createElement(i1, { ...t })), fH = ({ as: t = "dd", lang: e, value: n }) => /* @__PURE__ */ v.createElement(Dv, { markup: n, as: t, lang: e }), hH = le("span", {}), mH = ({
  as: t = "dd",
  customValueContent: e,
  lang: n,
  value: r
}) => {
  var a;
  const { delimiter: i } = kv(), s = (a = GT(r, n)) == null ? void 0 : a.map((o) => Af(e, {
    value: o
  }));
  return /* @__PURE__ */ v.createElement(hH, { as: t, lang: n }, s == null ? void 0 : s.map((o, u) => [
    u > 0 && `${i}`,
    /* @__PURE__ */ v.createElement(q1, { key: u }, o)
  ]));
}, Pv = (t) => {
  var o;
  const { item: e, lang: n, customValueContent: r } = t, { label: i, value: s } = e, a = (o = fn(i)) == null ? void 0 : o.replace(" ", "-").toLowerCase();
  return /* @__PURE__ */ v.createElement("div", { role: "group", "data-label": a }, /* @__PURE__ */ v.createElement(yr, { as: "dt", label: i, lang: n }), r ? /* @__PURE__ */ v.createElement(
    mH,
    {
      as: "dd",
      customValueContent: r,
      value: s,
      lang: n
    }
  ) : /* @__PURE__ */ v.createElement(fH, { as: "dd", value: s, lang: n }));
};
function pH(t, e) {
  const n = e.filter((r) => {
    const { matchingLabel: i } = r, s = Object.keys(r.matchingLabel)[0], a = fn(i, s);
    if (fn(t, s) === a) return !0;
  }).map((r) => r.Content);
  if (Array.isArray(n))
    return n[0];
}
const gH = le("dl", {}), bH = (t) => {
  const { as: e, customValueContent: n, metadata: r } = t;
  if (!Array.isArray(r)) return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const i = Q1(t, "customValueDelimiter"), a = Qn(t, [
    "as",
    "customValueContent",
    "customValueDelimiter",
    "metadata"
  ]);
  return /* @__PURE__ */ v.createElement(
    o0,
    {
      ...typeof i == "string" ? { initialState: { delimiter: i } } : void 0
    },
    r.length > 0 && /* @__PURE__ */ v.createElement(gH, { as: e, ...a }, r.map((o, u) => {
      const l = n ? pH(o.label, n) : void 0;
      return /* @__PURE__ */ v.createElement(
        Pv,
        {
          customValueContent: l,
          item: o,
          key: u,
          lang: a == null ? void 0 : a.lang
        }
      );
    }))
  );
};
le("li", {});
le("ul", {});
const EH = le("li", {}), yH = le("ul", {}), TH = (t) => {
  const { as: e, rendering: n } = t, i = Qn(t, ["as", "rendering"]);
  return /* @__PURE__ */ v.createElement(yH, { as: e }, n && n.map((s) => {
    const a = fn(
      s.label,
      i.lang
    );
    return /* @__PURE__ */ v.createElement(EH, { key: s.id }, /* @__PURE__ */ v.createElement("a", { href: s.id, ...i, target: "_blank" }, a || s.id));
  }));
}, SH = le("dl", {}), xH = (t) => {
  const { as: e, requiredStatement: n } = t;
  if (!n) return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const r = Q1(t, "customValueDelimiter"), s = Qn(t, ["as", "customValueDelimiter", "requiredStatement"]);
  return /* @__PURE__ */ v.createElement(
    o0,
    {
      ...typeof r == "string" ? { initialState: { delimiter: r } } : void 0
    },
    /* @__PURE__ */ v.createElement(SH, { as: e, ...s }, /* @__PURE__ */ v.createElement(Pv, { item: n, lang: s.lang }))
  );
}, vH = le("li", {}), AH = le("ul", {}), IH = (t) => {
  const { as: e, seeAlso: n } = t, i = Qn(t, ["as", "seeAlso"]);
  return /* @__PURE__ */ v.createElement(AH, { as: e }, n && n.map((s) => {
    const a = fn(
      s.label,
      i.lang
    );
    return /* @__PURE__ */ v.createElement(vH, { key: s.id }, /* @__PURE__ */ v.createElement("a", { href: s.id, ...i }, a || s.id));
  }));
}, CH = (t) => {
  const { as: e, summary: n } = t, i = Qn(t, ["as", "customValueDelimiter", "summary"]);
  return /* @__PURE__ */ v.createElement(Dv, { as: e, markup: n, ...i });
}, Ov = (t) => {
  const { thumbnail: e, region: n } = t, i = Qn(t, ["thumbnail"]);
  return /* @__PURE__ */ v.createElement(v.Fragment, null, e && e.map((s) => /* @__PURE__ */ v.createElement(
    aH,
    {
      contentResource: s,
      key: s.id,
      region: n,
      ...i
    }
  )));
}, LH = ({ annotationPage: t }) => {
  var u, l, c, d, f, h;
  const e = st(), { vault: n } = e;
  if (!t || !t.items || ((u = t.items) == null ? void 0 : u.length) === 0)
    return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const r = t.items.map((m) => n.get(m.id));
  if (!r) return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const i = r.reduce((m, p) => (m.canvas = p.target.source.id, m.annotations = [], m.annotations.push(p == null ? void 0 : p.id), m), {}), s = n.get(i.canvas), a = Dr(n, s.id), o = (l = a == null ? void 0 : a[0]) != null && l.service ? ((d = (c = a == null ? void 0 : a[0]) == null ? void 0 : c.service[0]) == null ? void 0 : d.id) || ((h = (f = a == null ? void 0 : a[0]) == null ? void 0 : f.service[0]) == null ? void 0 : h["@id"]) : void 0;
  return /* @__PURE__ */ v.createElement(Mf, { "data-testid": "annotation-page" }, s && /* @__PURE__ */ v.createElement("header", null, /* @__PURE__ */ v.createElement(yr, { label: s.label })), /* @__PURE__ */ v.createElement("div", { "data-testid": "annotation-page-items" }, r == null ? void 0 : r.map((m) => /* @__PURE__ */ v.createElement(
    ph,
    {
      annotation: m,
      targetResource: o,
      key: m.id
    }
  ))));
};
function hr() {
  return hr = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, hr.apply(null, arguments);
}
function oa(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (t == null || t(i), n === !1 || !i.defaultPrevented) return e == null ? void 0 : e(i);
  };
}
function _H(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function Nv(...t) {
  return (e) => t.forEach(
    (n) => _H(n, e)
  );
}
function Mv(...t) {
  return yt(Nv(...t), t);
}
function RH(t, e = []) {
  let n = [];
  function r(s, a) {
    const o = /* @__PURE__ */ du(a), u = n.length;
    n = [
      ...n,
      a
    ];
    function l(d) {
      const { scope: f, children: h, ...m } = d, p = (f == null ? void 0 : f[t][u]) || o, g = fu(
        () => m,
        Object.values(m)
      );
      return /* @__PURE__ */ qt(p.Provider, {
        value: g
      }, h);
    }
    function c(d, f) {
      const h = (f == null ? void 0 : f[t][u]) || o, m = z1(h);
      if (m) return m;
      if (a !== void 0) return a;
      throw new Error(`\`${d}\` must be used within \`${s}\``);
    }
    return l.displayName = s + "Provider", [
      l,
      c
    ];
  }
  const i = () => {
    const s = n.map((a) => /* @__PURE__ */ du(a));
    return function(o) {
      const u = (o == null ? void 0 : o[t]) || s;
      return fu(
        () => ({
          [`__scope${t}`]: {
            ...o,
            [t]: u
          }
        }),
        [
          o,
          u
        ]
      );
    };
  };
  return i.scopeName = t, [
    r,
    wH(i, ...e)
  ];
}
function wH(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(s) {
      const a = r.reduce((o, { useScope: u, scopeName: l }) => {
        const d = u(s)[`__scope${l}`];
        return {
          ...o,
          ...d
        };
      }, {});
      return fu(
        () => ({
          [`__scope${e.scopeName}`]: a
        }),
        [
          a
        ]
      );
    };
  };
  return n.scopeName = e.scopeName, n;
}
const kH = globalThis != null && globalThis.document ? W1 : () => {
}, DH = M.useId || (() => {
});
let PH = 0;
function OH(t) {
  const [e, n] = M.useState(DH());
  return kH(() => {
    n(
      (r) => r ?? String(PH++)
    );
  }, [
    t
  ]), e ? `radix-${e}` : "";
}
const Fv = /* @__PURE__ */ ci((t, e) => {
  const { children: n, ...r } = t, i = Ys.toArray(n), s = i.find(MH);
  if (s) {
    const a = s.props.children, o = i.map((u) => u === s ? Ys.count(a) > 1 ? Ys.only(null) : /* @__PURE__ */ hu(a) ? a.props.children : null : u);
    return /* @__PURE__ */ qt(df, hr({}, r, {
      ref: e
    }), /* @__PURE__ */ hu(a) ? /* @__PURE__ */ Af(a, void 0, o) : null);
  }
  return /* @__PURE__ */ qt(df, hr({}, r, {
    ref: e
  }), n);
});
Fv.displayName = "Slot";
const df = /* @__PURE__ */ ci((t, e) => {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ hu(n) ? /* @__PURE__ */ Af(n, {
    ...FH(r, n.props),
    ref: e ? Nv(e, n.ref) : n.ref
  }) : Ys.count(n) > 1 ? Ys.only(null) : null;
});
df.displayName = "SlotClone";
const NH = ({ children: t }) => /* @__PURE__ */ qt(q1, null, t);
function MH(t) {
  return /* @__PURE__ */ hu(t) && t.type === NH;
}
function FH(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const i = t[r], s = e[r];
    /^on[A-Z]/.test(r) ? i && s ? n[r] = (...o) => {
      s(...o), i(...o);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...s
    } : r === "className" && (n[r] = [
      i,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...t,
    ...n
  };
}
const BH = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Cl = BH.reduce((t, e) => {
  const n = /* @__PURE__ */ ci((r, i) => {
    const { asChild: s, ...a } = r, o = s ? Fv : e;
    return Se(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ qt(o, hr({}, a, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${e}`, {
    ...t,
    [e]: n
  };
}, {}), [u0] = RH("Form"), Bv = "Form", [$H, $v] = u0(Bv), [UH, HH] = u0(Bv), VH = /* @__PURE__ */ ci((t, e) => {
  const { __scopeForm: n, onClearServerErrors: r = () => {
  }, ...i } = t, s = ms(null), a = Mv(e, s), [o, u] = Be({}), l = yt(
    (A) => o[A],
    [
      o
    ]
  ), c = yt(
    (A, L) => u((P) => {
      var $;
      return {
        ...P,
        [A]: {
          ...($ = P[A]) !== null && $ !== void 0 ? $ : {},
          ...L
        }
      };
    }),
    []
  ), d = yt((A) => {
    u(
      (L) => ({
        ...L,
        [A]: void 0
      })
    ), y(
      (L) => ({
        ...L,
        [A]: {}
      })
    );
  }, []), [f, h] = Be({}), m = yt((A) => {
    var L;
    return (L = f[A]) !== null && L !== void 0 ? L : [];
  }, [
    f
  ]), p = yt((A, L) => {
    h((P) => {
      var $;
      return {
        ...P,
        [A]: [
          ...($ = P[A]) !== null && $ !== void 0 ? $ : [],
          L
        ]
      };
    });
  }, []), g = yt((A, L) => {
    h((P) => {
      var $;
      return {
        ...P,
        [A]: (($ = P[A]) !== null && $ !== void 0 ? $ : []).filter(
          (G) => G.id !== L
        )
      };
    });
  }, []), [b, y] = Be({}), T = yt((A) => {
    var L;
    return (L = b[A]) !== null && L !== void 0 ? L : {};
  }, [
    b
  ]), S = yt((A, L) => {
    y((P) => {
      var $;
      return {
        ...P,
        [A]: {
          ...($ = P[A]) !== null && $ !== void 0 ? $ : {},
          ...L
        }
      };
    });
  }, []), [I, C] = Be({}), _ = yt((A, L) => {
    C((P) => {
      const $ = new Set(P[A]).add(L);
      return {
        ...P,
        [A]: $
      };
    });
  }, []), R = yt((A, L) => {
    C((P) => {
      const $ = new Set(P[A]);
      return $.delete(L), {
        ...P,
        [A]: $
      };
    });
  }, []), k = yt((A) => {
    var L;
    return Array.from((L = I[A]) !== null && L !== void 0 ? L : []).join(" ") || void 0;
  }, [
    I
  ]);
  return /* @__PURE__ */ qt($H, {
    scope: n,
    getFieldValidity: l,
    onFieldValidityChange: c,
    getFieldCustomMatcherEntries: m,
    onFieldCustomMatcherEntryAdd: p,
    onFieldCustomMatcherEntryRemove: g,
    getFieldCustomErrors: T,
    onFieldCustomErrorsChange: S,
    onFieldValiditionClear: d
  }, /* @__PURE__ */ qt(UH, {
    scope: n,
    onFieldMessageIdAdd: _,
    onFieldMessageIdRemove: R,
    getFieldDescription: k
  }, /* @__PURE__ */ qt(Cl.form, hr({}, i, {
    ref: a,
    onInvalid: oa(t.onInvalid, (A) => {
      const L = Hv(A.currentTarget);
      L === A.target && L.focus(), A.preventDefault();
    }),
    onSubmit: oa(t.onSubmit, r, {
      checkForDefaultPrevented: !1
    }),
    onReset: oa(t.onReset, r)
  }))));
}), Uv = "FormField", [GH, zH] = u0(Uv), qH = /* @__PURE__ */ ci((t, e) => {
  const { __scopeForm: n, name: r, serverInvalid: i = !1, ...s } = t, o = $v(Uv, n).getFieldValidity(r), u = OH();
  return /* @__PURE__ */ qt(GH, {
    scope: n,
    id: u,
    name: r,
    serverInvalid: i
  }, /* @__PURE__ */ qt(Cl.div, hr({
    "data-valid": Vv(o, i),
    "data-invalid": Gv(o, i)
  }, s, {
    ref: e
  })));
}), $c = "FormControl", WH = /* @__PURE__ */ ci((t, e) => {
  const { __scopeForm: n, ...r } = t, i = $v($c, n), s = zH($c, n), a = HH($c, n), o = ms(null), u = Mv(e, o), l = r.name || s.name, c = r.id || s.id, d = i.getFieldCustomMatcherEntries(l), { onFieldValidityChange: f, onFieldCustomErrorsChange: h, onFieldValiditionClear: m } = i, p = yt(async (y) => {
    if (eV(y.validity)) {
      const P = Uc(y.validity);
      f(l, P);
      return;
    }
    const T = y.form ? new FormData(y.form) : new FormData(), S = [
      y.value,
      T
    ], I = [], C = [];
    d.forEach((P) => {
      QH(P, S) ? C.push(P) : ZH(P) && I.push(P);
    });
    const _ = I.map(({ id: P, match: $ }) => [
      P,
      $(...S)
    ]), R = Object.fromEntries(_), k = Object.values(R).some(Boolean), A = k;
    y.setCustomValidity(A ? s1 : "");
    const L = Uc(y.validity);
    if (f(l, L), h(l, R), !k && C.length > 0) {
      const P = C.map(
        ({ id: V, match: K }) => K(...S).then(
          (w) => [
            V,
            w
          ]
        )
      ), $ = await Promise.all(P), G = Object.fromEntries($), U = Object.values(G).some(Boolean);
      y.setCustomValidity(U ? s1 : "");
      const B = Uc(y.validity);
      f(l, B), h(l, G);
    }
  }, [
    d,
    l,
    h,
    f
  ]);
  Se(() => {
    const y = o.current;
    if (y) {
      const T = () => p(y);
      return y.addEventListener("change", T), () => y.removeEventListener("change", T);
    }
  }, [
    p
  ]);
  const g = yt(() => {
    const y = o.current;
    y && (y.setCustomValidity(""), m(l));
  }, [
    l,
    m
  ]);
  Se(() => {
    var y;
    const T = (y = o.current) === null || y === void 0 ? void 0 : y.form;
    if (T)
      return T.addEventListener("reset", g), () => T.removeEventListener("reset", g);
  }, [
    g
  ]), Se(() => {
    const y = o.current, T = y == null ? void 0 : y.closest("form");
    if (T && s.serverInvalid) {
      const S = Hv(T);
      S === y && S.focus();
    }
  }, [
    s.serverInvalid
  ]);
  const b = i.getFieldValidity(l);
  return /* @__PURE__ */ qt(Cl.input, hr({
    "data-valid": Vv(b, s.serverInvalid),
    "data-invalid": Gv(b, s.serverInvalid),
    "aria-invalid": s.serverInvalid ? !0 : void 0,
    "aria-describedby": a.getFieldDescription(l),
    title: ""
  }, r, {
    ref: u,
    id: c,
    name: l,
    onInvalid: oa(t.onInvalid, (y) => {
      const T = y.currentTarget;
      p(T);
    }),
    onChange: oa(t.onChange, (y) => {
      g();
    })
  }));
}), s1 = "This value is not valid", KH = /* @__PURE__ */ ci((t, e) => {
  const { __scopeForm: n, ...r } = t;
  return /* @__PURE__ */ qt(Cl.button, hr({
    type: "submit"
  }, r, {
    ref: e
  }));
});
function Uc(t) {
  const e = {};
  for (const n in t) e[n] = t[n];
  return e;
}
function jH(t) {
  return t instanceof HTMLElement;
}
function YH(t) {
  return "validity" in t;
}
function XH(t) {
  return YH(t) && (t.validity.valid === !1 || t.getAttribute("aria-invalid") === "true");
}
function Hv(t) {
  const e = t.elements, [n] = Array.from(e).filter(jH).filter(XH);
  return n;
}
function QH(t, e) {
  return t.match.constructor.name === "AsyncFunction" || JH(t.match, e);
}
function ZH(t) {
  return t.match.constructor.name === "Function";
}
function JH(t, e) {
  return t(...e) instanceof Promise;
}
function eV(t) {
  let e = !1;
  for (const n in t) {
    const r = n;
    if (r !== "valid" && r !== "customError" && t[r]) {
      e = !0;
      break;
    }
  }
  return e;
}
function Vv(t, e) {
  if ((t == null ? void 0 : t.valid) === !0 && !e) return !0;
}
function Gv(t, e) {
  if ((t == null ? void 0 : t.valid) === !1 || e) return !0;
}
const tV = VH, nV = qH, rV = WH, iV = KH, sV = le("div", {
  form: {
    display: "flex",
    alignItems: "center",
    width: "100%",
    height: "100%",
    gap: "1rem",
    padding: "0 1.618rem 1.618rem",
    ".content-search-input": {
      flexGrow: "1",
      input: {
        width: "100%",
        border: "none",
        backgroundColor: "$secondaryMuted",
        color: "$primary",
        marginRight: "1rem",
        height: "2rem",
        padding: "0 1rem",
        borderRadius: "1rem",
        fontFamily: "inherit",
        fontSize: "1rem",
        lineHeight: "1rem",
        boxShadow: "inset 1px 1px 2px #0001",
        "&::placeholder": {
          color: "#0006"
        }
      }
    }
  }
}), aV = le("button", {
  display: "flex",
  background: "none",
  border: "none",
  width: "2rem",
  height: "2rem",
  padding: "0",
  margin: "0",
  fontWeight: "700",
  borderRadius: "2rem",
  backgroundColor: "$accent",
  color: "$secondary",
  cursor: "pointer",
  boxSizing: "content-box",
  transition: "$all",
  svg: {
    height: "60%",
    width: "60%",
    padding: "20%",
    fill: "$secondary",
    stroke: "$secondary",
    opacity: "1",
    filter: "drop-shadow(5px 5px 5px #000D)",
    boxSizing: "inherit",
    transition: "$all"
  },
  "&:disabled": {
    backgroundColor: "transparent",
    boxShadow: "none",
    svg: { opacity: "0.25" }
  }
}), oV = "Close", uV = "Next", lV = "Open", cV = "Previous", dV = "Search", fV = "Search...", hV = "Share", mV = "View All", pV = "Failed", gV = "Copied", bV = "Loading...", EV = "Search", yV = "No Results", TV = "More Results", SV = "Full screen", xV = "Reset zoom", vV = "Rotate left", AV = "Rotate right", IV = "Zoom in", CV = "Zoom out", LV = "Select", _V = "Viewer", RV = "About", wV = "Annotations", kV = "Search", DV = "More Information", PV = "View Collection", OV = "Copy Collection URL", NV = "View Manifest", MV = "Copy Manifest URL", zv = {
  commonClose: oV,
  commonNext: uV,
  commonOpen: lV,
  commonPrevious: cV,
  commonSearch: dV,
  commonSearchPlaceholder: fV,
  commonShare: hV,
  commonViewAll: mV,
  copyFailure: pV,
  copySuccess: gV,
  contentSearchLoading: bV,
  contentSearchPlaceholder: EV,
  contentSearchResultsNone: yV,
  contentSearchResultsMore: TV,
  imageFullScreen: SV,
  imageResetZoom: xV,
  imageRotateLeft: vV,
  imageRotateRight: AV,
  imageZoomIn: IV,
  imageZoomOut: CV,
  informationPanelTabs: LV,
  informationPanelTabsClose: _V,
  informationPanelTabsAbout: RV,
  informationPanelTabsAnnotations: wV,
  informationPanelTabsSearch: kV,
  informationPanelToggle: DV,
  shareCollectionJson: PV,
  shareCollectionCopy: OV,
  shareManifestJson: NV,
  shareManifestCopy: MV
}, FV = "Sulje", BV = "Seuraava", $V = "Edellinen", UV = "Hae", HV = "Hae...", VV = "Jaa", GV = "Nyt kaikki", zV = "Kopiointi eponnistui", qV = "Kopioitu", WV = "Ladataan...", KV = "Haku", jV = "Ei osumia", YV = "Lis osumia", XV = "Valitse", QV = "Katselu", ZV = "Tiedot", JV = "Annotaatiot", eG = "Haku", tG = "Listiedot", nG = "Nyt kokoelma", rG = "Kopioi kokoelman osoite", iG = "Nyt manifesti", sG = "Kopioi manifestin osoite", aG = {
  commonClose: FV,
  commonNext: BV,
  commonPrevious: $V,
  commonSearch: UV,
  commonSearchPlaceholder: HV,
  commonShare: VV,
  commonViewAll: GV,
  copyFailure: zV,
  copySuccess: qV,
  contentSearchLoading: WV,
  contentSearchPlaceholder: KV,
  contentSearchResultsNone: jV,
  contentSearchResultsMore: YV,
  informationPanelTabs: XV,
  informationPanelTabsClose: QV,
  informationPanelTabsAbout: ZV,
  informationPanelTabsAnnotations: JV,
  informationPanelTabsSearch: eG,
  informationPanelToggle: tG,
  shareCollectionJson: nG,
  shareCollectionCopy: rG,
  shareManifestJson: iG,
  shareManifestCopy: sG
}, oG = "Fermer", uG = "Suivant", lG = "Ouvrir", cG = "Prcdent", dG = "Rechercher", fG = "Rechercher", hG = "Partager", mG = "Tout afficher", pG = "chec", gG = "Copi", bG = "Chargement", EG = "Rechercher", yG = "Aucun rsultat", TG = "Plus de rsultats", SG = "Plein cran", xG = "Rinitialiser le zoom", vG = "Rotation  gauche", AG = "Rotation  droite", IG = "Zoom avant", CG = "Zoom arrire", LG = "Slectionner", _G = "Visionneuse", RG = " propos", wG = "Annotations", kG = "Recherche", DG = "Plus dinformations", PG = "Afficher la collection", OG = "Copier lURL de la collection", NG = "Afficher le manifeste", MG = "Copier lURL du manifeste", FG = {
  commonClose: oG,
  commonNext: uG,
  commonOpen: lG,
  commonPrevious: cG,
  commonSearch: dG,
  commonSearchPlaceholder: fG,
  commonShare: hG,
  commonViewAll: mG,
  copyFailure: pG,
  copySuccess: gG,
  contentSearchLoading: bG,
  contentSearchPlaceholder: EG,
  contentSearchResultsNone: yG,
  contentSearchResultsMore: TG,
  imageFullScreen: SG,
  imageResetZoom: xG,
  imageRotateLeft: vG,
  imageRotateRight: AG,
  imageZoomIn: IG,
  imageZoomOut: CG,
  informationPanelTabs: LG,
  informationPanelTabsClose: _G,
  informationPanelTabsAbout: RG,
  informationPanelTabsAnnotations: wG,
  informationPanelTabsSearch: kG,
  informationPanelToggle: DG,
  shareCollectionJson: PG,
  shareCollectionCopy: OG,
  shareManifestJson: NG,
  shareManifestCopy: MG
}, BG = "Lukk", $G = "Neste", UG = "Forrige", HG = "Sk", VG = "Sk...", GG = "Del", zG = "Se alle", qG = "Feilet", WG = "Kopiert", KG = "Laster inn...", jG = "Sk", YG = "Ingen resultat", XG = "Flere resultat", QG = "Velg", ZG = "Viewer", JG = "Om", ez = "Annoteringer", tz = "Sk", nz = "Mer informasjon", rz = "Se samlingen", iz = "Kopir samlingens URL", sz = "Se manifestet", az = "Kopir manifestets URL", oz = {
  commonClose: BG,
  commonNext: $G,
  commonPrevious: UG,
  commonSearch: HG,
  commonSearchPlaceholder: VG,
  commonShare: GG,
  commonViewAll: zG,
  copyFailure: qG,
  copySuccess: WG,
  contentSearchLoading: KG,
  contentSearchPlaceholder: jG,
  contentSearchResultsNone: YG,
  contentSearchResultsMore: XG,
  informationPanelTabs: QG,
  informationPanelTabsClose: ZG,
  informationPanelTabsAbout: JG,
  informationPanelTabsAnnotations: ez,
  informationPanelTabsSearch: tz,
  informationPanelToggle: nz,
  shareCollectionJson: rz,
  shareCollectionCopy: iz,
  shareManifestJson: sz,
  shareManifestCopy: az
}, uz = "Lukk", lz = "Neste", cz = "Frre", dz = "Sk", fz = "Sk...", hz = "Del", mz = "Sj alle", pz = "Feila", gz = "Kopiert", bz = "Laster inn...", Ez = "Sk", yz = "Ingen resultat", Tz = "Fleire resultat", Sz = "Vel", xz = "Viewer", vz = "Om", Az = "Annoteringa", Iz = "Sk", Cz = "Meir informasjon", Lz = "Sj samlinga", _z = "Kopir samlingas URL", Rz = "Sj manifestet", wz = "Kopir manifestets URL", kz = {
  commonClose: uz,
  commonNext: lz,
  commonPrevious: cz,
  commonSearch: dz,
  commonSearchPlaceholder: fz,
  commonShare: hz,
  commonViewAll: mz,
  copyFailure: pz,
  copySuccess: gz,
  contentSearchLoading: bz,
  contentSearchPlaceholder: Ez,
  contentSearchResultsNone: yz,
  contentSearchResultsMore: Tz,
  informationPanelTabs: Sz,
  informationPanelTabsClose: xz,
  informationPanelTabsAbout: vz,
  informationPanelTabsAnnotations: Az,
  informationPanelTabsSearch: Iz,
  informationPanelToggle: Cz,
  shareCollectionJson: Lz,
  shareCollectionCopy: _z,
  shareManifestJson: Rz,
  shareManifestCopy: wz
}, Dz = "Lukk", Pz = "Neste", Oz = "Forrige", Nz = "Sk", Mz = "Sk...", Fz = "Del", Bz = "Se alle", $z = "Feilet", Uz = "Kopiert", Hz = "Laster inn...", Vz = "Sk", Gz = "Ingen resultat", zz = "Flere resultat", qz = "Velg", Wz = "Viewer", Kz = "Om", jz = "Annoteringer", Yz = "Sk", Xz = "Mer informasjon", Qz = "Se samlingen", Zz = "Kopir samlingens URL", Jz = "Se manifestet", eq = "Kopir manifestets URL", tq = {
  commonClose: Dz,
  commonNext: Pz,
  commonPrevious: Oz,
  commonSearch: Nz,
  commonSearchPlaceholder: Mz,
  commonShare: Fz,
  commonViewAll: Bz,
  copyFailure: $z,
  copySuccess: Uz,
  contentSearchLoading: Hz,
  contentSearchPlaceholder: Vz,
  contentSearchResultsNone: Gz,
  contentSearchResultsMore: zz,
  informationPanelTabs: qz,
  informationPanelTabsClose: Wz,
  informationPanelTabsAbout: Kz,
  informationPanelTabsAnnotations: jz,
  informationPanelTabsSearch: Yz,
  informationPanelToggle: Xz,
  shareCollectionJson: Qz,
  shareCollectionCopy: Zz,
  shareManifestJson: Jz,
  shareManifestCopy: eq
}, nq = {}, rq = {
  en: zv,
  fi: aG,
  fr: FG,
  nb: oz,
  nn: kz,
  no: tq,
  pt: nq
}, Vu = "clover", iq = Object.fromEntries(
  Object.entries(rq).map(([t, e]) => [
    t,
    { [Vu]: e }
  ])
), Hs = {
  defaultNS: Vu,
  fallbackLng: "en",
  ns: [Vu],
  resources: { ...iq }
}, sq = (t, e) => ({
  ...t || {},
  ...e || {}
});
let a1 = !1;
function aq(t) {
  if (t) {
    for (const [e, n] of Object.entries(t))
      if (n)
        for (const [r, i] of Object.entries(n))
          i && Gs.addResourceBundle(e, r, i, !0, !0);
  }
}
function oq(t = {}) {
  if (a1)
    aq(t.resources), t.lng && Gs.changeLanguage(t.lng), t.fallbackLng && (Gs.options.fallbackLng = t.fallbackLng);
  else {
    const e = sq(Hs.resources, t.resources);
    Gs.use(GA).use(HA).init({
      ...Hs,
      ...t,
      resources: e,
      // Preserve our namespace defaults unless explicitly overridden.
      ns: t.ns ?? Hs.ns,
      defaultNS: t.defaultNS ?? Hs.defaultNS,
      fallbackLng: t.fallbackLng ?? Hs.fallbackLng
    }), a1 = !0;
  }
  return Gs;
}
oq();
const uq = zv;
function lq(t) {
  return uq[t] ?? t;
}
function Zn(t = Vu) {
  const e = VA(t), { t: n } = e, r = yt(
    (i, s) => {
      const a = n(i, s);
      return typeof a != "string" || a === i ? lq(i) : a;
    },
    [n]
  );
  return {
    ...e,
    t: r
  };
}
const cq = ({
  searchServiceUrl: t,
  setContentSearchResource: e,
  setLoading: n
}) => {
  const { t: r } = Zn(), [i, s] = Be(), a = st(), { openSeadragonViewer: o, vault: u } = a;
  async function l(f) {
    if (f.preventDefault(), !!o && t) {
      if (!i || i.trim() === "") {
        e({});
        return;
      }
      n(!0), ab(u, t, {
        q: i
      }).then((h) => {
        e(h), n(!1);
      });
    }
  }
  const c = (f) => {
    f.preventDefault(), s(f.target.value);
  }, d = r("contentSearchPlaceholder");
  return /* @__PURE__ */ v.createElement(sV, null, /* @__PURE__ */ v.createElement(tV, { onSubmit: l, className: "content-search-form" }, /* @__PURE__ */ v.createElement(
    nV,
    {
      className: "content-search-input",
      name: "searchTerms",
      onChange: c
    },
    /* @__PURE__ */ v.createElement(rV, { placeholder: d })
  ), /* @__PURE__ */ v.createElement(iV, { asChild: !0 }, /* @__PURE__ */ v.createElement(aV, { type: "submit" }, /* @__PURE__ */ v.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ v.createElement("title", null, r("informationPanelTabsSearch")), /* @__PURE__ */ v.createElement("path", { d: "M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z" }))))));
}, dq = ({
  searchServiceUrl: t,
  setContentSearchResource: e,
  activeCanvas: n,
  annotationPage: r
}) => {
  const i = st(), { vault: s } = i, { t: a } = Zn(), [o, u] = Be(!1), [l, c] = Be({});
  Se(() => {
    var m;
    if (!(r != null && r.items)) return;
    const h = ((m = r == null ? void 0 : r.items) == null ? void 0 : m.map((p) => s.get(p.id))).reduce((p, g) => {
      const b = g.target.source.id;
      return p[b] || (p[b] = []), p[b].push(g.id), p;
    }, {});
    c(h);
  }, [r]);
  let d;
  return /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
    cq,
    {
      searchServiceUrl: t,
      setContentSearchResource: e,
      activeCanvas: n,
      setLoading: u
    }
  ), o ? /* @__PURE__ */ v.createElement("span", null, a("contentSearchLoading")) : l && Object.keys(l).length > 0 && Object.keys(l).map((f) => (d = s.get(f), /* @__PURE__ */ v.createElement(Mf, { key: f, "data-testid": "annotation-page" }, d && /* @__PURE__ */ v.createElement("header", null, /* @__PURE__ */ v.createElement(yr, { label: d.label })), l[f].map((h) => {
    var b, y, T, S, I;
    const m = s.get(
      h
    ), p = Dr(s, d.id), g = (b = p == null ? void 0 : p[0]) != null && b.service ? ((T = (y = p == null ? void 0 : p[0]) == null ? void 0 : y.service[0]) == null ? void 0 : T.id) || ((I = (S = p == null ? void 0 : p[0]) == null ? void 0 : S.service[0]) == null ? void 0 : I["@id"]) : void 0;
    return /* @__PURE__ */ v.createElement(
      ph,
      {
        annotation: m,
        targetResource: g,
        key: m.id,
        isContentSearch: !0
      }
    );
  })))));
}, fq = le("div", {
  width: "100%",
  padding: " 0 1.618rem 2rem",
  display: "flex",
  flexDirection: "column",
  overflow: "auto",
  position: "absolute",
  fontWeight: "400",
  fontSize: "1rem",
  zIndex: "0",
  img: {
    maxWidth: "100px",
    maxHeight: "100px",
    objectFit: "contain",
    color: "transparent",
    margin: "0 0 1rem",
    borderRadius: "3px",
    backgroundColor: "$secondaryMuted"
  },
  video: {
    display: "none"
  },
  "a, a:visited": {
    color: "$accent"
  },
  p: {
    fontSize: "1rem",
    lineHeight: "1.47em",
    margin: "0"
  },
  dl: {
    margin: "0",
    dt: {
      fontWeight: "700",
      margin: "1rem 0 0.25rem"
    },
    dd: {
      margin: "0"
    }
  },
  ".manifest-property-title": {
    fontWeight: "700",
    margin: "1rem 0 0.25rem"
  },
  "ul, ol": {
    padding: "0",
    margin: "0",
    li: {
      fontSize: "1rem",
      lineHeight: "1.45em",
      listStyle: "none",
      margin: "0.25rem 0 0.25rem"
    }
  }
}), hq = le("div", {
  position: "relative",
  width: "100%",
  height: "100%",
  zIndex: "0"
}), mq = ({
  homepage: t
}) => (t == null ? void 0 : t.length) === 0 ? /* @__PURE__ */ v.createElement(v.Fragment, null) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("span", { className: "manifest-property-title" }, "Homepage"), /* @__PURE__ */ v.createElement(uH, { homepage: t })), pq = ({
  id: t,
  htmlLabel: e,
  parent: n = "manifest"
}) => /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("span", { className: "manifest-property-title" }, e), /* @__PURE__ */ v.createElement("a", { href: t, target: "_blank", id: `iiif-${n}-id` }, t)), gq = ({
  metadata: t,
  parent: e = "manifest"
}) => t ? /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(bH, { metadata: t, id: `iiif-${e}-metadata` })) : /* @__PURE__ */ v.createElement(v.Fragment, null), bq = ({
  rendering: t
}) => (t == null ? void 0 : t.length) === 0 ? /* @__PURE__ */ v.createElement(v.Fragment, null) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("span", { className: "manifest-property-title" }, "Alternate formats"), /* @__PURE__ */ v.createElement(TH, { rendering: t })), Eq = ({
  requiredStatement: t,
  parent: e = "manifest"
}) => t ? /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
  xH,
  {
    requiredStatement: t,
    id: `iiif-${e}-required-statement`
  }
)) : /* @__PURE__ */ v.createElement(v.Fragment, null), yq = ({ rights: t }) => t ? /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("span", { className: "manifest-property-title" }, "Rights"), /* @__PURE__ */ v.createElement("a", { href: t, target: "_blank" }, t)) : /* @__PURE__ */ v.createElement(v.Fragment, null), Tq = ({ seeAlso: t }) => (t == null ? void 0 : t.length) === 0 ? /* @__PURE__ */ v.createElement(v.Fragment, null) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("span", { className: "manifest-property-title" }, "See Also"), /* @__PURE__ */ v.createElement(IH, { seeAlso: t })), Sq = ({
  summary: t,
  parent: e = "manifest"
}) => t ? /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(CH, { summary: t, as: "p", id: `iiif-${e}-summary` })) : /* @__PURE__ */ v.createElement(v.Fragment, null), xq = ({
  label: t,
  thumbnail: e
}) => (e == null ? void 0 : e.length) === 0 ? /* @__PURE__ */ v.createElement(v.Fragment, null) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
  Ov,
  {
    altAsLabel: t || { none: ["resource"] },
    thumbnail: e,
    style: { backgroundColor: "#6663", objectFit: "cover" }
  }
)), vq = () => {
  const t = st(), { activeManifest: e, vault: n } = t, [r, i] = Be(), [s, a] = Be([]), [o, u] = Be([]), [l, c] = Be(
    []
  ), [d, f] = Be([]);
  return Se(() => {
    var m, p, g, b;
    const h = n.get(e);
    h && (i(h), ((m = h.homepage) == null ? void 0 : m.length) > 0 && a(
      n.get(
        h.homepage
      )
    ), ((p = h.seeAlso) == null ? void 0 : p.length) > 0 && u(
      n.get(
        h.seeAlso
      )
    ), ((g = h.rendering) == null ? void 0 : g.length) > 0 && c(
      n.get(
        h.rendering
      )
    ), ((b = h.thumbnail) == null ? void 0 : b.length) > 0 && f(
      n.get(
        h.thumbnail
      )
    ));
  }, [e, n]), r ? /* @__PURE__ */ v.createElement(hq, null, /* @__PURE__ */ v.createElement(fq, null, /* @__PURE__ */ v.createElement(xq, { thumbnail: d, label: r.label }), /* @__PURE__ */ v.createElement(Sq, { summary: r.summary }), /* @__PURE__ */ v.createElement(gq, { metadata: r.metadata }), /* @__PURE__ */ v.createElement(Eq, { requiredStatement: r.requiredStatement }), /* @__PURE__ */ v.createElement(yq, { rights: r.rights }), /* @__PURE__ */ v.createElement(mq, { homepage: s }), /* @__PURE__ */ v.createElement(Tq, { seeAlso: o }), /* @__PURE__ */ v.createElement(bq, { rendering: l }), /* @__PURE__ */ v.createElement(pq, { id: r.id, htmlLabel: "IIIF Manifest" }))) : /* @__PURE__ */ v.createElement(v.Fragment, null);
};
function Aq(t) {
  const e = [];
  return t.forEach((n) => {
    var r;
    (r = n.informationPanel) != null && r.component && e.push(n);
  }), { pluginsWithInfoPanel: e };
}
const Iq = ({
  contentStateAnnotation: t
}) => {
  var o, u, l, c, d, f;
  const e = st(), { vault: n } = e;
  if (!t) return /* @__PURE__ */ v.createElement(v.Fragment, null);
  const r = (
    // @ts-ignore
    ((o = t == null ? void 0 : t.target) == null ? void 0 : o.source) || (t == null ? void 0 : t.target)
  ), i = n.get(r == null ? void 0 : r.id), s = Dr(n, i.id), a = (u = s == null ? void 0 : s[0]) != null && u.service ? ((c = (l = s == null ? void 0 : s[0]) == null ? void 0 : l.service[0]) == null ? void 0 : c.id) || ((f = (d = s == null ? void 0 : s[0]) == null ? void 0 : d.service[0]) == null ? void 0 : f["@id"]) : void 0;
  return /* @__PURE__ */ v.createElement(Mf, { "data-testid": "annotation-page" }, i && /* @__PURE__ */ v.createElement("header", null, /* @__PURE__ */ v.createElement(yr, { label: i.label }), " ", /* @__PURE__ */ v.createElement("em", null, "(Shared)")), /* @__PURE__ */ v.createElement("div", { "data-testid": "annotation-page-items" }, /* @__PURE__ */ v.createElement(
    ph,
    {
      annotation: t,
      targetResource: a,
      key: t.id,
      isContentState: !0
    }
  )));
}, Cq = 1500, Lq = ({
  activeCanvas: t,
  annotationResources: e,
  searchServiceUrl: n,
  setContentSearchResource: r,
  contentSearchResource: i
}) => {
  var N, U;
  const { t: s } = Zn(), a = jt(), o = st(), {
    contentStateAnnotation: u,
    informationPanelResource: l,
    isAutoScrolling: c,
    isUserScrolling: d,
    vault: f,
    configOptions: h,
    plugins: m
  } = o, { informationPanel: p } = h, g = p == null ? void 0 : p.renderAbout, b = p == null ? void 0 : p.renderAnnotation, y = f.get({
    id: t,
    type: "Canvas"
  }), T = p == null ? void 0 : p.renderContentSearch, S = p == null ? void 0 : p.renderToggle, I = (N = h == null ? void 0 : h.annotations) == null ? void 0 : N.motivations, C = (
    // @ts-ignore
    ((U = u == null ? void 0 : u.target) == null ? void 0 : U.source) || (u == null ? void 0 : u.target)
  ), _ = !!u && // @ts-ignore
  C.id === t, R = fu(() => e ? I ? e.map((B) => {
    var K;
    if (!((K = B == null ? void 0 : B.items) != null && K.length)) return null;
    const V = B.items.filter((w) => {
      const Y = f.get(w.id);
      return w8(
        Y,
        I
      );
    });
    return V.length ? {
      ...B,
      items: V
    } : null;
  }).filter(Boolean) : e : [], [e, I, f]), k = !!(R != null && R.length) || _, { pluginsWithInfoPanel: A } = Aq(m);
  function L(B, V) {
    var w, Y;
    const K = (w = B == null ? void 0 : B.informationPanel) == null ? void 0 : w.component;
    return K === void 0 ? /* @__PURE__ */ v.createElement(v.Fragment, null) : /* @__PURE__ */ v.createElement(Ja, { key: V, value: B.id }, /* @__PURE__ */ v.createElement(Df, { FallbackComponent: Of }, /* @__PURE__ */ v.createElement(
      K,
      {
        ...(Y = B == null ? void 0 : B.informationPanel) == null ? void 0 : Y.componentProps,
        canvas: y,
        useViewerDispatch: jt,
        useViewerState: st
      }
    )));
  }
  const P = () => {
    a({
      type: "updateInformationOpen",
      isInformationOpen: !1
    });
  };
  Se(() => {
    [
      "manifest-about",
      "manifest-annotations",
      "manifest-content-search"
    ].includes(String(p == null ? void 0 : p.defaultTab)) ? a({
      type: "updateInformationPanelResource",
      informationPanelResource: p == null ? void 0 : p.defaultTab
    }) : a(_ ? {
      type: "updateInformationPanelResource",
      informationPanelResource: "manifest-annotations"
    } : {
      type: "updateInformationPanelResource",
      informationPanelResource: "manifest-about"
    });
  }, []), Se(() => {
    k || a({
      type: "updateInformationPanelResource",
      informationPanelResource: "manifest-about"
    });
  }, [k]);
  function $() {
    if (!c) {
      clearTimeout(d);
      const B = setTimeout(() => {
        a({
          type: "updateUserScrolling",
          isUserScrolling: void 0
        });
      }, Cq);
      a({
        type: "updateUserScrolling",
        isUserScrolling: B
      });
    }
  }
  const G = (B) => {
    a({
      type: "updateInformationPanelResource",
      informationPanelResource: B
    });
  };
  return /* @__PURE__ */ v.createElement(
    CC,
    {
      "data-testid": "information-panel",
      defaultValue: l,
      onValueChange: G,
      orientation: "horizontal",
      value: l,
      className: "clover-viewer-information-panel"
    },
    /* @__PURE__ */ v.createElement(
      LC,
      {
        "aria-label": s("informationPanelTabs"),
        "data-testid": "information-panel-list"
      },
      S && /* @__PURE__ */ v.createElement(
        ks,
        {
          value: "manifest-back",
          "data-value": "manifest-back",
          onClick: P,
          as: "button"
        },
        s("informationPanelTabsClose")
      ),
      g && /* @__PURE__ */ v.createElement(ks, { value: "manifest-about" }, s("informationPanelTabsAbout")),
      T && i && /* @__PURE__ */ v.createElement(ks, { value: "manifest-content-search" }, s("informationPanelTabsSearch")),
      b && k && /* @__PURE__ */ v.createElement(ks, { value: "manifest-annotations" }, (p == null ? void 0 : p.annotationTabLabel) || s("informationPanelTabsAnnotations")),
      A && A.map((B, V) => {
        var K;
        return /* @__PURE__ */ v.createElement(ks, { key: V, value: B.id }, /* @__PURE__ */ v.createElement(
          yr,
          {
            label: (K = B.informationPanel) == null ? void 0 : K.label
          }
        ));
      })
    ),
    /* @__PURE__ */ v.createElement(RC, { handleScroll: $ }, g && /* @__PURE__ */ v.createElement(Ja, { value: "manifest-about" }, /* @__PURE__ */ v.createElement(vq, null)), T && i && /* @__PURE__ */ v.createElement(Ja, { value: "manifest-content-search" }, /* @__PURE__ */ v.createElement(
      dq,
      {
        searchServiceUrl: n,
        setContentSearchResource: r,
        activeCanvas: t,
        annotationPage: i
      }
    )), b && k && R && /* @__PURE__ */ v.createElement(Ja, { value: "manifest-annotations" }, u && _ && /* @__PURE__ */ v.createElement(
      Iq,
      {
        contentStateAnnotation: u
      }
    ), R.map((B) => /* @__PURE__ */ v.createElement(
      LH,
      {
        key: B.id,
        annotationPage: B
      }
    ))), A && A.map(
      (B, V) => L(B, V)
    ))
  );
}, _q = () => /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M256 112v288M400 256H112"
  }
), Rq = () => /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("path", { d: "M232 416a23.88 23.88 0 01-14.2-4.68 8.27 8.27 0 01-.66-.51L125.76 336H56a24 24 0 01-24-24V200a24 24 0 0124-24h69.75l91.37-74.81a8.27 8.27 0 01.66-.51A24 24 0 01256 120v272a24 24 0 01-24 24zm-106.18-80zm-.27-159.86zM320 336a16 16 0 01-14.29-23.19c9.49-18.87 14.3-38 14.3-56.81 0-19.38-4.66-37.94-14.25-56.73a16 16 0 0128.5-14.54C346.19 208.12 352 231.44 352 256c0 23.86-6 47.81-17.7 71.19A16 16 0 01320 336z" }), /* @__PURE__ */ v.createElement("path", { d: "M368 384a16 16 0 01-13.86-24C373.05 327.09 384 299.51 384 256c0-44.17-10.93-71.56-29.82-103.94a16 16 0 0127.64-16.12C402.92 172.11 416 204.81 416 256c0 50.43-13.06 83.29-34.13 120a16 16 0 01-13.87 8z" }), /* @__PURE__ */ v.createElement("path", { d: "M416 432a16 16 0 01-13.39-24.74C429.85 365.47 448 323.76 448 256c0-66.5-18.18-108.62-45.49-151.39a16 16 0 1127-17.22C459.81 134.89 480 181.74 480 256c0 64.75-14.66 113.63-50.6 168.74A16 16 0 01416 432z" })), wq = () => /* @__PURE__ */ v.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" }), kq = () => /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
  "path",
  {
    d: "M336 176h40a40 40 0 0140 40v208a40 40 0 01-40 40H136a40 40 0 01-40-40V216a40 40 0 0140-40h40",
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32"
  }
), /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M176 272l80 80 80-80M256 48v288"
  }
)), Dq = () => /* @__PURE__ */ v.createElement("path", { d: "M416 64H96a64.07 64.07 0 00-64 64v256a64.07 64.07 0 0064 64h320a64.07 64.07 0 0064-64V128a64.07 64.07 0 00-64-64zm-80 64a48 48 0 11-48 48 48.05 48.05 0 0148-48zM96 416a32 32 0 01-32-32v-67.63l94.84-84.3a48.06 48.06 0 0165.8 1.9l64.95 64.81L172.37 416zm352-32a32 32 0 01-32 32H217.63l121.42-121.42a47.72 47.72 0 0161.64-.16L448 333.84z" }), Pq = () => /* @__PURE__ */ v.createElement("path", { d: "M464 384.39a32 32 0 01-13-2.77 15.77 15.77 0 01-2.71-1.54l-82.71-58.22A32 32 0 01352 295.7v-79.4a32 32 0 0113.58-26.16l82.71-58.22a15.77 15.77 0 012.71-1.54 32 32 0 0145 29.24v192.76a32 32 0 01-32 32zM268 400H84a68.07 68.07 0 01-68-68V180a68.07 68.07 0 0168-68h184.48A67.6 67.6 0 01336 179.52V332a68.07 68.07 0 01-68 68z" }), qv = le("svg", {
  display: "inline-flex",
  variants: {
    isLarge: {
      true: {
        height: "4rem",
        width: "4rem"
      }
    },
    isMedium: {
      true: {
        height: "2rem",
        width: "2rem"
      }
    },
    isSmall: {
      true: {
        height: "1rem",
        width: "1rem"
      }
    }
  }
}), Oq = ({ children: t }) => /* @__PURE__ */ v.createElement("title", null, t), Dt = (t) => /* @__PURE__ */ v.createElement(
  qv,
  {
    ...t,
    "data-testid": "icon-svg",
    role: "img",
    viewBox: "0 0 512 512",
    xmlns: "http://www.w3.org/2000/svg"
  },
  t.children
);
Dt.Title = Oq;
Dt.Add = _q;
Dt.Audio = Rq;
Dt.Close = wq;
Dt.Download = kq;
Dt.Image = Dq;
Dt.Video = Pq;
function Nq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Pr(t);
  M.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var Mq = "DismissableLayer", ff = "dismissableLayer.update", Fq = "dismissableLayer.pointerDownOutside", Bq = "dismissableLayer.focusOutside", o1, Wv = M.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), l0 = M.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: a,
      onDismiss: o,
      ...u
    } = t, l = M.useContext(Wv), [c, d] = M.useState(null), f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = M.useState({}), m = Je(e, (_) => d(_)), p = Array.from(l.layers), [g] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), b = p.indexOf(g), y = c ? p.indexOf(c) : -1, T = l.layersWithOutsidePointerEventsDisabled.size > 0, S = y >= b, I = Hq((_) => {
      const R = _.target, k = [...l.branches].some((A) => A.contains(R));
      !S || k || (i == null || i(_), a == null || a(_), _.defaultPrevented || o == null || o());
    }, f), C = Vq((_) => {
      const R = _.target;
      [...l.branches].some((A) => A.contains(R)) || (s == null || s(_), a == null || a(_), _.defaultPrevented || o == null || o());
    }, f);
    return Nq((_) => {
      y === l.layers.size - 1 && (r == null || r(_), !_.defaultPrevented && o && (_.preventDefault(), o()));
    }, f), M.useEffect(() => {
      if (c)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (o1 = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(c)), l.layers.add(c), u1(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = o1);
        };
    }, [c, f, n, l]), M.useEffect(() => () => {
      c && (l.layers.delete(c), l.layersWithOutsidePointerEventsDisabled.delete(c), u1());
    }, [c, l]), M.useEffect(() => {
      const _ = () => h({});
      return document.addEventListener(ff, _), () => document.removeEventListener(ff, _);
    }, []), /* @__PURE__ */ ee(
      $e.div,
      {
        ...u,
        ref: m,
        style: {
          pointerEvents: T ? S ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Oe(t.onFocusCapture, C.onFocusCapture),
        onBlurCapture: Oe(t.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: Oe(
          t.onPointerDownCapture,
          I.onPointerDownCapture
        )
      }
    );
  }
);
l0.displayName = Mq;
var $q = "DismissableLayerBranch", Uq = M.forwardRef((t, e) => {
  const n = M.useContext(Wv), r = M.useRef(null), i = Je(e, r);
  return M.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [n.branches]), /* @__PURE__ */ ee($e.div, { ...t, ref: i });
});
Uq.displayName = $q;
function Hq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Pr(t), r = M.useRef(!1), i = M.useRef(() => {
  });
  return M.useEffect(() => {
    const s = (o) => {
      if (o.target && !r.current) {
        let u = function() {
          Kv(
            Fq,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: o };
        o.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = u, e.addEventListener("click", i.current, { once: !0 })) : u();
      } else
        e.removeEventListener("click", i.current);
      r.current = !1;
    }, a = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(a), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Vq(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = Pr(t), r = M.useRef(!1);
  return M.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && Kv(Bq, n, { originalEvent: s }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function u1() {
  const t = new CustomEvent(ff);
  document.dispatchEvent(t);
}
function Kv(t, e, n, { discrete: r }) {
  const i = n.originalEvent.target, s = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && i.addEventListener(t, e, { once: !0 }), r ? fI(i, s) : i.dispatchEvent(s);
}
var Hc = 0;
function jv() {
  M.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? l1()), document.body.insertAdjacentElement("beforeend", t[1] ?? l1()), Hc++, () => {
      Hc === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), Hc--;
    };
  }, []);
}
function l1() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var Vc = "focusScope.autoFocusOnMount", Gc = "focusScope.autoFocusOnUnmount", c1 = { bubbles: !1, cancelable: !0 }, Gq = "FocusScope", c0 = M.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...a
  } = t, [o, u] = M.useState(null), l = Pr(i), c = Pr(s), d = M.useRef(null), f = Je(e, (p) => u(p)), h = M.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  M.useEffect(() => {
    if (r) {
      let p = function(T) {
        if (h.paused || !o) return;
        const S = T.target;
        o.contains(S) ? d.current = S : Cr(d.current, { select: !0 });
      }, g = function(T) {
        if (h.paused || !o) return;
        const S = T.relatedTarget;
        S !== null && (o.contains(S) || Cr(d.current, { select: !0 }));
      }, b = function(T) {
        if (document.activeElement === document.body)
          for (const I of T)
            I.removedNodes.length > 0 && Cr(o);
      };
      document.addEventListener("focusin", p), document.addEventListener("focusout", g);
      const y = new MutationObserver(b);
      return o && y.observe(o, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", g), y.disconnect();
      };
    }
  }, [r, o, h.paused]), M.useEffect(() => {
    if (o) {
      f1.add(h);
      const p = document.activeElement;
      if (!o.contains(p)) {
        const b = new CustomEvent(Vc, c1);
        o.addEventListener(Vc, l), o.dispatchEvent(b), b.defaultPrevented || (zq(Yq(Yv(o)), { select: !0 }), document.activeElement === p && Cr(o));
      }
      return () => {
        o.removeEventListener(Vc, l), setTimeout(() => {
          const b = new CustomEvent(Gc, c1);
          o.addEventListener(Gc, c), o.dispatchEvent(b), b.defaultPrevented || Cr(p ?? document.body, { select: !0 }), o.removeEventListener(Gc, c), f1.remove(h);
        }, 0);
      };
    }
  }, [o, l, c, h]);
  const m = M.useCallback(
    (p) => {
      if (!n && !r || h.paused) return;
      const g = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, b = document.activeElement;
      if (g && b) {
        const y = p.currentTarget, [T, S] = qq(y);
        T && S ? !p.shiftKey && b === S ? (p.preventDefault(), n && Cr(T, { select: !0 })) : p.shiftKey && b === T && (p.preventDefault(), n && Cr(S, { select: !0 })) : b === y && p.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ ee($e.div, { tabIndex: -1, ...a, ref: f, onKeyDown: m });
});
c0.displayName = Gq;
function zq(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (Cr(r, { select: e }), document.activeElement !== n) return;
}
function qq(t) {
  const e = Yv(t), n = d1(e, t), r = d1(e.reverse(), t);
  return [n, r];
}
function Yv(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function d1(t, e) {
  for (const n of t)
    if (!Wq(n, { upTo: e })) return n;
}
function Wq(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function Kq(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Cr(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && Kq(t) && e && t.select();
  }
}
var f1 = jq();
function jq() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = h1(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = h1(t, e), (n = t[0]) == null || n.resume();
    }
  };
}
function h1(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function Yq(t) {
  return t.filter((e) => e.tagName !== "A");
}
const Xq = ["top", "right", "bottom", "left"], Mr = Math.min, ln = Math.max, Gu = Math.round, Bo = Math.floor, Gn = (t) => ({
  x: t,
  y: t
}), Qq = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Zq = {
  start: "end",
  end: "start"
};
function hf(t, e, n) {
  return ln(t, Mr(e, n));
}
function mr(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function pr(t) {
  return t.split("-")[0];
}
function Is(t) {
  return t.split("-")[1];
}
function d0(t) {
  return t === "x" ? "y" : "x";
}
function f0(t) {
  return t === "y" ? "height" : "width";
}
const Jq = /* @__PURE__ */ new Set(["top", "bottom"]);
function Hn(t) {
  return Jq.has(pr(t)) ? "y" : "x";
}
function h0(t) {
  return d0(Hn(t));
}
function eW(t, e, n) {
  n === void 0 && (n = !1);
  const r = Is(t), i = h0(t), s = f0(i);
  let a = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (a = zu(a)), [a, zu(a)];
}
function tW(t) {
  const e = zu(t);
  return [mf(t), e, mf(e)];
}
function mf(t) {
  return t.replace(/start|end/g, (e) => Zq[e]);
}
const m1 = ["left", "right"], p1 = ["right", "left"], nW = ["top", "bottom"], rW = ["bottom", "top"];
function iW(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? p1 : m1 : e ? m1 : p1;
    case "left":
    case "right":
      return e ? nW : rW;
    default:
      return [];
  }
}
function sW(t, e, n, r) {
  const i = Is(t);
  let s = iW(pr(t), n === "start", r);
  return i && (s = s.map((a) => a + "-" + i), e && (s = s.concat(s.map(mf)))), s;
}
function zu(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Qq[e]);
}
function aW(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Xv(t) {
  return typeof t != "number" ? aW(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function qu(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: i
  } = t;
  return {
    width: r,
    height: i,
    top: n,
    left: e,
    right: e + r,
    bottom: n + i,
    x: e,
    y: n
  };
}
function g1(t, e, n) {
  let {
    reference: r,
    floating: i
  } = t;
  const s = Hn(e), a = h0(e), o = f0(a), u = pr(e), l = s === "y", c = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[o] / 2 - i[o] / 2;
  let h;
  switch (u) {
    case "top":
      h = {
        x: c,
        y: r.y - i.height
      };
      break;
    case "bottom":
      h = {
        x: c,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (Is(e)) {
    case "start":
      h[a] -= f * (n && l ? -1 : 1);
      break;
    case "end":
      h[a] += f * (n && l ? -1 : 1);
      break;
  }
  return h;
}
const oW = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: a
  } = n, o = s.filter(Boolean), u = await (a.isRTL == null ? void 0 : a.isRTL(e));
  let l = await a.getElementRects({
    reference: t,
    floating: e,
    strategy: i
  }), {
    x: c,
    y: d
  } = g1(l, r, u), f = r, h = {}, m = 0;
  for (let p = 0; p < o.length; p++) {
    const {
      name: g,
      fn: b
    } = o[p], {
      x: y,
      y: T,
      data: S,
      reset: I
    } = await b({
      x: c,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: h,
      rects: l,
      platform: a,
      elements: {
        reference: t,
        floating: e
      }
    });
    c = y ?? c, d = T ?? d, h = {
      ...h,
      [g]: {
        ...h[g],
        ...S
      }
    }, I && m <= 50 && (m++, typeof I == "object" && (I.placement && (f = I.placement), I.rects && (l = I.rects === !0 ? await a.getElementRects({
      reference: t,
      floating: e,
      strategy: i
    }) : I.rects), {
      x: c,
      y: d
    } = g1(l, f, u)), p = -1);
  }
  return {
    x: c,
    y: d,
    placement: f,
    strategy: i,
    middlewareData: h
  };
};
async function wa(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: a,
    elements: o,
    strategy: u
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = mr(e, t), m = Xv(h), g = o[f ? d === "floating" ? "reference" : "floating" : d], b = qu(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(g))) == null || n ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(o.floating)),
    boundary: l,
    rootBoundary: c,
    strategy: u
  })), y = d === "floating" ? {
    x: r,
    y: i,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, T = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(o.floating)), S = await (s.isElement == null ? void 0 : s.isElement(T)) ? await (s.getScale == null ? void 0 : s.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, I = qu(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: o,
    rect: y,
    offsetParent: T,
    strategy: u
  }) : y);
  return {
    top: (b.top - I.top + m.top) / S.y,
    bottom: (I.bottom - b.bottom + m.bottom) / S.y,
    left: (b.left - I.left + m.left) / S.x,
    right: (I.right - b.right + m.right) / S.x
  };
}
const uW = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: s,
      platform: a,
      elements: o,
      middlewareData: u
    } = e, {
      element: l,
      padding: c = 0
    } = mr(t, e) || {};
    if (l == null)
      return {};
    const d = Xv(c), f = {
      x: n,
      y: r
    }, h = h0(i), m = f0(h), p = await a.getDimensions(l), g = h === "y", b = g ? "top" : "left", y = g ? "bottom" : "right", T = g ? "clientHeight" : "clientWidth", S = s.reference[m] + s.reference[h] - f[h] - s.floating[m], I = f[h] - s.reference[h], C = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(l));
    let _ = C ? C[T] : 0;
    (!_ || !await (a.isElement == null ? void 0 : a.isElement(C))) && (_ = o.floating[T] || s.floating[m]);
    const R = S / 2 - I / 2, k = _ / 2 - p[m] / 2 - 1, A = Mr(d[b], k), L = Mr(d[y], k), P = A, $ = _ - p[m] - L, G = _ / 2 - p[m] / 2 + R, N = hf(P, G, $), U = !u.arrow && Is(i) != null && G !== N && s.reference[m] / 2 - (G < P ? A : L) - p[m] / 2 < 0, B = U ? G < P ? G - P : G - $ : 0;
    return {
      [h]: f[h] + B,
      data: {
        [h]: N,
        centerOffset: G - N - B,
        ...U && {
          alignmentOffset: B
        }
      },
      reset: U
    };
  }
}), lW = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        middlewareData: s,
        rects: a,
        initialPlacement: o,
        platform: u,
        elements: l
      } = e, {
        mainAxis: c = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: p = !0,
        ...g
      } = mr(t, e);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const b = pr(i), y = Hn(o), T = pr(o) === o, S = await (u.isRTL == null ? void 0 : u.isRTL(l.floating)), I = f || (T || !p ? [zu(o)] : tW(o)), C = m !== "none";
      !f && C && I.push(...sW(o, p, m, S));
      const _ = [o, ...I], R = await wa(e, g), k = [];
      let A = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (c && k.push(R[b]), d) {
        const G = eW(i, a, S);
        k.push(R[G[0]], R[G[1]]);
      }
      if (A = [...A, {
        placement: i,
        overflows: k
      }], !k.every((G) => G <= 0)) {
        var L, P;
        const G = (((L = s.flip) == null ? void 0 : L.index) || 0) + 1, N = _[G];
        if (N && (!(d === "alignment" ? y !== Hn(N) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        A.every((V) => Hn(V.placement) === y ? V.overflows[0] > 0 : !0)))
          return {
            data: {
              index: G,
              overflows: A
            },
            reset: {
              placement: N
            }
          };
        let U = (P = A.filter((B) => B.overflows[0] <= 0).sort((B, V) => B.overflows[1] - V.overflows[1])[0]) == null ? void 0 : P.placement;
        if (!U)
          switch (h) {
            case "bestFit": {
              var $;
              const B = ($ = A.filter((V) => {
                if (C) {
                  const K = Hn(V.placement);
                  return K === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  K === "y";
                }
                return !0;
              }).map((V) => [V.placement, V.overflows.filter((K) => K > 0).reduce((K, w) => K + w, 0)]).sort((V, K) => V[1] - K[1])[0]) == null ? void 0 : $[0];
              B && (U = B);
              break;
            }
            case "initialPlacement":
              U = o;
              break;
          }
        if (i !== U)
          return {
            reset: {
              placement: U
            }
          };
      }
      return {};
    }
  };
};
function b1(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function E1(t) {
  return Xq.some((e) => t[e] >= 0);
}
const cW = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = mr(t, e);
      switch (r) {
        case "referenceHidden": {
          const s = await wa(e, {
            ...i,
            elementContext: "reference"
          }), a = b1(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: a,
              referenceHidden: E1(a)
            }
          };
        }
        case "escaped": {
          const s = await wa(e, {
            ...i,
            altBoundary: !0
          }), a = b1(s, n.floating);
          return {
            data: {
              escapedOffsets: a,
              escaped: E1(a)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, Qv = /* @__PURE__ */ new Set(["left", "top"]);
async function dW(t, e) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), a = pr(n), o = Is(n), u = Hn(n) === "y", l = Qv.has(a) ? -1 : 1, c = s && u ? -1 : 1, d = mr(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return o && typeof m == "number" && (h = o === "end" ? m * -1 : m), u ? {
    x: h * c,
    y: f * l
  } : {
    x: f * l,
    y: h * c
  };
}
const fW = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: i,
        y: s,
        placement: a,
        middlewareData: o
      } = e, u = await dW(e, t);
      return a === ((n = o.offset) == null ? void 0 : n.placement) && (r = o.arrow) != null && r.alignmentOffset ? {} : {
        x: i + u.x,
        y: s + u.y,
        data: {
          ...u,
          placement: a
        }
      };
    }
  };
}, hW = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: o = {
          fn: (g) => {
            let {
              x: b,
              y
            } = g;
            return {
              x: b,
              y
            };
          }
        },
        ...u
      } = mr(t, e), l = {
        x: n,
        y: r
      }, c = await wa(e, u), d = Hn(pr(i)), f = d0(d);
      let h = l[f], m = l[d];
      if (s) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", y = h + c[g], T = h - c[b];
        h = hf(y, h, T);
      }
      if (a) {
        const g = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", y = m + c[g], T = m - c[b];
        m = hf(y, m, T);
      }
      const p = o.fn({
        ...e,
        [f]: h,
        [d]: m
      });
      return {
        ...p,
        data: {
          x: p.x - n,
          y: p.y - r,
          enabled: {
            [f]: s,
            [d]: a
          }
        }
      };
    }
  };
}, mW = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: s,
        middlewareData: a
      } = e, {
        offset: o = 0,
        mainAxis: u = !0,
        crossAxis: l = !0
      } = mr(t, e), c = {
        x: n,
        y: r
      }, d = Hn(i), f = d0(d);
      let h = c[f], m = c[d];
      const p = mr(o, e), g = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (u) {
        const T = f === "y" ? "height" : "width", S = s.reference[f] - s.floating[T] + g.mainAxis, I = s.reference[f] + s.reference[T] - g.mainAxis;
        h < S ? h = S : h > I && (h = I);
      }
      if (l) {
        var b, y;
        const T = f === "y" ? "width" : "height", S = Qv.has(pr(i)), I = s.reference[d] - s.floating[T] + (S && ((b = a.offset) == null ? void 0 : b[d]) || 0) + (S ? 0 : g.crossAxis), C = s.reference[d] + s.reference[T] + (S ? 0 : ((y = a.offset) == null ? void 0 : y[d]) || 0) - (S ? g.crossAxis : 0);
        m < I ? m = I : m > C && (m = C);
      }
      return {
        [f]: h,
        [d]: m
      };
    }
  };
}, pW = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: i,
        rects: s,
        platform: a,
        elements: o
      } = e, {
        apply: u = () => {
        },
        ...l
      } = mr(t, e), c = await wa(e, l), d = pr(i), f = Is(i), h = Hn(i) === "y", {
        width: m,
        height: p
      } = s.floating;
      let g, b;
      d === "top" || d === "bottom" ? (g = d, b = f === (await (a.isRTL == null ? void 0 : a.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (b = d, g = f === "end" ? "top" : "bottom");
      const y = p - c.top - c.bottom, T = m - c.left - c.right, S = Mr(p - c[g], y), I = Mr(m - c[b], T), C = !e.middlewareData.shift;
      let _ = S, R = I;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (R = T), (r = e.middlewareData.shift) != null && r.enabled.y && (_ = y), C && !f) {
        const A = ln(c.left, 0), L = ln(c.right, 0), P = ln(c.top, 0), $ = ln(c.bottom, 0);
        h ? R = m - 2 * (A !== 0 || L !== 0 ? A + L : ln(c.left, c.right)) : _ = p - 2 * (P !== 0 || $ !== 0 ? P + $ : ln(c.top, c.bottom));
      }
      await u({
        ...e,
        availableWidth: R,
        availableHeight: _
      });
      const k = await a.getDimensions(o.floating);
      return m !== k.width || p !== k.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ll() {
  return typeof window < "u";
}
function Cs(t) {
  return Zv(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function dn(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Jn(t) {
  var e;
  return (e = (Zv(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Zv(t) {
  return Ll() ? t instanceof Node || t instanceof dn(t).Node : !1;
}
function Cn(t) {
  return Ll() ? t instanceof Element || t instanceof dn(t).Element : !1;
}
function Kn(t) {
  return Ll() ? t instanceof HTMLElement || t instanceof dn(t).HTMLElement : !1;
}
function y1(t) {
  return !Ll() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof dn(t).ShadowRoot;
}
const gW = /* @__PURE__ */ new Set(["inline", "contents"]);
function Ka(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: i
  } = Ln(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !gW.has(i);
}
const bW = /* @__PURE__ */ new Set(["table", "td", "th"]);
function EW(t) {
  return bW.has(Cs(t));
}
const yW = [":popover-open", ":modal"];
function _l(t) {
  return yW.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const TW = ["transform", "translate", "scale", "rotate", "perspective"], SW = ["transform", "translate", "scale", "rotate", "perspective", "filter"], xW = ["paint", "layout", "strict", "content"];
function m0(t) {
  const e = p0(), n = Cn(t) ? Ln(t) : t;
  return TW.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || SW.some((r) => (n.willChange || "").includes(r)) || xW.some((r) => (n.contain || "").includes(r));
}
function vW(t) {
  let e = Fr(t);
  for (; Kn(e) && !fs(e); ) {
    if (m0(e))
      return e;
    if (_l(e))
      return null;
    e = Fr(e);
  }
  return null;
}
function p0() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const AW = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function fs(t) {
  return AW.has(Cs(t));
}
function Ln(t) {
  return dn(t).getComputedStyle(t);
}
function Rl(t) {
  return Cn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Fr(t) {
  if (Cs(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    y1(t) && t.host || // Fallback.
    Jn(t)
  );
  return y1(e) ? e.host : e;
}
function Jv(t) {
  const e = Fr(t);
  return fs(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Kn(e) && Ka(e) ? e : Jv(e);
}
function ka(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const i = Jv(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), a = dn(i);
  if (s) {
    const o = pf(a);
    return e.concat(a, a.visualViewport || [], Ka(i) ? i : [], o && n ? ka(o) : []);
  }
  return e.concat(i, ka(i, [], n));
}
function pf(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function e2(t) {
  const e = Ln(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Kn(t), s = i ? t.offsetWidth : n, a = i ? t.offsetHeight : r, o = Gu(n) !== s || Gu(r) !== a;
  return o && (n = s, r = a), {
    width: n,
    height: r,
    $: o
  };
}
function g0(t) {
  return Cn(t) ? t : t.contextElement;
}
function Zi(t) {
  const e = g0(t);
  if (!Kn(e))
    return Gn(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = e2(e);
  let a = (s ? Gu(n.width) : n.width) / r, o = (s ? Gu(n.height) : n.height) / i;
  return (!a || !Number.isFinite(a)) && (a = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: a,
    y: o
  };
}
const IW = /* @__PURE__ */ Gn(0);
function t2(t) {
  const e = dn(t);
  return !p0() || !e.visualViewport ? IW : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function CW(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== dn(t) ? !1 : e;
}
function oi(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), s = g0(t);
  let a = Gn(1);
  e && (r ? Cn(r) && (a = Zi(r)) : a = Zi(t));
  const o = CW(s, n, r) ? t2(s) : Gn(0);
  let u = (i.left + o.x) / a.x, l = (i.top + o.y) / a.y, c = i.width / a.x, d = i.height / a.y;
  if (s) {
    const f = dn(s), h = r && Cn(r) ? dn(r) : r;
    let m = f, p = pf(m);
    for (; p && r && h !== m; ) {
      const g = Zi(p), b = p.getBoundingClientRect(), y = Ln(p), T = b.left + (p.clientLeft + parseFloat(y.paddingLeft)) * g.x, S = b.top + (p.clientTop + parseFloat(y.paddingTop)) * g.y;
      u *= g.x, l *= g.y, c *= g.x, d *= g.y, u += T, l += S, m = dn(p), p = pf(m);
    }
  }
  return qu({
    width: c,
    height: d,
    x: u,
    y: l
  });
}
function wl(t, e) {
  const n = Rl(t).scrollLeft;
  return e ? e.left + n : oi(Jn(t)).left + n;
}
function n2(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - wl(t, n), i = n.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function LW(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: i
  } = t;
  const s = i === "fixed", a = Jn(r), o = e ? _l(e.floating) : !1;
  if (r === a || o && s)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = Gn(1);
  const c = Gn(0), d = Kn(r);
  if ((d || !d && !s) && ((Cs(r) !== "body" || Ka(a)) && (u = Rl(r)), Kn(r))) {
    const h = oi(r);
    l = Zi(r), c.x = h.x + r.clientLeft, c.y = h.y + r.clientTop;
  }
  const f = a && !d && !s ? n2(a, u) : Gn(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - u.scrollLeft * l.x + c.x + f.x,
    y: n.y * l.y - u.scrollTop * l.y + c.y + f.y
  };
}
function _W(t) {
  return Array.from(t.getClientRects());
}
function RW(t) {
  const e = Jn(t), n = Rl(t), r = t.ownerDocument.body, i = ln(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = ln(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let a = -n.scrollLeft + wl(t);
  const o = -n.scrollTop;
  return Ln(r).direction === "rtl" && (a += ln(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: a,
    y: o
  };
}
const T1 = 25;
function wW(t, e) {
  const n = dn(t), r = Jn(t), i = n.visualViewport;
  let s = r.clientWidth, a = r.clientHeight, o = 0, u = 0;
  if (i) {
    s = i.width, a = i.height;
    const c = p0();
    (!c || c && e === "fixed") && (o = i.offsetLeft, u = i.offsetTop);
  }
  const l = wl(r);
  if (l <= 0) {
    const c = r.ownerDocument, d = c.body, f = getComputedStyle(d), h = c.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, m = Math.abs(r.clientWidth - d.clientWidth - h);
    m <= T1 && (s -= m);
  } else l <= T1 && (s += l);
  return {
    width: s,
    height: a,
    x: o,
    y: u
  };
}
const kW = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function DW(t, e) {
  const n = oi(t, !0, e === "fixed"), r = n.top + t.clientTop, i = n.left + t.clientLeft, s = Kn(t) ? Zi(t) : Gn(1), a = t.clientWidth * s.x, o = t.clientHeight * s.y, u = i * s.x, l = r * s.y;
  return {
    width: a,
    height: o,
    x: u,
    y: l
  };
}
function S1(t, e, n) {
  let r;
  if (e === "viewport")
    r = wW(t, n);
  else if (e === "document")
    r = RW(Jn(t));
  else if (Cn(e))
    r = DW(e, n);
  else {
    const i = t2(t);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return qu(r);
}
function r2(t, e) {
  const n = Fr(t);
  return n === e || !Cn(n) || fs(n) ? !1 : Ln(n).position === "fixed" || r2(n, e);
}
function PW(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = ka(t, [], !1).filter((o) => Cn(o) && Cs(o) !== "body"), i = null;
  const s = Ln(t).position === "fixed";
  let a = s ? Fr(t) : t;
  for (; Cn(a) && !fs(a); ) {
    const o = Ln(a), u = m0(a);
    !u && o.position === "fixed" && (i = null), (s ? !u && !i : !u && o.position === "static" && !!i && kW.has(i.position) || Ka(a) && !u && r2(t, a)) ? r = r.filter((c) => c !== a) : i = o, a = Fr(a);
  }
  return e.set(t, r), r;
}
function OW(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = t;
  const a = [...n === "clippingAncestors" ? _l(e) ? [] : PW(e, this._c) : [].concat(n), r], o = a[0], u = a.reduce((l, c) => {
    const d = S1(e, c, i);
    return l.top = ln(d.top, l.top), l.right = Mr(d.right, l.right), l.bottom = Mr(d.bottom, l.bottom), l.left = ln(d.left, l.left), l;
  }, S1(e, o, i));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function NW(t) {
  const {
    width: e,
    height: n
  } = e2(t);
  return {
    width: e,
    height: n
  };
}
function MW(t, e, n) {
  const r = Kn(e), i = Jn(e), s = n === "fixed", a = oi(t, !0, s, e);
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = Gn(0);
  function l() {
    u.x = wl(i);
  }
  if (r || !r && !s)
    if ((Cs(e) !== "body" || Ka(i)) && (o = Rl(e)), r) {
      const h = oi(e, !0, s, e);
      u.x = h.x + e.clientLeft, u.y = h.y + e.clientTop;
    } else i && l();
  s && !r && i && l();
  const c = i && !r && !s ? n2(i, o) : Gn(0), d = a.left + o.scrollLeft - u.x - c.x, f = a.top + o.scrollTop - u.y - c.y;
  return {
    x: d,
    y: f,
    width: a.width,
    height: a.height
  };
}
function zc(t) {
  return Ln(t).position === "static";
}
function x1(t, e) {
  if (!Kn(t) || Ln(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Jn(t) === n && (n = n.ownerDocument.body), n;
}
function i2(t, e) {
  const n = dn(t);
  if (_l(t))
    return n;
  if (!Kn(t)) {
    let i = Fr(t);
    for (; i && !fs(i); ) {
      if (Cn(i) && !zc(i))
        return i;
      i = Fr(i);
    }
    return n;
  }
  let r = x1(t, e);
  for (; r && EW(r) && zc(r); )
    r = x1(r, e);
  return r && fs(r) && zc(r) && !m0(r) ? n : r || vW(t) || n;
}
const FW = async function(t) {
  const e = this.getOffsetParent || i2, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: MW(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function BW(t) {
  return Ln(t).direction === "rtl";
}
const $W = {
  convertOffsetParentRelativeRectToViewportRelativeRect: LW,
  getDocumentElement: Jn,
  getClippingRect: OW,
  getOffsetParent: i2,
  getElementRects: FW,
  getClientRects: _W,
  getDimensions: NW,
  getScale: Zi,
  isElement: Cn,
  isRTL: BW
};
function s2(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function UW(t, e) {
  let n = null, r;
  const i = Jn(t);
  function s() {
    var o;
    clearTimeout(r), (o = n) == null || o.disconnect(), n = null;
  }
  function a(o, u) {
    o === void 0 && (o = !1), u === void 0 && (u = 1), s();
    const l = t.getBoundingClientRect(), {
      left: c,
      top: d,
      width: f,
      height: h
    } = l;
    if (o || e(), !f || !h)
      return;
    const m = Bo(d), p = Bo(i.clientWidth - (c + f)), g = Bo(i.clientHeight - (d + h)), b = Bo(c), T = {
      rootMargin: -m + "px " + -p + "px " + -g + "px " + -b + "px",
      threshold: ln(0, Mr(1, u)) || 1
    };
    let S = !0;
    function I(C) {
      const _ = C[0].intersectionRatio;
      if (_ !== u) {
        if (!S)
          return a();
        _ ? a(!1, _) : r = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      _ === 1 && !s2(l, t.getBoundingClientRect()) && a(), S = !1;
    }
    try {
      n = new IntersectionObserver(I, {
        ...T,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(I, T);
    }
    n.observe(t);
  }
  return a(!0), s;
}
function HW(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = r, l = g0(t), c = i || s ? [...l ? ka(l) : [], ...ka(e)] : [];
  c.forEach((b) => {
    i && b.addEventListener("scroll", n, {
      passive: !0
    }), s && b.addEventListener("resize", n);
  });
  const d = l && o ? UW(l, n) : null;
  let f = -1, h = null;
  a && (h = new ResizeObserver((b) => {
    let [y] = b;
    y && y.target === l && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var T;
      (T = h) == null || T.observe(e);
    })), n();
  }), l && !u && h.observe(l), h.observe(e));
  let m, p = u ? oi(t) : null;
  u && g();
  function g() {
    const b = oi(t);
    p && !s2(p, b) && n(), p = b, m = requestAnimationFrame(g);
  }
  return n(), () => {
    var b;
    c.forEach((y) => {
      i && y.removeEventListener("scroll", n), s && y.removeEventListener("resize", n);
    }), d == null || d(), (b = h) == null || b.disconnect(), h = null, u && cancelAnimationFrame(m);
  };
}
const VW = fW, GW = hW, zW = lW, qW = pW, WW = cW, v1 = uW, KW = mW, jW = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: $W,
    ...n
  }, s = {
    ...i.platform,
    _c: r
  };
  return oW(t, e, {
    ...i,
    platform: s
  });
};
var YW = typeof document < "u", XW = function() {
}, au = YW ? W1 : XW;
function Wu(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, i;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Wu(t[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(t), n = i.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && t.$$typeof) && !Wu(t[s], e[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function a2(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function A1(t, e) {
  const n = a2(t);
  return Math.round(e * n) / n;
}
function qc(t) {
  const e = M.useRef(t);
  return au(() => {
    e.current = t;
  }), e;
}
function QW(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: a
    } = {},
    transform: o = !0,
    whileElementsMounted: u,
    open: l
  } = t, [c, d] = M.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = M.useState(r);
  Wu(f, r) || h(r);
  const [m, p] = M.useState(null), [g, b] = M.useState(null), y = M.useCallback((V) => {
    V !== C.current && (C.current = V, p(V));
  }, []), T = M.useCallback((V) => {
    V !== _.current && (_.current = V, b(V));
  }, []), S = s || m, I = a || g, C = M.useRef(null), _ = M.useRef(null), R = M.useRef(c), k = u != null, A = qc(u), L = qc(i), P = qc(l), $ = M.useCallback(() => {
    if (!C.current || !_.current)
      return;
    const V = {
      placement: e,
      strategy: n,
      middleware: f
    };
    L.current && (V.platform = L.current), jW(C.current, _.current, V).then((K) => {
      const w = {
        ...K,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: P.current !== !1
      };
      G.current && !Wu(R.current, w) && (R.current = w, Yu.flushSync(() => {
        d(w);
      }));
    });
  }, [f, e, n, L, P]);
  au(() => {
    l === !1 && R.current.isPositioned && (R.current.isPositioned = !1, d((V) => ({
      ...V,
      isPositioned: !1
    })));
  }, [l]);
  const G = M.useRef(!1);
  au(() => (G.current = !0, () => {
    G.current = !1;
  }), []), au(() => {
    if (S && (C.current = S), I && (_.current = I), S && I) {
      if (A.current)
        return A.current(S, I, $);
      $();
    }
  }, [S, I, $, A, k]);
  const N = M.useMemo(() => ({
    reference: C,
    floating: _,
    setReference: y,
    setFloating: T
  }), [y, T]), U = M.useMemo(() => ({
    reference: S,
    floating: I
  }), [S, I]), B = M.useMemo(() => {
    const V = {
      position: n,
      left: 0,
      top: 0
    };
    if (!U.floating)
      return V;
    const K = A1(U.floating, c.x), w = A1(U.floating, c.y);
    return o ? {
      ...V,
      transform: "translate(" + K + "px, " + w + "px)",
      ...a2(U.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: K,
      top: w
    };
  }, [n, o, U.floating, c.x, c.y]);
  return M.useMemo(() => ({
    ...c,
    update: $,
    refs: N,
    elements: U,
    floatingStyles: B
  }), [c, $, N, U, B]);
}
const ZW = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? v1({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? v1({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, JW = (t, e) => ({
  ...VW(t),
  options: [t, e]
}), eK = (t, e) => ({
  ...GW(t),
  options: [t, e]
}), tK = (t, e) => ({
  ...KW(t),
  options: [t, e]
}), nK = (t, e) => ({
  ...zW(t),
  options: [t, e]
}), rK = (t, e) => ({
  ...qW(t),
  options: [t, e]
}), iK = (t, e) => ({
  ...WW(t),
  options: [t, e]
}), sK = (t, e) => ({
  ...ZW(t),
  options: [t, e]
});
var aK = "Arrow", o2 = M.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: i = 5, ...s } = t;
  return /* @__PURE__ */ ee(
    $e.svg,
    {
      ...s,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ ee("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
o2.displayName = aK;
var oK = o2, b0 = "Popper", [u2, kl] = jn(b0), [uK, l2] = u2(b0), c2 = (t) => {
  const { __scopePopper: e, children: n } = t, [r, i] = M.useState(null);
  return /* @__PURE__ */ ee(uK, { scope: e, anchor: r, onAnchorChange: i, children: n });
};
c2.displayName = b0;
var d2 = "PopperAnchor", f2 = M.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...i } = t, s = l2(d2, n), a = M.useRef(null), o = Je(e, a), u = M.useRef(null);
    return M.useEffect(() => {
      const l = u.current;
      u.current = (r == null ? void 0 : r.current) || a.current, l !== u.current && s.onAnchorChange(u.current);
    }), r ? null : /* @__PURE__ */ ee($e.div, { ...i, ref: o });
  }
);
f2.displayName = d2;
var E0 = "PopperContent", [lK, cK] = u2(E0), h2 = M.forwardRef(
  (t, e) => {
    var X, fe, Te, me, ye, Ee;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: a = 0,
      arrowPadding: o = 0,
      avoidCollisions: u = !0,
      collisionBoundary: l = [],
      collisionPadding: c = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: m,
      ...p
    } = t, g = l2(E0, n), [b, y] = M.useState(null), T = Je(e, (He) => y(He)), [S, I] = M.useState(null), C = fh(S), _ = (C == null ? void 0 : C.width) ?? 0, R = (C == null ? void 0 : C.height) ?? 0, k = r + (s !== "center" ? "-" + s : ""), A = typeof c == "number" ? c : { top: 0, right: 0, bottom: 0, left: 0, ...c }, L = Array.isArray(l) ? l : [l], P = L.length > 0, $ = {
      padding: A,
      boundary: L.filter(fK),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: P
    }, { refs: G, floatingStyles: N, placement: U, isPositioned: B, middlewareData: V } = QW({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: k,
      whileElementsMounted: (...He) => HW(...He, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        JW({ mainAxis: i + R, alignmentAxis: a }),
        u && eK({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? tK() : void 0,
          ...$
        }),
        u && nK({ ...$ }),
        rK({
          ...$,
          apply: ({ elements: He, rects: at, availableWidth: bt, availableHeight: Le }) => {
            const { width: Ke, height: kt } = at.reference, Ot = He.floating.style;
            Ot.setProperty("--radix-popper-available-width", `${bt}px`), Ot.setProperty("--radix-popper-available-height", `${Le}px`), Ot.setProperty("--radix-popper-anchor-width", `${Ke}px`), Ot.setProperty("--radix-popper-anchor-height", `${kt}px`);
          }
        }),
        S && sK({ element: S, padding: o }),
        hK({ arrowWidth: _, arrowHeight: R }),
        f && iK({ strategy: "referenceHidden", ...$ })
      ]
    }), [K, w] = g2(U), Y = Pr(m);
    wt(() => {
      B && (Y == null || Y());
    }, [B, Y]);
    const J = (X = V.arrow) == null ? void 0 : X.x, D = (fe = V.arrow) == null ? void 0 : fe.y, te = ((Te = V.arrow) == null ? void 0 : Te.centerOffset) !== 0, [he, ie] = M.useState();
    return wt(() => {
      b && ie(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ ee(
      "div",
      {
        ref: G.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...N,
          transform: B ? N.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            (me = V.transformOrigin) == null ? void 0 : me.x,
            (ye = V.transformOrigin) == null ? void 0 : ye.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((Ee = V.hide) == null ? void 0 : Ee.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ ee(
          lK,
          {
            scope: n,
            placedSide: K,
            onArrowChange: I,
            arrowX: J,
            arrowY: D,
            shouldHideArrow: te,
            children: /* @__PURE__ */ ee(
              $e.div,
              {
                "data-side": K,
                "data-align": w,
                ...p,
                ref: T,
                style: {
                  ...p.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: B ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
h2.displayName = E0;
var m2 = "PopperArrow", dK = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, p2 = M.forwardRef(function(e, n) {
  const { __scopePopper: r, ...i } = e, s = cK(m2, r), a = dK[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ ee(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [a]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ ee(
          oK,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
p2.displayName = m2;
function fK(t) {
  return t !== null;
}
var hK = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var g, b, y;
    const { placement: n, rects: r, middlewareData: i } = e, a = ((g = i.arrow) == null ? void 0 : g.centerOffset) !== 0, o = a ? 0 : t.arrowWidth, u = a ? 0 : t.arrowHeight, [l, c] = g2(n), d = { start: "0%", center: "50%", end: "100%" }[c], f = (((b = i.arrow) == null ? void 0 : b.x) ?? 0) + o / 2, h = (((y = i.arrow) == null ? void 0 : y.y) ?? 0) + u / 2;
    let m = "", p = "";
    return l === "bottom" ? (m = a ? d : `${f}px`, p = `${-u}px`) : l === "top" ? (m = a ? d : `${f}px`, p = `${r.floating.height + u}px`) : l === "right" ? (m = `${-u}px`, p = a ? d : `${h}px`) : l === "left" && (m = `${r.floating.width + u}px`, p = a ? d : `${h}px`), { data: { x: m, y: p } };
  }
});
function g2(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var b2 = c2, y0 = f2, E2 = h2, y2 = p2, mK = "Portal", T2 = M.forwardRef((t, e) => {
  var o;
  const { container: n, ...r } = t, [i, s] = M.useState(!1);
  wt(() => s(!0), []);
  const a = n || i && ((o = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : o.body);
  return a ? UA.createPortal(/* @__PURE__ */ ee($e.div, { ...r, ref: e }), a) : null;
});
T2.displayName = mK;
var pK = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, ki = /* @__PURE__ */ new WeakMap(), $o = /* @__PURE__ */ new WeakMap(), Uo = {}, Wc = 0, S2 = function(t) {
  return t && (t.host || S2(t.parentNode));
}, gK = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = S2(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, bK = function(t, e, n, r) {
  var i = gK(e, Array.isArray(t) ? t : [t]);
  Uo[n] || (Uo[n] = /* @__PURE__ */ new WeakMap());
  var s = Uo[n], a = [], o = /* @__PURE__ */ new Set(), u = new Set(i), l = function(d) {
    !d || o.has(d) || (o.add(d), l(d.parentNode));
  };
  i.forEach(l);
  var c = function(d) {
    !d || u.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (o.has(f))
        c(f);
      else
        try {
          var h = f.getAttribute(r), m = h !== null && h !== "false", p = (ki.get(f) || 0) + 1, g = (s.get(f) || 0) + 1;
          ki.set(f, p), s.set(f, g), a.push(f), p === 1 && m && $o.set(f, !0), g === 1 && f.setAttribute(n, "true"), m || f.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", f, b);
        }
    });
  };
  return c(e), o.clear(), Wc++, function() {
    a.forEach(function(d) {
      var f = ki.get(d) - 1, h = s.get(d) - 1;
      ki.set(d, f), s.set(d, h), f || ($o.has(d) || d.removeAttribute(r), $o.delete(d)), h || d.removeAttribute(n);
    }), Wc--, Wc || (ki = /* @__PURE__ */ new WeakMap(), ki = /* @__PURE__ */ new WeakMap(), $o = /* @__PURE__ */ new WeakMap(), Uo = {});
  };
}, x2 = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), i = pK(t);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live], script"))), bK(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Bn = function() {
  return Bn = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Bn.apply(this, arguments);
};
function v2(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
}
function EK(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, i = e.length, s; r < i; r++)
    (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var ou = "right-scroll-bar-position", uu = "width-before-scroll-bar", yK = "with-scroll-bars-hidden", TK = "--removed-body-scroll-bar-size";
function Kc(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function SK(t, e) {
  var n = Be(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var xK = typeof window < "u" ? M.useLayoutEffect : M.useEffect, I1 = /* @__PURE__ */ new WeakMap();
function vK(t, e) {
  var n = SK(null, function(r) {
    return t.forEach(function(i) {
      return Kc(i, r);
    });
  });
  return xK(function() {
    var r = I1.get(n);
    if (r) {
      var i = new Set(r), s = new Set(t), a = n.current;
      i.forEach(function(o) {
        s.has(o) || Kc(o, null);
      }), s.forEach(function(o) {
        i.has(o) || Kc(o, a);
      });
    }
    I1.set(n, t);
  }, [t]), n;
}
function AK(t) {
  return t;
}
function IK(t, e) {
  e === void 0 && (e = AK);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(s) {
      var a = e(s, r);
      return n.push(a), function() {
        n = n.filter(function(o) {
          return o !== a;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(s);
      }
      n = {
        push: function(o) {
          return s(o);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var a = [];
      if (n.length) {
        var o = n;
        n = [], o.forEach(s), a = n;
      }
      var u = function() {
        var c = a;
        a = [], c.forEach(s);
      }, l = function() {
        return Promise.resolve().then(u);
      };
      l(), n = {
        push: function(c) {
          a.push(c), l();
        },
        filter: function(c) {
          return a = a.filter(c), n;
        }
      };
    }
  };
  return i;
}
function CK(t) {
  t === void 0 && (t = {});
  var e = IK(null);
  return e.options = Bn({ async: !0, ssr: !1 }, t), e;
}
var A2 = function(t) {
  var e = t.sideCar, n = v2(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return M.createElement(r, Bn({}, n));
};
A2.isSideCarExport = !0;
function LK(t, e) {
  return t.useMedium(e), A2;
}
var I2 = CK(), jc = function() {
}, Dl = M.forwardRef(function(t, e) {
  var n = M.useRef(null), r = M.useState({
    onScrollCapture: jc,
    onWheelCapture: jc,
    onTouchMoveCapture: jc
  }), i = r[0], s = r[1], a = t.forwardProps, o = t.children, u = t.className, l = t.removeScrollBar, c = t.enabled, d = t.shards, f = t.sideCar, h = t.noRelative, m = t.noIsolation, p = t.inert, g = t.allowPinchZoom, b = t.as, y = b === void 0 ? "div" : b, T = t.gapMode, S = v2(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), I = f, C = vK([n, e]), _ = Bn(Bn({}, S), i);
  return M.createElement(
    M.Fragment,
    null,
    c && M.createElement(I, { sideCar: I2, removeScrollBar: l, shards: d, noRelative: h, noIsolation: m, inert: p, setCallbacks: s, allowPinchZoom: !!g, lockRef: n, gapMode: T }),
    a ? M.cloneElement(M.Children.only(o), Bn(Bn({}, _), { ref: C })) : M.createElement(y, Bn({}, _, { className: u, ref: C }), o)
  );
});
Dl.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Dl.classNames = {
  fullWidth: uu,
  zeroRight: ou
};
var _K = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function RK() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = _K();
  return e && t.setAttribute("nonce", e), t;
}
function wK(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function kK(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var DK = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = RK()) && (wK(e, n), kK(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, PK = function() {
  var t = DK();
  return function(e, n) {
    M.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, C2 = function() {
  var t = PK(), e = function(n) {
    var r = n.styles, i = n.dynamic;
    return t(r, i), null;
  };
  return e;
}, OK = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Yc = function(t) {
  return parseInt(t || "", 10) || 0;
}, NK = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], i = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Yc(n), Yc(r), Yc(i)];
}, MK = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return OK;
  var e = NK(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, FK = C2(), Ji = "data-scroll-locked", BK = function(t, e, n, r) {
  var i = t.left, s = t.top, a = t.right, o = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(yK, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(o, "px ").concat(r, `;
  }
  body[`).concat(Ji, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(o, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(o, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ou, ` {
    right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat(uu, ` {
    margin-right: `).concat(o, "px ").concat(r, `;
  }
  
  .`).concat(ou, " .").concat(ou, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(uu, " .").concat(uu, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Ji, `] {
    `).concat(TK, ": ").concat(o, `px;
  }
`);
}, C1 = function() {
  var t = parseInt(document.body.getAttribute(Ji) || "0", 10);
  return isFinite(t) ? t : 0;
}, $K = function() {
  M.useEffect(function() {
    return document.body.setAttribute(Ji, (C1() + 1).toString()), function() {
      var t = C1() - 1;
      t <= 0 ? document.body.removeAttribute(Ji) : document.body.setAttribute(Ji, t.toString());
    };
  }, []);
}, UK = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, i = r === void 0 ? "margin" : r;
  $K();
  var s = M.useMemo(function() {
    return MK(i);
  }, [i]);
  return M.createElement(FK, { styles: BK(s, !e, i, n ? "" : "!important") });
}, gf = !1;
if (typeof window < "u")
  try {
    var Ho = Object.defineProperty({}, "passive", {
      get: function() {
        return gf = !0, !0;
      }
    });
    window.addEventListener("test", Ho, Ho), window.removeEventListener("test", Ho, Ho);
  } catch {
    gf = !1;
  }
var Di = gf ? { passive: !1 } : !1, HK = function(t) {
  return t.tagName === "TEXTAREA";
}, L2 = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !HK(t) && n[e] === "visible")
  );
}, VK = function(t) {
  return L2(t, "overflowY");
}, GK = function(t) {
  return L2(t, "overflowX");
}, L1 = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = _2(t, r);
    if (i) {
      var s = R2(t, r), a = s[1], o = s[2];
      if (a > o)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, zK = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, qK = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, _2 = function(t, e) {
  return t === "v" ? VK(e) : GK(e);
}, R2 = function(t, e) {
  return t === "v" ? zK(e) : qK(e);
}, WK = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, KK = function(t, e, n, r, i) {
  var s = WK(t, window.getComputedStyle(e).direction), a = s * r, o = n.target, u = e.contains(o), l = !1, c = a > 0, d = 0, f = 0;
  do {
    if (!o)
      break;
    var h = R2(t, o), m = h[0], p = h[1], g = h[2], b = p - g - s * m;
    (m || b) && _2(t, o) && (d += b, f += m);
    var y = o.parentNode;
    o = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
  } while (
    // portaled content
    !u && o !== document.body || // self content
    u && (e.contains(o) || e === o)
  );
  return (c && Math.abs(d) < 1 || !c && Math.abs(f) < 1) && (l = !0), l;
}, Vo = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, _1 = function(t) {
  return [t.deltaX, t.deltaY];
}, R1 = function(t) {
  return t && "current" in t ? t.current : t;
}, jK = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, YK = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, XK = 0, Pi = [];
function QK(t) {
  var e = M.useRef([]), n = M.useRef([0, 0]), r = M.useRef(), i = M.useState(XK++)[0], s = M.useState(C2)[0], a = M.useRef(t);
  M.useEffect(function() {
    a.current = t;
  }, [t]), M.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var p = EK([t.lockRef.current], (t.shards || []).map(R1), !0).filter(Boolean);
      return p.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), p.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var o = M.useCallback(function(p, g) {
    if ("touches" in p && p.touches.length === 2 || p.type === "wheel" && p.ctrlKey)
      return !a.current.allowPinchZoom;
    var b = Vo(p), y = n.current, T = "deltaX" in p ? p.deltaX : y[0] - b[0], S = "deltaY" in p ? p.deltaY : y[1] - b[1], I, C = p.target, _ = Math.abs(T) > Math.abs(S) ? "h" : "v";
    if ("touches" in p && _ === "h" && C.type === "range")
      return !1;
    var R = L1(_, C);
    if (!R)
      return !0;
    if (R ? I = _ : (I = _ === "v" ? "h" : "v", R = L1(_, C)), !R)
      return !1;
    if (!r.current && "changedTouches" in p && (T || S) && (r.current = I), !I)
      return !0;
    var k = r.current || I;
    return KK(k, g, p, k === "h" ? T : S);
  }, []), u = M.useCallback(function(p) {
    var g = p;
    if (!(!Pi.length || Pi[Pi.length - 1] !== s)) {
      var b = "deltaY" in g ? _1(g) : Vo(g), y = e.current.filter(function(I) {
        return I.name === g.type && (I.target === g.target || g.target === I.shadowParent) && jK(I.delta, b);
      })[0];
      if (y && y.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!y) {
        var T = (a.current.shards || []).map(R1).filter(Boolean).filter(function(I) {
          return I.contains(g.target);
        }), S = T.length > 0 ? o(g, T[0]) : !a.current.noIsolation;
        S && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = M.useCallback(function(p, g, b, y) {
    var T = { name: p, delta: g, target: b, should: y, shadowParent: ZK(b) };
    e.current.push(T), setTimeout(function() {
      e.current = e.current.filter(function(S) {
        return S !== T;
      });
    }, 1);
  }, []), c = M.useCallback(function(p) {
    n.current = Vo(p), r.current = void 0;
  }, []), d = M.useCallback(function(p) {
    l(p.type, _1(p), p.target, o(p, t.lockRef.current));
  }, []), f = M.useCallback(function(p) {
    l(p.type, Vo(p), p.target, o(p, t.lockRef.current));
  }, []);
  M.useEffect(function() {
    return Pi.push(s), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", u, Di), document.addEventListener("touchmove", u, Di), document.addEventListener("touchstart", c, Di), function() {
      Pi = Pi.filter(function(p) {
        return p !== s;
      }), document.removeEventListener("wheel", u, Di), document.removeEventListener("touchmove", u, Di), document.removeEventListener("touchstart", c, Di);
    };
  }, []);
  var h = t.removeScrollBar, m = t.inert;
  return M.createElement(
    M.Fragment,
    null,
    m ? M.createElement(s, { styles: YK(i) }) : null,
    h ? M.createElement(UK, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function ZK(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const JK = LK(I2, QK);
var T0 = M.forwardRef(function(t, e) {
  return M.createElement(Dl, Bn({}, t, { ref: e, sideCar: JK }));
});
T0.classNames = Dl.classNames;
var Pl = "Popover", [w2] = jn(Pl, [
  kl
]), ja = kl(), [ej, Ti] = w2(Pl), k2 = (t) => {
  const {
    __scopePopover: e,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: a = !1
  } = t, o = ja(e), u = M.useRef(null), [l, c] = M.useState(!1), [d, f] = kr({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Pl
  });
  return /* @__PURE__ */ ee(b2, { ...o, children: /* @__PURE__ */ ee(
    ej,
    {
      scope: e,
      contentId: di(),
      triggerRef: u,
      open: d,
      onOpenChange: f,
      onOpenToggle: M.useCallback(() => f((h) => !h), [f]),
      hasCustomAnchor: l,
      onCustomAnchorAdd: M.useCallback(() => c(!0), []),
      onCustomAnchorRemove: M.useCallback(() => c(!1), []),
      modal: a,
      children: n
    }
  ) });
};
k2.displayName = Pl;
var D2 = "PopoverAnchor", tj = M.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = Ti(D2, n), s = ja(n), { onCustomAnchorAdd: a, onCustomAnchorRemove: o } = i;
    return M.useEffect(() => (a(), () => o()), [a, o]), /* @__PURE__ */ ee(y0, { ...s, ...r, ref: e });
  }
);
tj.displayName = D2;
var P2 = "PopoverTrigger", O2 = M.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = Ti(P2, n), s = ja(n), a = Je(e, i.triggerRef), o = /* @__PURE__ */ ee(
      $e.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": U2(i.open),
        ...r,
        ref: a,
        onClick: Oe(t.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? o : /* @__PURE__ */ ee(y0, { asChild: !0, ...s, children: o });
  }
);
O2.displayName = P2;
var nj = "PopoverPortal", [yQ, rj] = w2(nj, {
  forceMount: void 0
}), hs = "PopoverContent", N2 = M.forwardRef(
  (t, e) => {
    const n = rj(hs, t.__scopePopover), { forceMount: r = n.forceMount, ...i } = t, s = Ti(hs, t.__scopePopover);
    return /* @__PURE__ */ ee(Da, { present: r || s.open, children: s.modal ? /* @__PURE__ */ ee(sj, { ...i, ref: e }) : /* @__PURE__ */ ee(aj, { ...i, ref: e }) });
  }
);
N2.displayName = hs;
var ij = /* @__PURE__ */ ua("PopoverContent.RemoveScroll"), sj = M.forwardRef(
  (t, e) => {
    const n = Ti(hs, t.__scopePopover), r = M.useRef(null), i = Je(e, r), s = M.useRef(!1);
    return M.useEffect(() => {
      const a = r.current;
      if (a) return x2(a);
    }, []), /* @__PURE__ */ ee(T0, { as: ij, allowPinchZoom: !0, children: /* @__PURE__ */ ee(
      M2,
      {
        ...t,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Oe(t.onCloseAutoFocus, (a) => {
          var o;
          a.preventDefault(), s.current || (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Oe(
          t.onPointerDownOutside,
          (a) => {
            const o = a.detail.originalEvent, u = o.button === 0 && o.ctrlKey === !0, l = o.button === 2 || u;
            s.current = l;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Oe(
          t.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), aj = M.forwardRef(
  (t, e) => {
    const n = Ti(hs, t.__scopePopover), r = M.useRef(!1), i = M.useRef(!1);
    return /* @__PURE__ */ ee(
      M2,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var a, o;
          (a = t.onCloseAutoFocus) == null || a.call(t, s), s.defaultPrevented || (r.current || (o = n.triggerRef.current) == null || o.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var u, l;
          (u = t.onInteractOutside) == null || u.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const a = s.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(a)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), M2 = M.forwardRef(
  (t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEscapeKeyDown: o,
      onPointerDownOutside: u,
      onFocusOutside: l,
      onInteractOutside: c,
      ...d
    } = t, f = Ti(hs, n), h = ja(n);
    return jv(), /* @__PURE__ */ ee(
      c0,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ ee(
          l0,
          {
            asChild: !0,
            disableOutsidePointerEvents: a,
            onInteractOutside: c,
            onEscapeKeyDown: o,
            onPointerDownOutside: u,
            onFocusOutside: l,
            onDismiss: () => f.onOpenChange(!1),
            children: /* @__PURE__ */ ee(
              E2,
              {
                "data-state": U2(f.open),
                role: "dialog",
                id: f.contentId,
                ...h,
                ...d,
                ref: e,
                style: {
                  ...d.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), F2 = "PopoverClose", B2 = M.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = Ti(F2, n);
    return /* @__PURE__ */ ee(
      $e.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Oe(t.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
B2.displayName = F2;
var oj = "PopoverArrow", $2 = M.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, i = ja(n);
    return /* @__PURE__ */ ee(y2, { ...i, ...r, ref: e });
  }
);
$2.displayName = oj;
function U2(t) {
  return t ? "open" : "closed";
}
var uj = k2, lj = O2, cj = N2, dj = B2, fj = $2;
const hj = db({
  "0%": { opacity: 0, transform: "translateY(1rem)" },
  "100%": { opacity: 1, transform: "translateY(0)" }
}), mj = db({
  "0%": { opacity: 0, transform: "translateY(1rem)" },
  "100%": { opacity: 1, transform: "translateY(0)" }
}), H2 = le(fj, {
  fill: "$secondaryAlt"
}), pj = le(dj, {
  position: "absolute",
  right: "0",
  top: "0",
  padding: "0.5rem",
  margin: "0",
  cursor: "pointer",
  border: "none",
  background: "none",
  fill: "inherit",
  "&:hover": {
    opacity: "0.75"
  }
}), gj = le(cj, {
  border: "none",
  backgroundColor: "white",
  fill: "inhrerit",
  padding: "1rem 2rem 1rem 1rem",
  width: "auto",
  minWidth: "200px",
  maxWidth: "350px",
  borderRadius: "3px",
  boxShadow: "5px 5px 13px #0002",
  /**
   * Animate toggle
   */
  animationDuration: "0.3s",
  animationTimingFunction: "cubic-bezier(0.16, 1, 0.3, 1)",
  '&[data-side="top"]': { animationName: mj },
  '&[data-side="bottom"]': { animationName: hj },
  /**
   *
   */
  '&[data-align="end"]': {
    [`& ${H2}`]: {
      margin: "0 0.7rem"
    }
  }
}), bj = le(lj, {
  display: "inline-flex",
  padding: "0.5rem 0",
  margin: "0 0.5rem 0 0",
  cursor: "pointer",
  border: "none",
  background: "none",
  "> button, > span": {
    margin: "0"
  }
}), Ej = le(uj, {
  boxSizing: "content-box"
}), yj = (t) => /* @__PURE__ */ v.createElement(bj, { ...t }, t.children), Tj = (t) => /* @__PURE__ */ v.createElement(gj, { ...t, sideOffset: 5, collisionPadding: 21 }, /* @__PURE__ */ v.createElement(H2, null), /* @__PURE__ */ v.createElement(pj, null, /* @__PURE__ */ v.createElement(Dt, { isSmall: !0 }, /* @__PURE__ */ v.createElement(Dt.Close, null))), t.children), Si = ({ children: t }) => /* @__PURE__ */ v.createElement(Ej, null, t);
Si.Trigger = yj;
Si.Content = Tj;
const Ku = le("div", {
  // Reset
  boxSizing: "border-box",
  // Custom
  display: "inline-flex",
  alignItems: "center",
  borderRadius: "2px",
  padding: "$1",
  marginBottom: "$2",
  marginRight: "$2",
  backgroundColor: "$lightGrey",
  color: "$richBlack50",
  textTransform: "uppercase",
  fontSize: "$2",
  objectFit: "contain",
  lineHeight: "1em !important",
  "&:last-child": {
    marginRight: "0"
  },
  [`${qv}`]: {
    position: "absolute",
    left: "$1",
    height: "$3",
    width: "$3"
  },
  variants: {
    isIcon: {
      true: { position: "relative", paddingLeft: "$5" }
    }
  }
}), lu = le("span", {
  background: "transparent",
  opacity: "0",
  border: "3px solid transparent",
  position: "absolute",
  width: "100%",
  height: "100%",
  zIndex: "0",
  left: "0",
  top: "0",
  transition: "$all"
}), V2 = le("span", {
  display: "flex"
}), Sj = le("span", {
  display: "flex",
  width: "1.2111rem",
  height: "0.7222rem"
}), xj = le("span", {
  display: "inline-flex",
  marginLeft: "5px",
  marginBottom: "-1px"
}), cu = le("div", {
  position: "relative",
  display: "flex",
  backgroundColor: "$secondaryAlt",
  width: "inherit",
  height: "100px",
  overflow: "hidden",
  borderRadius: "3px",
  ".media-thumbnail-lazyload": {
    width: "100%",
    height: "100%",
    borderRadius: "3px"
  },
  img: {
    width: "100%",
    height: "100%",
    objectFit: "cover",
    objectPosition: "top center",
    filter: "blur(0)",
    transform: "scale3d(1, 1, 1)",
    borderRadius: "3px",
    transition: "$all",
    color: "transparent"
  },
  [`& ${V2}`]: {
    position: "absolute",
    right: "0",
    bottom: "0",
    [`& ${Ku}`]: {
      display: "none",
      margin: "0",
      paddingLeft: "0",
      fontSize: "0.7222rem",
      backgroundColor: "#000d",
      color: "$secondary",
      fill: "$secondary",
      borderBottomLeftRadius: "0",
      borderTopRightRadius: "0"
    }
  }
}), bf = le(UT, {
  display: "flex",
  flexShrink: "0",
  padding: "0",
  cursor: "pointer",
  background: "none",
  border: "none",
  fontFamily: "inherit",
  lineHeight: "1.25em",
  fontSize: "1rem",
  textAlign: "left",
  figure: {
    margin: "0",
    width: "161.8px",
    figcaption: {
      marginTop: "0.5rem",
      fontWeight: "400",
      fontSize: "0.8333rem",
      display: "-webkit-box",
      overflow: "hidden",
      MozBoxOrient: "vertical",
      WebkitBoxOrient: "vertical",
      WebkitLineClamp: "5",
      "@sm": {
        fontSize: "0.8333rem"
      }
    }
  }
}), vj = le($T, {
  display: "flex",
  flexDirection: "row",
  flexGrow: "1",
  overflowX: "scroll",
  position: "relative",
  zIndex: "0",
  gap: "1rem",
  padding: "1.618rem 0"
}), Aj = le("div", {
  display: "flex",
  flexDirection: "row",
  "&[data-active='true']": {
    [`& ${bf}`]: {
      figcaption: {
        fontWeight: "700"
      },
      [`& ${Ku}`]: {
        backgroundColor: "$accent"
      },
      [`& ${lu}`]: {
        background: "#0003",
        opacity: "1",
        borderBottom: "3px solid $accent"
      },
      "&:first-of-type": {
        [`& ${lu}`]: {
          borderRight: "unset"
        }
      },
      "&:last-of-type": {
        [`& ${lu}`]: {
          borderLeft: "unset"
        }
      }
    }
  },
  [`& ${bf}`]: {
    [`& ${cu}`]: {
      borderRadius: "unset"
    },
    "&:first-of-type": {
      [`& ${cu}`]: {
        borderTopLeftRadius: "3px",
        borderBottomLeftRadius: "3px"
      }
    },
    "&:last-of-type": {
      [`& ${cu}`]: {
        borderTopRightRadius: "3px",
        borderBottomRightRadius: "3px"
      },
      [`& ${Ku}`]: {
        display: "flex"
      }
    }
  }
}), G2 = le("div", {
  position: "absolute",
  right: "1rem",
  top: "1rem",
  display: "flex",
  justifyContent: "flex-end",
  zIndex: "1"
}), Ij = le("input", {
  flexGrow: "1",
  border: "none",
  backgroundColor: "$secondaryMuted",
  color: "$primary",
  marginRight: "1rem",
  height: "2rem",
  padding: "0 1rem",
  borderRadius: "2rem",
  fontFamily: "inherit",
  fontSize: "1rem",
  lineHeight: "1rem",
  boxShadow: "inset 1px 1px 2px #0001",
  "&::placeholder": {
    color: "$primaryMuted"
  }
}), Vs = le("button", {
  display: "flex",
  background: "none",
  border: "none",
  width: "2rem !important",
  height: "2rem !important",
  padding: "0",
  margin: "0",
  fontWeight: "700",
  borderRadius: "2rem",
  backgroundColor: "$accent",
  color: "$secondary",
  cursor: "pointer",
  boxSizing: "content-box !important",
  transition: "$all",
  svg: {
    height: "60%",
    width: "60%",
    padding: "20%",
    fill: "$secondary",
    stroke: "$secondary",
    opacity: "1",
    filter: "drop-shadow(5px 5px 5px #000D)",
    boxSizing: "inherit",
    transition: "$all"
  },
  "&:disabled": {
    backgroundColor: "transparent",
    boxShadow: "none",
    svg: { opacity: "0.25" }
  }
}), Cj = le("div", {
  display: "flex",
  marginRight: "0.618rem",
  backgroundColor: "$accentAlt",
  borderRadius: "2rem",
  boxShadow: "5px 5px 5px #0003",
  color: "$secondary",
  alignItems: "center",
  "> span": {
    display: "flex",
    margin: "0 0.5rem",
    fontSize: "0.7222rem",
    fontWeight: "bold",
    gap: "0.25rem",
    em: {
      opacity: "0.25"
    }
  }
}), Lj = le("div", {
  display: "flex",
  position: "relative",
  zIndex: "1",
  width: "100%",
  padding: "0",
  transition: "$all",
  variants: {
    isToggle: {
      true: {
        paddingTop: "2.618rem",
        [`& ${G2}`]: {
          width: "calc(100% - 2rem)",
          "@sm": {
            width: "calc(100% - 2rem)"
          }
        }
      }
    }
  }
}), _j = (t, e) => {
  Se(() => {
    function n(r) {
      r.key === t && e();
    }
    return window.addEventListener("keyup", n), () => window.removeEventListener("keyup", n);
  }, []);
}, w1 = ({ title: t }) => /* @__PURE__ */ v.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ v.createElement("title", null, t), /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M244 400L100 256l144-144M120 256h292"
  }
)), k1 = ({ title: t }) => /* @__PURE__ */ v.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ v.createElement("title", null, t), /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M268 112l144 144-144 144M392 256H100"
  }
)), Rj = ({ title: t }) => /* @__PURE__ */ v.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ v.createElement("title", null, t), /* @__PURE__ */ v.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" })), wj = ({ title: t }) => /* @__PURE__ */ v.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ v.createElement("title", null, t), /* @__PURE__ */ v.createElement("path", { d: "M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z" })), kj = ({
  handleCanvasToggle: t,
  handleFilter: e,
  activeIndex: n,
  canvasLength: r,
  isRtlPaged: i = !1
}) => {
  const [s, a] = Be(!1), [o, u] = Be(!1), [l, c] = Be(!1), { t: d } = Zn();
  Se(() => {
    c(n === 0), n === r - 1 ? u(!0) : u(!1);
  }, [n, r]), _j("Escape", () => {
    a(!1), e("");
  });
  const f = () => {
    a((m) => !m), e("");
  }, h = (m) => e(m.target.value);
  return /* @__PURE__ */ v.createElement(
    Lj,
    {
      isToggle: s,
      className: "clover-viewer-media-controls"
    },
    /* @__PURE__ */ v.createElement(G2, null, s && /* @__PURE__ */ v.createElement(
      Ij,
      {
        autoFocus: !0,
        onChange: h,
        placeholder: d("commonSearchPlaceholder")
      }
    ), !s && /* @__PURE__ */ v.createElement(Cj, { className: "clover-viewer-media-navigation", "data-rtl-paged": i }, i ? /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
      Vs,
      {
        onClick: () => t(1),
        disabled: o,
        type: "button"
      },
      /* @__PURE__ */ v.createElement(w1, { title: d("commonNext") })
    ), /* @__PURE__ */ v.createElement("span", null, n + 1, " ", /* @__PURE__ */ v.createElement("em", null, "/"), " ", r), /* @__PURE__ */ v.createElement(
      Vs,
      {
        onClick: () => t(-1),
        disabled: l,
        type: "button"
      },
      /* @__PURE__ */ v.createElement(k1, { title: d("commonPrevious") })
    )) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
      Vs,
      {
        onClick: () => t(-1),
        disabled: l,
        type: "button"
      },
      /* @__PURE__ */ v.createElement(w1, { title: d("commonPrevious") })
    ), /* @__PURE__ */ v.createElement("span", null, n + 1, " ", /* @__PURE__ */ v.createElement("em", null, "/"), " ", r), /* @__PURE__ */ v.createElement(
      Vs,
      {
        onClick: () => t(1),
        disabled: o,
        type: "button"
      },
      /* @__PURE__ */ v.createElement(k1, { title: d("commonNext") })
    ))), /* @__PURE__ */ v.createElement(
      Vs,
      {
        onClick: f,
        type: "button",
        className: "clover-viewer-media-search"
      },
      s ? /* @__PURE__ */ v.createElement(Rj, { title: d("commonClose") }) : /* @__PURE__ */ v.createElement(wj, { title: d("commonSearch") })
    ))
  );
}, Dj = ({
  children: t,
  rootMargin: e = "100px",
  attributes: n = {},
  isVisibleCallback: r = () => {
  }
}) => {
  const i = ms(null), [s, a] = Be(!1);
  return Se(() => {
    const o = i.current;
    if (!o) return;
    const u = new IntersectionObserver(
      ([l]) => {
        l.isIntersecting && (r(!0), a(!0), u.disconnect());
      },
      { rootMargin: e }
    );
    return u.observe(o), () => u.disconnect();
  }, [i]), /* @__PURE__ */ v.createElement("div", { ref: i, ...n }, s ? t : null);
}, Pj = ({ type: t }) => {
  switch (t) {
    case "Sound":
      return /* @__PURE__ */ v.createElement(Dt.Audio, null);
    case "Image":
      return /* @__PURE__ */ v.createElement(Dt.Image, null);
    case "Video":
      return /* @__PURE__ */ v.createElement(Dt.Video, null);
    default:
      return /* @__PURE__ */ v.createElement(Dt.Image, null);
  }
}, Oj = ({
  canvas: t,
  canvasIndex: e,
  isActive: n,
  type: r,
  handleChange: i
}) => {
  const [s, a] = Be(!1), [o, u] = Be(), l = st(), { vault: c } = l, d = 200, f = t != null && t.label ? fn(t == null ? void 0 : t.label) : String(e + 1);
  Se(() => {
    s && (async () => {
      var m, p;
      try {
        if (((m = t == null ? void 0 : t.thumbnail) == null ? void 0 : m.length) !== 0)
          u((p = t == null ? void 0 : t.thumbnail[0]) == null ? void 0 : p.id);
        else {
          const { best: g } = await zA(t, {
            vault: c,
            dereference: !0,
            width: d,
            height: d
          });
          u(g == null ? void 0 : g.id);
        }
      } catch (g) {
        console.error("Error fetching thumbnail", g);
      }
    })();
  }, [t, s]);
  const h = (m) => {
    a(m);
  };
  return /* @__PURE__ */ v.createElement(
    bf,
    {
      "aria-checked": n,
      "data-testid": "media-thumbnail",
      "data-canvas": e,
      onClick: () => i(t.id),
      value: t.id
    },
    /* @__PURE__ */ v.createElement("figure", null, /* @__PURE__ */ v.createElement(cu, null, /* @__PURE__ */ v.createElement(
      Dj,
      {
        isVisibleCallback: h,
        attributes: {
          className: "media-thumbnail-lazyload",
          "data-lazyload": String(s),
          "data-testid": "media-thumbnail-lazyload"
        }
      },
      o && /* @__PURE__ */ v.createElement(
        "img",
        {
          alt: f,
          "data-testid": "media-thumbnail-image",
          src: o
        }
      )
    ), /* @__PURE__ */ v.createElement(lu, null), /* @__PURE__ */ v.createElement(V2, null, /* @__PURE__ */ v.createElement(Ku, { isIcon: !0, "data-testid": "thumbnail-tag" }, /* @__PURE__ */ v.createElement(Sj, null), /* @__PURE__ */ v.createElement(Dt, { "aria-label": r }, /* @__PURE__ */ v.createElement(Pj, { type: r })), ["Video", "Sound"].includes(r) && /* @__PURE__ */ v.createElement(xj, null, j1(t.duration))))), /* @__PURE__ */ v.createElement("figcaption", { "data-testid": "fig-caption" }, t.label ? /* @__PURE__ */ v.createElement(yr, { label: t.label }) : (e + 1).toString()))
  );
}, Nj = (t) => t.body ? t.body.type : "Image", Mj = ({ items: t }) => {
  const { t: e } = Zn(), n = jt(), r = st(), { activeCanvas: i, isPaged: s, vault: a, sequence: o, viewingDirection: u } = r, l = s && u === "right-to-left", [c, d] = Be(""), [f, h] = Be([]), [m, p] = Be(0), g = v.useRef(null), b = "painting", y = (I) => {
    i !== I && n({
      type: "updateActiveCanvas",
      canvasId: I
    });
  };
  Se(() => {
    if (!f.length) {
      const I = ["Image", "Sound", "Video"], C = t.map(
        (_) => ob(a, _, b, I)
      ).filter((_) => _.annotations.length > 0);
      h(C);
    }
  }, [t, f.length, a]), Se(() => {
    f.forEach((I, C) => {
      I != null && I.canvas && I.canvas.id === i && p(C);
    });
  }, [i, f]), Se(() => {
    const I = document.querySelector(
      `[data-canvas="${m}"]`
    );
    if (I instanceof HTMLElement && g.current) {
      const C = I.offsetLeft - g.current.offsetWidth / 2 + I.offsetWidth / 2;
      g.current.scrollTo({ left: C, behavior: "smooth" });
    }
  }, [m]);
  const T = (I) => d(I), S = (I) => {
    const C = o[1].findIndex(
      (A) => A.includes(m)
    ), _ = C + I >= 0 ? C + I : o[1].length - 1;
    if (!o[1][_]) return;
    const R = o[1][_][0], k = o[0][R].id;
    k && y(k);
  };
  return /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
    kj,
    {
      handleFilter: T,
      handleCanvasToggle: S,
      activeIndex: m,
      canvasLength: t.length,
      isRtlPaged: l
    }
  ), /* @__PURE__ */ v.createElement(
    vj,
    {
      "aria-label": e("media.selectItem"),
      "data-testid": "media",
      "data-active-canvas": t[m].id,
      "data-canvas-length": t.length,
      "data-filter": c,
      "data-rtl-paged": l,
      ref: g,
      style: { direction: l ? "rtl" : "ltr" }
    },
    o[1].filter((I) => I.some((C) => {
      var A;
      const _ = o[0][C].id, R = f.find((L) => {
        var P;
        return ((P = L == null ? void 0 : L.canvas) == null ? void 0 : P.id) === _;
      });
      if (!R) return !1;
      const k = fn((A = R == null ? void 0 : R.canvas) == null ? void 0 : A.label) || "";
      return !(c && !k.toLowerCase().includes(c.toLowerCase()));
    })).map((I, C) => {
      const _ = I.map((R) => o[0][R].id).includes(i);
      return /* @__PURE__ */ v.createElement(Aj, { "data-active": _, key: C }, I.map((R) => {
        var L, P;
        const k = o[0][R].id, A = f.find(($) => {
          var G;
          return ((G = $ == null ? void 0 : $.canvas) == null ? void 0 : G.id) === k;
        });
        return A ? /* @__PURE__ */ v.createElement(
          Oj,
          {
            canvas: A.canvas,
            canvasIndex: f.findIndex(($) => $ === A),
            handleChange: y,
            isActive: i === ((L = A == null ? void 0 : A.canvas) == null ? void 0 : L.id),
            key: (P = A == null ? void 0 : A.canvas) == null ? void 0 : P.id,
            type: Nj(A.annotations[0])
          }
        ) : null;
      }));
    })
  ));
}, z2 = le("button", {
  position: "absolute",
  background: "none",
  border: "none",
  cursor: "zoom-in",
  margin: "0",
  padding: "0",
  width: "100%",
  height: "100%",
  transition: "$all",
  opacity: 1,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  img: {
    width: "100%",
    height: "100%",
    objectFit: "contain",
    color: "transparent",
    aspectRatio: "auto"
  },
  "&[data-paged=true]": {
    "img:first-child ": {
      objectPosition: "100% 50%"
    },
    "img:last-child": {
      objectPosition: "0 50%"
    }
  },
  "&[data-active=false]": {
    opacity: 0,
    objectPosition: "50% 50%"
  },
  variants: {
    isMedia: {
      true: {
        cursor: "pointer"
      }
    }
  }
}), q2 = le("button", {
  display: "flex",
  height: "2rem",
  width: "2rem",
  borderRadius: "2rem",
  padding: "0",
  margin: "0",
  fontFamily: "inherit",
  background: "none",
  backgroundColor: "$primary",
  border: "none",
  color: "white",
  cursor: "pointer",
  marginLeft: "0.618rem",
  filter: "drop-shadow(2px 2px 5px #0003)",
  transition: "$all",
  boxSizing: "content-box !important",
  "&:first-child": {
    marginLeft: "0"
  },
  "@xs": {
    marginBottom: "0.618rem",
    marginLeft: "0",
    "&:last-child": {
      marginBottom: "0"
    }
  },
  svg: {
    height: "60%",
    width: "60%",
    padding: "20%",
    fill: "$secondary",
    stroke: "$secondary",
    filter: "drop-shadow(2px 2px 5px #0003)",
    transition: "$all",
    boxSizing: "inherit"
  },
  "&:hover, &:focus": {
    backgroundColor: "$accent"
  },
  "&[data-button=rotate-right]": {
    "&:hover, &:focus": {
      svg: {
        rotate: "45deg"
      }
    }
  },
  "&[data-button=rotate-left]": {
    transform: "scaleX(-1)",
    "&:hover, &:focus": {
      svg: {
        rotate: "45deg"
      }
    }
  },
  "&[data-button=reset]": {
    "&:hover, &:focus": {
      svg: {
        rotate: "-15deg"
      }
    }
  }
}), W2 = le(q2, {
  position: "absolute",
  width: "2rem",
  top: "1rem",
  right: "1rem",
  zIndex: 100,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  transition: "$all",
  borderRadius: "50%",
  backgroundColor: "$accent",
  cursor: "pointer",
  "&:hover, &:focus": {
    backgroundColor: "$accent !important"
  },
  variants: {
    isInteractive: {
      true: {
        "&:hover": {
          opacity: "1"
        }
      },
      false: {}
    },
    isMedia: {
      true: {
        cursor: "pointer !important"
      }
    }
  },
  compoundVariants: [
    {
      isInteractive: !1,
      isMedia: !0,
      css: {
        top: "50%",
        right: "50%",
        width: "4rem",
        height: "4rem",
        transform: "translate(50%,-50%)"
      }
    }
  ]
}), Fj = le("div", {
  position: "relative",
  display: "flex",
  flexDirection: "column",
  flexGrow: "1",
  flexShrink: "1",
  gap: "1rem",
  zIndex: "0",
  overflow: "hidden",
  "&:hover": {
    [`${W2}`]: {
      backgroundColor: "$accent"
    },
    [`${z2}`]: {
      backgroundColor: "#6662"
    }
  }
}), Bj = le("div", {
  width: "100%",
  height: "100%"
});
function D1(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
var K2 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), $j = "VisuallyHidden", Uj = M.forwardRef(
  (t, e) => /* @__PURE__ */ ee(
    $e.span,
    {
      ...t,
      ref: e,
      style: { ...K2, ...t.style }
    }
  )
);
Uj.displayName = $j;
var Hj = [" ", "Enter", "ArrowUp", "ArrowDown"], Vj = [" ", "Enter"], ui = "Select", [Ol, Nl, Gj] = mb(ui), [Ls] = jn(ui, [
  Gj,
  kl
]), Ml = kl(), [zj, Vr] = Ls(ui), [qj, Wj] = Ls(ui), j2 = (t) => {
  const {
    __scopeSelect: e,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    value: a,
    defaultValue: o,
    onValueChange: u,
    dir: l,
    name: c,
    autoComplete: d,
    disabled: f,
    required: h,
    form: m
  } = t, p = Ml(e), [g, b] = M.useState(null), [y, T] = M.useState(null), [S, I] = M.useState(!1), C = Qu(l), [_, R] = kr({
    prop: r,
    defaultProp: i ?? !1,
    onChange: s,
    caller: ui
  }), [k, A] = kr({
    prop: a,
    defaultProp: o,
    onChange: u,
    caller: ui
  }), L = M.useRef(null), P = g ? m || !!g.closest("form") : !0, [$, G] = M.useState(/* @__PURE__ */ new Set()), N = Array.from($).map((U) => U.props.value).join(";");
  return /* @__PURE__ */ ee(b2, { ...p, children: /* @__PURE__ */ es(
    zj,
    {
      required: h,
      scope: e,
      trigger: g,
      onTriggerChange: b,
      valueNode: y,
      onValueNodeChange: T,
      valueNodeHasChildren: S,
      onValueNodeHasChildrenChange: I,
      contentId: di(),
      value: k,
      onValueChange: A,
      open: _,
      onOpenChange: R,
      dir: C,
      triggerPointerDownPosRef: L,
      disabled: f,
      children: [
        /* @__PURE__ */ ee(Ol.Provider, { scope: e, children: /* @__PURE__ */ ee(
          qj,
          {
            scope: t.__scopeSelect,
            onNativeOptionAdd: M.useCallback((U) => {
              G((B) => new Set(B).add(U));
            }, []),
            onNativeOptionRemove: M.useCallback((U) => {
              G((B) => {
                const V = new Set(B);
                return V.delete(U), V;
              });
            }, []),
            children: n
          }
        ) }),
        P ? /* @__PURE__ */ es(
          EA,
          {
            "aria-hidden": !0,
            required: h,
            tabIndex: -1,
            name: c,
            autoComplete: d,
            value: k,
            onChange: (U) => A(U.target.value),
            disabled: f,
            form: m,
            children: [
              k === void 0 ? /* @__PURE__ */ ee("option", { value: "" }) : null,
              Array.from($)
            ]
          },
          N
        ) : null
      ]
    }
  ) });
};
j2.displayName = ui;
var Y2 = "SelectTrigger", X2 = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, disabled: r = !1, ...i } = t, s = Ml(n), a = Vr(Y2, n), o = a.disabled || r, u = Je(e, a.onTriggerChange), l = Nl(n), c = M.useRef("touch"), [d, f, h] = TA((p) => {
      const g = l().filter((T) => !T.disabled), b = g.find((T) => T.value === a.value), y = SA(g, p, b);
      y !== void 0 && a.onValueChange(y.value);
    }), m = (p) => {
      o || (a.onOpenChange(!0), h()), p && (a.triggerPointerDownPosRef.current = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      });
    };
    return /* @__PURE__ */ ee(y0, { asChild: !0, ...s, children: /* @__PURE__ */ ee(
      $e.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": a.contentId,
        "aria-expanded": a.open,
        "aria-required": a.required,
        "aria-autocomplete": "none",
        dir: a.dir,
        "data-state": a.open ? "open" : "closed",
        disabled: o,
        "data-disabled": o ? "" : void 0,
        "data-placeholder": yA(a.value) ? "" : void 0,
        ...i,
        ref: u,
        onClick: Oe(i.onClick, (p) => {
          p.currentTarget.focus(), c.current !== "mouse" && m(p);
        }),
        onPointerDown: Oe(i.onPointerDown, (p) => {
          c.current = p.pointerType;
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && g.releasePointerCapture(p.pointerId), p.button === 0 && p.ctrlKey === !1 && p.pointerType === "mouse" && (m(p), p.preventDefault());
        }),
        onKeyDown: Oe(i.onKeyDown, (p) => {
          const g = d.current !== "";
          !(p.ctrlKey || p.altKey || p.metaKey) && p.key.length === 1 && f(p.key), !(g && p.key === " ") && Hj.includes(p.key) && (m(), p.preventDefault());
        })
      }
    ) });
  }
);
X2.displayName = Y2;
var Q2 = "SelectValue", Z2 = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, className: r, style: i, children: s, placeholder: a = "", ...o } = t, u = Vr(Q2, n), { onValueNodeHasChildrenChange: l } = u, c = s !== void 0, d = Je(e, u.onValueNodeChange);
    return wt(() => {
      l(c);
    }, [l, c]), /* @__PURE__ */ ee(
      $e.span,
      {
        ...o,
        ref: d,
        style: { pointerEvents: "none" },
        children: yA(u.value) ? /* @__PURE__ */ ee(If, { children: a }) : s
      }
    );
  }
);
Z2.displayName = Q2;
var Kj = "SelectIcon", J2 = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, children: r, ...i } = t;
    return /* @__PURE__ */ ee($e.span, { "aria-hidden": !0, ...i, ref: e, children: r || "" });
  }
);
J2.displayName = Kj;
var jj = "SelectPortal", eA = (t) => /* @__PURE__ */ ee(T2, { asChild: !0, ...t });
eA.displayName = jj;
var li = "SelectContent", tA = M.forwardRef(
  (t, e) => {
    const n = Vr(li, t.__scopeSelect), [r, i] = M.useState();
    if (wt(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const s = r;
      return s ? Yu.createPortal(
        /* @__PURE__ */ ee(nA, { scope: t.__scopeSelect, children: /* @__PURE__ */ ee(Ol.Slot, { scope: t.__scopeSelect, children: /* @__PURE__ */ ee("div", { children: t.children }) }) }),
        s
      ) : null;
    }
    return /* @__PURE__ */ ee(rA, { ...t, ref: e });
  }
);
tA.displayName = li;
var Sn = 10, [nA, Gr] = Ls(li), Yj = "SelectContentImpl", Xj = /* @__PURE__ */ ua("SelectContent.RemoveScroll"), rA = M.forwardRef(
  (t, e) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: s,
      onPointerDownOutside: a,
      //
      // PopperContent props
      side: o,
      sideOffset: u,
      align: l,
      alignOffset: c,
      arrowPadding: d,
      collisionBoundary: f,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: g,
      //
      ...b
    } = t, y = Vr(li, n), [T, S] = M.useState(null), [I, C] = M.useState(null), _ = Je(e, (X) => S(X)), [R, k] = M.useState(null), [A, L] = M.useState(
      null
    ), P = Nl(n), [$, G] = M.useState(!1), N = M.useRef(!1);
    M.useEffect(() => {
      if (T) return x2(T);
    }, [T]), jv();
    const U = M.useCallback(
      (X) => {
        const [fe, ...Te] = P().map((Ee) => Ee.ref.current), [me] = Te.slice(-1), ye = document.activeElement;
        for (const Ee of X)
          if (Ee === ye || (Ee == null || Ee.scrollIntoView({ block: "nearest" }), Ee === fe && I && (I.scrollTop = 0), Ee === me && I && (I.scrollTop = I.scrollHeight), Ee == null || Ee.focus(), document.activeElement !== ye)) return;
      },
      [P, I]
    ), B = M.useCallback(
      () => U([R, T]),
      [U, R, T]
    );
    M.useEffect(() => {
      $ && B();
    }, [$, B]);
    const { onOpenChange: V, triggerPointerDownPosRef: K } = y;
    M.useEffect(() => {
      if (T) {
        let X = { x: 0, y: 0 };
        const fe = (me) => {
          var ye, Ee;
          X = {
            x: Math.abs(Math.round(me.pageX) - (((ye = K.current) == null ? void 0 : ye.x) ?? 0)),
            y: Math.abs(Math.round(me.pageY) - (((Ee = K.current) == null ? void 0 : Ee.y) ?? 0))
          };
        }, Te = (me) => {
          X.x <= 10 && X.y <= 10 ? me.preventDefault() : T.contains(me.target) || V(!1), document.removeEventListener("pointermove", fe), K.current = null;
        };
        return K.current !== null && (document.addEventListener("pointermove", fe), document.addEventListener("pointerup", Te, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", fe), document.removeEventListener("pointerup", Te, { capture: !0 });
        };
      }
    }, [T, V, K]), M.useEffect(() => {
      const X = () => V(!1);
      return window.addEventListener("blur", X), window.addEventListener("resize", X), () => {
        window.removeEventListener("blur", X), window.removeEventListener("resize", X);
      };
    }, [V]);
    const [w, Y] = TA((X) => {
      const fe = P().filter((ye) => !ye.disabled), Te = fe.find((ye) => ye.ref.current === document.activeElement), me = SA(fe, X, Te);
      me && setTimeout(() => me.ref.current.focus());
    }), J = M.useCallback(
      (X, fe, Te) => {
        const me = !N.current && !Te;
        (y.value !== void 0 && y.value === fe || me) && (k(X), me && (N.current = !0));
      },
      [y.value]
    ), D = M.useCallback(() => T == null ? void 0 : T.focus(), [T]), te = M.useCallback(
      (X, fe, Te) => {
        const me = !N.current && !Te;
        (y.value !== void 0 && y.value === fe || me) && L(X);
      },
      [y.value]
    ), he = r === "popper" ? Ef : iA, ie = he === Ef ? {
      side: o,
      sideOffset: u,
      align: l,
      alignOffset: c,
      arrowPadding: d,
      collisionBoundary: f,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: g
    } : {};
    return /* @__PURE__ */ ee(
      nA,
      {
        scope: n,
        content: T,
        viewport: I,
        onViewportChange: C,
        itemRefCallback: J,
        selectedItem: R,
        onItemLeave: D,
        itemTextRefCallback: te,
        focusSelectedItem: B,
        selectedItemText: A,
        position: r,
        isPositioned: $,
        searchRef: w,
        children: /* @__PURE__ */ ee(T0, { as: Xj, allowPinchZoom: !0, children: /* @__PURE__ */ ee(
          c0,
          {
            asChild: !0,
            trapped: y.open,
            onMountAutoFocus: (X) => {
              X.preventDefault();
            },
            onUnmountAutoFocus: Oe(i, (X) => {
              var fe;
              (fe = y.trigger) == null || fe.focus({ preventScroll: !0 }), X.preventDefault();
            }),
            children: /* @__PURE__ */ ee(
              l0,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: s,
                onPointerDownOutside: a,
                onFocusOutside: (X) => X.preventDefault(),
                onDismiss: () => y.onOpenChange(!1),
                children: /* @__PURE__ */ ee(
                  he,
                  {
                    role: "listbox",
                    id: y.contentId,
                    "data-state": y.open ? "open" : "closed",
                    dir: y.dir,
                    onContextMenu: (X) => X.preventDefault(),
                    ...b,
                    ...ie,
                    onPlaced: () => G(!0),
                    ref: _,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...b.style
                    },
                    onKeyDown: Oe(b.onKeyDown, (X) => {
                      const fe = X.ctrlKey || X.altKey || X.metaKey;
                      if (X.key === "Tab" && X.preventDefault(), !fe && X.key.length === 1 && Y(X.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(X.key)) {
                        let me = P().filter((ye) => !ye.disabled).map((ye) => ye.ref.current);
                        if (["ArrowUp", "End"].includes(X.key) && (me = me.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(X.key)) {
                          const ye = X.target, Ee = me.indexOf(ye);
                          me = me.slice(Ee + 1);
                        }
                        setTimeout(() => U(me)), X.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
rA.displayName = Yj;
var Qj = "SelectItemAlignedPosition", iA = M.forwardRef((t, e) => {
  const { __scopeSelect: n, onPlaced: r, ...i } = t, s = Vr(li, n), a = Gr(li, n), [o, u] = M.useState(null), [l, c] = M.useState(null), d = Je(e, (_) => c(_)), f = Nl(n), h = M.useRef(!1), m = M.useRef(!0), { viewport: p, selectedItem: g, selectedItemText: b, focusSelectedItem: y } = a, T = M.useCallback(() => {
    if (s.trigger && s.valueNode && o && l && p && g && b) {
      const _ = s.trigger.getBoundingClientRect(), R = l.getBoundingClientRect(), k = s.valueNode.getBoundingClientRect(), A = b.getBoundingClientRect();
      if (s.dir !== "rtl") {
        const ye = A.left - R.left, Ee = k.left - ye, He = _.left - Ee, at = _.width + He, bt = Math.max(at, R.width), Le = window.innerWidth - Sn, Ke = D1(Ee, [
          Sn,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Sn, Le - bt)
        ]);
        o.style.minWidth = at + "px", o.style.left = Ke + "px";
      } else {
        const ye = R.right - A.right, Ee = window.innerWidth - k.right - ye, He = window.innerWidth - _.right - Ee, at = _.width + He, bt = Math.max(at, R.width), Le = window.innerWidth - Sn, Ke = D1(Ee, [
          Sn,
          Math.max(Sn, Le - bt)
        ]);
        o.style.minWidth = at + "px", o.style.right = Ke + "px";
      }
      const L = f(), P = window.innerHeight - Sn * 2, $ = p.scrollHeight, G = window.getComputedStyle(l), N = parseInt(G.borderTopWidth, 10), U = parseInt(G.paddingTop, 10), B = parseInt(G.borderBottomWidth, 10), V = parseInt(G.paddingBottom, 10), K = N + U + $ + V + B, w = Math.min(g.offsetHeight * 5, K), Y = window.getComputedStyle(p), J = parseInt(Y.paddingTop, 10), D = parseInt(Y.paddingBottom, 10), te = _.top + _.height / 2 - Sn, he = P - te, ie = g.offsetHeight / 2, X = g.offsetTop + ie, fe = N + U + X, Te = K - fe;
      if (fe <= te) {
        const ye = L.length > 0 && g === L[L.length - 1].ref.current;
        o.style.bottom = "0px";
        const Ee = l.clientHeight - p.offsetTop - p.offsetHeight, He = Math.max(
          he,
          ie + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (ye ? D : 0) + Ee + B
        ), at = fe + He;
        o.style.height = at + "px";
      } else {
        const ye = L.length > 0 && g === L[0].ref.current;
        o.style.top = "0px";
        const He = Math.max(
          te,
          N + p.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (ye ? J : 0) + ie
        ) + Te;
        o.style.height = He + "px", p.scrollTop = fe - te + p.offsetTop;
      }
      o.style.margin = `${Sn}px 0`, o.style.minHeight = w + "px", o.style.maxHeight = P + "px", r == null || r(), requestAnimationFrame(() => h.current = !0);
    }
  }, [
    f,
    s.trigger,
    s.valueNode,
    o,
    l,
    p,
    g,
    b,
    s.dir,
    r
  ]);
  wt(() => T(), [T]);
  const [S, I] = M.useState();
  wt(() => {
    l && I(window.getComputedStyle(l).zIndex);
  }, [l]);
  const C = M.useCallback(
    (_) => {
      _ && m.current === !0 && (T(), y == null || y(), m.current = !1);
    },
    [T, y]
  );
  return /* @__PURE__ */ ee(
    Jj,
    {
      scope: n,
      contentWrapper: o,
      shouldExpandOnScrollRef: h,
      onScrollButtonChange: C,
      children: /* @__PURE__ */ ee(
        "div",
        {
          ref: u,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: S
          },
          children: /* @__PURE__ */ ee(
            $e.div,
            {
              ...i,
              ref: d,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
iA.displayName = Qj;
var Zj = "SelectPopperPosition", Ef = M.forwardRef((t, e) => {
  const {
    __scopeSelect: n,
    align: r = "start",
    collisionPadding: i = Sn,
    ...s
  } = t, a = Ml(n);
  return /* @__PURE__ */ ee(
    E2,
    {
      ...a,
      ...s,
      ref: e,
      align: r,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
Ef.displayName = Zj;
var [Jj, S0] = Ls(li, {}), yf = "SelectViewport", sA = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, nonce: r, ...i } = t, s = Gr(yf, n), a = S0(yf, n), o = Je(e, s.onViewportChange), u = M.useRef(0);
    return /* @__PURE__ */ es(If, { children: [
      /* @__PURE__ */ ee(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: r
        }
      ),
      /* @__PURE__ */ ee(Ol.Slot, { scope: n, children: /* @__PURE__ */ ee(
        $e.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: o,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: Oe(i.onScroll, (l) => {
            const c = l.currentTarget, { contentWrapper: d, shouldExpandOnScrollRef: f } = a;
            if (f != null && f.current && d) {
              const h = Math.abs(u.current - c.scrollTop);
              if (h > 0) {
                const m = window.innerHeight - Sn * 2, p = parseFloat(d.style.minHeight), g = parseFloat(d.style.height), b = Math.max(p, g);
                if (b < m) {
                  const y = b + h, T = Math.min(m, y), S = y - T;
                  d.style.height = T + "px", d.style.bottom === "0px" && (c.scrollTop = S > 0 ? S : 0, d.style.justifyContent = "flex-end");
                }
              }
            }
            u.current = c.scrollTop;
          })
        }
      ) })
    ] });
  }
);
sA.displayName = yf;
var aA = "SelectGroup", [eY, tY] = Ls(aA), oA = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = di();
    return /* @__PURE__ */ ee(eY, { scope: n, id: i, children: /* @__PURE__ */ ee($e.div, { role: "group", "aria-labelledby": i, ...r, ref: e }) });
  }
);
oA.displayName = aA;
var uA = "SelectLabel", lA = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = tY(uA, n);
    return /* @__PURE__ */ ee($e.div, { id: i.id, ...r, ref: e });
  }
);
lA.displayName = uA;
var ju = "SelectItem", [nY, cA] = Ls(ju), dA = M.forwardRef(
  (t, e) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: i = !1,
      textValue: s,
      ...a
    } = t, o = Vr(ju, n), u = Gr(ju, n), l = o.value === r, [c, d] = M.useState(s ?? ""), [f, h] = M.useState(!1), m = Je(
      e,
      (y) => {
        var T;
        return (T = u.itemRefCallback) == null ? void 0 : T.call(u, y, r, i);
      }
    ), p = di(), g = M.useRef("touch"), b = () => {
      i || (o.onValueChange(r), o.onOpenChange(!1));
    };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ ee(
      nY,
      {
        scope: n,
        value: r,
        disabled: i,
        textId: p,
        isSelected: l,
        onItemTextChange: M.useCallback((y) => {
          d((T) => T || ((y == null ? void 0 : y.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ ee(
          Ol.ItemSlot,
          {
            scope: n,
            value: r,
            disabled: i,
            textValue: c,
            children: /* @__PURE__ */ ee(
              $e.div,
              {
                role: "option",
                "aria-labelledby": p,
                "data-highlighted": f ? "" : void 0,
                "aria-selected": l && f,
                "data-state": l ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...a,
                ref: m,
                onFocus: Oe(a.onFocus, () => h(!0)),
                onBlur: Oe(a.onBlur, () => h(!1)),
                onClick: Oe(a.onClick, () => {
                  g.current !== "mouse" && b();
                }),
                onPointerUp: Oe(a.onPointerUp, () => {
                  g.current === "mouse" && b();
                }),
                onPointerDown: Oe(a.onPointerDown, (y) => {
                  g.current = y.pointerType;
                }),
                onPointerMove: Oe(a.onPointerMove, (y) => {
                  var T;
                  g.current = y.pointerType, i ? (T = u.onItemLeave) == null || T.call(u) : g.current === "mouse" && y.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: Oe(a.onPointerLeave, (y) => {
                  var T;
                  y.currentTarget === document.activeElement && ((T = u.onItemLeave) == null || T.call(u));
                }),
                onKeyDown: Oe(a.onKeyDown, (y) => {
                  var S;
                  ((S = u.searchRef) == null ? void 0 : S.current) !== "" && y.key === " " || (Vj.includes(y.key) && b(), y.key === " " && y.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
dA.displayName = ju;
var js = "SelectItemText", fA = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, className: r, style: i, ...s } = t, a = Vr(js, n), o = Gr(js, n), u = cA(js, n), l = Wj(js, n), [c, d] = M.useState(null), f = Je(
      e,
      (b) => d(b),
      u.onItemTextChange,
      (b) => {
        var y;
        return (y = o.itemTextRefCallback) == null ? void 0 : y.call(o, b, u.value, u.disabled);
      }
    ), h = c == null ? void 0 : c.textContent, m = M.useMemo(
      () => /* @__PURE__ */ ee("option", { value: u.value, disabled: u.disabled, children: h }, u.value),
      [u.disabled, u.value, h]
    ), { onNativeOptionAdd: p, onNativeOptionRemove: g } = l;
    return wt(() => (p(m), () => g(m)), [p, g, m]), /* @__PURE__ */ es(If, { children: [
      /* @__PURE__ */ ee($e.span, { id: u.textId, ...s, ref: f }),
      u.isSelected && a.valueNode && !a.valueNodeHasChildren ? Yu.createPortal(s.children, a.valueNode) : null
    ] });
  }
);
fA.displayName = js;
var hA = "SelectItemIndicator", mA = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return cA(hA, n).isSelected ? /* @__PURE__ */ ee($e.span, { "aria-hidden": !0, ...r, ref: e }) : null;
  }
);
mA.displayName = hA;
var Tf = "SelectScrollUpButton", pA = M.forwardRef((t, e) => {
  const n = Gr(Tf, t.__scopeSelect), r = S0(Tf, t.__scopeSelect), [i, s] = M.useState(!1), a = Je(e, r.onScrollButtonChange);
  return wt(() => {
    if (n.viewport && n.isPositioned) {
      let o = function() {
        const l = u.scrollTop > 0;
        s(l);
      };
      const u = n.viewport;
      return o(), u.addEventListener("scroll", o), () => u.removeEventListener("scroll", o);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ ee(
    bA,
    {
      ...t,
      ref: a,
      onAutoScroll: () => {
        const { viewport: o, selectedItem: u } = n;
        o && u && (o.scrollTop = o.scrollTop - u.offsetHeight);
      }
    }
  ) : null;
});
pA.displayName = Tf;
var Sf = "SelectScrollDownButton", gA = M.forwardRef((t, e) => {
  const n = Gr(Sf, t.__scopeSelect), r = S0(Sf, t.__scopeSelect), [i, s] = M.useState(!1), a = Je(e, r.onScrollButtonChange);
  return wt(() => {
    if (n.viewport && n.isPositioned) {
      let o = function() {
        const l = u.scrollHeight - u.clientHeight, c = Math.ceil(u.scrollTop) < l;
        s(c);
      };
      const u = n.viewport;
      return o(), u.addEventListener("scroll", o), () => u.removeEventListener("scroll", o);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ ee(
    bA,
    {
      ...t,
      ref: a,
      onAutoScroll: () => {
        const { viewport: o, selectedItem: u } = n;
        o && u && (o.scrollTop = o.scrollTop + u.offsetHeight);
      }
    }
  ) : null;
});
gA.displayName = Sf;
var bA = M.forwardRef((t, e) => {
  const { __scopeSelect: n, onAutoScroll: r, ...i } = t, s = Gr("SelectScrollButton", n), a = M.useRef(null), o = Nl(n), u = M.useCallback(() => {
    a.current !== null && (window.clearInterval(a.current), a.current = null);
  }, []);
  return M.useEffect(() => () => u(), [u]), wt(() => {
    var c;
    const l = o().find((d) => d.ref.current === document.activeElement);
    (c = l == null ? void 0 : l.ref.current) == null || c.scrollIntoView({ block: "nearest" });
  }, [o]), /* @__PURE__ */ ee(
    $e.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: e,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: Oe(i.onPointerDown, () => {
        a.current === null && (a.current = window.setInterval(r, 50));
      }),
      onPointerMove: Oe(i.onPointerMove, () => {
        var l;
        (l = s.onItemLeave) == null || l.call(s), a.current === null && (a.current = window.setInterval(r, 50));
      }),
      onPointerLeave: Oe(i.onPointerLeave, () => {
        u();
      })
    }
  );
}), rY = "SelectSeparator", iY = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t;
    return /* @__PURE__ */ ee($e.div, { "aria-hidden": !0, ...r, ref: e });
  }
);
iY.displayName = rY;
var xf = "SelectArrow", sY = M.forwardRef(
  (t, e) => {
    const { __scopeSelect: n, ...r } = t, i = Ml(n), s = Vr(xf, n), a = Gr(xf, n);
    return s.open && a.position === "popper" ? /* @__PURE__ */ ee(y2, { ...i, ...r, ref: e }) : null;
  }
);
sY.displayName = xf;
var aY = "SelectBubbleInput", EA = M.forwardRef(
  ({ __scopeSelect: t, value: e, ...n }, r) => {
    const i = M.useRef(null), s = Je(r, i), a = hh(e);
    return M.useEffect(() => {
      const o = i.current;
      if (!o) return;
      const u = window.HTMLSelectElement.prototype, c = Object.getOwnPropertyDescriptor(
        u,
        "value"
      ).set;
      if (a !== e && c) {
        const d = new Event("change", { bubbles: !0 });
        c.call(o, e), o.dispatchEvent(d);
      }
    }, [a, e]), /* @__PURE__ */ ee(
      $e.select,
      {
        ...n,
        style: { ...K2, ...n.style },
        ref: s,
        defaultValue: e
      }
    );
  }
);
EA.displayName = aY;
function yA(t) {
  return t === "" || t === void 0;
}
function TA(t) {
  const e = Pr(t), n = M.useRef(""), r = M.useRef(0), i = M.useCallback(
    (a) => {
      const o = n.current + a;
      e(o), function u(l) {
        n.current = l, window.clearTimeout(r.current), l !== "" && (r.current = window.setTimeout(() => u(""), 1e3));
      }(o);
    },
    [e]
  ), s = M.useCallback(() => {
    n.current = "", window.clearTimeout(r.current);
  }, []);
  return M.useEffect(() => () => window.clearTimeout(r.current), []), [n, i, s];
}
function SA(t, e, n) {
  const i = e.length > 1 && Array.from(e).every((l) => l === e[0]) ? e[0] : e, s = n ? t.indexOf(n) : -1;
  let a = oY(t, Math.max(s, 0));
  i.length === 1 && (a = a.filter((l) => l !== n));
  const u = a.find(
    (l) => l.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return u !== n ? u : void 0;
}
function oY(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var uY = j2, lY = X2, cY = tA, dY = lA, fY = dA;
const hY = le("svg", {
  height: "19px",
  color: "$accent",
  fill: "$accent",
  stroke: "$accent",
  display: "flex",
  margin: "0.25rem 0.85rem"
}), mY = le(lY, {
  fontSize: "1.25rem",
  fontWeight: "400",
  fontFamily: "inherit",
  alignSelf: "flex-start",
  flexGrow: "1",
  cursor: "pointer",
  transition: "$all",
  border: "1px solid #6663",
  boxShadow: "2px 2px 5px #0001",
  borderRadius: "3px",
  display: "flex",
  alignItems: "center",
  paddingLeft: "0.5rem",
  width: "100%",
  "@sm": {
    fontSize: "1rem"
  }
}), pY = le(cY, {
  borderRadius: "3px",
  boxShadow: "3px 3px 8px #0003",
  backgroundColor: "$secondary",
  marginTop: "2.25rem",
  marginLeft: "6px",
  paddingBottom: "0.25rem",
  maxHeight: "calc(61.8vh - 2.5rem) !important",
  borderTopLeftRadius: "0",
  border: "1px solid $secondaryMuted",
  maxWidth: "90vw"
}), gY = le(fY, {
  display: "flex",
  alignItems: "center",
  fontFamily: "inherit",
  padding: "0.25rem 0.5rem",
  color: "$primary",
  fontWeight: "400",
  fontSize: "0.8333rem",
  cursor: "pointer",
  backgroundColor: "$secondary",
  width: "calc(100% - 1rem)",
  "> span": {
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    overflow: "hidden"
  },
  '&[data-state="checked"]': {
    fontWeight: "700",
    color: "$primary !important"
  },
  "&:hover": {
    color: "$accent"
  },
  img: {
    width: "31px",
    height: "31px",
    marginRight: "0.5rem",
    borderRadius: "3px"
  }
}), bY = le(dY, {
  color: "$primaryMuted",
  fontFamily: "inherit",
  fontSize: "0.85rem",
  padding: "0.5rem 1rem 0.5rem 0.5rem",
  display: "flex",
  alignItems: "center",
  marginBottom: "0.25rem",
  borderRadius: "3px",
  borderTopLeftRadius: "0",
  borderBottomLeftRadius: "0",
  borderBottomRightRadius: "0",
  backgroundColor: "$secondaryMuted"
}), xA = le(uY, {
  position: "relative",
  zIndex: "5",
  width: "100%"
}), Xc = ({ direction: t, title: e }) => {
  const n = () => /* @__PURE__ */ v.createElement("path", { d: "M414 321.94L274.22 158.82a24 24 0 00-36.44 0L98 321.94c-13.34 15.57-2.28 39.62 18.22 39.62h279.6c20.5 0 31.56-24.05 18.18-39.62z" }), r = () => /* @__PURE__ */ v.createElement("path", { d: "M98 190.06l139.78 163.12a24 24 0 0036.44 0L414 190.06c13.34-15.57 2.28-39.62-18.22-39.62h-279.6c-20.5 0-31.56 24.05-18.18 39.62z" });
  return /* @__PURE__ */ v.createElement(
    hY,
    {
      xmlns: "http://www.w3.org/2000/svg",
      focusable: "false",
      viewBox: "0 0 512 512",
      role: "img"
    },
    /* @__PURE__ */ v.createElement("title", null, e),
    t === "up" && /* @__PURE__ */ v.createElement(n, null),
    t === "down" && /* @__PURE__ */ v.createElement(r, null)
  );
}, vA = ({
  children: t,
  label: e,
  maxHeight: n,
  onValueChange: r,
  value: i
}) => /* @__PURE__ */ v.createElement(xA, { onValueChange: r, value: i }, /* @__PURE__ */ v.createElement(mY, { "data-testid": "select-button" }, /* @__PURE__ */ v.createElement(Z2, { "data-testid": "select-button-value" }), /* @__PURE__ */ v.createElement(J2, null, /* @__PURE__ */ v.createElement(Xc, { direction: "down", title: "select" }))), /* @__PURE__ */ v.createElement(eA, null, /* @__PURE__ */ v.createElement(
  pY,
  {
    css: { maxHeight: `${n} !important` },
    "data-testid": "select-content"
  },
  /* @__PURE__ */ v.createElement(pA, null, /* @__PURE__ */ v.createElement(Xc, { direction: "up", title: "scroll up for more" })),
  /* @__PURE__ */ v.createElement(sA, null, /* @__PURE__ */ v.createElement(oA, null, e && /* @__PURE__ */ v.createElement(bY, null, /* @__PURE__ */ v.createElement(yr, { "data-testid": "select-label", label: e })), t)),
  /* @__PURE__ */ v.createElement(gA, null, /* @__PURE__ */ v.createElement(Xc, { direction: "down", title: "scroll down for more" }))
))), AA = (t) => /* @__PURE__ */ v.createElement(gY, { ...t }, t.thumbnail && /* @__PURE__ */ v.createElement(Ov, { thumbnail: t.thumbnail }), /* @__PURE__ */ v.createElement(fA, null, /* @__PURE__ */ v.createElement(yr, { label: t.label })), /* @__PURE__ */ v.createElement(mA, null));
let ri = window.OpenSeadragon;
if (!ri && (ri = zs, !ri))
  throw new Error("OpenSeadragon is missing.");
const P1 = "http://www.w3.org/2000/svg";
ri.Viewer && (ri.Viewer.prototype.svgOverlay = function() {
  return this._svgOverlayInfo ? this._svgOverlayInfo : (this._svgOverlayInfo = new IA(this), this._svgOverlayInfo);
});
const IA = function(t) {
  const e = this;
  this._viewer = t, this._containerWidth = 0, this._containerHeight = 0, this._svg = document.createElementNS(P1, "svg"), this._svg.style.position = "absolute", this._svg.style.left = 0, this._svg.style.top = 0, this._svg.style.width = "100%", this._svg.style.height = "100%", this._viewer.canvas.appendChild(this._svg), this._node = document.createElementNS(P1, "g"), this._svg.appendChild(this._node), this._viewer.addHandler("animation", function() {
    e.resize();
  }), this._viewer.addHandler("open", function() {
    e.resize();
  }), this._viewer.addHandler("rotate", function() {
    e.resize();
  }), this._viewer.addHandler("flip", function() {
    e.resize();
  }), this._viewer.addHandler("resize", function() {
    e.resize();
  }), this.resize();
};
IA.prototype = {
  // ----------
  node: function() {
    return this._node;
  },
  // ----------
  resize: function() {
    this._containerWidth !== this._viewer.container.clientWidth && (this._containerWidth = this._viewer.container.clientWidth, this._svg.setAttribute("width", this._containerWidth)), this._containerHeight !== this._viewer.container.clientHeight && (this._containerHeight = this._viewer.container.clientHeight, this._svg.setAttribute("height", this._containerHeight));
    const t = this._viewer.viewport.pixelFromPoint(new ri.Point(0, 0), !0), e = this._viewer.viewport.getZoom(!0), n = this._viewer.viewport.getRotation(), r = this._viewer.viewport.getFlip(), i = this._viewer.viewport._containerInnerSize.x;
    let s = i * e;
    const a = s;
    r && (s = -s, t.x = -t.x + i), this._node.setAttribute(
      "transform",
      "translate(" + t.x + "," + t.y + ") scale(" + s + "," + a + ") rotate(" + n + ")"
    );
  },
  // ----------
  onClick: function(t, e) {
    new ri.MouseTracker({
      element: t,
      clickHandler: e
    }).setTracking(!0);
  }
};
const EY = (t) => (Array.isArray(t["@context"]) ? t["@context"] : [t["@context"]]).map((n) => n == null ? void 0 : n.replace("http://", "https://")), yY = (t) => fetch(`${t.replace(/\/$/, "")}/info.json`).then((e) => e.json()).then((e) => e).catch((e) => {
  console.error(
    `The IIIF tilesource ${t.replace(
      /\/$/,
      ""
    )}/info.json failed to load: ${e}`
  );
}), TY = (t) => {
  let e, n;
  if (Array.isArray(t) && (e = t[0], e)) {
    let r;
    "@id" in e ? r = e["@id"] : r = e.id, n = r;
  }
  return n;
}, CA = (t) => {
  var r, i, s, a, o, u, l, c, d, f, h, m, p, g, b;
  let e, n = {};
  switch (t == null ? void 0 : t.type) {
    case "SpecificResource":
      e = (s = (i = (r = t == null ? void 0 : t.target) == null ? void 0 : r.partOf) == null ? void 0 : i[0]) == null ? void 0 : s.id, n = {
        manifest: e,
        canvas: (a = t == null ? void 0 : t.target) == null ? void 0 : a.id
      }, t != null && t.selector && (n.selector = t.selector);
      break;
    case "Range":
    case "Annotation":
      const y = ((o = t == null ? void 0 : t.target) == null ? void 0 : o.source) || (t == null ? void 0 : t.target), T = (u = t == null ? void 0 : t.target) == null ? void 0 : u.selector;
      n = {
        manifest: (c = (l = y == null ? void 0 : y.partOf) == null ? void 0 : l[0]) == null ? void 0 : c.id,
        canvas: y == null ? void 0 : y.id
      }, (((d = t == null ? void 0 : t.target) == null ? void 0 : d.type) === "SpecificResource" || (f = t == null ? void 0 : t.target) != null && f.selector) && (n.selector = T);
      break;
    case "Canvas":
      if (e = (m = (h = t == null ? void 0 : t.partOf) == null ? void 0 : h[0]) == null ? void 0 : m.id, n = {
        manifest: e,
        canvas: t == null ? void 0 : t.id
      }, (p = t == null ? void 0 : t.id) != null && p.includes("#xywh=")) {
        const [S, I] = t.id.split("#xywh=");
        n.canvas = S, n.selector = {
          type: "FragmentSelector",
          value: `xywh=${I}`
        };
      }
      break;
    case "Manifest":
      e = t == null ? void 0 : t.id, n = {
        collection: (b = (g = t == null ? void 0 : t.partOf) == null ? void 0 : g[0]) == null ? void 0 : b.id,
        manifest: t == null ? void 0 : t.id
      };
      break;
    case "Collection":
      e = t == null ? void 0 : t.id, n = {
        collection: e
      };
      break;
  }
  return { resourceId: e, active: n };
}, SY = (t) => {
  const e = [
    "https://iiif.io/api/presentation/2/context.json",
    "https://iiif.io/api/presentation/3/context.json"
  ], n = new TypeError(
    `The IIIF content may not be a valid IIIF resource: ${e.join(", ")}`
  );
  t["@context"] || console.warn(n);
  const r = EY(t);
  try {
    if (r.includes(e[0])) {
      const i = qA(t);
      if (!i || !i.id || !i.type)
        throw n;
      return i;
    } else {
      if (r.includes(e[1]))
        return t;
      throw n;
    }
  } catch (i) {
    console.warn(i);
  }
}, xY = (t) => {
  if (typeof t == "string" && CY(t))
    return { resourceId: t };
  if (typeof t == "object") {
    const e = SY(t);
    return {
      resourceId: e == null ? void 0 : e.id,
      resourceObject: e
    };
  } else {
    const e = JSON.parse(MA(t)), { active: n } = CA(e);
    return { active: n, resourceId: e == null ? void 0 : e.resourceId, resourceObject: e };
  }
}, vY = (t) => {
  const { resourceId: e, resourceObject: n } = xY(t);
  return n || e;
}, AY = (t) => t.items.map((n) => n.id)[0], IY = (t) => {
  const e = t.items.filter((n) => n.type === "Manifest").map((n) => n.id);
  return e.length == 0 ? null : e[0];
}, CY = (t) => {
  try {
    new URL(t);
  } catch {
    return !1;
  }
  return !0;
};
var hn = /* @__PURE__ */ ((t) => (t.TiledImage = "tiledImage", t.SimpleImage = "simpleImage", t))(hn || {});
const LY = (t) => {
  const e = Array.isArray(t == null ? void 0 : t.service) && (t == null ? void 0 : t.service.length) > 0, n = e ? TY(t == null ? void 0 : t.service) : t == null ? void 0 : t.id, r = e ? hn.TiledImage : hn.SimpleImage;
  return {
    uri: n,
    imageType: r
  };
}, _Y = (t, e) => {
  const n = e ? hn.TiledImage : hn.SimpleImage;
  return {
    uri: t,
    imageType: n
  };
}, vf = le("div", {
  position: "absolute !important",
  zIndex: "1",
  top: "1rem",
  left: "1rem",
  width: "161.8px",
  height: "100px",
  backgroundColor: "#000D",
  boxShadow: "5px 5px 5px #0002",
  borderRadius: "3px",
  ".displayregion": {
    border: " 3px solid $accent !important",
    boxShadow: "0 0 3px #0006"
  },
  "@sm": {
    width: "123px",
    height: "76px"
  },
  "@xs": {
    width: "100px",
    height: "61.8px"
  }
}), RY = le("div", {
  position: "relative",
  width: "100%",
  height: "100%",
  zIndex: "0",
  ".clover-iiif-image-openseadragon-annotation": {
    position: "relative",
    backgroundColor: "transparent",
    border: "2px solid #0003",
    boxSizing: "content-box",
    borderRadius: "3px",
    boxShadow: "0 0 38vw 38vw transparent",
    transition: "box-shadow 100ms ease-in-out",
    zIndex: "0",
    label: {
      opacity: 0,
      position: "absolute",
      lineHeight: "1.47rem",
      pointerEvents: "none",
      textAlign: "center",
      minWidth: "300px",
      maxWidth: "20vw",
      padding: "0.5rem",
      borderRadius: "3px",
      top: "calc(100% + 0.5rem)",
      left: "50%",
      transform: "translate(-50%, 0)",
      backgroundColor: "$primary",
      color: "$secondary",
      transition: "opacity 100ms ease-in-out"
    },
    "&[data-active=true]": {
      border: "2px solid $accent !important",
      boxShadow: "0 0 38vw 38vw #0003",
      zIndex: "99999999",
      label: {
        opacity: 1
      }
    }
  }
}), wY = le("div", {
  width: "100%",
  height: "100%",
  maxHeight: "100vh",
  background: "transparent",
  backgroundSize: "contain",
  color: "white",
  position: "relative",
  zIndex: "0",
  overflow: "hidden",
  variants: {
    hasNavigator: {
      true: {
        [`${vf}`]: {
          display: "block"
        }
      },
      false: {
        [`${vf}`]: {
          display: "none"
        }
      }
    }
  }
}), Oi = ({ className: t, id: e, label: n, children: r }) => {
  const s = e.split("-")[0].replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  return /* @__PURE__ */ v.createElement(
    q2,
    {
      id: e,
      className: t,
      "data-testid": "openseadragon-button",
      "data-button": s
    },
    /* @__PURE__ */ v.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        "aria-labelledby": `${e}-svg-title`,
        "data-testid": "openseadragon-button-svg",
        focusable: "false",
        viewBox: "0 0 512 512",
        role: "img"
      },
      /* @__PURE__ */ v.createElement("title", { id: `${e}-svg-title` }, n),
      r
    )
  );
}, kY = le("div", {
  position: "absolute",
  zIndex: "1",
  top: "1rem",
  right: "1rem",
  display: "flex",
  "@xs": {
    flexDirection: "column",
    zIndex: "2"
  },
  variants: {
    hasPlaceholder: {
      true: {
        right: "3.618rem",
        "@xs": {
          top: "3.618rem",
          right: "1rem"
        }
      },
      false: {
        right: "1rem",
        "@xs": {
          top: "1rem",
          right: "1rem"
        }
      }
    }
  }
}), DY = () => /* @__PURE__ */ v.createElement(
  "path",
  {
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M256 112v288M400 256H112"
  }
), PY = () => /* @__PURE__ */ v.createElement(
  "path",
  {
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M400 256H112"
  }
), OY = () => /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "32",
    d: "M432 320v112H320M421.8 421.77L304 304M80 192V80h112M90.2 90.23L208 208M320 80h112v112M421.77 90.2L304 208M192 432H80V320M90.23 421.8L208 304"
  }
), NY = () => /* @__PURE__ */ v.createElement("path", { d: "M448 440a16 16 0 01-12.61-6.15c-22.86-29.27-44.07-51.86-73.32-67C335 352.88 301 345.59 256 344.23V424a16 16 0 01-27 11.57l-176-168a16 16 0 010-23.14l176-168A16 16 0 01256 88v80.36c74.14 3.41 129.38 30.91 164.35 81.87C449.32 292.44 464 350.9 464 424a16 16 0 01-16 16z" }), O1 = () => /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
  "path",
  {
    fill: "none",
    strokeLinecap: "round",
    strokeMiterlimit: "10",
    strokeWidth: "45",
    d: "M400 148l-21.12-24.57A191.43 191.43 0 00240 64C134 64 48 150 48 256s86 192 192 192a192.09 192.09 0 00181.07-128"
  }
), /* @__PURE__ */ v.createElement("path", { d: "M464 97.42V208a16 16 0 01-16 16H337.42c-14.26 0-21.4-17.23-11.32-27.31L436.69 86.1C446.77 76 464 83.16 464 97.42z" })), MY = ({
  _cloverViewerHasPlaceholder: t,
  config: e
}) => {
  const { t: n } = Zn(), r = st(), { activeCanvas: i, plugins: s, vault: a, openSeadragonViewer: o } = r, u = a.get({
    id: i,
    type: "Canvas"
  });
  function l() {
    return s.filter((c) => {
      var d;
      return (d = c.imageViewer) == null ? void 0 : d.controls;
    }).map((c, d) => {
      var h, m, p, g;
      const f = (m = (h = c.imageViewer) == null ? void 0 : h.controls) == null ? void 0 : m.component;
      return /* @__PURE__ */ v.createElement(
        f,
        {
          key: d,
          ...(g = (p = c == null ? void 0 : c.imageViewer) == null ? void 0 : p.controls) == null ? void 0 : g.componentProps,
          canvas: u,
          useViewerDispatch: jt,
          useViewerState: st
        }
      );
    });
  }
  return Se(() => {
    if (!o) return;
    const c = o.viewport.getRotation();
    o.addHandler("home", () => {
      o.viewport.setRotation(c);
    });
  }, [o]), /* @__PURE__ */ v.createElement(
    kY,
    {
      "data-testid": "clover-iiif-image-openseadragon-controls",
      hasPlaceholder: t
    },
    e.showZoomControl && /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(Oi, { id: e.zoomInButton, label: n("imageZoomIn") }, /* @__PURE__ */ v.createElement(DY, null)), /* @__PURE__ */ v.createElement(Oi, { id: e.zoomOutButton, label: n("imageZoomOut") }, /* @__PURE__ */ v.createElement(PY, null))),
    e.showFullPageControl && /* @__PURE__ */ v.createElement(
      Oi,
      {
        id: e.fullPageButton,
        label: n("imageFullScreen")
      },
      /* @__PURE__ */ v.createElement(OY, null)
    ),
    e.showRotationControl && /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement(
      Oi,
      {
        id: e.rotateRightButton,
        label: n("imageRotateRight")
      },
      /* @__PURE__ */ v.createElement(O1, null)
    ), /* @__PURE__ */ v.createElement(
      Oi,
      {
        id: e.rotateLeftButton,
        label: n("imageRotateLeft")
      },
      /* @__PURE__ */ v.createElement(O1, null)
    )),
    e.showHomeControl && /* @__PURE__ */ v.createElement(Oi, { id: e.homeButton, label: n("imageResetZoom") }, /* @__PURE__ */ v.createElement(NY, null)),
    l()
  );
};
async function LA(t, e = 3, n = 500) {
  try {
    return await t();
  } catch (r) {
    if (e <= 0) throw r;
    return await new Promise((i) => setTimeout(i, n)), LA(t, e - 1, n);
  }
}
const FY = (t) => new Promise((e) => setTimeout(e, t)), N1 = async (t, e, n = 3, r = 300) => {
  for (let i = 0; i < n; i++) {
    const s = e ? e - 1 : 0, a = t.getItemAt(s);
    if (a) return a;
    await FY(r);
  }
  throw new Error("No base item found at index 0 after retries");
}, BY = ({
  annotations: t,
  ariaLabel: e,
  config: n,
  uri: r,
  _cloverViewerHasPlaceholder: i,
  imageType: s,
  openSeadragonCallback: a
}) => {
  const [o, u] = Be([]), [l, c] = Be([]), [d, f] = Be(), [h, m] = Be([]), p = jt(), g = ms(!1), b = "clover-iiif-image-openseadragon-annotation", y = n.gestureSettingsMouse.scrollToZoom === !1;
  Se(() => (g.current || (g.current = !0, d || f(zs(n))), () => d == null ? void 0 : d.destroy()), []), Se(() => {
    T();
  }, [d, a]), Se(() => {
    d && JSON.stringify(r) !== JSON.stringify(l) && (d.forceRedraw(), y && d.addHandler("canvas-scroll", function(S) {
      S.preventDefault = !1;
    }), c(r));
  }, [y, d, l, r]), Se(() => {
    if (!l.length || !d) return;
    d.close(), (async () => {
      switch (s) {
        case "simpleImage":
          let I = 1, C = 0;
          for (let _ = 0; _ < l.length; _++) {
            const R = l[_];
            if (t) {
              const k = new Image();
              k.src = R, await k.decode(), m((A) => [
                ...A,
                { width: k == null ? void 0 : k.width, height: k == null ? void 0 : k.height }
              ]);
            }
            try {
              if (_ !== 0) {
                const A = (await N1(
                  d.world,
                  _
                )).getBounds();
                C = A.x + A.width, I = A.height;
              }
              d.addSimpleImage({
                url: R,
                x: C,
                y: 0,
                height: I,
                success: () => {
                  u((k) => [...k, R]), typeof p == "function" && p({
                    type: "updateOSDImageLoaded",
                    OSDImageLoaded: !0
                  });
                }
              });
            } catch (k) {
              console.error(`Failed to load image at ${R}:`, k);
            }
          }
          break;
        case "tiledImage": {
          let _ = 1, R = 0;
          for (let k = 0; k < l.length; k++) {
            const A = l[k];
            try {
              const L = await LA(
                () => yY(A),
                3,
                1e3
              );
              if (!L) throw new Error(`No tile source for ${A}`);
              if (k !== 0) {
                const $ = (await N1(
                  d.world,
                  k
                )).getBounds();
                R = $.x + $.width, _ = $.height;
              }
              d.addTiledImage({
                tileSource: L,
                x: R,
                y: 0,
                height: _,
                success: () => {
                  u((P) => [...P, A]), typeof p == "function" && p({
                    type: "updateOSDImageLoaded",
                    OSDImageLoaded: !0
                  });
                }
              });
            } catch (L) {
              console.error(`Failed to load tile at ${A}:`, L);
            }
          }
          break;
        }
        default:
          console.warn(`Unsupported imageType: "${s}"`);
          break;
      }
    })().catch((I) => console.error("Error drawing tiles", I));
  }, [l, s, d]), Se(() => {
    if (o) {
      let I = 0;
      const C = () => {
        if (I < 3) {
          const _ = d == null ? void 0 : d.world.getHomeBounds();
          _ && (d == null || d.viewport.fitBounds(_, !0)), I++, setTimeout(C, 50);
        }
      };
      C(), d == null || d.addHandler("canvas-click", (_) => {
        const R = d == null ? void 0 : d.getOverlayById(
          _.originalTarget.id
        );
        if (R) {
          const k = R == null ? void 0 : R.getBounds(d.viewport);
          return k.x -= 0.1, k.y -= 0.1, k.width += 0.2, k.height += 0.2, d == null || d.viewport.fitBounds(k, !1), _.preventDefaultAction = !0;
        }
      });
    }
  }, [o]), Se(() => {
    function S(I, C, _) {
      let R = I * _;
      if (C === 0) return R;
      for (; C > 0; ) {
        const k = d == null ? void 0 : d.world.getItemAt(C - 1);
        if (k) {
          const A = k.getBounds().width;
          R += A, C--;
        } else
          break;
      }
      return R;
    }
    t && (d == null || d.clearOverlays(), t.forEach((I) => {
      var $, G, N, U;
      const { annotation: C, targetIndex: _ } = I, R = ((G = ($ = d == null ? void 0 : d.viewport) == null ? void 0 : $.getBounds()) == null ? void 0 : G.width) || 1, k = d == null ? void 0 : d.world.getItemAt(_), A = k ? (k == null ? void 0 : k.getBounds().width) / (k == null ? void 0 : k.getContentSize().x) : ((N = h[_]) == null ? void 0 : N.width) / R, L = _8(
        C == null ? void 0 : C.target
      ), P = C != null && C.body ? (U = C == null ? void 0 : C.body[0]) == null ? void 0 : U.value : void 0;
      if (L != null && L.rect) {
        const { x: B, y: V, w: K, h: w } = L == null ? void 0 : L.rect, Y = S(B, _, A), J = new zs.Rect(
          Y,
          V * A,
          K * A,
          w * A
        ), D = document.createElement("button");
        if (D.classList.add(b), D.id = C.id, D.setAttribute("tabindex", "0"), D.setAttribute("role", "button"), D.setAttribute("data-active", "true"), D.setAttribute("tabindex", "0"), D.setAttribute("role", "button"), D.setAttribute("data-active", "false"), P) {
          D.setAttribute("aria-label", P);
          const te = document.createElement("label");
          te.innerHTML = P, D.appendChild(te);
        }
        D.addEventListener("mousedown", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), D.addEventListener("touchstart", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), D.addEventListener("click", (te) => {
          te.stopPropagation(), te.preventDefault();
        }), D.addEventListener("keydown", (te) => {
          if (te.key === "Enter") {
            te.stopPropagation(), te.preventDefault();
            const he = new zs.Rect(
              J.x - 0.1,
              J.y - 0.1,
              J.width + 0.2,
              J.height + 0.2
            );
            d == null || d.viewport.fitBounds(he, !1);
          }
        }), D.addEventListener("focus", () => {
          D.setAttribute("data-active", "true");
        }), D.addEventListener("mouseover", () => {
          D.setAttribute("data-active", "true");
        }), D.addEventListener("mouseout", () => {
          D.removeAttribute("data-active");
        }), D.addEventListener("blur", () => {
          D.removeAttribute("data-active");
        }), d == null || d.addOverlay(D, J, zs.Placement.CENTER);
      }
    }), T());
  }, [o, t]);
  function T() {
    d && (a == null || a(d));
  }
  return /* @__PURE__ */ v.createElement(
    wY,
    {
      className: "clover-iiif-image-openseadragon",
      "data-testid": "clover-iiif-image-openseadragon",
      "data-openseadragon-instance": n.id,
      hasNavigator: n.showNavigator
    },
    /* @__PURE__ */ v.createElement(
      MY,
      {
        _cloverViewerHasPlaceholder: i,
        config: n
      }
    ),
    n.showNavigator && /* @__PURE__ */ v.createElement(
      vf,
      {
        id: n.navigatorId,
        "data-testid": "clover-iiif-image-openseadragon-navigator"
      }
    ),
    /* @__PURE__ */ v.createElement(
      RY,
      {
        id: n.id,
        "data-testid": "clover-iiif-image-openseadragon-viewport",
        role: "img",
        ...e && { "aria-label": e }
      }
    )
  );
};
function $Y(t) {
  return {
    id: `openseadragon-${t}`,
    navigatorId: `openseadragon-navigator-${t}`,
    loadTilesWithAjax: !0,
    fullPageButton: `fullPage-${t}`,
    homeButton: `reset-${t}`,
    rotateLeftButton: `rotateLeft-${t}`,
    rotateRightButton: `rotateRight-${t}`,
    zoomInButton: `zoomIn-${t}`,
    zoomOutButton: `zoomOut-${t}`,
    showNavigator: !0,
    showFullPageControl: !0,
    showHomeControl: !0,
    showRotationControl: !0,
    showZoomControl: !0,
    navigatorBorderColor: "transparent",
    gestureSettingsMouse: {
      clickToZoom: !0,
      dblClickToZoom: !0,
      pinchToZoom: !0,
      scrollToZoom: !1
    }
  };
}
const UY = ({
  _cloverViewerHasPlaceholder: t = !1,
  annotations: e,
  body: n,
  instanceId: r,
  isTiledImage: i = !1,
  label: s,
  src: a = "",
  openSeadragonCallback: o,
  openSeadragonConfig: u = {}
}) => {
  const l = r ?? ts(), c = typeof s == "string" ? s : fn(s), d = {
    ...$Y(l),
    ...u
  }, f = Array.isArray(n) ? n : n ? [n] : [], h = Array.isArray(a) ? a : a ? [a] : [];
  let m = [], p = hn.SimpleImage;
  if (f.length) {
    const b = f.map(LY);
    m = b.map((y) => y.uri).filter(Boolean), p = b.some(
      (y) => y.imageType === hn.TiledImage
    ) ? hn.TiledImage : hn.SimpleImage;
  } else if (h.length) {
    const b = h.map((y) => _Y(y, i));
    m = b.map((y) => y.uri).filter(Boolean), p = b.some(
      (y) => y.imageType === hn.TiledImage
    ) ? hn.TiledImage : hn.SimpleImage;
  }
  if (!m.length) return null;
  const g = (b) => {
    o == null || o(b);
  };
  return /* @__PURE__ */ v.createElement(Df, { FallbackComponent: Of }, /* @__PURE__ */ v.createElement(
    BY,
    {
      _cloverViewerHasPlaceholder: t,
      annotations: e,
      ariaLabel: c,
      config: d,
      imageType: p,
      key: l,
      uri: m,
      openSeadragonCallback: g
    }
  ));
}, HY = ({
  isActive: t,
  isMedia: e,
  items: n,
  setIsInteractive: r
}) => {
  const { vault: i } = st(), [s, a] = Be([]), o = s.length > 1;
  if (Se(() => {
    a([]);
    const c = n.map((d) => {
      const f = Dr(i, d.id);
      if (!f) return null;
      const { id: h, width: m, height: p } = f[0];
      return h ? {
        src: h,
        width: m || 640,
        height: p || 640,
        alt: d.label ? kf(d.label) : "placeholder image"
      } : null;
    }).filter((d) => d !== null);
    c.length && a(c);
  }, [n, o]), !t || !s.length) return null;
  const u = s.map((c) => c.width / c.height * 1), l = u.reduce((c, d) => c + d, 0);
  return /* @__PURE__ */ v.createElement(
    z2,
    {
      onClick: () => r(!0),
      isMedia: e,
      className: "clover-viewer-placeholder",
      "data-active": t,
      "data-paged": o
    },
    s.map((c, d) => {
      const f = u[d] / l * 100;
      return /* @__PURE__ */ v.createElement(
        "img",
        {
          ...c,
          key: d,
          alt: c.alt,
          style: {
            width: `${f}%`
          }
        }
      );
    })
  );
}, VY = le("canvas", {
  position: "absolute",
  width: "100%",
  height: "100%",
  zIndex: "0"
}), GY = v.forwardRef(
  (t, e) => {
    const n = v.useRef(null), r = yt(() => {
      var h, m;
      if ((h = e.current) != null && h.currentTime && ((m = e.current) == null ? void 0 : m.currentTime) > 0) return;
      const s = e.current;
      if (!s) return;
      const a = new AudioContext(), o = a.createMediaElementSource(s), u = a.createAnalyser(), l = n.current;
      if (!l) return;
      l.width = s.offsetWidth, l.height = s.offsetHeight;
      const c = l.getContext("2d");
      o.connect(u), u.connect(a.destination), u.fftSize = 256;
      const d = u.frequencyBinCount, f = new Uint8Array(d);
      setInterval(function() {
        i(
          u,
          c,
          d,
          f,
          l.width,
          l.height
        );
      }, 20);
    }, [e]);
    v.useEffect(() => {
      !e || !e.current || (e.current.onplay = r);
    }, [r, e]);
    function i(s, a, o, u, l, c) {
      const d = l / o * 2.6;
      let f, h = 0;
      s.getByteFrequencyData(u), a.fillStyle = "#000000", a.fillRect(0, 0, l, c);
      for (let m = 0; m < o; m++)
        f = u[m] * 2, a.fillStyle = "rgba(78, 42, 132, 1)", a.fillRect(h, c - f, d, f), h += d + 6;
    }
    return /* @__PURE__ */ v.createElement(VY, { ref: n, role: "presentation" });
  }
), zY = le("div", {
  position: "relative",
  backgroundColor: "$primaryAlt",
  display: "flex",
  flexGrow: "0",
  flexShrink: "1",
  height: "100%",
  zIndex: "1",
  video: {
    backgroundColor: "transparent",
    objectFit: "contain",
    width: "100%",
    height: "100%",
    position: "relative",
    zIndex: "1"
  }
}), qY = ({ resource: t, ignoreCaptionLabels: e }) => {
  const n = kf(t.label, "en");
  return Array.isArray(n) && n.some((i) => e.includes(i)) ? null : /* @__PURE__ */ v.createElement(
    "track",
    {
      key: t.id,
      src: t.id,
      label: Array.isArray(n) ? n[0] : n,
      srcLang: "en",
      "data-testid": "player-track"
    }
  );
}, WY = [
  // Apple santioned
  "application/vnd.apple.mpegurl",
  "vnd.apple.mpegurl",
  // Apple sanctioned for backwards compatibility
  "audio/mpegurl",
  // Very common
  "audio/x-mpegurl",
  // Very common
  "application/x-mpegurl",
  // Included for completeness
  "video/x-mpegurl",
  "video/mpegurl",
  "application/mpegurl"
], KY = ({
  allSources: t,
  annotationResources: e,
  painting: n
}) => {
  const [r, i] = v.useState(0), [s, a] = v.useState(), o = v.useRef(null), u = (n == null ? void 0 : n.type) === "Sound", l = jt(), c = st(), { activeCanvas: d, configOptions: f, contentStateAnnotation: h, vault: m } = c;
  return Se(() => {
    if (!n.id || !o.current) return;
    if (o != null && o.current) {
      const b = o.current;
      l({
        type: "updateActivePlayer",
        player: b
      }), b.src = n.id, b.load();
    }
    if (n.id.split(".").pop() !== "m3u8" && n.format && !WY.includes(n.format))
      return;
    const p = {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      xhrSetup: function(b, y) {
        b.withCredentials = !!f.withCredentials;
      }
    }, g = new Rt(p);
    return g.attachMedia(o.current), g.on(Rt.Events.MEDIA_ATTACHED, function() {
      g.loadSource(n.id);
    }), g.on(Rt.Events.ERROR, function(b, y) {
      if (y.fatal)
        switch (y.type) {
          case Rt.ErrorTypes.NETWORK_ERROR:
            console.error(
              `fatal ${b} network error encountered, try to recover`
            ), g.startLoad();
            break;
          case Rt.ErrorTypes.MEDIA_ERROR:
            console.error(
              `fatal ${b} media error encountered, try to recover`
            ), g.recoverMediaError();
            break;
          default:
            g.destroy();
            break;
        }
    }), () => {
      if (g && o.current) {
        const b = o.current;
        g.detachMedia(), g.destroy(), b.currentTime = 0;
      }
    };
  }, [
    f.withCredentials,
    n.id,
    n.format,
    l
  ]), Se(() => {
    var T, S, I, C;
    const p = m.get(d), g = (T = p.accompanyingCanvas) != null && T.id ? Dr(m, (S = p.accompanyingCanvas) == null ? void 0 : S.id) : null, b = (I = p.placeholderCanvas) != null && I.id ? Dr(m, (C = p.placeholderCanvas) == null ? void 0 : C.id) : null;
    !!(g && b) ? a(r === 0 ? b[0].id : g[0].id) : (g && a(g[0].id), b && a(b[0].id));
  }, [d, r, m]), Se(() => {
    const p = o == null ? void 0 : o.current;
    if (!p) return;
    let g = null, b = !1;
    const y = () => {
      b || (b = !0, g = setInterval(() => {
        p && !p.paused && !p.ended && (i(p.currentTime), l({
          type: "updateActiveSelector",
          selector: {
            type: "PointSelector",
            t: Math.round(p.currentTime)
          }
        }));
      }, 500)), p && p.paused && (i(p.currentTime), l({
        type: "updateActiveSelector",
        selector: {
          type: "PointSelector",
          t: Math.round(p.currentTime)
        }
      }));
    };
    return p.addEventListener("timeupdate", y), () => {
      p == null || p.removeEventListener("timeupdate", y), g && clearInterval(g);
    };
  }, [n.id, d]), Se(() => {
    var p, g;
    if (h) {
      const b = o == null ? void 0 : o.current;
      if (!b) return;
      const y = (p = h == null ? void 0 : h.target) == null ? void 0 : p.selector, { type: T, t: S, value: I } = y || {};
      if (// @ts-ignore
      (((g = h == null ? void 0 : h.target) == null ? void 0 : g.source) || (h == null ? void 0 : h.target)).id !== d) return;
      if (S && T === "PointSelector" && (i(S), b.currentTime = S), T === "FragmentSelector" && I) {
        const _ = I.split("=")[1];
        if (!_) return;
        const R = _.split(",")[0];
        i(R), b.currentTime = R;
      }
    }
  }, [o, h]), /* @__PURE__ */ v.createElement(
    zY,
    {
      css: {
        backgroundColor: f.canvasBackgroundColor,
        maxHeight: f.canvasHeight,
        position: "relative"
      },
      "data-testid": "player-wrapper",
      className: "clover-viewer-player-wrapper"
    },
    /* @__PURE__ */ v.createElement(
      "video",
      {
        id: "clover-iiif-video",
        key: n.id,
        ref: o,
        "data-src": n.id,
        controls: !0,
        height: n.height,
        width: n.width,
        crossOrigin: f.crossOrigin,
        poster: s,
        style: {
          maxHeight: f.canvasHeight,
          position: "relative",
          zIndex: "1"
        }
      },
      t.map((p) => /* @__PURE__ */ v.createElement("source", { src: p.id, type: p.format, key: p.id })),
      (e == null ? void 0 : e.length) > 0 && e.map((p) => {
        const g = [];
        return p.items.forEach((b) => {
          m.get(
            b.id
          ).body.forEach((T) => {
            const S = m.get(
              T.id
            );
            g.push(S);
          });
        }), g.map((b) => /* @__PURE__ */ v.createElement(
          qY,
          {
            resource: b,
            ignoreCaptionLabels: f.ignoreCaptionLabels || [],
            key: b.id
          }
        ));
      }),
      "Sorry, your browser doesn't support embedded videos."
    ),
    u && /* @__PURE__ */ v.createElement(GY, { ref: o })
  );
}, jY = ({ label: t }) => /* @__PURE__ */ v.createElement(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": "close-svg-title",
    focusable: "false",
    viewBox: "0 0 512 512",
    role: "img"
  },
  /* @__PURE__ */ v.createElement("title", { id: "close-svg-title" }, t),
  /* @__PURE__ */ v.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" })
), YY = ({ isMedia: t, label: e }) => /* @__PURE__ */ v.createElement(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": "open-svg-title",
    focusable: "false",
    viewBox: "0 0 512 512",
    role: "img"
  },
  /* @__PURE__ */ v.createElement("title", { id: "open-svg-title" }, e),
  t ? /* @__PURE__ */ v.createElement("path", { d: "M133 440a35.37 35.37 0 01-17.5-4.67c-12-6.8-19.46-20-19.46-34.33V111c0-14.37 7.46-27.53 19.46-34.33a35.13 35.13 0 0135.77.45l247.85 148.36a36 36 0 010 61l-247.89 148.4A35.5 35.5 0 01133 440z" }) : /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("path", { d: "m456.69,421.39l-94.09-94.09c22.65-30.16,34.88-66.86,34.84-104.58,0-96.34-78.38-174.72-174.72-174.72S48,126.38,48,222.72s78.38,174.72,174.72,174.72c37.72.04,74.42-12.19,104.58-34.84l94.09,94.09c10.29,9.2,26.1,8.32,35.3-1.98,8.48-9.49,8.48-23.83,0-33.32Zm-233.97-73.87c-68.89-.08-124.72-55.91-124.8-124.8h0c0-68.93,55.87-124.8,124.8-124.8s124.8,55.87,124.8,124.8-55.87,124.8-124.8,124.8Z" }), /* @__PURE__ */ v.createElement("path", { d: "m279.5,197.76h-3.35s-28.47,0-28.47,0v-31.82c-.77-13.79-12.57-24.33-26.36-23.56-12.71.71-22.85,10.86-23.56,23.56v3.35h0v28.47h-31.82c-13.79.77-24.33,12.57-23.56,26.36.71,12.71,10.86,22.85,23.56,23.56h3.35s28.47,0,28.47,0v31.82c.77,13.79,12.57,24.33,26.36,23.56,12.71-.71,22.85-10.86,23.56-23.56v-3.35h0v-28.47h31.82c13.79-.77,24.33-12.57,23.56-26.36-.71-12.71-10.86-22.85-23.56-23.56Z" }))
), XY = ({
  handleToggle: t,
  isInteractive: e,
  isMedia: n
}) => {
  const { t: r } = Zn();
  return /* @__PURE__ */ v.createElement(
    W2,
    {
      onClick: t,
      isInteractive: e,
      isMedia: n,
      "data-testid": "placeholder-toggle"
    },
    e ? /* @__PURE__ */ v.createElement(jY, { label: r("commonClose") }) : /* @__PURE__ */ v.createElement(YY, { isMedia: n, label: r("commonOpen") })
  );
}, QY = ({
  activeCanvas: t,
  annotationResources: e,
  contentSearchResource: n,
  isMedia: r,
  painting: i
}) => {
  var D, te, he, ie;
  const [s, a] = v.useState(0), [o, u] = v.useState(!1), [l, c] = v.useState([]), [d, f] = v.useState([]), [h, m] = v.useState(0), {
    configOptions: p,
    customDisplays: g,
    contentStateAnnotation: b,
    informationPanelResource: y,
    isPaged: T,
    openSeadragonViewer: S,
    vault: I,
    viewerId: C,
    viewingDirection: _,
    visibleCanvases: R
  } = st(), k = T && _ === "right-to-left", [A, L] = v.useState([]), P = !!b && t === ((te = (D = b == null ? void 0 : b.target) == null ? void 0 : D.source) == null ? void 0 : te.id), $ = jt(), G = I.get(t), N = d.length && !o && !r, U = (i == null ? void 0 : i.length) > 1, B = `${C}-${X1(t + s + JSON.stringify(R) + h)}`, V = () => {
    u(!o), m((X) => X + 1);
  }, K = (X) => {
    const fe = i.findIndex((Te) => Te.id === X);
    a(fe);
  }, w = g.find((X) => {
    var ye;
    let fe = !1;
    const { canvasId: Te, paintingFormat: me } = X.target;
    if (Array.isArray(Te) && Te.length > 0 && (fe = Te.includes(t)), Array.isArray(me) && me.length > 0) {
      const Ee = ((ye = i[s]) == null ? void 0 : ye.format) || "";
      fe = !!(Ee && me.includes(Ee));
    }
    return fe;
  });
  Se(() => {
    P && N && h === 0 && V();
  }, [P, N]), Se(() => {
    N && ($({
      type: "updateOpenSeadragonViewer",
      openSeadragonViewer: void 0
    }), $({
      type: "updateActiveSelector",
      selector: void 0
    }));
  }, [N]), Se(() => {
    var fe, Te, me;
    const X = [];
    if (y === "manifest-annotations" && (e == null || e.forEach((ye, Ee) => {
      var He;
      (He = ye == null ? void 0 : ye.items) == null || He.forEach((at) => {
        const bt = I.get(at.id);
        bt && X.push({
          annotation: {
            ...bt,
            body: bt.body.map((Le) => {
              const Ke = I.get(Le.id);
              return Ke || Le;
            })
          },
          targetIndex: Ee
        });
      });
    }), b)) {
      const ye = (
        // @ts-ignore
        ((fe = b == null ? void 0 : b.target) == null ? void 0 : fe.source) || (b == null ? void 0 : b.target)
      );
      X.push({
        // @ts-ignore
        annotation: {
          ...b,
          body: (Te = b == null ? void 0 : b.body) == null ? void 0 : Te.map((Ee) => {
            const He = I.get(Ee.id);
            return He || Ee;
          })
        },
        targetIndex: R.findIndex(
          (Ee) => Ee.id === ye.id
        )
      });
    }
    y === "manifest-content-search" && ((me = n == null ? void 0 : n.items) == null || me.forEach((ye) => {
      const Ee = I.get(ye.id);
      if (Ee) {
        const He = R.findIndex(
          (at) => at.id === Ee.target.source.id
        );
        typeof He == "number" && X.push({
          annotation: {
            ...Ee,
            body: Ee.body.map((at) => {
              const bt = I.get(at.id);
              return bt || at;
            })
          },
          targetIndex: He
        });
      }
    })), L(X);
  }, [
    e,
    n,
    b,
    y,
    R
  ]), Se(() => {
    if (!r) {
      const X = k ? [...R].reverse() : R, fe = X.map((me) => {
        const ye = me.id, Ee = Dr(I, ye);
        return Ee ? Ee[s] : void 0;
      }).filter(Boolean), Te = X.map((me) => {
        var bt;
        const ye = me.id, Ee = I.get(ye), He = (bt = Ee == null ? void 0 : Ee.placeholderCanvas) == null ? void 0 : bt.id;
        return !!!He || !He ? null : {
          id: He,
          label: Ee == null ? void 0 : Ee.label
        };
      }).filter((me) => me !== null);
      c(fe), f(Te);
    }
  }, [
    s,
    t,
    k,
    R,
    r,
    G
  ]), Se(() => {
    a(0);
  }, [R]);
  const Y = (X) => {
    X && !N && // @ts-ignore
    (S == null ? void 0 : S.id) !== `openseadragon-${B}` && $({
      type: "updateOpenSeadragonViewer",
      openSeadragonViewer: X
    });
  }, J = (he = w == null ? void 0 : w.display) == null ? void 0 : he.component;
  return /* @__PURE__ */ v.createElement(Fj, { className: "clover-viewer-painting" }, /* @__PURE__ */ v.createElement(
    Bj,
    {
      style: {
        backgroundColor: p.canvasBackgroundColor,
        height: p.canvasHeight === "auto" ? "100%" : p.canvasHeight
      }
    },
    !!d.length && !r && /* @__PURE__ */ v.createElement(
      XY,
      {
        handleToggle: V,
        isInteractive: o,
        isMedia: r
      }
    ),
    !!(d != null && d.length) && !r && /* @__PURE__ */ v.createElement(
      HY,
      {
        isActive: !!N,
        isMedia: r,
        items: d,
        setIsInteractive: u
      }
    ),
    !N && !w && (r ? /* @__PURE__ */ v.createElement(
      KY,
      {
        allSources: i,
        painting: i[s],
        annotationResources: e
      }
    ) : i && /* @__PURE__ */ v.createElement(
      UY,
      {
        _cloverViewerHasPlaceholder: !!(d != null && d.length),
        annotations: A,
        body: l,
        instanceId: B,
        key: B,
        openSeadragonCallback: Y,
        openSeadragonConfig: p.openSeadragon
      }
    )),
    !N && J && /* @__PURE__ */ v.createElement(
      J,
      {
        id: t,
        annotationBody: i[s],
        hooks: { useViewerDispatch: jt, useViewerState: st },
        ...w == null ? void 0 : w.display.componentProps
      }
    )
  ), U && /* @__PURE__ */ v.createElement(
    vA,
    {
      value: (ie = i[s]) == null ? void 0 : ie.id,
      onValueChange: K,
      maxHeight: "200px"
    },
    i == null ? void 0 : i.map((X) => /* @__PURE__ */ v.createElement(
      AA,
      {
        value: X == null ? void 0 : X.id,
        key: X == null ? void 0 : X.id,
        label: X == null ? void 0 : X.label
      }
    ))
  ));
}, ZY = ({
  activeCanvas: t,
  annotationResources: e,
  searchServiceUrl: n,
  setContentSearchResource: r,
  contentSearchResource: i,
  isAudioVideo: s,
  items: a,
  painting: o
}) => {
  var T, S;
  const {
    contentStateAnnotation: u,
    isInformationOpen: l,
    configOptions: c,
    sequence: d,
    visibleCanvases: f
  } = st(), { informationPanel: h } = c, m = f.map((I) => I.id), g = (e.length > 0 || // @ts-ignore
  m.includes((S = (T = u == null ? void 0 : u.target) == null ? void 0 : T.source) == null ? void 0 : S.id)) && (h == null ? void 0 : h.renderAnnotation) && (h == null ? void 0 : h.renderToggle) === !1 && l, b = (h == null ? void 0 : h.renderAbout) && l || g, y = h == null ? void 0 : h.renderToggle;
  return /* @__PURE__ */ v.createElement(
    fb,
    {
      className: "clover-viewer-content",
      "data-testid": "clover-viewer-content"
    },
    /* @__PURE__ */ v.createElement(hb, { "data-aside-active": b, "data-aside-toggle": y }, /* @__PURE__ */ v.createElement(
      QY,
      {
        activeCanvas: t,
        annotationResources: e,
        contentSearchResource: i,
        isMedia: s,
        painting: o
      }
    ), d[1].length > 1 && /* @__PURE__ */ v.createElement(aC, { className: "clover-viewer-media-wrapper" }, /* @__PURE__ */ v.createElement(Mj, { items: a, activeItem: 0 }))),
    b && /* @__PURE__ */ v.createElement(oC, { "data-aside-active": b, "data-aside-toggle": y }, /* @__PURE__ */ v.createElement(
      Lq,
      {
        activeCanvas: t,
        annotationResources: e,
        searchServiceUrl: n,
        setContentSearchResource: r,
        contentSearchResource: i
      }
    ))
  );
}, JY = le(Si.Trigger, {
  width: "30px",
  padding: "5px"
}), _A = le(Si.Content, {
  display: "flex",
  flexDirection: "column",
  fontSize: "0.8333rem",
  border: "none",
  boxShadow: "2px 2px 5px #0003",
  zIndex: "2",
  button: {
    display: "flex",
    textDecoration: "none",
    marginBottom: "0.5em",
    color: "$accentAlt",
    cursor: "pointer",
    background: "$secondary",
    border: "none",
    "&:last-child": {
      marginBottom: "0"
    }
  }
}), eX = le("span", {
  fontSize: "1.33rem",
  alignSelf: "flex-start",
  flexGrow: "0",
  flexShrink: "1",
  padding: "1rem",
  "@sm": {
    fontSize: "1rem"
  },
  "&.visually-hidden": {
    position: "absolute",
    width: "1px",
    height: "1px",
    padding: "0",
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    border: "0"
  }
}), tX = le("header", {
  display: "flex",
  backgroundColor: "transparent !important",
  justifyContent: "space-between",
  alignItems: "flex-start",
  width: "100%",
  [`> ${xA}`]: {
    flexGrow: "1",
    flexShrink: "0"
  },
  form: {
    flexGrow: "0",
    flexShrink: "1"
  }
}), nX = le("div", {
  display: "flex",
  alignItems: "flex-end",
  justifyContent: "flex-end",
  padding: "1rem",
  flexShrink: "0",
  flexGrow: "1"
}), rX = () => {
  var u;
  const t = jt(), e = st(), { activeManifest: n, collection: r, configOptions: i, vault: s } = e, a = i == null ? void 0 : i.canvasHeight, o = (l) => {
    t({
      type: "updateActiveCanvas",
      canvasId: void 0
    }), t({
      type: "updateActiveManifest",
      manifestId: l
    }), t({
      type: "updateViewerId",
      viewerId: ts()
    });
  };
  return /* @__PURE__ */ v.createElement("div", { style: { margin: "0.75rem" } }, /* @__PURE__ */ v.createElement(
    vA,
    {
      label: r.label,
      maxHeight: a,
      value: n,
      onValueChange: o
    },
    (u = r == null ? void 0 : r.items) == null ? void 0 : u.map((l) => /* @__PURE__ */ v.createElement(
      AA,
      {
        value: l.id,
        key: l.id,
        thumbnail: l != null && l.thumbnail ? s.get(l == null ? void 0 : l.thumbnail) : void 0,
        label: l.label
      }
    ))
  ));
}, iX = (t, e = 2500) => {
  const { t: n } = Zn(), [r, i] = Be(""), s = yt(() => {
    navigator.clipboard.writeText(t).then(
      () => i(n("copySuccess")),
      () => i(n("copyFailure"))
    );
  }, [n, t]);
  return Se(() => {
    if (!r) return;
    const a = setTimeout(() => i(""), e);
    return () => clearTimeout(a);
  }, [r, e]), [r, s];
}, sX = le("span", {
  display: "flex",
  alignContent: "center",
  alignItems: "center",
  padding: "0.125rem 0.25rem 0",
  marginTop: "-0.125rem",
  marginLeft: "0.5rem",
  backgroundColor: "$accent",
  color: "$secondary",
  borderRadius: "3px",
  lineHeight: "1em"
}), aX = ({ status: t }) => t ? /* @__PURE__ */ v.createElement(sX, { "data-copy-status": t }, t) : null, M1 = ({
  textPrompt: t,
  textToCopy: e
}) => {
  const [n, r] = iX(e);
  return /* @__PURE__ */ v.createElement("button", { onClick: r }, t, " ", /* @__PURE__ */ v.createElement(aX, { status: n }));
}, oX = ({ title: t }) => {
  const e = "#ed1d33", n = "#2873ab";
  return /* @__PURE__ */ v.createElement("svg", { viewBox: "0 0 493.35999 441.33334", id: "iiif-logo", version: "1.1" }, /* @__PURE__ */ v.createElement("title", null, t), /* @__PURE__ */ v.createElement("g", { transform: "matrix(1.3333333,0,0,-1.3333333,0,441.33333)" }, /* @__PURE__ */ v.createElement("g", { transform: "scale(0.1)" }, /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: n },
      d: "M 65.2422,2178.75 775.242,1915 773.992,15 65.2422,276.25 v 1902.5"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: n },
      d: "m 804.145,2640.09 c 81.441,-240.91 -26.473,-436.2 -241.04,-436.2 -214.558,0 -454.511,195.29 -535.9527,436.2 -81.4335,240.89 26.4805,436.18 241.0387,436.18 214.567,0 454.512,-195.29 535.954,-436.18"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: e },
      d: "M 1678.58,2178.75 968.578,1915 969.828,15 1678.58,276.25 v 1902.5"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: e },
      d: "m 935.082,2640.09 c -81.437,-240.91 26.477,-436.2 241.038,-436.2 214.56,0 454.51,195.29 535.96,436.2 81.43,240.89 -26.48,436.18 -241.04,436.18 -214.57,0 -454.52,-195.29 -535.958,-436.18"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: n },
      d: "m 1860.24,2178.75 710,-263.75 -1.25,-1900 -708.75,261.25 v 1902.5"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: n },
      d: "m 2603.74,2640.09 c 81.45,-240.91 -26.47,-436.2 -241.03,-436.2 -214.58,0 -454.52,195.29 -535.96,436.2 -81.44,240.89 26.48,436.18 241.03,436.18 214.57,0 454.51,-195.29 535.96,-436.18"
    }
  ), /* @__PURE__ */ v.createElement(
    "path",
    {
      style: { fill: e },
      d: "m 3700.24,3310 v -652.5 c 0,0 -230,90 -257.5,-142.5 -2.5,-247.5 0,-336.25 0,-336.25 l 257.5,83.75 V 1690 l -258.61,-92.5 V 262.5 L 2735.24,0 v 2360 c 0,0 -15,850 965,950"
    }
  ))));
};
var Fl = "Switch", [uX] = jn(Fl), [lX, cX] = uX(Fl), RA = M.forwardRef(
  (t, e) => {
    const {
      __scopeSwitch: n,
      name: r,
      checked: i,
      defaultChecked: s,
      required: a,
      disabled: o,
      value: u = "on",
      onCheckedChange: l,
      form: c,
      ...d
    } = t, [f, h] = M.useState(null), m = Je(e, (T) => h(T)), p = M.useRef(!1), g = f ? c || !!f.closest("form") : !0, [b, y] = kr({
      prop: i,
      defaultProp: s ?? !1,
      onChange: l,
      caller: Fl
    });
    return /* @__PURE__ */ es(lX, { scope: n, checked: b, disabled: o, children: [
      /* @__PURE__ */ ee(
        $e.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": b,
          "aria-required": a,
          "data-state": PA(b),
          "data-disabled": o ? "" : void 0,
          disabled: o,
          value: u,
          ...d,
          ref: m,
          onClick: Oe(t.onClick, (T) => {
            y((S) => !S), g && (p.current = T.isPropagationStopped(), p.current || T.stopPropagation());
          })
        }
      ),
      g && /* @__PURE__ */ ee(
        DA,
        {
          control: f,
          bubbles: !p.current,
          name: r,
          value: u,
          checked: b,
          required: a,
          disabled: o,
          form: c,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
RA.displayName = Fl;
var wA = "SwitchThumb", kA = M.forwardRef(
  (t, e) => {
    const { __scopeSwitch: n, ...r } = t, i = cX(wA, n);
    return /* @__PURE__ */ ee(
      $e.span,
      {
        "data-state": PA(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: e
      }
    );
  }
);
kA.displayName = wA;
var dX = "SwitchBubbleInput", DA = M.forwardRef(
  ({
    __scopeSwitch: t,
    control: e,
    checked: n,
    bubbles: r = !0,
    ...i
  }, s) => {
    const a = M.useRef(null), o = Je(a, s), u = hh(n), l = fh(e);
    return M.useEffect(() => {
      const c = a.current;
      if (!c) return;
      const d = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(
        d,
        "checked"
      ).set;
      if (u !== n && h) {
        const m = new Event("click", { bubbles: r });
        h.call(c, n), c.dispatchEvent(m);
      }
    }, [u, n, r]), /* @__PURE__ */ ee(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: o,
        style: {
          ...i.style,
          ...l,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
DA.displayName = dX;
function PA(t) {
  return t ? "checked" : "unchecked";
}
var fX = RA, hX = kA;
const mX = le(fX, {
  all: "unset",
  height: "2rem",
  width: "3.236rem",
  backgroundColor: "#6663",
  borderRadius: "9999px",
  position: "relative",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:focus": {
    boxShadow: "0 0 0 2px $secondaryAlt"
  },
  '&[data-state="checked"]': {
    backgroundColor: "$accent",
    boxShadow: "inset 2px 2px 5px #0003"
  }
}), pX = le(hX, {
  display: "block",
  height: "calc(2rem - 12px)",
  width: "calc(2rem - 12px)",
  backgroundColor: "$secondary",
  borderRadius: "100%",
  boxShadow: "2px 2px 5px #0001",
  transition: "$all",
  transform: "translateX(6px)",
  willChange: "transform",
  span: {
    fontFamily: "monospace",
    fontSize: "0.8333rem",
    fontWeight: "700",
    display: "flex",
    height: "100%",
    width: "100%",
    alignItems: "center",
    justifyContent: "center",
    color: "$primary",
    opacity: "0.382",
    userSelect: "none",
    pointerEvents: "none"
  },
  '&[data-state="checked"]': {
    transform: "translateX(calc(1.236rem + 6px))",
    span: {
      opacity: "1",
      color: "$accent"
    }
  }
});
le("label", {
  fontSize: "0.8333rem",
  fontWeight: "400",
  lineHeight: "1em",
  userSelect: "none",
  cursor: "pointer",
  paddingRight: "0.618rem"
});
const gX = le("form", {
  display: "flex",
  flexShrink: "0",
  flexGrow: "1",
  alignItems: "center",
  marginLeft: "1.618rem"
}), bX = () => {
  const { isInformationOpen: t } = st(), e = jt(), { t: n } = Zn(), r = (i) => {
    e({
      type: "updateInformationOpen",
      isInformationOpen: i
    });
  };
  return /* @__PURE__ */ v.createElement(gX, null, /* @__PURE__ */ v.createElement(
    mX,
    {
      checked: t,
      onCheckedChange: r,
      id: "information-toggle",
      "aria-label": n("informationPanelToggle"),
      name: "toggled?"
    },
    /* @__PURE__ */ v.createElement(pX, null, /* @__PURE__ */ v.createElement("span", null, "i"))
  ));
}, EX = v.memo(bX), yX = le(Si.Trigger, {
  width: "30px",
  padding: "5px",
  marginBottom: "auto"
}), TX = le(_A, {
  h3: {
    color: "$primaryAlt",
    fontSize: "$2",
    fontWeight: "700",
    margin: "$2 0"
  },
  button: {},
  "& ul li": {
    marginBottom: "$1"
  }
});
function SX(t) {
  const { vault: e } = st();
  try {
    const n = t && e.get(t);
    if (!n) throw new Error(`Vault entity ${t} not found.`);
    return (n == null ? void 0 : n["@id"]) || (n == null ? void 0 : n.id);
  } catch (n) {
    return console.error(n), t;
  }
}
function F1(t, e) {
  const n = [];
  if (!t) return n;
  for (const r of t)
    if (r.id) {
      const i = e.get(r.id);
      i && n.push(i);
    }
  return n;
}
function xX() {
  const { activeCanvas: t, activeManifest: e, vault: n } = st(), [r, i] = Be({
    root: [],
    canvas: []
  });
  return Se(() => {
    const s = n.get(e), a = n.get(t), o = s == null ? void 0 : s.rendering, u = a == null ? void 0 : a.rendering, l = F1(o, n), c = F1(u, n);
    i({
      root: l,
      canvas: c
    });
  }, [t, e, n]), { ...r };
}
function B1(t, e) {
  return t.map(({ format: n, id: r, label: i }) => {
    const s = SX(r);
    return {
      format: n,
      id: s,
      label: fn(i) || e
    };
  });
}
function vX() {
  const t = xX(), e = B1(
    (t == null ? void 0 : t.root) || [],
    "Root Rendering Label"
  ), n = B1(
    (t == null ? void 0 : t.canvas) || [],
    "Canvas Rendering Label"
  );
  return {
    allPages: e,
    individualPages: n
  };
}
const AX = () => {
  const { allPages: t, individualPages: e } = vX(), n = t.length > 0 || e.length > 0, r = (i) => {
    window.open(i, "_blank");
  };
  return n ? /* @__PURE__ */ v.createElement(Si, null, /* @__PURE__ */ v.createElement(yX, { "data-testid": "download-button" }, /* @__PURE__ */ v.createElement(Dt, null, /* @__PURE__ */ v.createElement(Dt.Download, null))), /* @__PURE__ */ v.createElement(TX, { "data-testid": "download-content" }, e.length > 0 && /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("h3", null, "Individual Pages"), /* @__PURE__ */ v.createElement("ul", null, e.map(({ format: i, id: s, label: a }) => /* @__PURE__ */ v.createElement("li", { key: a }, /* @__PURE__ */ v.createElement("button", { onClick: () => r(s) }, a, " (", i, ")"))))), t.length > 0 && /* @__PURE__ */ v.createElement(v.Fragment, null, /* @__PURE__ */ v.createElement("h3", null, "All Pages"), /* @__PURE__ */ v.createElement("ul", null, t.map(({ format: i, id: s, label: a }) => /* @__PURE__ */ v.createElement("li", { key: a }, /* @__PURE__ */ v.createElement("button", { onClick: () => r(s) }, a, " (", i, ")"))))))) : null;
}, IX = ({ manifestId: t, manifestLabel: e }) => {
  const n = st(), { collection: r, configOptions: i } = n, { informationPanel: s, showDownload: a, showIIIFBadge: o, showTitle: u } = i, l = a || o || (s == null ? void 0 : s.renderToggle), { t: c } = Zn();
  return /* @__PURE__ */ v.createElement(tX, { className: "clover-viewer-header" }, r != null && r.items ? /* @__PURE__ */ v.createElement(rX, null) : /* @__PURE__ */ v.createElement(eX, { className: u ? "" : "visually-hidden" }, u && /* @__PURE__ */ v.createElement(yr, { label: e, className: "label" })), l && /* @__PURE__ */ v.createElement(nX, null, a && /* @__PURE__ */ v.createElement(AX, null), o && /* @__PURE__ */ v.createElement(Si, null, /* @__PURE__ */ v.createElement(JY, null, /* @__PURE__ */ v.createElement(oX, { title: c("commonShare") })), /* @__PURE__ */ v.createElement(_A, null, (r == null ? void 0 : r.items) && /* @__PURE__ */ v.createElement(
    "button",
    {
      onClick: (d) => {
        d.preventDefault(), window.open(r.id, "_blank");
      }
    },
    c("shareCollectionJson")
  ), /* @__PURE__ */ v.createElement(
    "button",
    {
      onClick: (d) => {
        d.preventDefault(), window.open(t, "_blank");
      }
    },
    c("shareManifestJson")
  ), " ", (r == null ? void 0 : r.items) && /* @__PURE__ */ v.createElement(
    M1,
    {
      textPrompt: c("shareCollectionCopy"),
      textToCopy: r.id
    }
  ), /* @__PURE__ */ v.createElement(
    M1,
    {
      textPrompt: c("shareManifestCopy"),
      textToCopy: t
    }
  ))), (s == null ? void 0 : s.renderToggle) && /* @__PURE__ */ v.createElement(EX, null)));
}, CX = (t) => {
  const e = () => window.matchMedia ? window.matchMedia(t).matches : !1, [n, r] = Be(e);
  return Se(() => {
    const i = () => r(e);
    return window.addEventListener("resize", i), () => window.removeEventListener("resize", i);
  }), n;
}, LX = ({
  manifest: t,
  theme: e,
  iiifContentSearchQuery: n
}) => {
  var k;
  const r = st(), i = jt(), {
    activeCanvas: s,
    isInformationOpen: a,
    vault: o,
    configOptions: u,
    visibleCanvases: l
  } = r, c = ["100%", "auto"], d = (u == null ? void 0 : u.canvasHeight) && c.includes(u == null ? void 0 : u.canvasHeight), [f, h] = Be(!1), [m, p] = Be([]), [g, b] = Be([]), [y, T] = Be(), S = CX(cb.sm), [I, C] = Be(), _ = yt(
    (A) => {
      i({
        type: "updateInformationOpen",
        isInformationOpen: A
      });
    },
    [i]
  );
  Se(() => {
    var A;
    (A = u == null ? void 0 : u.informationPanel) != null && A.open && _(!S);
  }, [S, (k = u == null ? void 0 : u.informationPanel) == null ? void 0 : k.open]), Se(() => {
  }, [S]), Se(() => {
    const A = Dr(o, s);
    A && (h(
      ["Sound", "Video"].indexOf(
        A[0].type
      ) > -1
    ), p(A));
    const L = FA(
      o,
      // @ts-ignore
      t,
      s
    );
    i({
      type: "updateVisibleCanvases",
      visibleCanvases: L
    });
  }, [s, S, t, o, i]), Se(() => {
    (async () => {
      const A = await Promise.all(
        l.map(
          (L) => AI(o, L.id)
        )
      );
      b(A.flat());
    })();
  }, [l]);
  const R = t.service.some(
    (A) => ["SearchService1", "SearchService2"].includes(
      A.type || A["@type"]
    )
  );
  return Se(() => {
    if (R) {
      const A = t.service.find(
        (L) => ["SearchService1", "SearchService2"].includes(
          L.type || L["@type"]
        )
      );
      A && C(A.id || A["@id"]);
    }
  }, [t, R]), Se(() => {
    var A;
    I && ((A = u.informationPanel) == null ? void 0 : A.renderContentSearch) !== !1 && ab(
      o,
      I,
      n
    ).then((L) => T(L));
  }, [I]), /* @__PURE__ */ v.createElement(Df, { FallbackComponent: Of }, /* @__PURE__ */ v.createElement(
    uC,
    {
      className: `${e} clover-viewer`,
      css: { background: u == null ? void 0 : u.background },
      "data-absolute-position": d,
      "data-information-panel-open": a
    },
    /* @__PURE__ */ v.createElement(
      vI,
      {
        open: a,
        onOpenChange: _
      },
      /* @__PURE__ */ v.createElement(
        IX,
        {
          manifestLabel: t.label,
          manifestId: t.id
        }
      ),
      /* @__PURE__ */ v.createElement(
        ZY,
        {
          activeCanvas: s,
          painting: m,
          annotationResources: g,
          searchServiceUrl: I,
          setContentSearchResource: T,
          contentSearchResource: y,
          items: t.items,
          isAudioVideo: f
        }
      )
    )
  ));
}, $1 = {
  ignoreCache: !1,
  headers: {
    Accept: "application/json, text/javascript, text/plain"
  },
  timeout: 5e3,
  withCredentials: !1
};
function _X(t) {
  return {
    ok: t.status >= 200 && t.status < 300,
    status: t.status,
    statusText: t.statusText,
    headers: t.getAllResponseHeaders(),
    data: t.responseText,
    json: () => JSON.parse(t.responseText)
  };
}
function U1(t, e = null) {
  return {
    ok: !1,
    status: t.status,
    statusText: t.statusText,
    headers: t.getAllResponseHeaders(),
    data: e || t.statusText,
    json: () => JSON.parse(e || t.statusText)
  };
}
function RX(t, e = $1) {
  const n = e.headers || $1.headers;
  return new Promise((r, i) => {
    const s = new XMLHttpRequest();
    s.open("get", t), s.withCredentials = e.withCredentials, n && Object.keys(n).forEach(
      (a) => s.setRequestHeader(a, n[a])
    ), s.onload = () => {
      r(_X(s));
    }, s.onerror = () => {
      i(U1(s, "Failed to make request."));
    }, s.ontimeout = () => {
      i(U1(s, "Request took longer than expected."));
    }, s.send();
  });
}
const H1 = {
  "@context": "http://iiif.io/api/presentation/3/context.json",
  id: "https://example.org/iiif/content-state/specific-resource",
  type: "Annotation",
  motivation: ["contentState"],
  target: {
    type: "SpecificResource",
    source: {
      id: "https://example.org/iiif/manifest/canvas/0",
      type: "Canvas",
      partOf: [
        {
          id: "https://example.org/iiif/manifest",
          type: "Manifest"
        }
      ]
    }
  },
  body: []
}, TQ = ({
  canvasIdCallback: t,
  contentStateCallback: e,
  customDisplays: n = [],
  plugins: r = [],
  customTheme: i,
  iiifContent: s,
  id: a,
  manifestId: o,
  options: u,
  iiifContentSearchQuery: l
}) => {
  var f, h, m;
  let c = s;
  a && (c = a), o && (c = o);
  const d = J1(
    (h = (f = u == null ? void 0 : u.informationPanel) == null ? void 0 : f.vtt) == null ? void 0 : h.autoScroll
  );
  return /* @__PURE__ */ v.createElement(
    tI,
    {
      initialState: {
        ...Lf,
        customDisplays: n,
        plugins: r,
        isAutoScrollEnabled: d.enabled,
        isInformationOpen: !!((m = u == null ? void 0 : u.informationPanel) != null && m.open),
        vault: new K1({
          customFetcher: (p) => RX(p, {
            withCredentials: u == null ? void 0 : u.withCredentials,
            headers: u == null ? void 0 : u.requestHeaders
          }).then((g) => JSON.parse(g.data))
        })
      }
    },
    /* @__PURE__ */ v.createElement(
      wX,
      {
        iiifContent: c,
        canvasIdCallback: t,
        contentStateCallback: e,
        customTheme: i,
        options: u,
        iiifContentSearchQuery: l
      }
    )
  );
}, wX = ({
  canvasIdCallback: t,
  contentStateCallback: e,
  customTheme: n,
  iiifContent: r,
  options: i,
  iiifContentSearchQuery: s
}) => {
  const a = jt(), o = st(), {
    activeCanvas: u,
    activeManifest: l,
    activeSelector: c,
    isLoaded: d,
    vault: f,
    visibleCanvases: h
  } = o, [m, p] = Be(), [g, b] = Be();
  let y = {};
  if (n && (y = tC("custom", n)), Se(() => {
    a({
      type: "updateActiveSelector",
      selector: void 0
    });
  }, [u, l]), Se(() => {
    var T;
    if (t && t(u), e && l && u) {
      const S = ((T = h[0]) == null ? void 0 : T.id) || u, I = `${l}/state/${X1(S + JSON.stringify(c))}`, C = {
        ...H1,
        id: I,
        target: {
          type: "SpecificResource",
          source: {
            id: S,
            type: "Canvas",
            partOf: [
              {
                id: l,
                type: "Manifest"
              }
            ]
          },
          selector: c
        }
      };
      e({
        json: C,
        encoded: BA(JSON.stringify(C))
      });
    }
  }, [
    u,
    l,
    c,
    t,
    e,
    h
  ]), Se(() => {
    l && (async () => {
      try {
        const S = f.get(l);
        if (S)
          return S;
      } catch {
      }
      return await f.load(l);
    })().then((S) => {
      if (!S) return;
      b(S);
      const I = $A(f, S), C = u || AY(S);
      a({
        type: "updateActiveCanvas",
        canvasId: C
      }), a({
        type: "updateManifestSequence",
        sequence: I
      });
      const _ = S.viewingDirection || "left-to-right", R = S.behavior || [], k = Array.isArray(R) ? R.includes("paged") : R === "paged";
      a({
        type: "updateViewingDirection",
        viewingDirection: _
      }), a({
        type: "updateIsPaged",
        isPaged: k
      });
    }).catch((S) => {
      console.error(`Manifest failed to load: ${S}`);
    }).finally(() => {
      a({
        type: "updateIsLoaded",
        isLoaded: !0
      });
    });
  }, [r, l, a, f]), Se(() => {
    a({
      type: "updateConfigOptions",
      configOptions: i
    }), (async () => {
      var I;
      if (!r) return;
      const S = vY(r);
      try {
        const C = typeof S == "object" && (S != null && S.id) ? await f.loadSync(S == null ? void 0 : S.id, S) : await f.load(S);
        p(C);
      } catch (C) {
        if ((!S || !S.id) && console.error(`Failed to load resource: ${C}`), S != null && S.id && (S == null ? void 0 : S.type) === "Annotation" && ((I = S == null ? void 0 : S.motivation) != null && I.includes("contentState"))) {
          const _ = await f.loadSync(
            S.id,
            S
          );
          _ && p(_);
        } else S != null && S.id && ["Canvas", "Manifest"].includes(S == null ? void 0 : S.type) && await f.loadSync(S.id, S) && p({
          ...H1,
          target: S
        });
      }
    })();
  }, [a, r, i, f]), Se(() => {
    if (m)
      switch (m.type) {
        case "Annotation":
          if (m != null && m.motivation && (Array.isArray(m == null ? void 0 : m.motivation) ? m != null && m.motivation.includes("contentState") : (m == null ? void 0 : m.motivation) === "content-state")) {
            const { active: S } = CA(m);
            a({
              type: "updateActiveManifest",
              manifestId: S.manifest
            }), a({
              type: "updateActiveCanvas",
              canvasId: S.canvas
            }), a({
              type: "updateContentStateAnnotation",
              contentStateAnnotation: m
            });
          }
          break;
        case "Collection":
          const T = IY(
            m
          );
          a({
            type: "updateCollection",
            collection: m
          }), T && a({
            type: "updateActiveManifest",
            manifestId: T
          });
          break;
        case "Manifest":
          a({
            type: "updateActiveManifest",
            manifestId: m.id
          });
          break;
      }
  }, [a, r, m]), !d)
    if (i != null && i.customLoadingComponent) {
      const T = i.customLoadingComponent;
      return /* @__PURE__ */ v.createElement(T, null);
    } else
      return /* @__PURE__ */ v.createElement(v.Fragment, null, "Loading");
  return !g || !g.items ? (console.log(`The IIIF manifest ${r} failed to load.`), /* @__PURE__ */ v.createElement(v.Fragment, null)) : g.items.length === 0 ? (console.log(`The IIIF manifest ${r} does not contain canvases.`), /* @__PURE__ */ v.createElement(v.Fragment, null)) : /* @__PURE__ */ v.createElement(
    LX,
    {
      manifest: g,
      theme: y,
      key: g.id,
      iiifContentSearchQuery: s
    }
  );
};
export {
  TQ as default
};
